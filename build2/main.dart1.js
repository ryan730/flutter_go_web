// Generated by dart2js (fast startup emitter, strong), the Dart to JavaScript compiler version: 2.3.0-edge.a1668566e563aef64025d0af88a099cbbe847b7e.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
//
// dartCallInstrumentation(id, qualifiedName):
//    if this function is defined, it will be called at each entry of a
//    method or constructor. Used only when compiling programs with
//    --experiment-call-instrumentation.
//
// defaultPackagesBase:
//    Override the location where `package:` uris are resolved from. By default
//    they are resolved under "packages/" from the current window location.
{
}
(function dartProgram() {
  function copyProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      to[key] = from[key];
    }
  }
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(object.__proto__ && object.__proto__.p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function setFunctionNamesIfNecessary(holders) {
    function t() {
    }
    ;
    if (typeof t.name == "string")
      return;
    for (var i = 0; i < holders.length; i++) {
      var holder = holders[i];
      var keys = Object.keys(holder);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        var f = holder[key];
        if (typeof f == 'function')
          f.name = key;
      }
    }
  }
  function inherit(cls, sup) {
    cls.prototype.constructor = cls;
    cls.prototype["$is" + cls.name] = cls;
    if (sup != null) {
      if (supportsDirectProtoAccess) {
        cls.prototype.__proto__ = sup.prototype;
        return;
      }
      var clsPrototype = Object.create(sup.prototype);
      copyProperties(cls.prototype, clsPrototype);
      cls.prototype = clsPrototype;
    }
  }
  function inheritMany(sup, classes) {
    for (var i = 0; i < classes.length; i++)
      inherit(classes[i], sup);
  }
  function mixin(cls, mixin) {
    copyProperties(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function lazy(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      holder[getterName] = function() {
        H.throwCyclicInit(name);
      };
      var result;
      var sentinelInProgress = initializer;
      try {
        if (holder[name] === uninitializedSentinel) {
          result = holder[name] = sentinelInProgress;
          result = holder[name] = initializer();
        } else
          result = holder[name];
      } finally {
        if (result === sentinelInProgress)
          holder[name] = null;
        holder[getterName] = function() {
          return this[name];
        };
      }
      return result;
    };
  }
  function makeConstList(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  }
  function convertToFastObject(properties) {
    function t() {
    }
    t.prototype = properties;
    new t();
    return properties;
  }
  function convertAllToFastObject(arrayOfObjects) {
    for (var i = 0; i < arrayOfObjects.length; ++i)
      convertToFastObject(arrayOfObjects[i]);
  }
  var functionCounter = 0;
  function tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(receiver) {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, true, name);" + "return new c(this, funcs[0], receiver, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null) : new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, false, name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null);
  }
  function tearOff(funcs, applyTrampolineIndex, reflectionInfo, isStatic, name, isIntercepted) {
    var cache = null;
    return isStatic ? function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, applyTrampolineIndex, reflectionInfo, true, false, name).prototype;
      return cache;
    } : tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted);
  }
  var typesOffset = 0;
  function installTearOff(container, getterName, isStatic, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    var funs = [];
    for (var i = 0; i < funsOrNames.length; i++) {
      var fun = funsOrNames[i];
      if (typeof fun == 'string')
        fun = container[fun];
      fun.$callName = callNames[i];
      funs.push(fun);
    }
    var fun = funs[0];
    fun.$requiredArgCount = requiredParameterCount;
    fun.$defaultValues = optionalParameterDefaultValues;
    var reflectionInfo = funType;
    if (typeof reflectionInfo == "number")
      reflectionInfo = reflectionInfo + typesOffset;
    var name = funsOrNames[0];
    fun.$stubName = name;
    var getterFunction = tearOff(funs, applyIndex || 0, reflectionInfo, isStatic, name, isIntercepted);
    container[getterName] = getterFunction;
    if (isStatic)
      fun.$tearOff = getterFunction;
  }
  function installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    return installTearOff(container, getterName, true, false, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex);
  }
  function installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    return installTearOff(container, getterName, false, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex);
  }
  function setOrUpdateInterceptorsByTag(newTags) {
    var tags = init.interceptorsByTag;
    if (!tags) {
      init.interceptorsByTag = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function setOrUpdateLeafTags(newTags) {
    var tags = init.leafTags;
    if (!tags) {
      init.leafTags = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function updateTypes(newTypes) {
    var types = init.types;
    var length = types.length;
    types.push.apply(types, newTypes);
    return length;
  }
  function updateHolder(holder, newHolder) {
    copyProperties(newHolder, holder);
    return holder;
  }
  var hunkHelpers = function() {
    var mkInstance = function(isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      },
      mkStatic = function(requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      };
    return {inherit: inherit, inheritMany: inheritMany, mixin: mixin, installStaticTearOff: installStaticTearOff, installInstanceTearOff: installInstanceTearOff, _instance_0u: mkInstance(0, 0, null, ["call$0"], 0), _instance_1u: mkInstance(0, 1, null, ["call$1"], 0), _instance_2u: mkInstance(0, 2, null, ["call$2"], 0), _instance_0i: mkInstance(1, 0, null, ["call$0"], 0), _instance_1i: mkInstance(1, 1, null, ["call$1"], 0), _instance_2i: mkInstance(1, 2, null, ["call$2"], 0), _static_0: mkStatic(0, null, ["call$0"], 0), _static_1: mkStatic(1, null, ["call$1"], 0), _static_2: mkStatic(2, null, ["call$2"], 0), makeConstList: makeConstList, lazy: lazy, updateHolder: updateHolder, convertToFastObject: convertToFastObject, setFunctionNamesIfNecessary: setFunctionNamesIfNecessary, updateTypes: updateTypes, setOrUpdateInterceptorsByTag: setOrUpdateInterceptorsByTag, setOrUpdateLeafTags: setOrUpdateLeafTags};
  }();
  function initializeDeferredHunk(hunk) {
    typesOffset = init.types.length;
    hunk(hunkHelpers, init, holders, $);
  }
  function getGlobalFromName(name) {
    for (var i = 0; i < holders.length; i++) {
      if (holders[i] == C)
        continue;
      if (holders[i][name])
        return holders[i][name];
    }
  }
  var C = {},
  H = {JS_CONST: function JS_CONST() {
    },
    hexDigitValue: function(char) {
      var letter,
        digit = char ^ 48;
      if (digit <= 9)
        return digit;
      letter = char | 32;
      if (97 <= letter && letter <= 102)
        return letter - 87;
      return -1;
    },
    SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
      P.RangeError_checkNotNegative(_start, "start");
      if (_endOrLength != null) {
        P.RangeError_checkNotNegative(_endOrLength, "end");
        if (_start > _endOrLength)
          H.throwExpression(P.RangeError$range(_start, 0, _endOrLength, "start", null));
      }
      return new H.SubListIterable(_iterable, _start, _endOrLength, [$E]);
    },
    MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
      H.assertSubtype(iterable, "$isIterable", [$S], "$asIterable");
      H.functionTypeCheck($function, {func: 1, ret: $T, args: [$S]});
      if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable)
        return new H.EfficientLengthMappedIterable(iterable, $function, [$S, $T]);
      return new H.MappedIterable(iterable, $function, [$S, $T]);
    },
    TakeIterable_TakeIterable: function(iterable, takeCount, $E) {
      H.assertSubtype(iterable, "$isIterable", [$E], "$asIterable");
      P.RangeError_checkNotNegative(takeCount, "takeCount");
      if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable)
        return new H.EfficientLengthTakeIterable(iterable, takeCount, [$E]);
      return new H.TakeIterable(iterable, takeCount, [$E]);
    },
    IterableElementError_noElement: function() {
      return new P.StateError("No element");
    },
    IterableElementError_tooMany: function() {
      return new P.StateError("Too many elements");
    },
    IterableElementError_tooFew: function() {
      return new P.StateError("Too few elements");
    },
    Sort_sort: function(a, compare, $E) {
      var t1;
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      t1 = J.get$length$asx(a);
      if (typeof t1 !== "number")
        return t1.$sub();
      H.Sort__doSort(a, 0, t1 - 1, compare, $E);
    },
    Sort__doSort: function(a, left, right, compare, $E) {
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      if (right - left <= 32)
        H.Sort__insertionSort(a, left, right, compare, $E);
      else
        H.Sort__dualPivotQuicksort(a, left, right, compare, $E);
    },
    Sort__insertionSort: function(a, left, right, compare, $E) {
      var i, t1, el, j, j0;
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      for (i = left + 1, t1 = J.getInterceptor$asx(a); i <= right; ++i) {
        el = t1.$index(a, i);
        j = i;
        while (true) {
          if (!(j > left && J.$gt$n(compare.call$2(t1.$index(a, j - 1), el), 0)))
            break;
          j0 = j - 1;
          t1.$indexSet(a, j, t1.$index(a, j0));
          j = j0;
        }
        t1.$indexSet(a, j, el);
      }
    },
    Sort__dualPivotQuicksort: function(a, left, right, compare, $E) {
      var sixth, index1, index5, index3, index2, index4, t1, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, great0, less0, pivots_are_equal, comp_pivot1, comp_pivot2, t2;
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      sixth = C.JSInt_methods._tdivFast$1(right - left + 1, 6);
      index1 = left + sixth;
      index5 = right - sixth;
      index3 = C.JSInt_methods._tdivFast$1(left + right, 2);
      index2 = index3 - sixth;
      index4 = index3 + sixth;
      t1 = J.getInterceptor$asx(a);
      el1 = t1.$index(a, index1);
      el2 = t1.$index(a, index2);
      el3 = t1.$index(a, index3);
      el4 = t1.$index(a, index4);
      el5 = t1.$index(a, index5);
      if (J.$gt$n(compare.call$2(el1, el2), 0)) {
        t0 = el2;
        el2 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el3), 0)) {
        t0 = el3;
        el3 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el4), 0)) {
        t0 = el4;
        el4 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el3, el4), 0)) {
        t0 = el4;
        el4 = el3;
        el3 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el5), 0)) {
        t0 = el5;
        el5 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      t1.$indexSet(a, index1, el1);
      t1.$indexSet(a, index3, el3);
      t1.$indexSet(a, index5, el5);
      t1.$indexSet(a, index2, t1.$index(a, left));
      t1.$indexSet(a, index4, t1.$index(a, right));
      less = left + 1;
      great = right - 1;
      if (J.$eq$(compare.call$2(el2, el4), 0)) {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          comp = compare.call$2(ak, el2);
          if (comp === 0)
            continue;
          if (typeof comp !== "number")
            return comp.$lt();
          if (comp < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else
            for (; true;) {
              comp = compare.call$2(t1.$index(a, great), el2);
              if (typeof comp !== "number")
                return comp.$gt();
              if (comp > 0) {
                --great;
                continue;
              } else {
                great0 = great - 1;
                if (comp < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                  break;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  break;
                }
              }
            }
        }
        pivots_are_equal = true;
      } else {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          comp_pivot1 = compare.call$2(ak, el2);
          if (typeof comp_pivot1 !== "number")
            return comp_pivot1.$lt();
          if (comp_pivot1 < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else {
            comp_pivot2 = compare.call$2(ak, el4);
            if (typeof comp_pivot2 !== "number")
              return comp_pivot2.$gt();
            if (comp_pivot2 > 0)
              for (; true;) {
                comp = compare.call$2(t1.$index(a, great), el4);
                if (typeof comp !== "number")
                  return comp.$gt();
                if (comp > 0) {
                  --great;
                  if (great < k)
                    break;
                  continue;
                } else {
                  comp = compare.call$2(t1.$index(a, great), el2);
                  if (typeof comp !== "number")
                    return comp.$lt();
                  great0 = great - 1;
                  if (comp < 0) {
                    t1.$indexSet(a, k, t1.$index(a, less));
                    less0 = less + 1;
                    t1.$indexSet(a, less, t1.$index(a, great));
                    t1.$indexSet(a, great, ak);
                    less = less0;
                  } else {
                    t1.$indexSet(a, k, t1.$index(a, great));
                    t1.$indexSet(a, great, ak);
                  }
                  great = great0;
                  break;
                }
              }
          }
        }
        pivots_are_equal = false;
      }
      t2 = less - 1;
      t1.$indexSet(a, left, t1.$index(a, t2));
      t1.$indexSet(a, t2, el2);
      t2 = great + 1;
      t1.$indexSet(a, right, t1.$index(a, t2));
      t1.$indexSet(a, t2, el4);
      H.Sort__doSort(a, left, less - 2, compare, $E);
      H.Sort__doSort(a, great + 2, right, compare, $E);
      if (pivots_are_equal)
        return;
      if (less < index1 && great > index5) {
        for (; J.$eq$(compare.call$2(t1.$index(a, less), el2), 0);)
          ++less;
        for (; J.$eq$(compare.call$2(t1.$index(a, great), el4), 0);)
          --great;
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          if (compare.call$2(ak, el2) === 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else if (compare.call$2(ak, el4) === 0)
            for (; true;)
              if (compare.call$2(t1.$index(a, great), el4) === 0) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                comp = compare.call$2(t1.$index(a, great), el2);
                if (typeof comp !== "number")
                  return comp.$lt();
                great0 = great - 1;
                if (comp < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  less = less0;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                }
                great = great0;
                break;
              }
        }
        H.Sort__doSort(a, less, great, compare, $E);
      } else
        H.Sort__doSort(a, less, great, compare, $E);
    },
    CodeUnits: function CodeUnits(t0) {
      this._string = t0;
    },
    EfficientLengthIterable: function EfficientLengthIterable() {
    },
    ListIterable: function ListIterable() {
    },
    SubListIterable: function SubListIterable(t0, t1, t2, t3) {
      var _ = this;
      _._iterable = t0;
      _._start = t1;
      _._endOrLength = t2;
      _.$ti = t3;
    },
    ListIterator: function ListIterator(t0, t1, t2) {
      var _ = this;
      _._iterable = t0;
      _.__internal$_length = t1;
      _._index = 0;
      _._current = null;
      _.$ti = t2;
    },
    MappedIterable: function MappedIterable(t0, t1, t2) {
      this._iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    EfficientLengthMappedIterable: function EfficientLengthMappedIterable(t0, t1, t2) {
      this._iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    MappedIterator: function MappedIterator(t0, t1, t2) {
      var _ = this;
      _._current = null;
      _._iterator = t0;
      _._f = t1;
      _.$ti = t2;
    },
    MappedListIterable: function MappedListIterable(t0, t1, t2) {
      this._source = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterable: function WhereIterable(t0, t1, t2) {
      this._iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterator: function WhereIterator(t0, t1, t2) {
      this._iterator = t0;
      this._f = t1;
      this.$ti = t2;
    },
    TakeIterable: function TakeIterable(t0, t1, t2) {
      this._iterable = t0;
      this._takeCount = t1;
      this.$ti = t2;
    },
    EfficientLengthTakeIterable: function EfficientLengthTakeIterable(t0, t1, t2) {
      this._iterable = t0;
      this._takeCount = t1;
      this.$ti = t2;
    },
    TakeIterator: function TakeIterator(t0, t1, t2) {
      this._iterator = t0;
      this._remaining = t1;
      this.$ti = t2;
    },
    EmptyIterator: function EmptyIterator(t0) {
      this.$ti = t0;
    },
    FixedLengthListMixin: function FixedLengthListMixin() {
    },
    UnmodifiableListMixin: function UnmodifiableListMixin() {
    },
    UnmodifiableListBase: function UnmodifiableListBase() {
    },
    ReversedListIterable: function ReversedListIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    Symbol: function Symbol(t0) {
      this.__internal$_name = t0;
    },
    ConstantMap__throwUnmodifiable: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable Map"));
    },
    unminifyOrTag: function(rawClassName) {
      var preserved = H.stringTypeCheck(init.mangledGlobalNames[rawClassName]);
      if (typeof preserved === "string")
        return preserved;
      return rawClassName;
    },
    getType: function(index) {
      return init.types[H.intTypeCheck(index)];
    },
    isJsIndexable: function(object, record) {
      var result;
      if (record != null) {
        result = record.x;
        if (result != null)
          return result;
      }
      return !!J.getInterceptor$(object).$isJavaScriptIndexingBehavior;
    },
    S: function(value) {
      var res;
      if (typeof value === "string")
        return value;
      if (typeof value === "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      res = J.toString$0$(value);
      if (typeof res !== "string")
        throw H.wrapException(H.argumentErrorValue(value));
      return res;
    },
    Primitives_objectHashCode: function(object) {
      var hash = object.$identityHash;
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object.$identityHash = hash;
      }
      return hash;
    },
    Primitives_parseInt: function(source, radix) {
      var match, decimalMatch, maxCharCode, digitsPart, t1, i;
      if (typeof source !== "string")
        H.throwExpression(H.argumentErrorValue(source));
      match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
      if (match == null)
        return;
      if (3 >= match.length)
        return H.ioore(match, 3);
      decimalMatch = H.stringTypeCheck(match[3]);
      if (radix == null) {
        if (decimalMatch != null)
          return parseInt(source, 10);
        if (match[2] != null)
          return parseInt(source, 16);
        return;
      }
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      if (radix === 10 && decimalMatch != null)
        return parseInt(source, 10);
      if (radix < 10 || decimalMatch == null) {
        maxCharCode = radix <= 10 ? 47 + radix : 86 + radix;
        digitsPart = match[1];
        for (t1 = digitsPart.length, i = 0; i < t1; ++i)
          if ((C.JSString_methods._codeUnitAt$1(digitsPart, i) | 32) > maxCharCode)
            return;
      }
      return parseInt(source, radix);
    },
    Primitives_parseDouble: function(source) {
      var result, trimmed;
      if (typeof source !== "string")
        H.throwExpression(H.argumentErrorValue(source));
      if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
        return;
      result = parseFloat(source);
      if (isNaN(result)) {
        trimmed = J.trim$0$s(source);
        if (trimmed === "NaN" || trimmed === "+NaN" || trimmed === "-NaN")
          return result;
        return;
      }
      return result;
    },
    Primitives_objectTypeName: function(object) {
      return H.Primitives__objectClassName(object) + H._joinArguments(H.getRuntimeTypeInfo(object), 0, null);
    },
    Primitives__objectClassName: function(object) {
      var interceptorConstructorName, $name, t1, dispatchName, objectConstructor, match, decompiledName,
        interceptor = J.getInterceptor$(object),
        interceptorConstructor = interceptor.constructor;
      if (typeof interceptorConstructor == "function") {
        interceptorConstructorName = interceptorConstructor.name;
        $name = typeof interceptorConstructorName === "string" ? interceptorConstructorName : null;
      } else
        $name = null;
      t1 = $name == null;
      if (t1 || interceptor === C.Interceptor_methods || !!interceptor.$isUnknownJavaScriptObject) {
        dispatchName = C.C_JS_CONST(object);
        if (t1)
          $name = dispatchName;
        if (dispatchName === "Object") {
          objectConstructor = object.constructor;
          if (typeof objectConstructor == "function") {
            match = String(objectConstructor).match(/^\s*function\s*([\w$]*)\s*\(/);
            decompiledName = match == null ? null : match[1];
            if (typeof decompiledName === "string" && /^\w+$/.test(decompiledName))
              $name = decompiledName;
          }
        }
        return $name;
      }
      $name = $name;
      return H.unminifyOrTag($name.length > 1 && C.JSString_methods._codeUnitAt$1($name, 0) === 36 ? C.JSString_methods.substring$1($name, 1) : $name);
    },
    Primitives_dateNow: function() {
      return Date.now();
    },
    Primitives_initTicker: function() {
      var $window, performance;
      if ($.Primitives_timerFrequency != null)
        return;
      $.Primitives_timerFrequency = 1000;
      $.Primitives_timerTicks = H._js_helper_Primitives_dateNow$closure();
      if (typeof window == "undefined")
        return;
      $window = window;
      if ($window == null)
        return;
      performance = $window.performance;
      if (performance == null)
        return;
      if (typeof performance.now != "function")
        return;
      $.Primitives_timerFrequency = 1000000;
      $.Primitives_timerTicks = new H.Primitives_initTicker_closure(performance);
    },
    Primitives__fromCharCodeApply: function(array) {
      var result, i, i0, chunkEnd,
        end = array.length;
      if (end <= 500)
        return String.fromCharCode.apply(null, array);
      for (result = "", i = 0; i < end; i = i0) {
        i0 = i + 500;
        chunkEnd = i0 < end ? i0 : end;
        result += String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCodePoints: function(codePoints) {
      var t1, _i, i,
        a = H.setRuntimeTypeInfo([], [P.int]);
      for (t1 = codePoints.length, _i = 0; _i < codePoints.length; codePoints.length === t1 || (0, H.throwConcurrentModificationError)(codePoints), ++_i) {
        i = codePoints[_i];
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i <= 65535)
          C.JSArray_methods.add$1(a, i);
        else if (i <= 1114111) {
          C.JSArray_methods.add$1(a, 55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
          C.JSArray_methods.add$1(a, 56320 + (i & 1023));
        } else
          throw H.wrapException(H.argumentErrorValue(i));
      }
      return H.Primitives__fromCharCodeApply(a);
    },
    Primitives_stringFromCharCodes: function(charCodes) {
      var t1, _i, i;
      for (t1 = charCodes.length, _i = 0; _i < t1; ++_i) {
        i = charCodes[_i];
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i < 0)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i > 65535)
          return H.Primitives_stringFromCodePoints(charCodes);
      }
      return H.Primitives__fromCharCodeApply(charCodes);
    },
    Primitives_stringFromNativeUint8List: function(charCodes, start, end) {
      var i, result, i0, chunkEnd;
      if (typeof end !== "number")
        return end.$le();
      if (end <= 500 && start === 0 && end === charCodes.length)
        return String.fromCharCode.apply(null, charCodes);
      for (i = start, result = ""; i < end; i = i0) {
        i0 = i + 500;
        if (i0 < end)
          chunkEnd = i0;
        else
          chunkEnd = end;
        result += String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCharCode: function(charCode) {
      var bits;
      if (0 <= charCode) {
        if (charCode <= 65535)
          return String.fromCharCode(charCode);
        if (charCode <= 1114111) {
          bits = charCode - 65536;
          return String.fromCharCode((55296 | C.JSInt_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
        }
      }
      throw H.wrapException(P.RangeError$range(charCode, 0, 1114111, null, null));
    },
    Primitives_lazyAsJsDate: function(receiver) {
      if (receiver.date === void 0)
        receiver.date = new Date(receiver._core$_value);
      return receiver.date;
    },
    Primitives_getYear: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCFullYear() + 0 : H.Primitives_lazyAsJsDate(receiver).getFullYear() + 0;
    },
    Primitives_getMonth: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMonth() + 1 : H.Primitives_lazyAsJsDate(receiver).getMonth() + 1;
    },
    Primitives_getDay: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCDate() + 0 : H.Primitives_lazyAsJsDate(receiver).getDate() + 0;
    },
    Primitives_getHours: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCHours() + 0 : H.Primitives_lazyAsJsDate(receiver).getHours() + 0;
    },
    Primitives_getMinutes: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMinutes() + 0 : H.Primitives_lazyAsJsDate(receiver).getMinutes() + 0;
    },
    Primitives_getSeconds: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getSeconds() + 0;
    },
    Primitives_getMilliseconds: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMilliseconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getMilliseconds() + 0;
    },
    Primitives_functionNoSuchMethod: function($function, positionalArguments, namedArguments) {
      var $arguments, namedArgumentList, t1 = {};
      H.assertSubtype(namedArguments, "$isMap", [P.String, null], "$asMap");
      t1.argumentCount = 0;
      $arguments = [];
      namedArgumentList = [];
      t1.argumentCount = positionalArguments.length;
      C.JSArray_methods.addAll$1($arguments, positionalArguments);
      t1.names = "";
      if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments))
        namedArguments.forEach$1(0, new H.Primitives_functionNoSuchMethod_closure(t1, namedArgumentList, $arguments));
      "" + t1.argumentCount;
      return J.noSuchMethod$1$($function, new H.JSInvocationMirror(C.Symbol_call, 0, $arguments, namedArgumentList, 0));
    },
    Primitives_applyFunction: function($function, positionalArguments, namedArguments) {
      var t1, $arguments, argumentCount, jsStub;
      H.assertSubtype(namedArguments, "$isMap", [P.String, null], "$asMap");
      if (positionalArguments instanceof Array)
        t1 = namedArguments == null || namedArguments.get$isEmpty(namedArguments);
      else
        t1 = false;
      if (t1) {
        $arguments = positionalArguments;
        argumentCount = $arguments.length;
        if (argumentCount === 0) {
          if (!!$function.call$0)
            return $function.call$0();
        } else if (argumentCount === 1) {
          if (!!$function.call$1)
            return $function.call$1($arguments[0]);
        } else if (argumentCount === 2) {
          if (!!$function.call$2)
            return $function.call$2($arguments[0], $arguments[1]);
        } else if (argumentCount === 3) {
          if (!!$function.call$3)
            return $function.call$3($arguments[0], $arguments[1], $arguments[2]);
        } else if (argumentCount === 4) {
          if (!!$function.call$4)
            return $function.call$4($arguments[0], $arguments[1], $arguments[2], $arguments[3]);
        } else if (argumentCount === 5)
          if (!!$function.call$5)
            return $function.call$5($arguments[0], $arguments[1], $arguments[2], $arguments[3], $arguments[4]);
        jsStub = $function["call" + "$" + argumentCount];
        if (jsStub != null)
          return jsStub.apply($function, $arguments);
      }
      return H.Primitives__genericApplyFunction2($function, positionalArguments, namedArguments);
    },
    Primitives__genericApplyFunction2: function($function, positionalArguments, namedArguments) {
      var $arguments, argumentCount, requiredParameterCount, defaultValuesClosure, t1, defaultValues, interceptor, jsFunction, keys, _i, used, t2;
      H.assertSubtype(namedArguments, "$isMap", [P.String, null], "$asMap");
      if (positionalArguments != null)
        $arguments = positionalArguments instanceof Array ? positionalArguments : P.List_List$from(positionalArguments, true, null);
      else
        $arguments = [];
      argumentCount = $arguments.length;
      requiredParameterCount = $function.$requiredArgCount;
      if (argumentCount < requiredParameterCount)
        return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
      defaultValuesClosure = $function.$defaultValues;
      t1 = defaultValuesClosure == null;
      defaultValues = !t1 ? defaultValuesClosure() : null;
      interceptor = J.getInterceptor$($function);
      jsFunction = interceptor["call*"];
      if (typeof jsFunction === "string")
        jsFunction = interceptor[jsFunction];
      if (t1) {
        if (namedArguments != null && namedArguments.get$isNotEmpty(namedArguments))
          return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        if (argumentCount === requiredParameterCount)
          return jsFunction.apply($function, $arguments);
        return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
      }
      if (defaultValues instanceof Array) {
        if (namedArguments != null && namedArguments.get$isNotEmpty(namedArguments))
          return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        if (argumentCount > requiredParameterCount + defaultValues.length)
          return H.Primitives_functionNoSuchMethod($function, $arguments, null);
        C.JSArray_methods.addAll$1($arguments, defaultValues.slice(argumentCount - requiredParameterCount));
        return jsFunction.apply($function, $arguments);
      } else {
        if (argumentCount > requiredParameterCount)
          return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        keys = Object.keys(defaultValues);
        if (namedArguments == null)
          for (t1 = keys.length, _i = 0; _i < keys.length; keys.length === t1 || (0, H.throwConcurrentModificationError)(keys), ++_i)
            C.JSArray_methods.add$1($arguments, defaultValues[H.stringTypeCheck(keys[_i])]);
        else {
          for (t1 = keys.length, used = 0, _i = 0; _i < keys.length; keys.length === t1 || (0, H.throwConcurrentModificationError)(keys), ++_i) {
            t2 = H.stringTypeCheck(keys[_i]);
            if (namedArguments.containsKey$1(0, t2)) {
              ++used;
              C.JSArray_methods.add$1($arguments, namedArguments.$index(0, t2));
            } else
              C.JSArray_methods.add$1($arguments, defaultValues[t2]);
          }
          if (used !== namedArguments.get$length(namedArguments))
            return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        }
        return jsFunction.apply($function, $arguments);
      }
    },
    iae: function(argument) {
      throw H.wrapException(H.argumentErrorValue(argument));
    },
    ioore: function(receiver, index) {
      if (receiver == null)
        J.get$length$asx(receiver);
      throw H.wrapException(H.diagnoseIndexError(receiver, index));
    },
    diagnoseIndexError: function(indexable, index) {
      var $length, t1, _s5_ = "index";
      if (typeof index !== "number" || Math.floor(index) !== index)
        return new P.ArgumentError(true, index, _s5_, null);
      $length = H.intTypeCheck(J.get$length$asx(indexable));
      if (!(index < 0)) {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = index >= $length;
      } else
        t1 = true;
      if (t1)
        return P.IndexError$(index, indexable, _s5_, null, $length);
      return P.RangeError$value(index, _s5_);
    },
    diagnoseRangeError: function(start, end, $length) {
      var _s13_ = "Invalid value";
      if (start > $length)
        return new P.RangeError(0, $length, true, start, "start", _s13_);
      if (end != null)
        if (end < start || end > $length)
          return new P.RangeError(start, $length, true, end, "end", _s13_);
      return new P.ArgumentError(true, end, "end", null);
    },
    argumentErrorValue: function(object) {
      return new P.ArgumentError(true, object, null, null);
    },
    checkNum: function(value) {
      if (typeof value !== "number")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    wrapException: function(ex) {
      var wrapper;
      if (ex == null)
        ex = new P.NullThrownError();
      wrapper = new Error();
      wrapper.dartException = ex;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
        wrapper.name = "";
      } else
        wrapper.toString = H.toStringWrapper;
      return wrapper;
    },
    toStringWrapper: function() {
      return J.toString$0$(this.dartException);
    },
    throwExpression: function(ex) {
      throw H.wrapException(ex);
    },
    throwConcurrentModificationError: function(collection) {
      throw H.wrapException(P.ConcurrentModificationError$(collection));
    },
    TypeErrorDecoder_extractPattern: function(message) {
      var match, $arguments, argumentsExpr, expr, method, receiver;
      message = H.quoteStringForRegExp(message.replace(String({}), '$receiver$'));
      match = message.match(/\\\$[a-zA-Z]+\\\$/g);
      if (match == null)
        match = H.setRuntimeTypeInfo([], [P.String]);
      $arguments = match.indexOf("\\$arguments\\$");
      argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
      expr = match.indexOf("\\$expr\\$");
      method = match.indexOf("\\$method\\$");
      receiver = match.indexOf("\\$receiver\\$");
      return new H.TypeErrorDecoder(message.replace(new RegExp('\\\\\\$arguments\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$argumentsExpr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$expr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$method\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$receiver\\\\\\$', 'g'), '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
    },
    TypeErrorDecoder_provokeCallErrorOn: function(expression) {
      return function($expr$) {
        var $argumentsExpr$ = '$arguments$';
        try {
          $expr$.$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
      return function($expr$) {
        try {
          $expr$.$method$;
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    NullError$: function(_message, match) {
      return new H.NullError(_message, match == null ? null : match.method);
    },
    JsNoSuchMethodError$: function(_message, match) {
      var t1 = match == null,
        t2 = t1 ? null : match.method;
      return new H.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
    },
    unwrapException: function(ex) {
      var message, number, ieErrorCode, nsme, notClosure, nullCall, nullLiteralCall, undefCall, undefLiteralCall, nullProperty, undefProperty, undefLiteralProperty, match, t2, _null = null,
        t1 = new H.unwrapException_saveStackTrace(ex);
      if (ex == null)
        return;
      if (ex instanceof H.ExceptionAndStackTrace)
        return t1.call$1(ex.dartException);
      if (typeof ex !== "object")
        return ex;
      if ("dartException" in ex)
        return t1.call$1(ex.dartException);
      else if (!("message" in ex))
        return ex;
      message = ex.message;
      if ("number" in ex && typeof ex.number == "number") {
        number = ex.number;
        ieErrorCode = number & 65535;
        if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
          switch (ieErrorCode) {
            case 438:
              return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", _null));
            case 445:
            case 5007:
              return t1.call$1(H.NullError$(H.S(message) + " (Error " + ieErrorCode + ")", _null));
          }
      }
      if (ex instanceof TypeError) {
        nsme = $.$get$TypeErrorDecoder_noSuchMethodPattern();
        notClosure = $.$get$TypeErrorDecoder_notClosurePattern();
        nullCall = $.$get$TypeErrorDecoder_nullCallPattern();
        nullLiteralCall = $.$get$TypeErrorDecoder_nullLiteralCallPattern();
        undefCall = $.$get$TypeErrorDecoder_undefinedCallPattern();
        undefLiteralCall = $.$get$TypeErrorDecoder_undefinedLiteralCallPattern();
        nullProperty = $.$get$TypeErrorDecoder_nullPropertyPattern();
        $.$get$TypeErrorDecoder_nullLiteralPropertyPattern();
        undefProperty = $.$get$TypeErrorDecoder_undefinedPropertyPattern();
        undefLiteralProperty = $.$get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
        match = nsme.matchTypeError$1(message);
        if (match != null)
          return t1.call$1(H.JsNoSuchMethodError$(H.stringTypeCheck(message), match));
        else {
          match = notClosure.matchTypeError$1(message);
          if (match != null) {
            match.method = "call";
            return t1.call$1(H.JsNoSuchMethodError$(H.stringTypeCheck(message), match));
          } else {
            match = nullCall.matchTypeError$1(message);
            if (match == null) {
              match = nullLiteralCall.matchTypeError$1(message);
              if (match == null) {
                match = undefCall.matchTypeError$1(message);
                if (match == null) {
                  match = undefLiteralCall.matchTypeError$1(message);
                  if (match == null) {
                    match = nullProperty.matchTypeError$1(message);
                    if (match == null) {
                      match = nullLiteralCall.matchTypeError$1(message);
                      if (match == null) {
                        match = undefProperty.matchTypeError$1(message);
                        if (match == null) {
                          match = undefLiteralProperty.matchTypeError$1(message);
                          t2 = match != null;
                        } else
                          t2 = true;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
            if (t2)
              return t1.call$1(H.NullError$(H.stringTypeCheck(message), match));
          }
        }
        return t1.call$1(new H.UnknownJsTypeError(typeof message === "string" ? message : ""));
      }
      if (ex instanceof RangeError) {
        if (typeof message === "string" && message.indexOf("call stack") !== -1)
          return new P.StackOverflowError();
        message = function(ex) {
          try {
            return String(ex);
          } catch (e) {
          }
          return null;
        }(ex);
        return t1.call$1(new P.ArgumentError(false, _null, _null, typeof message === "string" ? message.replace(/^RangeError:\s*/, "") : message));
      }
      if (typeof InternalError == "function" && ex instanceof InternalError)
        if (typeof message === "string" && message === "too much recursion")
          return new P.StackOverflowError();
      return ex;
    },
    getTraceFromException: function(exception) {
      var trace;
      if (exception instanceof H.ExceptionAndStackTrace)
        return exception.stackTrace;
      if (exception == null)
        return new H._StackTrace(exception);
      trace = exception.$cachedTrace;
      if (trace != null)
        return trace;
      return exception.$cachedTrace = new H._StackTrace(exception);
    },
    objectHashCode: function(object) {
      if (object == null || typeof object != 'object')
        return J.get$hashCode$(object);
      else
        return H.Primitives_objectHashCode(object);
    },
    fillLiteralMap: function(keyValuePairs, result) {
      var index, index0, index1,
        $length = keyValuePairs.length;
      for (index = 0; index < $length; index = index1) {
        index0 = index + 1;
        index1 = index0 + 1;
        result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
      }
      return result;
    },
    invokeClosure: function(closure, numberOfArguments, arg1, arg2, arg3, arg4) {
      H.interceptedTypeCheck(closure, "$isFunction");
      switch (H.intTypeCheck(numberOfArguments)) {
        case 0:
          return closure.call$0();
        case 1:
          return closure.call$1(arg1);
        case 2:
          return closure.call$2(arg1, arg2);
        case 3:
          return closure.call$3(arg1, arg2, arg3);
        case 4:
          return closure.call$4(arg1, arg2, arg3, arg4);
      }
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
    },
    convertDartClosureToJS: function(closure, arity) {
      var $function;
      H.intTypeCheck(arity);
      if (closure == null)
        return;
      $function = closure.$identity;
      if (!!$function)
        return $function;
      $function = function(closure, arity, invoke) {
        return function(a1, a2, a3, a4) {
          return invoke(closure, arity, a1, a2, a3, a4);
        };
      }(closure, arity, H.invokeClosure);
      closure.$identity = $function;
      return $function;
    },
    Closure_fromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, propertyName) {
      var $constructor, t1, trampoline, signatureFunction, getReceiver, applyTrampoline, i, stub, stubCallName, _null = null,
        $function = functions[0],
        callName = $function.$callName,
        $prototype = isStatic ? Object.create(new H.StaticClosure().constructor.prototype) : Object.create(new H.BoundClosure(_null, _null, _null, _null).constructor.prototype);
      $prototype.$initialize = $prototype.constructor;
      if (isStatic)
        $constructor = function static_tear_off() {
          this.$initialize();
        };
      else {
        t1 = $.Closure_functionCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.Closure_functionCounter = t1 + 1;
        t1 = new Function("a,b,c,d" + t1, "this.$initialize(a,b,c,d" + t1 + ")");
        $constructor = t1;
      }
      $prototype.constructor = $constructor;
      $constructor.prototype = $prototype;
      if (!isStatic) {
        trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
        trampoline.$reflectionInfo = reflectionInfo;
      } else {
        $prototype.$static_name = propertyName;
        trampoline = $function;
      }
      if (typeof reflectionInfo == "number")
        signatureFunction = function(getType, t) {
          return function() {
            return getType(t);
          };
        }(H.getType, reflectionInfo);
      else if (typeof reflectionInfo == "function")
        if (isStatic)
          signatureFunction = reflectionInfo;
        else {
          getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
          signatureFunction = function(f, r) {
            return function() {
              return f.apply({$receiver: r(this)}, arguments);
            };
          }(reflectionInfo, getReceiver);
        }
      else
        throw H.wrapException("Error in reflectionInfo.");
      $prototype.$signature = signatureFunction;
      $prototype[callName] = trampoline;
      for (applyTrampoline = trampoline, i = 1; i < functions.length; ++i) {
        stub = functions[i];
        stubCallName = stub.$callName;
        if (stubCallName != null) {
          stub = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
          $prototype[stubCallName] = stub;
        }
        if (i === applyTrampolineIndex) {
          stub.$reflectionInfo = reflectionInfo;
          applyTrampoline = stub;
        }
      }
      $prototype["call*"] = applyTrampoline;
      $prototype.$requiredArgCount = $function.$requiredArgCount;
      $prototype.$defaultValues = $function.$defaultValues;
      return $constructor;
    },
    Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
      var getSelf = H.BoundClosure_selfOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          return function(n, S) {
            return function() {
              return S(this)[n]();
            };
          }(stubName, getSelf);
        case 1:
          return function(n, S) {
            return function(a) {
              return S(this)[n](a);
            };
          }(stubName, getSelf);
        case 2:
          return function(n, S) {
            return function(a, b) {
              return S(this)[n](a, b);
            };
          }(stubName, getSelf);
        case 3:
          return function(n, S) {
            return function(a, b, c) {
              return S(this)[n](a, b, c);
            };
          }(stubName, getSelf);
        case 4:
          return function(n, S) {
            return function(a, b, c, d) {
              return S(this)[n](a, b, c, d);
            };
          }(stubName, getSelf);
        case 5:
          return function(n, S) {
            return function(a, b, c, d, e) {
              return S(this)[n](a, b, c, d, e);
            };
          }(stubName, getSelf);
        default:
          return function(f, s) {
            return function() {
              return f.apply(s(this), arguments);
            };
          }($function, getSelf);
      }
    },
    Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
      var stubName, arity, lookedUpFunction, t1, t2, selfName, $arguments;
      if (isIntercepted)
        return H.Closure_forwardInterceptedCallTo(receiver, $function);
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t2 = !t1 || arity >= 27;
      if (t2)
        return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
      if (arity === 0) {
        t1 = $.Closure_functionCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.Closure_functionCounter = t1 + 1;
        selfName = "self" + t1;
        t1 = "return function(){var " + selfName + " = this.";
        t2 = $.BoundClosure_selfFieldNameCache;
        return new Function(t1 + H.S(t2 == null ? $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self") : t2) + ";return " + selfName + "." + H.S(stubName) + "();}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
      t1 = $.Closure_functionCounter;
      if (typeof t1 !== "number")
        return t1.$add();
      $.Closure_functionCounter = t1 + 1;
      $arguments += t1;
      t1 = "return function(" + $arguments + "){return this.";
      t2 = $.BoundClosure_selfFieldNameCache;
      return new Function(t1 + H.S(t2 == null ? $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self") : t2) + "." + H.S(stubName) + "(" + $arguments + ");}")();
    },
    Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
      var getSelf = H.BoundClosure_selfOf,
        getReceiver = H.BoundClosure_receiverOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
        case 1:
          return function(n, s, r) {
            return function() {
              return s(this)[n](r(this));
            };
          }($name, getSelf, getReceiver);
        case 2:
          return function(n, s, r) {
            return function(a) {
              return s(this)[n](r(this), a);
            };
          }($name, getSelf, getReceiver);
        case 3:
          return function(n, s, r) {
            return function(a, b) {
              return s(this)[n](r(this), a, b);
            };
          }($name, getSelf, getReceiver);
        case 4:
          return function(n, s, r) {
            return function(a, b, c) {
              return s(this)[n](r(this), a, b, c);
            };
          }($name, getSelf, getReceiver);
        case 5:
          return function(n, s, r) {
            return function(a, b, c, d) {
              return s(this)[n](r(this), a, b, c, d);
            };
          }($name, getSelf, getReceiver);
        case 6:
          return function(n, s, r) {
            return function(a, b, c, d, e) {
              return s(this)[n](r(this), a, b, c, d, e);
            };
          }($name, getSelf, getReceiver);
        default:
          return function(f, s, r, a) {
            return function() {
              a = [r(this)];
              Array.prototype.push.apply(a, arguments);
              return f.apply(s(this), a);
            };
          }($function, getSelf, getReceiver);
      }
    },
    Closure_forwardInterceptedCallTo: function(receiver, $function) {
      var t2, stubName, arity, lookedUpFunction, t3, t4, $arguments,
        t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null)
        t1 = $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self");
      t2 = $.BoundClosure_receiverFieldNameCache;
      if (t2 == null)
        t2 = $.BoundClosure_receiverFieldNameCache = H.BoundClosure_computeFieldNamed("receiver");
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t3 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t4 = !t3 || arity >= 28;
      if (t4)
        return H.Closure_cspForwardInterceptedCall(arity, !t3, stubName, $function);
      if (arity === 1) {
        t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "(this." + H.S(t2) + ");";
        t2 = $.Closure_functionCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.Closure_functionCounter = t2 + 1;
        return new Function(t1 + t2 + "}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
      t1 = "return function(" + $arguments + "){return this." + H.S(t1) + "." + H.S(stubName) + "(this." + H.S(t2) + ", " + $arguments + ");";
      t2 = $.Closure_functionCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.Closure_functionCounter = t2 + 1;
      return new Function(t1 + t2 + "}")();
    },
    closureFromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, $name) {
      return H.Closure_fromTearOff(receiver, functions, H.intTypeCheck(applyTrampolineIndex), reflectionInfo, !!isStatic, !!isIntercepted, $name);
    },
    BoundClosure_selfOf: function(closure) {
      return closure._self;
    },
    BoundClosure_receiverOf: function(closure) {
      return closure._receiver;
    },
    BoundClosure_computeFieldNamed: function(fieldName) {
      var t1, i, $name,
        template = new H.BoundClosure("self", "target", "receiver", "name"),
        names = J.JSArray_markFixedList(Object.getOwnPropertyNames(template));
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (template[$name] === fieldName)
          return $name;
      }
    },
    boolConversionCheck: function(value) {
      if (value == null)
        H.assertThrow("boolean expression must not be null");
      return value;
    },
    stringTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "String"));
    },
    doubleTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "double"));
    },
    doubleTypeCast: function(value) {
      if (typeof value === "number" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(value, "double"));
    },
    numTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "num"));
    },
    boolTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "boolean")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "bool"));
    },
    intTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number" && Math.floor(value) === value)
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "int"));
    },
    propertyTypeError: function(value, property) {
      throw H.wrapException(H.TypeErrorImplementation$(value, H.unminifyOrTag(H.stringTypeCheck(property).substring(3))));
    },
    propertyTypeCastError: function(value, property) {
      throw H.wrapException(H.CastErrorImplementation$(value, H.unminifyOrTag(H.stringTypeCheck(property).substring(3))));
    },
    interceptedTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if ((typeof value === "object" || typeof value === "function") && J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    interceptedTypeCast: function(value, property) {
      var t1;
      if (value != null)
        t1 = (typeof value === "object" || typeof value === "function") && J.getInterceptor$(value)[property];
      else
        t1 = true;
      if (t1)
        return value;
      H.propertyTypeCastError(value, property);
    },
    numberOrStringSuperNativeTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (typeof value === "number")
        return value;
      if (J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    stringSuperNativeTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    listTypeCheck: function(value) {
      if (value == null)
        return value;
      if (!!J.getInterceptor$(value).$isList)
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "List<dynamic>"));
    },
    listSuperNativeTypeCheck: function(value, property) {
      var t1;
      if (value == null)
        return value;
      t1 = J.getInterceptor$(value);
      if (!!t1.$isList)
        return value;
      if (t1[property])
        return value;
      H.propertyTypeError(value, property);
    },
    extractFunctionTypeObjectFromInternal: function(o) {
      var signature;
      if ("$signature" in o) {
        signature = o.$signature;
        if (typeof signature == "number")
          return init.types[H.intTypeCheck(signature)];
        else
          return o.$signature();
      }
      return;
    },
    functionTypeTest: function(value, functionTypeRti) {
      var functionTypeObject;
      if (typeof value == "function")
        return true;
      functionTypeObject = H.extractFunctionTypeObjectFromInternal(J.getInterceptor$(value));
      if (functionTypeObject == null)
        return false;
      return H._isFunctionSubtype(functionTypeObject, null, functionTypeRti, null);
    },
    functionTypeCheck: function(value, functionTypeRti) {
      var $self, t1;
      if (value == null)
        return value;
      if ($._inTypeAssertion)
        return value;
      $._inTypeAssertion = true;
      try {
        if (H.functionTypeTest(value, functionTypeRti))
          return value;
        $self = H.runtimeTypeToString(functionTypeRti);
        t1 = H.TypeErrorImplementation$(value, $self);
        throw H.wrapException(t1);
      } finally {
        $._inTypeAssertion = false;
      }
    },
    futureOrCheck: function(o, futureOrRti) {
      if (o != null && !H.checkSubtypeOfRuntimeType(o, futureOrRti))
        H.throwExpression(H.TypeErrorImplementation$(o, H.runtimeTypeToString(futureOrRti)));
      return o;
    },
    TypeErrorImplementation$: function(value, type) {
      return new H.TypeErrorImplementation("TypeError: " + P.Error_safeToString(value) + ": type '" + H._typeDescription(value) + "' is not a subtype of type '" + type + "'");
    },
    CastErrorImplementation$: function(value, type) {
      return new H.CastErrorImplementation("CastError: " + P.Error_safeToString(value) + ": type '" + H._typeDescription(value) + "' is not a subtype of type '" + type + "'");
    },
    _typeDescription: function(value) {
      var functionTypeObject,
        t1 = J.getInterceptor$(value);
      if (!!t1.$isClosure) {
        functionTypeObject = H.extractFunctionTypeObjectFromInternal(t1);
        if (functionTypeObject != null)
          return H.runtimeTypeToString(functionTypeObject);
        return "Closure";
      }
      return H.Primitives_objectTypeName(value);
    },
    assertThrow: function(message) {
      throw H.wrapException(new H._AssertionError(message));
    },
    throwCyclicInit: function(staticName) {
      throw H.wrapException(new P.CyclicInitializationError(H.stringTypeCheck(staticName)));
    },
    RuntimeError$: function(message) {
      return new H.RuntimeError(message);
    },
    getIsolateAffinityTag: function($name) {
      return init.getIsolateTag($name);
    },
    createRuntimeType: function(rti) {
      return new H.TypeImpl(rti);
    },
    setRuntimeTypeInfo: function(target, rti) {
      target.$ti = rti;
      return target;
    },
    getRuntimeTypeInfo: function(target) {
      if (target == null)
        return;
      return target.$ti;
    },
    getRuntimeTypeArguments: function(interceptor, object, substitutionName) {
      return H.substitute(interceptor["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(object));
    },
    getRuntimeTypeArgumentIntercepted: function(interceptor, target, substitutionName, index) {
      var $arguments;
      H.stringTypeCheck(substitutionName);
      H.intTypeCheck(index);
      $arguments = H.substitute(interceptor["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
      return $arguments == null ? null : $arguments[index];
    },
    getRuntimeTypeArgument: function(target, substitutionName, index) {
      var $arguments;
      H.stringTypeCheck(substitutionName);
      H.intTypeCheck(index);
      $arguments = H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
      return $arguments == null ? null : $arguments[index];
    },
    getTypeArgumentByIndex: function(target, index) {
      var rti;
      H.intTypeCheck(index);
      rti = H.getRuntimeTypeInfo(target);
      return rti == null ? null : rti[index];
    },
    runtimeTypeToString: function(rti) {
      return H._runtimeTypeToString(rti, null);
    },
    _runtimeTypeToString: function(rti, genericContext) {
      var t1, t2;
      H.assertSubtype(genericContext, "$isList", [P.String], "$asList");
      if (rti == null)
        return "dynamic";
      if (rti === -1)
        return "void";
      if (typeof rti === "object" && rti !== null && rti.constructor === Array)
        return H.unminifyOrTag(rti[0].name) + H._joinArguments(rti, 1, genericContext);
      if (typeof rti == "function")
        return H.unminifyOrTag(rti.name);
      if (rti === -2)
        return "dynamic";
      if (typeof rti === "number") {
        H.intTypeCheck(rti);
        if (genericContext == null || rti < 0 || rti >= genericContext.length)
          return "unexpected-generic-index:" + rti;
        t1 = genericContext.length;
        t2 = t1 - rti - 1;
        if (t2 < 0 || t2 >= t1)
          return H.ioore(genericContext, t2);
        return H.S(genericContext[t2]);
      }
      if ('func' in rti)
        return H._functionRtiToString(rti, genericContext);
      if ('futureOr' in rti)
        return "FutureOr<" + H._runtimeTypeToString("type" in rti ? rti.type : null, genericContext) + ">";
      return "unknown-reified-type";
    },
    _functionRtiToString: function(rti, genericContext) {
      var boundsRti, outerContextLength, offset, i, i0, typeParameters, typeSep, t2, boundRti, returnTypeText, $arguments, argumentsText, sep, _i, argument, optionalArguments, namedArguments, t3, _s2_ = ", ",
        t1 = [P.String];
      H.assertSubtype(genericContext, "$isList", t1, "$asList");
      if ("bounds" in rti) {
        boundsRti = rti.bounds;
        if (genericContext == null) {
          genericContext = H.setRuntimeTypeInfo([], t1);
          outerContextLength = null;
        } else
          outerContextLength = genericContext.length;
        offset = genericContext.length;
        for (i = boundsRti.length, i0 = i; i0 > 0; --i0)
          C.JSArray_methods.add$1(genericContext, "T" + (offset + i0));
        for (typeParameters = "<", typeSep = "", i0 = 0; i0 < i; ++i0, typeSep = _s2_) {
          typeParameters += typeSep;
          t1 = genericContext.length;
          t2 = t1 - i0 - 1;
          if (t2 < 0)
            return H.ioore(genericContext, t2);
          typeParameters = C.JSString_methods.$add(typeParameters, genericContext[t2]);
          boundRti = boundsRti[i0];
          if (boundRti != null && boundRti !== P.Object)
            typeParameters += " extends " + H._runtimeTypeToString(boundRti, genericContext);
        }
        typeParameters += ">";
      } else {
        typeParameters = "";
        outerContextLength = null;
      }
      returnTypeText = !!rti.v ? "void" : H._runtimeTypeToString(rti.ret, genericContext);
      if ("args" in rti) {
        $arguments = rti.args;
        for (t1 = $arguments.length, argumentsText = "", sep = "", _i = 0; _i < t1; ++_i, sep = _s2_) {
          argument = $arguments[_i];
          argumentsText = argumentsText + sep + H._runtimeTypeToString(argument, genericContext);
        }
      } else {
        argumentsText = "";
        sep = "";
      }
      if ("opt" in rti) {
        optionalArguments = rti.opt;
        argumentsText += sep + "[";
        for (t1 = optionalArguments.length, sep = "", _i = 0; _i < t1; ++_i, sep = _s2_) {
          argument = optionalArguments[_i];
          argumentsText = argumentsText + sep + H._runtimeTypeToString(argument, genericContext);
        }
        argumentsText += "]";
      }
      if ("named" in rti) {
        namedArguments = rti.named;
        argumentsText += sep + "{";
        for (t1 = H.extractKeys(namedArguments), t2 = t1.length, sep = "", _i = 0; _i < t2; ++_i, sep = _s2_) {
          t3 = H.stringTypeCheck(t1[_i]);
          argumentsText = argumentsText + sep + H._runtimeTypeToString(namedArguments[t3], genericContext) + (" " + H.S(t3));
        }
        argumentsText += "}";
      }
      if (outerContextLength != null)
        genericContext.length = outerContextLength;
      return typeParameters + "(" + argumentsText + ") => " + returnTypeText;
    },
    _joinArguments: function(types, startIndex, genericContext) {
      var buffer, index, separator, allDynamic, t1, argument;
      H.assertSubtype(genericContext, "$isList", [P.String], "$asList");
      if (types == null)
        return "";
      buffer = new P.StringBuffer("");
      for (index = startIndex, separator = "", allDynamic = true, t1 = ""; index < types.length; ++index, separator = ", ") {
        buffer._contents = t1 + separator;
        argument = types[index];
        if (argument != null)
          allDynamic = false;
        t1 = buffer._contents += H._runtimeTypeToString(argument, genericContext);
      }
      return "<" + buffer.toString$0(0) + ">";
    },
    getRti: function(o) {
      var functionRti, type, rti,
        t1 = J.getInterceptor$(o);
      if (!!t1.$isClosure) {
        functionRti = H.extractFunctionTypeObjectFromInternal(t1);
        if (functionRti != null)
          return functionRti;
      }
      type = t1.constructor;
      if (typeof o != "object")
        return type;
      rti = H.getRuntimeTypeInfo(o);
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      return type;
    },
    substitute: function(substitution, $arguments) {
      if (substitution == null)
        return $arguments;
      substitution = substitution.apply(null, $arguments);
      if (substitution == null)
        return;
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        return substitution;
      if (typeof substitution == "function")
        return substitution.apply(null, $arguments);
      return $arguments;
    },
    checkSubtype: function(object, isField, checks, asField) {
      var $arguments, interceptor;
      H.stringTypeCheck(isField);
      H.listTypeCheck(checks);
      H.stringTypeCheck(asField);
      if (object == null)
        return false;
      $arguments = H.getRuntimeTypeInfo(object);
      interceptor = J.getInterceptor$(object);
      if (interceptor[isField] == null)
        return false;
      return H.areSubtypes(H.substitute(interceptor[asField], $arguments), null, checks, null);
    },
    assertSubtype: function(object, isField, checks, asField) {
      H.stringTypeCheck(isField);
      H.listTypeCheck(checks);
      H.stringTypeCheck(asField);
      if (object == null)
        return object;
      if (H.checkSubtype(object, isField, checks, asField))
        return object;
      throw H.wrapException(H.TypeErrorImplementation$(object, function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(H.unminifyOrTag(isField.substring(3)) + H._joinArguments(checks, 0, null), init.mangledGlobalNames)));
    },
    assertIsSubtype: function(subtype, supertype, prefix, infix, suffix) {
      H.stringTypeCheck(prefix);
      H.stringTypeCheck(infix);
      H.stringTypeCheck(suffix);
      if (!H._isSubtype(subtype, null, supertype, null))
        H.throwTypeError("TypeError: " + H.S(prefix) + H.runtimeTypeToString(subtype) + H.S(infix) + H.runtimeTypeToString(supertype) + H.S(suffix));
    },
    throwTypeError: function(message) {
      throw H.wrapException(new H.TypeErrorImplementation(H.stringTypeCheck(message)));
    },
    areSubtypes: function(s, sEnv, t, tEnv) {
      var len, i;
      if (t == null)
        return true;
      if (s == null) {
        len = t.length;
        for (i = 0; i < len; ++i)
          if (!H._isSubtype(null, null, t[i], tEnv))
            return false;
        return true;
      }
      len = s.length;
      for (i = 0; i < len; ++i)
        if (!H._isSubtype(s[i], sEnv, t[i], tEnv))
          return false;
      return true;
    },
    computeSignature: function(signature, context, contextName) {
      return signature.apply(context, H.substitute(J.getInterceptor$(context)["$as" + H.S(contextName)], H.getRuntimeTypeInfo(context)));
    },
    isSupertypeOfNullRecursive: function(type) {
      var typeArgument;
      if (typeof type === "number")
        return false;
      if ('futureOr' in type) {
        typeArgument = "type" in type ? type.type : null;
        return type == null || type.name === "Object" || type.name === "Null" || type === -1 || type === -2 || H.isSupertypeOfNullRecursive(typeArgument);
      }
      return false;
    },
    checkSubtypeOfRuntimeType: function(o, t) {
      var type, rti;
      if (o == null)
        return t == null || t.name === "Object" || t.name === "Null" || t === -1 || t === -2 || H.isSupertypeOfNullRecursive(t);
      if (t == null || t === -1 || t.name === "Object" || t === -2)
        return true;
      if (typeof t == "object") {
        if ('futureOr' in t)
          if (H.checkSubtypeOfRuntimeType(o, "type" in t ? t.type : null))
            return true;
        if ('func' in t)
          return H.functionTypeTest(o, t);
      }
      type = J.getInterceptor$(o).constructor;
      rti = H.getRuntimeTypeInfo(o);
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      return H._isSubtype(type, null, t, null);
    },
    assertSubtypeOfRuntimeType: function(object, type) {
      if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
        throw H.wrapException(H.TypeErrorImplementation$(object, H.runtimeTypeToString(type)));
      return object;
    },
    _isSubtype: function(s, sEnv, t, tEnv) {
      var t1, typeOfS, tTypeArgument, futureSubstitution, futureArguments, t2, typeOfT, typeOfTString, substitution, _null = null;
      if (s === t)
        return true;
      if (t == null || t === -1 || t.name === "Object" || t === -2)
        return true;
      if (s === -2)
        return true;
      if (s == null || s === -1 || s.name === "Object" || s === -2) {
        if (typeof t === "number")
          return false;
        if ('futureOr' in t)
          return H._isSubtype(s, sEnv, "type" in t ? t.type : _null, tEnv);
        return false;
      }
      if (typeof s === "number")
        return false;
      if (typeof t === "number")
        return false;
      if (s.name === "Null")
        return true;
      if ('func' in t)
        return H._isFunctionSubtype(s, sEnv, t, tEnv);
      if ('func' in s)
        return t.name === "Function";
      t1 = typeof s === "object" && s !== null && s.constructor === Array;
      typeOfS = t1 ? s[0] : s;
      if ('futureOr' in t) {
        tTypeArgument = "type" in t ? t.type : _null;
        if ('futureOr' in s)
          return H._isSubtype("type" in s ? s.type : _null, sEnv, tTypeArgument, tEnv);
        else if (H._isSubtype(s, sEnv, tTypeArgument, tEnv))
          return true;
        else {
          if (!('$is' + "Future" in typeOfS.prototype))
            return false;
          futureSubstitution = typeOfS.prototype["$as" + "Future"];
          futureArguments = H.substitute(futureSubstitution, t1 ? s.slice(1) : _null);
          return H._isSubtype(typeof futureArguments === "object" && futureArguments !== null && futureArguments.constructor === Array ? futureArguments[0] : _null, sEnv, tTypeArgument, tEnv);
        }
      }
      t2 = typeof t === "object" && t !== null && t.constructor === Array;
      typeOfT = t2 ? t[0] : t;
      if (typeOfT !== typeOfS) {
        typeOfTString = typeOfT.name;
        if (!('$is' + typeOfTString in typeOfS.prototype))
          return false;
        substitution = typeOfS.prototype["$as" + typeOfTString];
      } else
        substitution = _null;
      if (!t2)
        return true;
      t1 = t1 ? s.slice(1) : _null;
      t2 = t.slice(1);
      return H.areSubtypes(H.substitute(substitution, t1), sEnv, t2, tEnv);
    },
    _isFunctionSubtype: function(s, sEnv, t, tEnv) {
      var sBounds, tBounds, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, tPos, sPos, sNamedParameters, tNamedParameters;
      if (!('func' in s))
        return false;
      if ("bounds" in s) {
        if (!("bounds" in t))
          return false;
        sBounds = s.bounds;
        tBounds = t.bounds;
        if (sBounds.length !== tBounds.length)
          return false;
      } else if ("bounds" in t)
        return false;
      if (!H._isSubtype(s.ret, sEnv, t.ret, tEnv))
        return false;
      sParameterTypes = s.args;
      tParameterTypes = t.args;
      sOptionalParameterTypes = s.opt;
      tOptionalParameterTypes = t.opt;
      sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
      tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
      sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
      tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
      if (sParametersLen > tParametersLen)
        return false;
      if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
        return false;
      for (pos = 0; pos < sParametersLen; ++pos)
        if (!H._isSubtype(tParameterTypes[pos], tEnv, sParameterTypes[pos], sEnv))
          return false;
      for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos)
        if (!H._isSubtype(tParameterTypes[tPos], tEnv, sOptionalParameterTypes[sPos], sEnv))
          return false;
      for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos)
        if (!H._isSubtype(tOptionalParameterTypes[tPos], tEnv, sOptionalParameterTypes[sPos], sEnv))
          return false;
      sNamedParameters = s.named;
      tNamedParameters = t.named;
      if (tNamedParameters == null)
        return true;
      if (sNamedParameters == null)
        return false;
      return H.namedParametersSubtypeCheck(sNamedParameters, sEnv, tNamedParameters, tEnv);
    },
    namedParametersSubtypeCheck: function(s, sEnv, t, tEnv) {
      var t1, i, $name,
        names = Object.getOwnPropertyNames(t);
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (!Object.hasOwnProperty.call(s, $name))
          return false;
        if (!H._isSubtype(t[$name], tEnv, s[$name], sEnv))
          return false;
      }
      return true;
    },
    JsLinkedHashMap_JsLinkedHashMap$es6: function($K, $V) {
      return new H.JsLinkedHashMap([$K, $V]);
    },
    defineProperty: function(obj, property, value) {
      Object.defineProperty(obj, H.stringTypeCheck(property), {value: value, enumerable: false, writable: true, configurable: true});
    },
    lookupAndCacheInterceptor: function(obj) {
      var interceptor, interceptorClass, mark, t1,
        tag = H.stringTypeCheck($.getTagFunction.call$1(obj)),
        record = $.dispatchRecordsForInstanceTags[tag];
      if (record != null) {
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      interceptor = $.interceptorsForUncacheableTags[tag];
      if (interceptor != null)
        return interceptor;
      interceptorClass = init.interceptorsByTag[tag];
      if (interceptorClass == null) {
        tag = H.stringTypeCheck($.alternateTagFunction.call$2(obj, tag));
        if (tag != null) {
          record = $.dispatchRecordsForInstanceTags[tag];
          if (record != null) {
            Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            return record.i;
          }
          interceptor = $.interceptorsForUncacheableTags[tag];
          if (interceptor != null)
            return interceptor;
          interceptorClass = init.interceptorsByTag[tag];
        }
      }
      if (interceptorClass == null)
        return;
      interceptor = interceptorClass.prototype;
      mark = tag[0];
      if (mark === "!") {
        record = H.makeLeafDispatchRecord(interceptor);
        $.dispatchRecordsForInstanceTags[tag] = record;
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      if (mark === "~") {
        $.interceptorsForUncacheableTags[tag] = interceptor;
        return interceptor;
      }
      if (mark === "-") {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      }
      if (mark === "+")
        return H.patchInteriorProto(obj, interceptor);
      if (mark === "*")
        throw H.wrapException(P.UnimplementedError$(tag));
      if (init.leafTags[tag] === true) {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      } else
        return H.patchInteriorProto(obj, interceptor);
    },
    patchInteriorProto: function(obj, interceptor) {
      var proto = Object.getPrototypeOf(obj);
      Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
      return interceptor;
    },
    makeLeafDispatchRecord: function(interceptor) {
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    },
    makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
      var interceptor = interceptorClass.prototype;
      if (init.leafTags[tag] === true)
        return H.makeLeafDispatchRecord(interceptor);
      else
        return J.makeDispatchRecord(interceptor, proto, null, null);
    },
    initNativeDispatch: function() {
      if (true === $.initNativeDispatchFlag)
        return;
      $.initNativeDispatchFlag = true;
      H.initNativeDispatchContinue();
    },
    initNativeDispatchContinue: function() {
      var map, tags, fun, i, tag, proto, record, interceptorClass;
      $.dispatchRecordsForInstanceTags = Object.create(null);
      $.interceptorsForUncacheableTags = Object.create(null);
      H.initHooks();
      map = init.interceptorsByTag;
      tags = Object.getOwnPropertyNames(map);
      if (typeof window != "undefined") {
        window;
        fun = function() {
        };
        for (i = 0; i < tags.length; ++i) {
          tag = tags[i];
          proto = $.prototypeForTagFunction.call$1(tag);
          if (proto != null) {
            record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
            if (record != null) {
              Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
              fun.prototype = proto;
            }
          }
        }
      }
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        if (/^[A-Za-z_]/.test(tag)) {
          interceptorClass = map[tag];
          map["!" + tag] = interceptorClass;
          map["~" + tag] = interceptorClass;
          map["-" + tag] = interceptorClass;
          map["+" + tag] = interceptorClass;
          map["*" + tag] = interceptorClass;
        }
      }
    },
    initHooks: function() {
      var transformers, i, transformer, getTag, getUnknownTag, prototypeForTag,
        hooks = C.C_JS_CONST0();
      hooks = H.applyHooksTransformer(C.C_JS_CONST1, H.applyHooksTransformer(C.C_JS_CONST2, H.applyHooksTransformer(C.C_JS_CONST3, H.applyHooksTransformer(C.C_JS_CONST3, H.applyHooksTransformer(C.C_JS_CONST4, H.applyHooksTransformer(C.C_JS_CONST5, H.applyHooksTransformer(C.C_JS_CONST6(C.C_JS_CONST), hooks)))))));
      if (typeof dartNativeDispatchHooksTransformer != "undefined") {
        transformers = dartNativeDispatchHooksTransformer;
        if (typeof transformers == "function")
          transformers = [transformers];
        if (transformers.constructor == Array)
          for (i = 0; i < transformers.length; ++i) {
            transformer = transformers[i];
            if (typeof transformer == "function")
              hooks = transformer(hooks) || hooks;
          }
      }
      getTag = hooks.getTag;
      getUnknownTag = hooks.getUnknownTag;
      prototypeForTag = hooks.prototypeForTag;
      $.getTagFunction = new H.initHooks_closure(getTag);
      $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
      $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
    },
    applyHooksTransformer: function(transformer, hooks) {
      return transformer(hooks) || hooks;
    },
    JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
      var m = multiLine ? "m" : "",
        i = caseSensitive ? "" : "i",
        g = global ? "g" : "",
        regexp = function(source, modifiers) {
          try {
            return new RegExp(source, modifiers);
          } catch (e) {
            return e;
          }
        }(source, m + i + g);
      if (regexp instanceof RegExp)
        return regexp;
      throw H.wrapException(P.FormatException$("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
    },
    stringContainsUnchecked: function(receiver, other, startIndex) {
      var t1 = receiver.indexOf(other, startIndex);
      return t1 >= 0;
    },
    escapeReplacement: function(replacement) {
      if (replacement.indexOf("$", 0) >= 0)
        return replacement.replace(/\$/g, "$$$$");
      return replacement;
    },
    quoteStringForRegExp: function(string) {
      if (/[[\]{}()*+?.\\^$|]/.test(string))
        return string.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
      return string;
    },
    stringReplaceAllUnchecked: function(receiver, pattern, replacement) {
      var t1 = H.stringReplaceAllUncheckedString(receiver, pattern, replacement);
      return t1;
    },
    stringReplaceAllUncheckedString: function(receiver, pattern, replacement) {
      var $length, t1, i, index;
      if (pattern === "") {
        if (receiver === "")
          return replacement;
        $length = receiver.length;
        for (t1 = replacement, i = 0; i < $length; ++i)
          t1 = t1 + receiver[i] + replacement;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      index = receiver.indexOf(pattern, 0);
      if (index < 0)
        return receiver;
      if (receiver.length < 500 || replacement.indexOf("$", 0) >= 0)
        return receiver.split(pattern).join(replacement);
      return receiver.replace(new RegExp(H.quoteStringForRegExp(pattern), 'g'), H.escapeReplacement(replacement));
    },
    ConstantMapView: function ConstantMapView(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    ConstantMap: function ConstantMap() {
    },
    ConstantStringMap: function ConstantStringMap(t0, t1, t2, t3) {
      var _ = this;
      _.__js_helper$_length = t0;
      _._jsObject = t1;
      _._keys = t2;
      _.$ti = t3;
    },
    ConstantStringMap_values_closure: function ConstantStringMap_values_closure(t0) {
      this.$this = t0;
    },
    _ConstantMapKeyIterable: function _ConstantMapKeyIterable(t0, t1) {
      this._map = t0;
      this.$ti = t1;
    },
    GeneralConstantMap: function GeneralConstantMap(t0, t1) {
      this._jsData = t0;
      this.$ti = t1;
    },
    JSInvocationMirror: function JSInvocationMirror(t0, t1, t2, t3, t4) {
      var _ = this;
      _._memberName = t0;
      _._kind = t1;
      _._arguments = t2;
      _._namedArgumentNames = t3;
      _._typeArgumentCount = t4;
    },
    Primitives_initTicker_closure: function Primitives_initTicker_closure(t0) {
      this.performance = t0;
    },
    Primitives_functionNoSuchMethod_closure: function Primitives_functionNoSuchMethod_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.namedArgumentList = t1;
      this.$arguments = t2;
    },
    TypeErrorDecoder: function TypeErrorDecoder(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._pattern = t0;
      _._arguments = t1;
      _._argumentsExpr = t2;
      _._expr = t3;
      _._method = t4;
      _._receiver = t5;
    },
    NullError: function NullError(t0, t1) {
      this._message = t0;
      this._method = t1;
    },
    JsNoSuchMethodError: function JsNoSuchMethodError(t0, t1, t2) {
      this._message = t0;
      this._method = t1;
      this._receiver = t2;
    },
    UnknownJsTypeError: function UnknownJsTypeError(t0) {
      this._message = t0;
    },
    ExceptionAndStackTrace: function ExceptionAndStackTrace(t0, t1) {
      this.dartException = t0;
      this.stackTrace = t1;
    },
    unwrapException_saveStackTrace: function unwrapException_saveStackTrace(t0) {
      this.ex = t0;
    },
    _StackTrace: function _StackTrace(t0) {
      this.__js_helper$_exception = t0;
      this._trace = null;
    },
    Closure: function Closure() {
    },
    TearOffClosure: function TearOffClosure() {
    },
    StaticClosure: function StaticClosure() {
    },
    BoundClosure: function BoundClosure(t0, t1, t2, t3) {
      var _ = this;
      _._self = t0;
      _._target = t1;
      _._receiver = t2;
      _.__js_helper$_name = t3;
    },
    TypeErrorImplementation: function TypeErrorImplementation(t0) {
      this.message = t0;
    },
    CastErrorImplementation: function CastErrorImplementation(t0) {
      this.message = t0;
    },
    RuntimeError: function RuntimeError(t0) {
      this.message = t0;
    },
    _AssertionError: function _AssertionError(t0) {
      this.message = t0;
    },
    TypeImpl: function TypeImpl(t0) {
      this._rti = t0;
      this._hashCode = this.__typeName = null;
    },
    JsLinkedHashMap: function JsLinkedHashMap(t0) {
      var _ = this;
      _.__js_helper$_length = 0;
      _._last = _._first = _._rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    JsLinkedHashMap_values_closure: function JsLinkedHashMap_values_closure(t0) {
      this.$this = t0;
    },
    JsLinkedHashMap_addAll_closure: function JsLinkedHashMap_addAll_closure(t0) {
      this.$this = t0;
    },
    LinkedHashMapCell: function LinkedHashMapCell(t0, t1) {
      var _ = this;
      _.hashMapCellKey = t0;
      _.hashMapCellValue = t1;
      _._previous = _._next = null;
    },
    LinkedHashMapKeyIterable: function LinkedHashMapKeyIterable(t0, t1) {
      this._map = t0;
      this.$ti = t1;
    },
    LinkedHashMapKeyIterator: function LinkedHashMapKeyIterator(t0, t1, t2) {
      var _ = this;
      _._map = t0;
      _._modifications = t1;
      _.__js_helper$_current = _._cell = null;
      _.$ti = t2;
    },
    initHooks_closure: function initHooks_closure(t0) {
      this.getTag = t0;
    },
    initHooks_closure0: function initHooks_closure0(t0) {
      this.getUnknownTag = t0;
    },
    initHooks_closure1: function initHooks_closure1(t0) {
      this.prototypeForTag = t0;
    },
    JSSyntaxRegExp: function JSSyntaxRegExp(t0, t1) {
      var _ = this;
      _.pattern = t0;
      _._nativeRegExp = t1;
      _._nativeAnchoredRegExp = _._nativeGlobalRegExp = null;
    },
    _MatchImplementation: function _MatchImplementation(t0) {
      this._match = t0;
    },
    StringMatch: function StringMatch(t0, t1) {
      this.start = t0;
      this.pattern = t1;
    },
    _checkViewArguments: function(buffer, offsetInBytes, $length) {
      if (typeof offsetInBytes !== "number" || Math.floor(offsetInBytes) !== offsetInBytes)
        throw H.wrapException(P.ArgumentError$("Invalid view offsetInBytes " + H.S(offsetInBytes)));
    },
    _ensureNativeList: function(list) {
      return list;
    },
    NativeByteData_NativeByteData$view: function(buffer, offsetInBytes, $length) {
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new DataView(buffer, offsetInBytes) : new DataView(buffer, offsetInBytes, $length);
    },
    NativeInt32List_NativeInt32List: function($length) {
      return new Int32Array($length);
    },
    NativeInt8List__create1: function(arg) {
      return new Int8Array(arg);
    },
    NativeUint16List__create1: function(arg) {
      return new Uint16Array(arg);
    },
    NativeUint8List_NativeUint8List$view: function(buffer, offsetInBytes, $length) {
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new Uint8Array(buffer, offsetInBytes) : new Uint8Array(buffer, offsetInBytes, $length);
    },
    _checkValidIndex: function(index, list, $length) {
      if (index >>> 0 !== index || index >= $length)
        throw H.wrapException(H.diagnoseIndexError(list, index));
    },
    _checkValidRange: function(start, end, $length) {
      var t1;
      if (!(start >>> 0 !== start))
        t1 = end >>> 0 !== end || start > end || end > $length;
      else
        t1 = true;
      if (t1)
        throw H.wrapException(H.diagnoseRangeError(start, end, $length));
      return end;
    },
    NativeByteBuffer: function NativeByteBuffer() {
    },
    NativeTypedData: function NativeTypedData() {
    },
    NativeByteData: function NativeByteData() {
    },
    NativeTypedArray: function NativeTypedArray() {
    },
    NativeTypedArrayOfDouble: function NativeTypedArrayOfDouble() {
    },
    NativeTypedArrayOfInt: function NativeTypedArrayOfInt() {
    },
    NativeFloat32List: function NativeFloat32List() {
    },
    NativeFloat64List: function NativeFloat64List() {
    },
    NativeInt16List: function NativeInt16List() {
    },
    NativeInt32List: function NativeInt32List() {
    },
    NativeInt8List: function NativeInt8List() {
    },
    NativeUint16List: function NativeUint16List() {
    },
    NativeUint32List: function NativeUint32List() {
    },
    NativeUint8ClampedList: function NativeUint8ClampedList() {
    },
    NativeUint8List: function NativeUint8List() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    extractKeys: function(victim) {
      return J.JSArray_JSArray$markFixed(victim ? Object.keys(victim) : [], null);
    },
    printString: function(string) {
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof window == "object")
        return;
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    }
  },
  J = {
    makeDispatchRecord: function(interceptor, proto, extension, indexability) {
      return {i: interceptor, p: proto, e: extension, x: indexability};
    },
    getNativeInterceptor: function(object) {
      var proto, objectProto, $constructor, interceptor,
        record = object[init.dispatchPropertyName];
      if (record == null)
        if ($.initNativeDispatchFlag == null) {
          H.initNativeDispatch();
          record = object[init.dispatchPropertyName];
        }
      if (record != null) {
        proto = record.p;
        if (false === proto)
          return record.i;
        if (true === proto)
          return object;
        objectProto = Object.getPrototypeOf(object);
        if (proto === objectProto)
          return record.i;
        if (record.e === objectProto)
          throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
      }
      $constructor = object.constructor;
      interceptor = $constructor == null ? null : $constructor[$.$get$JS_INTEROP_INTERCEPTOR_TAG()];
      if (interceptor != null)
        return interceptor;
      interceptor = H.lookupAndCacheInterceptor(object);
      if (interceptor != null)
        return interceptor;
      if (typeof object == "function")
        return C.JavaScriptFunction_methods;
      proto = Object.getPrototypeOf(object);
      if (proto == null)
        return C.PlainJavaScriptObject_methods;
      if (proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      if (typeof $constructor == "function") {
        Object.defineProperty($constructor, $.$get$JS_INTEROP_INTERCEPTOR_TAG(), {value: C.UnknownJavaScriptObject_methods, enumerable: false, writable: true, configurable: true});
        return C.UnknownJavaScriptObject_methods;
      }
      return C.UnknownJavaScriptObject_methods;
    },
    JSArray_JSArray$markFixed: function(allocation, $E) {
      return J.JSArray_markFixedList(H.setRuntimeTypeInfo(allocation, [$E]));
    },
    JSArray_markFixedList: function(list) {
      H.listTypeCheck(list);
      list.fixed$length = Array;
      return list;
    },
    JSArray__compareAny: function(a, b) {
      return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
    },
    JSString__isWhitespace: function(codeUnit) {
      if (codeUnit < 256)
        switch (codeUnit) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 133:
          case 160:
            return true;
          default:
            return false;
        }
      switch (codeUnit) {
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8232:
        case 8233:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    },
    JSString__skipLeadingWhitespace: function(string, index) {
      var t1, codeUnit;
      for (t1 = string.length; index < t1;) {
        codeUnit = C.JSString_methods._codeUnitAt$1(string, index);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
        ++index;
      }
      return index;
    },
    JSString__skipTrailingWhitespace: function(string, index) {
      var index0, codeUnit;
      for (; index > 0; index = index0) {
        index0 = index - 1;
        codeUnit = C.JSString_methods.codeUnitAt$1(string, index0);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
      }
      return index;
    },
    getInterceptor$: function(receiver) {
      if (typeof receiver == "number") {
        if (Math.floor(receiver) == receiver)
          return J.JSInt.prototype;
        return J.JSDouble.prototype;
      }
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return J.JSNull.prototype;
      if (typeof receiver == "boolean")
        return J.JSBool.prototype;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ansx: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$asx: function(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ax: function(receiver) {
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$in: function(receiver) {
      if (typeof receiver == "number") {
        if (Math.floor(receiver) == receiver)
          return J.JSInt.prototype;
        return J.JSNumber.prototype;
      }
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$n: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$ns: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$s: function(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$x: function(receiver) {
      if (receiver == null)
        return receiver;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    get$attributes$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$attributes(receiver);
    },
    get$children$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$children(receiver);
    },
    get$hashCode$: function(receiver) {
      return J.getInterceptor$(receiver).get$hashCode(receiver);
    },
    get$isEmpty$asx: function(receiver) {
      return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
    },
    get$isNotEmpty$asx: function(receiver) {
      return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
    },
    get$iterator$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).get$iterator(receiver);
    },
    get$length$asx: function(receiver) {
      return J.getInterceptor$asx(receiver).get$length(receiver);
    },
    get$offset$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$offset(receiver);
    },
    get$runtimeType$: function(receiver) {
      return J.getInterceptor$(receiver).get$runtimeType(receiver);
    },
    get$sign$in: function(receiver) {
      if (typeof receiver === "number")
        return receiver > 0 ? 1 : receiver < 0 ? -1 : receiver;
      return J.getInterceptor$in(receiver).get$sign(receiver);
    },
    get$target$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$target(receiver);
    },
    $add$ansx: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver + a0;
      return J.getInterceptor$ansx(receiver).$add(receiver, a0);
    },
    $eq$: function(receiver, a0) {
      if (receiver == null)
        return a0 == null;
      if (typeof receiver != "object")
        return a0 != null && receiver === a0;
      return J.getInterceptor$(receiver).$eq(receiver, a0);
    },
    $gt$n: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver > a0;
      return J.getInterceptor$n(receiver).$gt(receiver, a0);
    },
    $index$asx: function(receiver, a0) {
      if (typeof a0 === "number")
        if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
          if (a0 >>> 0 === a0 && a0 < receiver.length)
            return receiver[a0];
      return J.getInterceptor$asx(receiver).$index(receiver, a0);
    },
    $indexSet$ax: function(receiver, a0, a1) {
      return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
    },
    _codeUnitAt$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver)._codeUnitAt$1(receiver, a0);
    },
    _replaceChild$2$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver)._replaceChild$2(receiver, a0, a1);
    },
    addEventListener$2$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver).addEventListener$2(receiver, a0, a1);
    },
    addEventListener$3$x: function(receiver, a0, a1, a2) {
      return J.getInterceptor$x(receiver).addEventListener$3(receiver, a0, a1, a2);
    },
    clamp$2$n: function(receiver, a0, a1) {
      return J.getInterceptor$n(receiver).clamp$2(receiver, a0, a1);
    },
    compareTo$1$ns: function(receiver, a0) {
      return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
    },
    contains$1$asx: function(receiver, a0) {
      return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
    },
    contains$2$asx: function(receiver, a0, a1) {
      return J.getInterceptor$asx(receiver).contains$2(receiver, a0, a1);
    },
    elementAt$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
    },
    fillRange$3$x: function(receiver, a0, a1, a2) {
      return J.getInterceptor$x(receiver).fillRange$3(receiver, a0, a1, a2);
    },
    floor$0$n: function(receiver) {
      return J.getInterceptor$n(receiver).floor$0(receiver);
    },
    forEach$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
    },
    join$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).join$1(receiver, a0);
    },
    map$1$1$ax: function(receiver, a0, $T1) {
      return J.getInterceptor$ax(receiver).map$1$1(receiver, a0, $T1);
    },
    matchAsPrefix$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
    },
    noSuchMethod$1$: function(receiver, a0) {
      return J.getInterceptor$(receiver).noSuchMethod$1(receiver, a0);
    },
    remove$0$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).remove$0(receiver);
    },
    removeEventListener$2$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver).removeEventListener$2(receiver, a0, a1);
    },
    removeEventListener$3$x: function(receiver, a0, a1, a2) {
      return J.getInterceptor$x(receiver).removeEventListener$3(receiver, a0, a1, a2);
    },
    replaceRange$3$s: function(receiver, a0, a1, a2) {
      return J.getInterceptor$s(receiver).replaceRange$3(receiver, a0, a1, a2);
    },
    replaceWith$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).replaceWith$1(receiver, a0);
    },
    sort$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).sort$1(receiver, a0);
    },
    startsWith$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).startsWith$2(receiver, a0, a1);
    },
    substring$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).substring$1(receiver, a0);
    },
    substring$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
    },
    toInt$0$n: function(receiver) {
      return J.getInterceptor$n(receiver).toInt$0(receiver);
    },
    toLowerCase$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).toLowerCase$0(receiver);
    },
    toString$0$: function(receiver) {
      return J.getInterceptor$(receiver).toString$0(receiver);
    },
    toStringAsFixed$1$n: function(receiver, a0) {
      return J.getInterceptor$n(receiver).toStringAsFixed$1(receiver, a0);
    },
    trim$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).trim$0(receiver);
    },
    trimLeft$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).trimLeft$0(receiver);
    },
    trimRight$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).trimRight$0(receiver);
    },
    Interceptor: function Interceptor() {
    },
    JSBool: function JSBool() {
    },
    JSNull: function JSNull() {
    },
    JSObject: function JSObject() {
    },
    JavaScriptObject: function JavaScriptObject() {
    },
    PlainJavaScriptObject: function PlainJavaScriptObject() {
    },
    UnknownJavaScriptObject: function UnknownJavaScriptObject() {
    },
    JavaScriptFunction: function JavaScriptFunction() {
    },
    JSArray: function JSArray(t0) {
      this.$ti = t0;
    },
    JSUnmodifiableArray: function JSUnmodifiableArray(t0) {
      this.$ti = t0;
    },
    ArrayIterator: function ArrayIterator(t0, t1, t2) {
      var _ = this;
      _.__interceptors$_iterable = t0;
      _.__interceptors$_length = t1;
      _.__interceptors$_index = 0;
      _.__interceptors$_current = null;
      _.$ti = t2;
    },
    JSNumber: function JSNumber() {
    },
    JSInt: function JSInt() {
    },
    JSDouble: function JSDouble() {
    },
    JSString: function JSString() {
    }
  },
  P = {
    _AsyncRun__initializeScheduleImmediate: function() {
      var div, span, t1 = {};
      if (self.scheduleImmediate != null)
        return P.async__AsyncRun__scheduleImmediateJsOverride$closure();
      if (self.MutationObserver != null && self.document != null) {
        div = self.document.createElement("div");
        span = self.document.createElement("span");
        t1.storedCallback = null;
        new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
        return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
      } else if (self.setImmediate != null)
        return P.async__AsyncRun__scheduleImmediateWithSetImmediate$closure();
      return P.async__AsyncRun__scheduleImmediateWithTimer$closure();
    },
    _AsyncRun__scheduleImmediateJsOverride: function(callback) {
      self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(H.functionTypeCheck(callback, {func: 1, ret: -1})), 0));
    },
    _AsyncRun__scheduleImmediateWithSetImmediate: function(callback) {
      self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(H.functionTypeCheck(callback, {func: 1, ret: -1})), 0));
    },
    _AsyncRun__scheduleImmediateWithTimer: function(callback) {
      P.Timer__createTimer(C.Duration_0, H.functionTypeCheck(callback, {func: 1, ret: -1}));
    },
    Timer__createTimer: function(duration, callback) {
      var milliseconds;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
      return P._TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
    },
    Timer__createPeriodicTimer: function(duration, callback) {
      var milliseconds;
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.Timer]});
      milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
      return P._TimerImpl$periodic(milliseconds < 0 ? 0 : milliseconds, callback);
    },
    _TimerImpl$: function(milliseconds, callback) {
      var t1 = new P._TimerImpl(true);
      t1._TimerImpl$2(milliseconds, callback);
      return t1;
    },
    _TimerImpl$periodic: function(milliseconds, callback) {
      var t1 = new P._TimerImpl(false);
      t1._TimerImpl$periodic$2(milliseconds, callback);
      return t1;
    },
    _makeAsyncAwaitCompleter: function($T) {
      return new P._AsyncAwaitCompleter(new P._SyncCompleter(new P._Future($.Zone__current, [$T]), [$T]), [$T]);
    },
    _asyncStartSync: function(bodyFunction, completer) {
      H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]});
      H.interceptedTypeCheck(completer, "$is_AsyncAwaitCompleter");
      bodyFunction.call$2(0, null);
      completer.isSync = true;
      return completer._completer.future;
    },
    _asyncAwait: function(object, bodyFunction) {
      P._awaitOnObject(object, H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]}));
    },
    _asyncReturn: function(object, completer) {
      H.interceptedTypeCheck(completer, "$isCompleter").complete$1(0, object);
    },
    _asyncRethrow: function(object, completer) {
      H.interceptedTypeCheck(completer, "$isCompleter").completeError$2(H.unwrapException(object), H.getTraceFromException(object));
    },
    _awaitOnObject: function(object, bodyFunction) {
      var thenCallback, errorCallback, t1, future, _null = null;
      H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]});
      thenCallback = new P._awaitOnObject_closure(bodyFunction);
      errorCallback = new P._awaitOnObject_closure0(bodyFunction);
      t1 = J.getInterceptor$(object);
      if (!!t1.$is_Future)
        object._thenNoZoneRegistration$1$2(thenCallback, errorCallback, _null);
      else if (!!t1.$isFuture)
        object.then$1$2$onError(thenCallback, errorCallback, _null);
      else {
        future = new P._Future($.Zone__current, [null]);
        H.assertSubtypeOfRuntimeType(object, null);
        future._state = 4;
        future._resultOrListeners = object;
        future._thenNoZoneRegistration$1$2(thenCallback, _null, _null);
      }
    },
    _wrapJsFunctionForAsync: function($function) {
      var $protected = function(fn, ERROR) {
        return function(errorCode, result) {
          while (true)
            try {
              fn(errorCode, result);
              break;
            } catch (error) {
              result = error;
              errorCode = ERROR;
            }
        };
      }($function, 1);
      return $.Zone__current.registerBinaryCallback$3$1(new P._wrapJsFunctionForAsync_closure($protected), P.Null, P.int, null);
    },
    _asyncStarHelper: function(object, bodyFunctionOrErrorCode, controller) {
      var t1, error, stackTrace, t2;
      H.interceptedTypeCheck(controller, "$is_AsyncStarStreamController");
      if (bodyFunctionOrErrorCode === 0) {
        t1 = controller.cancelationCompleter;
        if (t1 != null)
          t1.complete$0(0);
        else
          controller.controller.close$0(0);
        return;
      } else if (bodyFunctionOrErrorCode === 1) {
        t1 = controller.cancelationCompleter;
        if (t1 != null)
          t1.completeError$2(H.unwrapException(object), H.getTraceFromException(object));
        else {
          error = H.unwrapException(object);
          stackTrace = H.getTraceFromException(object);
          t1 = controller.controller;
          if (t1._state >= 4)
            H.throwExpression(t1._badEventState$0());
          if (error == null)
            error = new P.NullThrownError();
          $.Zone__current.toString;
          t1._addError$2(error, stackTrace);
          controller.controller.close$0(0);
        }
        return;
      }
      if (object instanceof P._IterationMarker) {
        if (controller.cancelationCompleter != null) {
          bodyFunctionOrErrorCode.call$2(2, null);
          return;
        }
        t1 = object.state;
        if (t1 === 0) {
          t1 = object.value;
          t2 = controller.controller;
          H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(controller, 0));
          t2.toString;
          H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
          if (t2._state >= 4)
            H.throwExpression(t2._badEventState$0());
          t2._add$1(0, t1);
          P.scheduleMicrotask(new P._asyncStarHelper_closure(controller, bodyFunctionOrErrorCode));
          return;
        } else if (t1 === 1) {
          t1 = H.assertSubtype(H.interceptedTypeCheck(object.value, "$isStream"), "$isStream", [H.getTypeArgumentByIndex(controller, 0)], "$asStream");
          controller.controller.addStream$2$cancelOnError(0, t1, false).then$1(new P._asyncStarHelper_closure0(controller, bodyFunctionOrErrorCode));
          return;
        }
      }
      P._awaitOnObject(object, H.functionTypeCheck(bodyFunctionOrErrorCode, {func: 1, ret: -1, args: [P.int,,]}));
    },
    _streamOfController: function(controller) {
      var t1 = H.interceptedTypeCheck(controller, "$is_AsyncStarStreamController").controller;
      t1.toString;
      return new P._ControllerStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    _AsyncStarStreamController$: function(body, $T) {
      var t1 = new P._AsyncStarStreamController([$T]);
      t1._AsyncStarStreamController$1(body, $T);
      return t1;
    },
    _makeAsyncStarStreamController: function(body, $T) {
      return P._AsyncStarStreamController$(H.functionTypeCheck(body, {func: 1, ret: -1, args: [P.int,,]}), $T);
    },
    _IterationMarker_yieldStar: function(values) {
      return new P._IterationMarker(values, 1);
    },
    _IterationMarker_endOfIteration: function() {
      return C._IterationMarker_null_2;
    },
    _IterationMarker_yieldSingle: function(value) {
      return new P._IterationMarker(value, 0);
    },
    _IterationMarker_uncaughtError: function(error) {
      return new P._IterationMarker(error, 3);
    },
    _makeSyncStarIterable: function(body, $T) {
      return new P._SyncStarIterable(body, [$T]);
    },
    Future_Future$error: function(error, stackTrace, $T) {
      var t1;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      t1 = $.Zone__current;
      if (t1 !== C.C__RootZone)
        t1.toString;
      t1 = new P._Future(t1, [$T]);
      t1._asyncCompleteError$2(error, stackTrace);
      return t1;
    },
    Future_Future$delayed: function(duration, $T) {
      var result = new P._Future($.Zone__current, [$T]);
      P.Timer_Timer(duration, new P.Future_Future$delayed_closure(null, result));
      return result;
    },
    Future_wait: function(futures, $T) {
      var result, handleError, future, pos, e, st, t1, t2, t3, t4, _i, t5, exception, _box_0 = {}, cleanUp = null,
        eagerError = false;
      H.assertSubtype(futures, "$isIterable", [[P.Future, $T]], "$asIterable");
      t1 = [P.List, $T];
      t2 = [t1];
      result = new P._Future($.Zone__current, t2);
      _box_0.values = null;
      _box_0.remaining = 0;
      _box_0.stackTrace = _box_0.error = null;
      handleError = new P.Future_wait_handleError(_box_0, cleanUp, eagerError, result);
      try {
        for (t3 = futures, t4 = t3.length, _i = 0, t5 = 0; _i < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i) {
          future = t3[_i];
          pos = t5;
          future.then$1$2$onError(new P.Future_wait_closure(_box_0, pos, result, cleanUp, eagerError, $T), handleError, null);
          t5 = ++_box_0.remaining;
        }
        if (t5 === 0) {
          t2 = new P._Future($.Zone__current, t2);
          t2._asyncComplete$1(C.List_empty2);
          return t2;
        }
        t2 = new Array(t5);
        t2.fixed$length = Array;
        _box_0.values = H.setRuntimeTypeInfo(t2, [$T]);
      } catch (exception) {
        e = H.unwrapException(exception);
        st = H.getTraceFromException(exception);
        if (_box_0.remaining === 0 || H.boolConversionCheck(eagerError))
          return P.Future_Future$error(e, st, t1);
        else {
          _box_0.error = e;
          _box_0.stackTrace = st;
        }
      }
      return result;
    },
    _Future$zoneValue: function(value, _zone, $T) {
      var t1 = new P._Future(_zone, [$T]);
      H.assertSubtypeOfRuntimeType(value, $T);
      t1._state = 4;
      t1._resultOrListeners = value;
      return t1;
    },
    _Future__chainForeignFuture: function(source, target) {
      var e, s, exception;
      target._state = 1;
      try {
        source.then$1$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target), null);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P.scheduleMicrotask(new P._Future__chainForeignFuture_closure1(target, e, s));
      }
    },
    _Future__chainCoreFuture: function(source, target) {
      var t1, listeners;
      for (; t1 = source._state, t1 === 2;)
        source = H.interceptedTypeCheck(source._resultOrListeners, "$is_Future");
      if (t1 >= 4) {
        listeners = target._removeListeners$0();
        target._state = source._state;
        target._resultOrListeners = source._resultOrListeners;
        P._Future__propagateToListeners(target, listeners);
      } else {
        listeners = H.interceptedTypeCheck(target._resultOrListeners, "$is_FutureListener");
        target._state = 2;
        target._resultOrListeners = source;
        source._prependListeners$1(listeners);
      }
    },
    _Future__propagateToListeners: function(source, listeners) {
      var _box_0, hasError, asyncError, t2, t3, listeners0, sourceResult, zone, t4, oldZone, current, result, _null = null, _box_1 = {},
        t1 = _box_1.source = source;
      for (; true;) {
        _box_0 = {};
        hasError = t1._state === 8;
        if (listeners == null) {
          if (hasError) {
            asyncError = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
            t1 = t1._zone;
            t2 = asyncError.error;
            t3 = asyncError.stackTrace;
            t1.toString;
            P._rootHandleUncaughtError(_null, _null, t1, t2, t3);
          }
          return;
        }
        for (; listeners0 = listeners._nextListener, listeners0 != null; listeners = listeners0) {
          listeners._nextListener = null;
          P._Future__propagateToListeners(_box_1.source, listeners);
        }
        t1 = _box_1.source;
        sourceResult = t1._resultOrListeners;
        _box_0.listenerHasError = hasError;
        _box_0.listenerValueOrError = sourceResult;
        t2 = !hasError;
        if (t2) {
          t3 = listeners.state;
          t3 = (t3 & 1) !== 0 || t3 === 8;
        } else
          t3 = true;
        if (t3) {
          t3 = listeners.result;
          zone = t3._zone;
          if (hasError) {
            t4 = t1._zone;
            t4.toString;
            t4 = t4 == zone;
            if (!t4)
              zone.toString;
            else
              t4 = true;
            t4 = !t4;
          } else
            t4 = false;
          if (t4) {
            H.interceptedTypeCheck(sourceResult, "$isAsyncError");
            t1 = t1._zone;
            t2 = sourceResult.error;
            t3 = sourceResult.stackTrace;
            t1.toString;
            P._rootHandleUncaughtError(_null, _null, t1, t2, t3);
            return;
          }
          oldZone = $.Zone__current;
          if (oldZone != zone)
            $.Zone__current = zone;
          else
            oldZone = _null;
          t1 = listeners.state;
          if (t1 === 8)
            new P._Future__propagateToListeners_handleWhenCompleteCallback(_box_1, _box_0, listeners, hasError).call$0();
          else if (t2) {
            if ((t1 & 1) !== 0)
              new P._Future__propagateToListeners_handleValueCallback(_box_0, listeners, sourceResult).call$0();
          } else if ((t1 & 2) !== 0)
            new P._Future__propagateToListeners_handleError(_box_1, _box_0, listeners).call$0();
          if (oldZone != null)
            $.Zone__current = oldZone;
          t1 = _box_0.listenerValueOrError;
          if (!!J.getInterceptor$(t1).$isFuture) {
            if (t1._state >= 4) {
              current = H.interceptedTypeCheck(t3._resultOrListeners, "$is_FutureListener");
              t3._resultOrListeners = null;
              listeners = t3._reverseListeners$1(current);
              t3._state = t1._state;
              t3._resultOrListeners = t1._resultOrListeners;
              _box_1.source = t1;
              continue;
            } else
              P._Future__chainCoreFuture(t1, t3);
            return;
          }
        }
        result = listeners.result;
        current = H.interceptedTypeCheck(result._resultOrListeners, "$is_FutureListener");
        result._resultOrListeners = null;
        listeners = result._reverseListeners$1(current);
        t1 = _box_0.listenerHasError;
        t2 = _box_0.listenerValueOrError;
        if (!t1) {
          H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(result, 0));
          result._state = 4;
          result._resultOrListeners = t2;
        } else {
          H.interceptedTypeCheck(t2, "$isAsyncError");
          result._state = 8;
          result._resultOrListeners = t2;
        }
        _box_1.source = result;
        t1 = result;
      }
    },
    _registerErrorHandler: function(errorHandler, zone) {
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object, P.StackTrace]}))
        return zone.registerBinaryCallback$3$1(errorHandler, null, P.Object, P.StackTrace);
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object]}))
        return H.functionTypeCheck(errorHandler, {func: 1, ret: null, args: [P.Object]});
      throw H.wrapException(P.ArgumentError$value(errorHandler, "onError", "Error handler must accept one Object or one Object and a StackTrace as arguments, and return a a valid result"));
    },
    _microtaskLoop: function() {
      var t1, t2;
      for (; t1 = $._nextCallback, t1 != null;) {
        $._lastPriorityCallback = null;
        t2 = t1.next;
        $._nextCallback = t2;
        if (t2 == null)
          $._lastCallback = null;
        t1.callback.call$0();
      }
    },
    _startMicrotaskLoop: function() {
      $._isInCallbackLoop = true;
      try {
        P._microtaskLoop();
      } finally {
        $._lastPriorityCallback = null;
        $._isInCallbackLoop = false;
        if ($._nextCallback != null)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      }
    },
    _scheduleAsyncCallback: function(callback) {
      var newEntry = new P._AsyncCallbackEntry(H.functionTypeCheck(callback, {func: 1, ret: -1}));
      if ($._nextCallback == null) {
        $._nextCallback = $._lastCallback = newEntry;
        if (!$._isInCallbackLoop)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      } else
        $._lastCallback = $._lastCallback.next = newEntry;
    },
    _schedulePriorityAsyncCallback: function(callback) {
      var t1, entry, t2;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      t1 = $._nextCallback;
      if (t1 == null) {
        P._scheduleAsyncCallback(callback);
        $._lastPriorityCallback = $._lastCallback;
        return;
      }
      entry = new P._AsyncCallbackEntry(callback);
      t2 = $._lastPriorityCallback;
      if (t2 == null) {
        entry.next = t1;
        $._nextCallback = $._lastPriorityCallback = entry;
      } else {
        entry.next = t2.next;
        $._lastPriorityCallback = t2.next = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    },
    scheduleMicrotask: function(callback) {
      var currentZone, _null = null,
        t1 = {func: 1, ret: -1};
      H.functionTypeCheck(callback, t1);
      currentZone = $.Zone__current;
      if (C.C__RootZone === currentZone) {
        P._rootScheduleMicrotask(_null, _null, C.C__RootZone, callback);
        return;
      }
      currentZone.toString;
      P._rootScheduleMicrotask(_null, _null, currentZone, H.functionTypeCheck(currentZone.bindCallbackGuarded$1(callback), t1));
    },
    Stream_Stream$fromIterable: function(elements, $T) {
      return new P._GeneratedStreamImpl(new P.Stream_Stream$fromIterable_closure(H.assertSubtype(elements, "$isIterable", [$T], "$asIterable"), $T), [$T]);
    },
    StreamIterator_StreamIterator: function(stream, $T) {
      return new P._StreamIterator(H.assertSubtype(stream, "$isStream", [$T], "$asStream"), [$T]);
    },
    _runGuarded: function(notificationHandler) {
      var e, s, exception, t1;
      H.functionTypeCheck(notificationHandler, {func: 1});
      if (notificationHandler == null)
        return;
      try {
        notificationHandler.call$0();
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = $.Zone__current;
        t1.toString;
        P._rootHandleUncaughtError(null, null, t1, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    _BufferingStreamSubscription$: function(onData, onError, onDone, cancelOnError, $T) {
      var t1 = $.Zone__current,
        t2 = cancelOnError ? 1 : 0;
      t2 = new P._BufferingStreamSubscription(t1, t2, [$T]);
      t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
      return t2;
    },
    _cancelAndValue: function(subscription, future, value) {
      var cancelFuture = subscription.cancel$0(0);
      if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, false));
      else
        future._complete$1(false);
    },
    Timer_Timer: function(duration, callback) {
      var t2,
        t1 = {func: 1, ret: -1};
      H.functionTypeCheck(callback, t1);
      t2 = $.Zone__current;
      if (t2 === C.C__RootZone) {
        t2.toString;
        return P.Timer__createTimer(duration, callback);
      }
      return P.Timer__createTimer(duration, H.functionTypeCheck(t2.bindCallbackGuarded$1(callback), t1));
    },
    Timer_Timer$periodic: function(duration, callback) {
      var t2, boundCallback,
        t1 = {func: 1, ret: -1, args: [P.Timer]};
      H.functionTypeCheck(callback, t1);
      t2 = $.Zone__current;
      if (t2 === C.C__RootZone) {
        t2.toString;
        return P.Timer__createPeriodicTimer(duration, callback);
      }
      boundCallback = t2.bindUnaryCallbackGuarded$1$1(callback, P.Timer);
      $.Zone__current.toString;
      return P.Timer__createPeriodicTimer(duration, H.functionTypeCheck(boundCallback, t1));
    },
    _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
      var t1 = {};
      t1.error = error;
      P._schedulePriorityAsyncCallback(new P._rootHandleUncaughtError_closure(t1, stackTrace));
    },
    _rootRun: function($self, $parent, zone, f, $R) {
      var old, t1;
      H.functionTypeCheck(f, {func: 1, ret: $R});
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$0();
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$0();
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunUnary: function($self, $parent, zone, f, arg, $R, $T) {
      var old, t1;
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$1(arg);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$1(arg);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunBinary: function($self, $parent, zone, f, arg1, arg2, $R, T1, T2) {
      var old, t1;
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$2(arg1, arg2);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$2(arg1, arg2);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootScheduleMicrotask: function($self, $parent, zone, f) {
      var t1;
      H.functionTypeCheck(f, {func: 1, ret: -1});
      t1 = C.C__RootZone !== zone;
      if (t1)
        f = !(!t1 || false) ? zone.bindCallbackGuarded$1(f) : zone.bindCallback$1$1(f, -1);
      P._scheduleAsyncCallback(f);
    },
    _AsyncRun__initializeScheduleImmediate_internalCallback: function _AsyncRun__initializeScheduleImmediate_internalCallback(t0) {
      this._box_0 = t0;
    },
    _AsyncRun__initializeScheduleImmediate_closure: function _AsyncRun__initializeScheduleImmediate_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.div = t1;
      this.span = t2;
    },
    _AsyncRun__scheduleImmediateJsOverride_internalCallback: function _AsyncRun__scheduleImmediateJsOverride_internalCallback(t0) {
      this.callback = t0;
    },
    _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: function _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(t0) {
      this.callback = t0;
    },
    _TimerImpl: function _TimerImpl(t0) {
      this._once = t0;
      this._handle = null;
      this._tick = 0;
    },
    _TimerImpl_internalCallback: function _TimerImpl_internalCallback(t0, t1) {
      this.$this = t0;
      this.callback = t1;
    },
    _TimerImpl$periodic_closure: function _TimerImpl$periodic_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.milliseconds = t1;
      _.start = t2;
      _.callback = t3;
    },
    _AsyncAwaitCompleter: function _AsyncAwaitCompleter(t0, t1) {
      this._completer = t0;
      this.isSync = false;
      this.$ti = t1;
    },
    _AsyncAwaitCompleter_complete_closure: function _AsyncAwaitCompleter_complete_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _AsyncAwaitCompleter_completeError_closure: function _AsyncAwaitCompleter_completeError_closure(t0, t1, t2) {
      this.$this = t0;
      this.e = t1;
      this.st = t2;
    },
    _awaitOnObject_closure: function _awaitOnObject_closure(t0) {
      this.bodyFunction = t0;
    },
    _awaitOnObject_closure0: function _awaitOnObject_closure0(t0) {
      this.bodyFunction = t0;
    },
    _wrapJsFunctionForAsync_closure: function _wrapJsFunctionForAsync_closure(t0) {
      this.$protected = t0;
    },
    _asyncStarHelper_closure: function _asyncStarHelper_closure(t0, t1) {
      this.controller = t0;
      this.bodyFunctionOrErrorCode = t1;
    },
    _asyncStarHelper_closure0: function _asyncStarHelper_closure0(t0, t1) {
      this.controller = t0;
      this.bodyFunctionOrErrorCode = t1;
    },
    _AsyncStarStreamController: function _AsyncStarStreamController(t0) {
      var _ = this;
      _.controller = null;
      _.isSuspended = false;
      _.cancelationCompleter = null;
      _.$ti = t0;
    },
    _AsyncStarStreamController__resumeBody: function _AsyncStarStreamController__resumeBody(t0) {
      this.body = t0;
    },
    _AsyncStarStreamController__resumeBody_closure: function _AsyncStarStreamController__resumeBody_closure(t0) {
      this.body = t0;
    },
    _AsyncStarStreamController_closure: function _AsyncStarStreamController_closure(t0) {
      this._resumeBody = t0;
    },
    _AsyncStarStreamController_closure0: function _AsyncStarStreamController_closure0(t0, t1) {
      this.$this = t0;
      this._resumeBody = t1;
    },
    _AsyncStarStreamController_closure1: function _AsyncStarStreamController_closure1(t0, t1) {
      this.$this = t0;
      this.body = t1;
    },
    _AsyncStarStreamController__closure: function _AsyncStarStreamController__closure(t0) {
      this.body = t0;
    },
    _IterationMarker: function _IterationMarker(t0, t1) {
      this.value = t0;
      this.state = t1;
    },
    _SyncStarIterator: function _SyncStarIterator(t0, t1) {
      var _ = this;
      _._body = t0;
      _._suspendedBodies = _._nestedIterator = _._async$_current = null;
      _.$ti = t1;
    },
    _SyncStarIterable: function _SyncStarIterable(t0, t1) {
      this._outerHelper = t0;
      this.$ti = t1;
    },
    Future: function Future() {
    },
    Future_Future$delayed_closure: function Future_Future$delayed_closure(t0, t1) {
      this.computation = t0;
      this.result = t1;
    },
    Future_wait_handleError: function Future_wait_handleError(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.cleanUp = t1;
      _.eagerError = t2;
      _.result = t3;
    },
    Future_wait_closure: function Future_wait_closure(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._box_0 = t0;
      _.pos = t1;
      _.result = t2;
      _.cleanUp = t3;
      _.eagerError = t4;
      _.T = t5;
    },
    _Completer: function _Completer() {
    },
    _AsyncCompleter: function _AsyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _SyncCompleter: function _SyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _FutureListener: function _FutureListener(t0, t1, t2, t3, t4) {
      var _ = this;
      _._nextListener = null;
      _.result = t0;
      _.state = t1;
      _.callback = t2;
      _.errorCallback = t3;
      _.$ti = t4;
    },
    _Future: function _Future(t0, t1) {
      var _ = this;
      _._state = 0;
      _._zone = t0;
      _._resultOrListeners = null;
      _.$ti = t1;
    },
    _Future__addListener_closure: function _Future__addListener_closure(t0, t1) {
      this.$this = t0;
      this.listener = t1;
    },
    _Future__prependListeners_closure: function _Future__prependListeners_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _Future__chainForeignFuture_closure: function _Future__chainForeignFuture_closure(t0) {
      this.target = t0;
    },
    _Future__chainForeignFuture_closure0: function _Future__chainForeignFuture_closure0(t0) {
      this.target = t0;
    },
    _Future__chainForeignFuture_closure1: function _Future__chainForeignFuture_closure1(t0, t1, t2) {
      this.target = t0;
      this.e = t1;
      this.s = t2;
    },
    _Future__asyncComplete_closure: function _Future__asyncComplete_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _Future__chainFuture_closure: function _Future__chainFuture_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _Future__asyncCompleteError_closure: function _Future__asyncCompleteError_closure(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback: function _Future__propagateToListeners_handleWhenCompleteCallback(t0, t1, t2, t3) {
      var _ = this;
      _._box_1 = t0;
      _._box_0 = t1;
      _.listener = t2;
      _.hasError = t3;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback_closure: function _Future__propagateToListeners_handleWhenCompleteCallback_closure(t0) {
      this.originalSource = t0;
    },
    _Future__propagateToListeners_handleValueCallback: function _Future__propagateToListeners_handleValueCallback(t0, t1, t2) {
      this._box_0 = t0;
      this.listener = t1;
      this.sourceResult = t2;
    },
    _Future__propagateToListeners_handleError: function _Future__propagateToListeners_handleError(t0, t1, t2) {
      this._box_1 = t0;
      this._box_0 = t1;
      this.listener = t2;
    },
    _AsyncCallbackEntry: function _AsyncCallbackEntry(t0) {
      this.callback = t0;
      this.next = null;
    },
    Stream: function Stream() {
    },
    Stream_Stream$fromIterable_closure: function Stream_Stream$fromIterable_closure(t0, t1) {
      this.elements = t0;
      this.T = t1;
    },
    Stream_length_closure: function Stream_length_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Stream_length_closure0: function Stream_length_closure0(t0, t1) {
      this._box_0 = t0;
      this.future = t1;
    },
    Stream_isEmpty_closure: function Stream_isEmpty_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.future = t2;
    },
    Stream_isEmpty_closure0: function Stream_isEmpty_closure0(t0) {
      this.future = t0;
    },
    StreamSubscription: function StreamSubscription() {
    },
    StreamTransformerBase: function StreamTransformerBase() {
    },
    _StreamController: function _StreamController() {
    },
    _StreamController__subscribe_closure: function _StreamController__subscribe_closure(t0) {
      this.$this = t0;
    },
    _StreamController__recordCancel_complete: function _StreamController__recordCancel_complete(t0) {
      this.$this = t0;
    },
    _AsyncStreamControllerDispatch: function _AsyncStreamControllerDispatch() {
    },
    _AsyncStreamController: function _AsyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _ControllerStream: function _ControllerStream(t0, t1) {
      this._controller = t0;
      this.$ti = t1;
    },
    _ControllerSubscription: function _ControllerSubscription(t0, t1, t2, t3) {
      var _ = this;
      _._controller = t0;
      _._onDone = _._onError = _._async$_onData = null;
      _._zone = t1;
      _._state = t2;
      _._pending = _._cancelFuture = null;
      _.$ti = t3;
    },
    _AddStreamState: function _AddStreamState() {
    },
    _AddStreamState_cancel_closure: function _AddStreamState_cancel_closure(t0) {
      this.$this = t0;
    },
    _StreamControllerAddStreamState: function _StreamControllerAddStreamState(t0, t1, t2, t3) {
      var _ = this;
      _.varData = t0;
      _.addStreamFuture = t1;
      _.addSubscription = t2;
      _.$ti = t3;
    },
    _BufferingStreamSubscription: function _BufferingStreamSubscription(t0, t1, t2) {
      var _ = this;
      _._onDone = _._onError = _._async$_onData = null;
      _._zone = t0;
      _._state = t1;
      _._pending = _._cancelFuture = null;
      _.$ti = t2;
    },
    _BufferingStreamSubscription__sendError_sendError: function _BufferingStreamSubscription__sendError_sendError(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _BufferingStreamSubscription__sendDone_sendDone: function _BufferingStreamSubscription__sendDone_sendDone(t0) {
      this.$this = t0;
    },
    _StreamImpl: function _StreamImpl() {
    },
    _GeneratedStreamImpl: function _GeneratedStreamImpl(t0, t1) {
      this._pending = t0;
      this._isUsed = false;
      this.$ti = t1;
    },
    _IterablePendingEvents: function _IterablePendingEvents(t0, t1) {
      this._async$_iterator = t0;
      this._state = 0;
      this.$ti = t1;
    },
    _DelayedEvent: function _DelayedEvent() {
    },
    _DelayedData: function _DelayedData(t0, t1) {
      this.value = t0;
      this.next = null;
      this.$ti = t1;
    },
    _DelayedError: function _DelayedError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
      this.next = null;
    },
    _DelayedDone: function _DelayedDone() {
    },
    _PendingEvents: function _PendingEvents() {
    },
    _PendingEvents_schedule_closure: function _PendingEvents_schedule_closure(t0, t1) {
      this.$this = t0;
      this.dispatch = t1;
    },
    _StreamImplEvents: function _StreamImplEvents(t0) {
      var _ = this;
      _.lastPendingEvent = _.firstPendingEvent = null;
      _._state = 0;
      _.$ti = t0;
    },
    _StreamIterator: function _StreamIterator(t0, t1) {
      var _ = this;
      _._subscription = null;
      _._stateData = t0;
      _._isPaused = false;
      _.$ti = t1;
    },
    _cancelAndValue_closure: function _cancelAndValue_closure(t0, t1) {
      this.future = t0;
      this.value = t1;
    },
    Timer: function Timer() {
    },
    AsyncError: function AsyncError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    _Zone: function _Zone() {
    },
    _rootHandleUncaughtError_closure: function _rootHandleUncaughtError_closure(t0, t1) {
      this._box_0 = t0;
      this.stackTrace = t1;
    },
    _RootZone: function _RootZone() {
    },
    _RootZone_bindCallback_closure: function _RootZone_bindCallback_closure(t0, t1, t2) {
      this.$this = t0;
      this.f = t1;
      this.R = t2;
    },
    _RootZone_bindCallbackGuarded_closure: function _RootZone_bindCallbackGuarded_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    _RootZone_bindUnaryCallbackGuarded_closure: function _RootZone_bindUnaryCallbackGuarded_closure(t0, t1, t2) {
      this.$this = t0;
      this.f = t1;
      this.T = t2;
    },
    LinkedHashMap_LinkedHashMap: function($K, $V) {
      return new H.JsLinkedHashMap([$K, $V]);
    },
    LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
      H.listTypeCheck(keyValuePairs);
      return H.assertSubtype(H.fillLiteralMap(keyValuePairs, new H.JsLinkedHashMap([$K, $V])), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
    },
    LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
      return new H.JsLinkedHashMap([$K, $V]);
    },
    LinkedHashMap__makeEmpty: function() {
      return new H.JsLinkedHashMap([null, null]);
    },
    HashSet_HashSet: function($E) {
      return new P._HashSet([$E]);
    },
    _HashSet__newHashTable: function() {
      var table = Object.create(null);
      table["<non-identifier-key>"] = table;
      delete table["<non-identifier-key>"];
      return table;
    },
    LinkedHashSet_LinkedHashSet: function($E) {
      return new P._LinkedHashSet([$E]);
    },
    LinkedHashSet_LinkedHashSet$_empty: function($E) {
      return new P._LinkedHashSet([$E]);
    },
    _LinkedHashSet__newHashTable: function() {
      var table = Object.create(null);
      table["<non-identifier-key>"] = table;
      delete table["<non-identifier-key>"];
      return table;
    },
    _LinkedHashSetIterator$: function(_set, _modifications, $E) {
      var t1 = new P._LinkedHashSetIterator(_set, _modifications, [$E]);
      t1._collection$_cell = _set._collection$_first;
      return t1;
    },
    HashSet_HashSet$from: function(elements, $E) {
      var t1, _i,
        result = P.HashSet_HashSet($E);
      for (t1 = elements.length, _i = 0; _i < elements.length; elements.length === t1 || (0, H.throwConcurrentModificationError)(elements), ++_i)
        result.add$1(0, H.assertSubtypeOfRuntimeType(elements[_i], $E));
      return result;
    },
    IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
      var parts, t1;
      if (P._isToStringVisiting(iterable)) {
        if (leftDelimiter === "(" && rightDelimiter === ")")
          return "(...)";
        return leftDelimiter + "..." + rightDelimiter;
      }
      parts = H.setRuntimeTypeInfo([], [P.String]);
      C.JSArray_methods.add$1($._toStringVisiting, iterable);
      try {
        P._iterablePartsToStrings(iterable, parts);
      } finally {
        if (0 >= $._toStringVisiting.length)
          return H.ioore($._toStringVisiting, -1);
        $._toStringVisiting.pop();
      }
      t1 = P.StringBuffer__writeAll(leftDelimiter, H.listSuperNativeTypeCheck(parts, "$isIterable"), ", ") + rightDelimiter;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
      var buffer, t1;
      if (P._isToStringVisiting(iterable))
        return leftDelimiter + "..." + rightDelimiter;
      buffer = new P.StringBuffer(leftDelimiter);
      C.JSArray_methods.add$1($._toStringVisiting, iterable);
      try {
        t1 = buffer;
        t1._contents = P.StringBuffer__writeAll(t1._contents, iterable, ", ");
      } finally {
        if (0 >= $._toStringVisiting.length)
          return H.ioore($._toStringVisiting, -1);
        $._toStringVisiting.pop();
      }
      buffer._contents += rightDelimiter;
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _isToStringVisiting: function(o) {
      var t1, i;
      for (t1 = $._toStringVisiting.length, i = 0; i < t1; ++i)
        if (o === $._toStringVisiting[i])
          return true;
      return false;
    },
    _iterablePartsToStrings: function(iterable, parts) {
      var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
      H.assertSubtype(parts, "$isList", [P.String], "$asList");
      it = iterable.get$iterator(iterable);
      $length = 0;
      count = 0;
      while (true) {
        if (!($length < 80 || count < 3))
          break;
        if (!it.moveNext$0())
          return;
        next = H.S(it.get$current(it));
        C.JSArray_methods.add$1(parts, next);
        $length += next.length + 2;
        ++count;
      }
      if (!it.moveNext$0()) {
        if (count <= 5)
          return;
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        ultimateString = parts.pop();
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        penultimateString = parts.pop();
      } else {
        penultimate = it.get$current(it);
        ++count;
        if (!it.moveNext$0()) {
          if (count <= 4) {
            C.JSArray_methods.add$1(parts, H.S(penultimate));
            return;
          }
          ultimateString = H.S(penultimate);
          if (0 >= parts.length)
            return H.ioore(parts, -1);
          penultimateString = parts.pop();
          $length += ultimateString.length + 2;
        } else {
          ultimate = it.get$current(it);
          ++count;
          for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
            ultimate0 = it.get$current(it);
            ++count;
            if (count > 100) {
              while (true) {
                if (!($length > 75 && count > 3))
                  break;
                if (0 >= parts.length)
                  return H.ioore(parts, -1);
                $length -= parts.pop().length + 2;
                --count;
              }
              C.JSArray_methods.add$1(parts, "...");
              return;
            }
          }
          penultimateString = H.S(penultimate);
          ultimateString = H.S(ultimate);
          $length += ultimateString.length + penultimateString.length + 4;
        }
      }
      if (count > parts.length + 2) {
        $length += 5;
        elision = "...";
      } else
        elision = null;
      while (true) {
        if (!($length > 80 && parts.length > 3))
          break;
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        $length -= parts.pop().length + 2;
        if (elision == null) {
          $length += 5;
          elision = "...";
        }
      }
      if (elision != null)
        C.JSArray_methods.add$1(parts, elision);
      C.JSArray_methods.add$1(parts, penultimateString);
      C.JSArray_methods.add$1(parts, ultimateString);
    },
    LinkedHashMap_LinkedHashMap$from: function(other, $K, $V) {
      var result = P.LinkedHashMap_LinkedHashMap($K, $V);
      other.forEach$1(0, new P.LinkedHashMap_LinkedHashMap$from_closure(result, $K, $V));
      return result;
    },
    LinkedHashSet_LinkedHashSet$from: function(elements, $E) {
      var t1,
        result = P.LinkedHashSet_LinkedHashSet($E);
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        result.add$1(0, H.assertSubtypeOfRuntimeType(t1.get$current(t1), $E));
      return result;
    },
    ListMixin__compareAny: function(a, b) {
      return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
    },
    MapBase_mapToString: function(m) {
      var result, t1 = {};
      if (P._isToStringVisiting(m))
        return "{...}";
      result = new P.StringBuffer("");
      try {
        C.JSArray_methods.add$1($._toStringVisiting, m);
        result._contents += "{";
        t1.first = true;
        J.forEach$1$ax(m, new P.MapBase_mapToString_closure(t1, result));
        result._contents += "}";
      } finally {
        if (0 >= $._toStringVisiting.length)
          return H.ioore($._toStringVisiting, -1);
        $._toStringVisiting.pop();
      }
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    ListQueue$: function($E) {
      var t1 = new P.ListQueue([$E]),
        t2 = new Array(8);
      t2.fixed$length = Array;
      t1.set$_table(H.setRuntimeTypeInfo(t2, [$E]));
      return t1;
    },
    ListQueue__nextPowerOf2: function(number) {
      var nextNumber;
      number = (number << 1 >>> 0) - 1;
      for (; true; number = nextNumber) {
        nextNumber = (number & number - 1) >>> 0;
        if (nextNumber === 0)
          return number;
      }
    },
    _HashSet: function _HashSet(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_elements = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _.$ti = t0;
    },
    _HashSetIterator: function _HashSetIterator(t0, t1, t2) {
      var _ = this;
      _._collection$_set = t0;
      _._collection$_elements = t1;
      _._offset = 0;
      _._collection$_current = null;
      _.$ti = t2;
    },
    _LinkedHashSet: function _LinkedHashSet(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_last = _._collection$_first = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _._collection$_modifications = 0;
      _.$ti = t0;
    },
    _LinkedHashSetCell: function _LinkedHashSetCell(t0) {
      this._collection$_element = t0;
      this._collection$_previous = this._collection$_next = null;
    },
    _LinkedHashSetIterator: function _LinkedHashSetIterator(t0, t1, t2) {
      var _ = this;
      _._collection$_set = t0;
      _._collection$_modifications = t1;
      _._collection$_current = _._collection$_cell = null;
      _.$ti = t2;
    },
    IterableBase: function IterableBase() {
    },
    LinkedHashMap_LinkedHashMap$from_closure: function LinkedHashMap_LinkedHashMap$from_closure(t0, t1, t2) {
      this.result = t0;
      this.K = t1;
      this.V = t2;
    },
    LinkedHashSet: function LinkedHashSet() {
    },
    ListBase: function ListBase() {
    },
    ListMixin: function ListMixin() {
    },
    MapBase: function MapBase() {
    },
    MapBase_mapToString_closure: function MapBase_mapToString_closure(t0, t1) {
      this._box_0 = t0;
      this.result = t1;
    },
    MapMixin: function MapMixin() {
    },
    _UnmodifiableMapMixin: function _UnmodifiableMapMixin() {
    },
    MapView: function MapView() {
    },
    UnmodifiableMapView: function UnmodifiableMapView() {
    },
    ListQueue: function ListQueue(t0) {
      var _ = this;
      _._table = null;
      _._modificationCount = _._tail = _._head = 0;
      _.$ti = t0;
    },
    _ListQueueIterator: function _ListQueueIterator(t0, t1, t2, t3, t4) {
      var _ = this;
      _._queue = t0;
      _._end = t1;
      _._modificationCount = t2;
      _._position = t3;
      _._collection$_current = null;
      _.$ti = t4;
    },
    _SetBase: function _SetBase() {
    },
    _ListBase_Object_ListMixin: function _ListBase_Object_ListMixin() {
    },
    _UnmodifiableMapView_MapView__UnmodifiableMapMixin: function _UnmodifiableMapView_MapView__UnmodifiableMapMixin() {
    },
    _parseJson: function(source, reviver) {
      var parsed, e, exception, t1;
      if (typeof source !== "string")
        throw H.wrapException(H.argumentErrorValue(source));
      parsed = null;
      try {
        parsed = JSON.parse(source);
      } catch (exception) {
        e = H.unwrapException(exception);
        t1 = P.FormatException$(String(e), null, null);
        throw H.wrapException(t1);
      }
      t1 = P._convertJsonToDartLazy(parsed);
      return t1;
    },
    _convertJsonToDartLazy: function(object) {
      var i;
      if (object == null)
        return;
      if (typeof object != "object")
        return object;
      if (Object.getPrototypeOf(object) !== Array.prototype)
        return new P._JsonMap(object, Object.create(null));
      for (i = 0; i < object.length; ++i)
        object[i] = P._convertJsonToDartLazy(object[i]);
      return object;
    },
    Utf8Decoder__convertIntercepted: function(allowMalformed, codeUnits, start, end) {
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      if (codeUnits instanceof Uint8Array)
        return P.Utf8Decoder__convertInterceptedUint8List(false, codeUnits, start, end);
      return;
    },
    Utf8Decoder__convertInterceptedUint8List: function(allowMalformed, codeUnits, start, end) {
      var t1, $length,
        decoder = $.$get$Utf8Decoder__decoder();
      if (decoder == null)
        return;
      t1 = 0 === start;
      if (t1 && true)
        return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
      $length = codeUnits.length;
      end = P.RangeError_checkValidRange(start, end, $length);
      if (t1 && end === $length)
        return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
      return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits.subarray(start, end));
    },
    Utf8Decoder__useTextDecoderChecked: function(decoder, codeUnits) {
      if (P.Utf8Decoder__unsafe(codeUnits))
        return;
      return P.Utf8Decoder__useTextDecoderUnchecked(decoder, codeUnits);
    },
    Utf8Decoder__useTextDecoderUnchecked: function(decoder, codeUnits) {
      var t1, exception;
      try {
        t1 = decoder.decode(codeUnits);
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
      }
      return;
    },
    Utf8Decoder__unsafe: function(codeUnits) {
      var i,
        limit = codeUnits.length - 2;
      for (i = 0; i < limit; ++i)
        if (codeUnits[i] === 237)
          if ((codeUnits[i + 1] & 224) === 160)
            return true;
      return false;
    },
    Utf8Decoder__makeDecoder: function() {
      var t1, exception;
      try {
        t1 = new TextDecoder("utf-8", {fatal: true});
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
      }
      return;
    },
    _scanOneByteCharacters: function(units, from, endIndex) {
      var t1, i, unit;
      H.assertSubtype(units, "$isList", [P.int], "$asList");
      if (typeof endIndex !== "number")
        return H.iae(endIndex);
      t1 = units.length;
      i = from;
      for (; i < endIndex; ++i) {
        if (i < 0 || i >= t1)
          return H.ioore(units, i);
        unit = units[i];
        if ((unit & 127) !== unit)
          return i - from;
      }
      return endIndex - from;
    },
    Base64Codec__checkPadding: function(source, sourceIndex, sourceEnd, firstPadding, paddingCount, $length) {
      if (C.JSInt_methods.$mod($length, 4) !== 0)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, padded length must be multiple of four, is " + $length, source, sourceEnd));
      if (firstPadding + paddingCount !== $length)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, '=' not at the end", source, sourceIndex));
      if (paddingCount > 2)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, more than two '=' characters", source, sourceIndex));
    },
    JsonUnsupportedObjectError$: function(unsupportedObject, cause, partialResult) {
      return new P.JsonUnsupportedObjectError(unsupportedObject, cause);
    },
    _defaultToEncodable: function(object) {
      return object.toJson$0();
    },
    _JsonStringStringifier_stringify: function(object, toEncodable, indent) {
      var t1,
        output = new P.StringBuffer(""),
        stringifier = new P._JsonStringStringifier(output, [], P.convert___defaultToEncodable$closure());
      stringifier.writeObject$1(object);
      t1 = output._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _JsonMap: function _JsonMap(t0, t1) {
      this._original = t0;
      this._processed = t1;
      this._data = null;
    },
    _JsonMapKeyIterable: function _JsonMapKeyIterable(t0) {
      this._convert$_parent = t0;
    },
    Base64Codec: function Base64Codec() {
    },
    Base64Encoder: function Base64Encoder() {
    },
    Codec: function Codec() {
    },
    Converter: function Converter() {
    },
    Encoding: function Encoding() {
    },
    JsonUnsupportedObjectError: function JsonUnsupportedObjectError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCyclicError: function JsonCyclicError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCodec: function JsonCodec() {
    },
    JsonEncoder: function JsonEncoder(t0) {
      this._toEncodable = t0;
    },
    JsonDecoder: function JsonDecoder(t0) {
      this._reviver = t0;
    },
    _JsonStringifier: function _JsonStringifier() {
    },
    _JsonStringifier_writeMap_closure: function _JsonStringifier_writeMap_closure(t0, t1) {
      this._box_0 = t0;
      this.keyValueList = t1;
    },
    _JsonStringStringifier: function _JsonStringStringifier(t0, t1, t2) {
      this._sink = t0;
      this._seen = t1;
      this._toEncodable = t2;
    },
    Utf8Codec: function Utf8Codec() {
    },
    Utf8Encoder: function Utf8Encoder() {
    },
    _Utf8Encoder: function _Utf8Encoder(t0) {
      this._bufferIndex = 0;
      this._convert$_buffer = t0;
    },
    Utf8Decoder: function Utf8Decoder(t0) {
      this._allowMalformed = t0;
    },
    _Utf8Decoder: function _Utf8Decoder(t0, t1) {
      var _ = this;
      _._allowMalformed = t0;
      _._stringSink = t1;
      _._isFirstCharacter = true;
      _._extraUnits = _._expectedUnits = _._convert$_value = 0;
    },
    Function_apply: function($function, positionalArguments) {
      return H.Primitives_applyFunction($function, positionalArguments, null);
    },
    int_parse: function(source, onError, radix) {
      var value;
      H.functionTypeCheck(onError, {func: 1, ret: P.int, args: [P.String]});
      value = H.Primitives_parseInt(source, radix);
      if (value != null)
        return value;
      if (onError != null)
        return onError.call$1(source);
      throw H.wrapException(P.FormatException$(source, null, null));
    },
    double_parse: function(source) {
      var value = H.Primitives_parseDouble(source);
      if (value != null)
        return value;
      throw H.wrapException(P.FormatException$("Invalid double", source, null));
    },
    Error__objectToString: function(object) {
      if (object instanceof H.Closure)
        return object.toString$0(0);
      return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
    },
    List_List$from: function(elements, growable, $E) {
      var t2,
        t1 = [$E],
        list = H.setRuntimeTypeInfo([], t1);
      for (t2 = J.get$iterator$ax(elements); t2.moveNext$0();)
        C.JSArray_methods.add$1(list, H.assertSubtypeOfRuntimeType(t2.get$current(t2), $E));
      if (growable)
        return list;
      return H.assertSubtype(J.JSArray_markFixedList(list), "$isList", t1, "$asList");
    },
    String_String$fromCharCodes: function(charCodes, start, end) {
      var len,
        t1 = P.int;
      H.assertSubtype(charCodes, "$isIterable", [t1], "$asIterable");
      if (typeof charCodes === "object" && charCodes !== null && charCodes.constructor === Array) {
        H.assertSubtype(charCodes, "$isJSArray", [t1], "$asJSArray");
        len = charCodes.length;
        end = P.RangeError_checkValidRange(start, end, len);
        if (start <= 0) {
          if (typeof end !== "number")
            return end.$lt();
          t1 = end < len;
        } else
          t1 = true;
        return H.Primitives_stringFromCharCodes(t1 ? C.JSArray_methods.sublist$2(charCodes, start, end) : charCodes);
      }
      if (!!J.getInterceptor$(charCodes).$isNativeUint8List)
        return H.Primitives_stringFromNativeUint8List(charCodes, start, P.RangeError_checkValidRange(start, end, charCodes.length));
      return P.String__stringFromIterable(charCodes, start, end);
    },
    String__stringFromIterable: function(charCodes, start, end) {
      var t1, it, i, list, _null = null;
      H.assertSubtype(charCodes, "$isIterable", [P.int], "$asIterable");
      if (start < 0)
        throw H.wrapException(P.RangeError$range(start, 0, charCodes.length, _null, _null));
      t1 = end == null;
      if (!t1 && end < start)
        throw H.wrapException(P.RangeError$range(end, start, charCodes.length, _null, _null));
      it = J.get$iterator$ax(charCodes);
      for (i = 0; i < start; ++i)
        if (!it.moveNext$0())
          throw H.wrapException(P.RangeError$range(start, 0, i, _null, _null));
      list = [];
      if (t1)
        for (; it.moveNext$0();)
          list.push(it.get$current(it));
      else
        for (i = start; i < end; ++i) {
          if (!it.moveNext$0())
            throw H.wrapException(P.RangeError$range(end, start, i, _null, _null));
          list.push(it.get$current(it));
        }
      return H.Primitives_stringFromCharCodes(list);
    },
    RegExp_RegExp: function(source) {
      return new H.JSSyntaxRegExp(source, H.JSSyntaxRegExp_makeNative(source, false, true, false));
    },
    StringBuffer__writeAll: function(string, objects, separator) {
      var iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return string;
      if (separator.length === 0) {
        do
          string += H.S(iterator.get$current(iterator));
        while (iterator.moveNext$0());
      } else {
        string += H.S(iterator.get$current(iterator));
        for (; iterator.moveNext$0();)
          string = string + separator + H.S(iterator.get$current(iterator));
      }
      return string;
    },
    NoSuchMethodError$: function(receiver, memberName, positionalArguments, namedArguments) {
      return new P.NoSuchMethodError(receiver, memberName, positionalArguments, namedArguments);
    },
    _Uri__uriEncode: function(canonicalTable, text, encoding, spaceToPlus) {
      var t1, bytes, i, t2, byte, t3,
        _s16_ = "0123456789ABCDEF";
      H.assertSubtype(canonicalTable, "$isList", [P.int], "$asList");
      if (encoding === C.C_Utf8Codec) {
        t1 = $.$get$_Uri__needsNoEncoding()._nativeRegExp;
        t1 = t1.test(text);
      } else
        t1 = false;
      if (t1)
        return text;
      H.assertSubtypeOfRuntimeType(text, H.getRuntimeTypeArgument(encoding, "Codec", 0));
      bytes = encoding.get$encoder().convert$1(text);
      for (t1 = bytes.length, i = 0, t2 = ""; i < t1; ++i) {
        byte = bytes[i];
        if (byte < 128) {
          t3 = byte >>> 4;
          if (t3 >= 8)
            return H.ioore(canonicalTable, t3);
          t3 = (canonicalTable[t3] & 1 << (byte & 15)) !== 0;
        } else
          t3 = false;
        if (t3)
          t2 += H.Primitives_stringFromCharCode(byte);
        else
          t2 = spaceToPlus && byte === 32 ? t2 + "+" : t2 + "%" + _s16_[byte >>> 4 & 15] + _s16_[byte & 15];
      }
      return t2.charCodeAt(0) == 0 ? t2 : t2;
    },
    DateTime$_withValue: function(_value, isUtc) {
      var t1;
      if (Math.abs(_value) <= 864e13)
        t1 = false;
      else
        t1 = true;
      if (t1)
        H.throwExpression(P.ArgumentError$("DateTime is outside valid range: " + _value));
      return new P.DateTime(_value, isUtc);
    },
    DateTime__fourDigits: function(n) {
      var absN = Math.abs(n),
        sign = n < 0 ? "-" : "";
      if (absN >= 1000)
        return "" + n;
      if (absN >= 100)
        return sign + "0" + absN;
      if (absN >= 10)
        return sign + "00" + absN;
      return sign + "000" + absN;
    },
    DateTime__threeDigits: function(n) {
      if (n >= 100)
        return "" + n;
      if (n >= 10)
        return "0" + n;
      return "00" + n;
    },
    DateTime__twoDigits: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    },
    Duration$: function(microseconds, milliseconds, seconds) {
      return new P.Duration(1000000 * seconds + 1000 * milliseconds + microseconds);
    },
    Error_safeToString: function(object) {
      if (typeof object === "number" || typeof object === "boolean" || null == object)
        return J.toString$0$(object);
      if (typeof object === "string")
        return JSON.stringify(object);
      return P.Error__objectToString(object);
    },
    AssertionError$: function(message) {
      return new P.AssertionError(message);
    },
    ArgumentError$: function(message) {
      return new P.ArgumentError(false, null, null, message);
    },
    ArgumentError$value: function(value, $name, message) {
      return new P.ArgumentError(true, value, $name, message);
    },
    ArgumentError$notNull: function($name) {
      return new P.ArgumentError(false, null, $name, "Must not be null");
    },
    RangeError$value: function(value, $name) {
      return new P.RangeError(null, null, true, value, $name, "Value not in range");
    },
    RangeError$range: function(invalidValue, minValue, maxValue, $name, message) {
      return new P.RangeError(minValue, maxValue, true, invalidValue, $name, "Invalid value");
    },
    RangeError_checkValidRange: function(start, end, $length) {
      var t1;
      if (typeof start !== "number")
        return H.iae(start);
      if (0 <= start) {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = start > $length;
      } else
        t1 = true;
      if (t1)
        throw H.wrapException(P.RangeError$range(start, 0, $length, "start", null));
      if (end != null) {
        if (!(start > end)) {
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = end > $length;
        } else
          t1 = true;
        if (t1)
          throw H.wrapException(P.RangeError$range(end, start, $length, "end", null));
        return end;
      }
      return $length;
    },
    RangeError_checkNotNegative: function(value, $name) {
      if (typeof value !== "number")
        return value.$lt();
      if (value < 0)
        throw H.wrapException(P.RangeError$range(value, 0, null, $name, null));
    },
    IndexError$: function(invalidValue, indexable, $name, message, $length) {
      var t1 = H.intTypeCheck($length == null ? J.get$length$asx(indexable) : $length);
      return new P.IndexError(t1, true, invalidValue, $name, "Index out of range");
    },
    UnsupportedError$: function(message) {
      return new P.UnsupportedError(message);
    },
    UnimplementedError$: function(message) {
      return new P.UnimplementedError(message);
    },
    StateError$: function(message) {
      return new P.StateError(message);
    },
    ConcurrentModificationError$: function(modifiedObject) {
      return new P.ConcurrentModificationError(modifiedObject);
    },
    Exception_Exception: function(message) {
      return new P._Exception(message);
    },
    FormatException$: function(message, source, offset) {
      return new P.FormatException(message, source, offset);
    },
    List_List$generate: function($length, generator, $E) {
      var result, i;
      H.functionTypeCheck(generator, {func: 1, ret: $E, args: [P.int]});
      result = H.setRuntimeTypeInfo([], [$E]);
      C.JSArray_methods.set$length(result, $length);
      for (i = 0; i < $length; ++i)
        C.JSArray_methods.$indexSet(result, i, generator.call$1(i));
      return result;
    },
    print: function(object) {
      H.printString(H.S(object));
    },
    Stopwatch$: function() {
      if ($.Stopwatch__frequency == null) {
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      }
      return new P.Stopwatch();
    },
    Uri_parse: function(uri) {
      var delta, t1, indices, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, isSimple, scheme, t2, schemeAuth, queryStart0, pathStart0, _null = null,
        end = uri.length;
      if (end >= 5) {
        delta = ((J._codeUnitAt$1$s(uri, 4) ^ 58) * 3 | C.JSString_methods._codeUnitAt$1(uri, 0) ^ 100 | C.JSString_methods._codeUnitAt$1(uri, 1) ^ 97 | C.JSString_methods._codeUnitAt$1(uri, 2) ^ 116 | C.JSString_methods._codeUnitAt$1(uri, 3) ^ 97) >>> 0;
        if (delta === 0)
          return P.UriData__parse(end < end ? C.JSString_methods.substring$2(uri, 0, end) : uri, 5, _null).get$uri();
        else if (delta === 32)
          return P.UriData__parse(C.JSString_methods.substring$2(uri, 5, end), 0, _null).get$uri();
      }
      t1 = new Array(8);
      t1.fixed$length = Array;
      indices = H.setRuntimeTypeInfo(t1, [P.int]);
      C.JSArray_methods.$indexSet(indices, 0, 0);
      C.JSArray_methods.$indexSet(indices, 1, -1);
      C.JSArray_methods.$indexSet(indices, 2, -1);
      C.JSArray_methods.$indexSet(indices, 7, -1);
      C.JSArray_methods.$indexSet(indices, 3, 0);
      C.JSArray_methods.$indexSet(indices, 4, 0);
      C.JSArray_methods.$indexSet(indices, 5, end);
      C.JSArray_methods.$indexSet(indices, 6, end);
      if (P._scan(uri, 0, end, 0, indices) >= 14)
        C.JSArray_methods.$indexSet(indices, 7, end);
      schemeEnd = indices[1];
      if (typeof schemeEnd !== "number")
        return schemeEnd.$ge();
      if (schemeEnd >= 0)
        if (P._scan(uri, 0, schemeEnd, 20, indices) === 20)
          indices[7] = schemeEnd;
      t1 = indices[2];
      if (typeof t1 !== "number")
        return t1.$add();
      hostStart = t1 + 1;
      portStart = indices[3];
      pathStart = indices[4];
      queryStart = indices[5];
      fragmentStart = indices[6];
      if (typeof fragmentStart !== "number")
        return fragmentStart.$lt();
      if (typeof queryStart !== "number")
        return H.iae(queryStart);
      if (fragmentStart < queryStart)
        queryStart = fragmentStart;
      if (typeof pathStart !== "number")
        return pathStart.$lt();
      if (pathStart < hostStart)
        pathStart = queryStart;
      else if (pathStart <= schemeEnd)
        pathStart = schemeEnd + 1;
      if (typeof portStart !== "number")
        return portStart.$lt();
      if (portStart < hostStart)
        portStart = pathStart;
      t1 = indices[7];
      if (typeof t1 !== "number")
        return t1.$lt();
      isSimple = t1 < 0;
      if (isSimple)
        if (hostStart > schemeEnd + 3) {
          scheme = _null;
          isSimple = false;
        } else {
          t1 = portStart > 0;
          if (t1 && portStart + 1 === pathStart) {
            scheme = _null;
            isSimple = false;
          } else {
            if (!(queryStart < end && queryStart === pathStart + 2 && J.startsWith$2$s(uri, "..", pathStart)))
              t2 = queryStart > pathStart + 2 && J.startsWith$2$s(uri, "/..", queryStart - 3);
            else
              t2 = true;
            if (t2) {
              scheme = _null;
              isSimple = false;
            } else {
              if (schemeEnd === 4)
                if (J.startsWith$2$s(uri, "file", 0)) {
                  if (hostStart <= 0) {
                    if (!C.JSString_methods.startsWith$2(uri, "/", pathStart)) {
                      schemeAuth = "file:///";
                      delta = 3;
                    } else {
                      schemeAuth = "file://";
                      delta = 2;
                    }
                    uri = schemeAuth + C.JSString_methods.substring$2(uri, pathStart, end);
                    schemeEnd -= 0;
                    t1 = delta - 0;
                    queryStart += t1;
                    fragmentStart += t1;
                    end = uri.length;
                    hostStart = 7;
                    portStart = 7;
                    pathStart = 7;
                  } else if (pathStart === queryStart) {
                    queryStart0 = queryStart + 1;
                    ++fragmentStart;
                    uri = C.JSString_methods.replaceRange$3(uri, pathStart, queryStart, "/");
                    ++end;
                    queryStart = queryStart0;
                  }
                  scheme = "file";
                } else if (C.JSString_methods.startsWith$2(uri, "http", 0)) {
                  if (t1 && portStart + 3 === pathStart && C.JSString_methods.startsWith$2(uri, "80", portStart + 1)) {
                    pathStart0 = pathStart - 3;
                    queryStart -= 3;
                    fragmentStart -= 3;
                    uri = C.JSString_methods.replaceRange$3(uri, portStart, pathStart, "");
                    end -= 3;
                    pathStart = pathStart0;
                  }
                  scheme = "http";
                } else
                  scheme = _null;
              else if (schemeEnd === 5 && J.startsWith$2$s(uri, "https", 0)) {
                if (t1 && portStart + 4 === pathStart && J.startsWith$2$s(uri, "443", portStart + 1)) {
                  pathStart0 = pathStart - 4;
                  queryStart -= 4;
                  fragmentStart -= 4;
                  uri = J.replaceRange$3$s(uri, portStart, pathStart, "");
                  end -= 3;
                  pathStart = pathStart0;
                }
                scheme = "https";
              } else
                scheme = _null;
              isSimple = true;
            }
          }
        }
      else
        scheme = _null;
      if (isSimple) {
        t1 = uri.length;
        if (end < t1) {
          uri = J.substring$2$s(uri, 0, end);
          schemeEnd -= 0;
          hostStart -= 0;
          portStart -= 0;
          pathStart -= 0;
          queryStart -= 0;
          fragmentStart -= 0;
        }
        return new P._SimpleUri(uri, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
      }
      return P._Uri__Uri$notSimple(uri, 0, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
    },
    Uri__parseIPv4Address: function(host, start, end) {
      var t1, i, partStart, partIndex, char, part, partIndex0, _null = null,
        _s43_ = "IPv4 address should contain exactly 4 parts",
        _s37_ = "each part must be in the range 0..255",
        error = new P.Uri__parseIPv4Address_error(host),
        result = new Uint8Array(4);
      for (t1 = result.length, i = start, partStart = i, partIndex = 0; i < end; ++i) {
        char = C.JSString_methods.codeUnitAt$1(host, i);
        if (char !== 46) {
          if ((char ^ 48) > 9)
            error.call$2("invalid character", i);
        } else {
          if (partIndex === 3)
            error.call$2(_s43_, i);
          part = P.int_parse(C.JSString_methods.substring$2(host, partStart, i), _null, _null);
          if (typeof part !== "number")
            return part.$gt();
          if (part > 255)
            error.call$2(_s37_, partStart);
          partIndex0 = partIndex + 1;
          if (partIndex >= t1)
            return H.ioore(result, partIndex);
          result[partIndex] = part;
          partStart = i + 1;
          partIndex = partIndex0;
        }
      }
      if (partIndex !== 3)
        error.call$2(_s43_, end);
      part = P.int_parse(C.JSString_methods.substring$2(host, partStart, end), _null, _null);
      if (typeof part !== "number")
        return part.$gt();
      if (part > 255)
        error.call$2(_s37_, partStart);
      if (partIndex >= t1)
        return H.ioore(result, partIndex);
      result[partIndex] = part;
      return result;
    },
    Uri_parseIPv6Address: function(host, start, end) {
      var error, parseHex, parts, i, partStart, wildcardSeen, seenDot, char, atEnd, t1, last, bytes, t2, wildCardLength, index, value, j, t3;
      if (end == null)
        end = host.length;
      error = new P.Uri_parseIPv6Address_error(host);
      parseHex = new P.Uri_parseIPv6Address_parseHex(error, host);
      if (host.length < 2)
        error.call$1("address is too short");
      parts = H.setRuntimeTypeInfo([], [P.int]);
      for (i = start, partStart = i, wildcardSeen = false, seenDot = false; i < end; ++i) {
        char = C.JSString_methods.codeUnitAt$1(host, i);
        if (char === 58) {
          if (i === start) {
            ++i;
            if (C.JSString_methods.codeUnitAt$1(host, i) !== 58)
              error.call$2("invalid start colon.", i);
            partStart = i;
          }
          if (i === partStart) {
            if (wildcardSeen)
              error.call$2("only one wildcard `::` is allowed", i);
            C.JSArray_methods.add$1(parts, -1);
            wildcardSeen = true;
          } else
            C.JSArray_methods.add$1(parts, parseHex.call$2(partStart, i));
          partStart = i + 1;
        } else if (char === 46)
          seenDot = true;
      }
      if (parts.length === 0)
        error.call$1("too few parts");
      atEnd = partStart === end;
      t1 = C.JSArray_methods.get$last(parts);
      if (atEnd && t1 !== -1)
        error.call$2("expected a part after last `:`", end);
      if (!atEnd)
        if (!seenDot)
          C.JSArray_methods.add$1(parts, parseHex.call$2(partStart, end));
        else {
          last = P.Uri__parseIPv4Address(host, partStart, end);
          C.JSArray_methods.add$1(parts, (last[0] << 8 | last[1]) >>> 0);
          C.JSArray_methods.add$1(parts, (last[2] << 8 | last[3]) >>> 0);
        }
      if (wildcardSeen) {
        if (parts.length > 7)
          error.call$1("an address with a wildcard must have less than 7 parts");
      } else if (parts.length !== 8)
        error.call$1("an address without a wildcard must contain exactly 8 parts");
      bytes = new Uint8Array(16);
      for (t1 = parts.length, t2 = bytes.length, wildCardLength = 9 - t1, i = 0, index = 0; i < t1; ++i) {
        value = parts[i];
        if (value === -1)
          for (j = 0; j < wildCardLength; ++j) {
            if (index < 0 || index >= t2)
              return H.ioore(bytes, index);
            bytes[index] = 0;
            t3 = index + 1;
            if (t3 >= t2)
              return H.ioore(bytes, t3);
            bytes[t3] = 0;
            index += 2;
          }
        else {
          t3 = C.JSInt_methods._shrOtherPositive$1(value, 8);
          if (index < 0 || index >= t2)
            return H.ioore(bytes, index);
          bytes[index] = t3;
          t3 = index + 1;
          if (t3 >= t2)
            return H.ioore(bytes, t3);
          bytes[t3] = value & 255;
          index += 2;
        }
      }
      return bytes;
    },
    _Uri__Uri$notSimple: function(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme) {
      var userInfoStart, userInfo, host, t1, port, path, query, _null = null;
      if (scheme == null)
        if (schemeEnd > start)
          scheme = P._Uri__makeScheme(uri, start, schemeEnd);
        else {
          if (schemeEnd === start)
            P._Uri__fail(uri, start, "Invalid empty scheme");
          scheme = "";
        }
      if (hostStart > start) {
        userInfoStart = schemeEnd + 3;
        userInfo = userInfoStart < hostStart ? P._Uri__makeUserInfo(uri, userInfoStart, hostStart - 1) : "";
        host = P._Uri__makeHost(uri, hostStart, portStart, false);
        if (typeof portStart !== "number")
          return portStart.$add();
        t1 = portStart + 1;
        if (typeof pathStart !== "number")
          return H.iae(pathStart);
        port = t1 < pathStart ? P._Uri__makePort(P.int_parse(J.substring$2$s(uri, t1, pathStart), new P._Uri__Uri$notSimple_closure(uri, portStart), _null), scheme) : _null;
      } else {
        port = _null;
        host = port;
        userInfo = "";
      }
      path = P._Uri__makePath(uri, pathStart, queryStart, _null, scheme, host != null);
      if (typeof queryStart !== "number")
        return queryStart.$lt();
      query = queryStart < fragmentStart ? P._Uri__makeQuery(uri, queryStart + 1, fragmentStart, _null) : _null;
      return new P._Uri(scheme, userInfo, host, port, path, query, fragmentStart < end ? P._Uri__makeFragment(uri, fragmentStart + 1, end) : _null);
    },
    _Uri__defaultPort: function(scheme) {
      if (scheme === "http")
        return 80;
      if (scheme === "https")
        return 443;
      return 0;
    },
    _Uri__fail: function(uri, index, message) {
      throw H.wrapException(P.FormatException$(message, uri, index));
    },
    _Uri__makePort: function(port, scheme) {
      if (port != null && port === P._Uri__defaultPort(scheme))
        return;
      return port;
    },
    _Uri__makeHost: function(host, start, end, strictIPv6) {
      var t1, i;
      if (host == null)
        return;
      if (start === end)
        return "";
      if (C.JSString_methods.codeUnitAt$1(host, start) === 91) {
        if (typeof end !== "number")
          return end.$sub();
        t1 = end - 1;
        if (C.JSString_methods.codeUnitAt$1(host, t1) !== 93)
          P._Uri__fail(host, start, "Missing end `]` to match `[` in host");
        P.Uri_parseIPv6Address(host, start + 1, t1);
        return C.JSString_methods.substring$2(host, start, end).toLowerCase();
      }
      if (typeof end !== "number")
        return H.iae(end);
      i = start;
      for (; i < end; ++i)
        if (C.JSString_methods.codeUnitAt$1(host, i) === 58) {
          P.Uri_parseIPv6Address(host, start, end);
          return "[" + host + "]";
        }
      return P._Uri__normalizeRegName(host, start, end);
    },
    _Uri__normalizeRegName: function(host, start, end) {
      var index, sectionStart, buffer, isNormalized, char, replacement, t1, slice, t2, sourceLength, tail;
      if (typeof end !== "number")
        return H.iae(end);
      index = start;
      sectionStart = index;
      buffer = null;
      isNormalized = true;
      for (; index < end;) {
        char = C.JSString_methods.codeUnitAt$1(host, index);
        if (char === 37) {
          replacement = P._Uri__normalizeEscape(host, index, true);
          t1 = replacement == null;
          if (t1 && isNormalized) {
            index += 3;
            continue;
          }
          if (buffer == null)
            buffer = new P.StringBuffer("");
          slice = C.JSString_methods.substring$2(host, sectionStart, index);
          t2 = buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
          if (t1) {
            replacement = C.JSString_methods.substring$2(host, index, index + 3);
            sourceLength = 3;
          } else if (replacement === "%") {
            replacement = "%25";
            sourceLength = 1;
          } else
            sourceLength = 3;
          buffer._contents = t2 + replacement;
          index += sourceLength;
          sectionStart = index;
          isNormalized = true;
        } else {
          if (char < 127) {
            t1 = char >>> 4;
            if (t1 >= 8)
              return H.ioore(C.List_qNA, t1);
            t1 = (C.List_qNA[t1] & 1 << (char & 15)) !== 0;
          } else
            t1 = false;
          if (t1) {
            if (isNormalized && 65 <= char && 90 >= char) {
              if (buffer == null)
                buffer = new P.StringBuffer("");
              if (sectionStart < index) {
                buffer._contents += C.JSString_methods.substring$2(host, sectionStart, index);
                sectionStart = index;
              }
              isNormalized = false;
            }
            ++index;
          } else {
            if (char <= 93) {
              t1 = char >>> 4;
              if (t1 >= 8)
                return H.ioore(C.List_2Vk, t1);
              t1 = (C.List_2Vk[t1] & 1 << (char & 15)) !== 0;
            } else
              t1 = false;
            if (t1)
              P._Uri__fail(host, index, "Invalid character");
            else {
              if ((char & 64512) === 55296 && index + 1 < end) {
                tail = C.JSString_methods.codeUnitAt$1(host, index + 1);
                if ((tail & 64512) === 56320) {
                  char = 65536 | (char & 1023) << 10 | tail & 1023;
                  sourceLength = 2;
                } else
                  sourceLength = 1;
              } else
                sourceLength = 1;
              if (buffer == null)
                buffer = new P.StringBuffer("");
              slice = C.JSString_methods.substring$2(host, sectionStart, index);
              buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
              buffer._contents += P._Uri__escapeChar(char);
              index += sourceLength;
              sectionStart = index;
            }
          }
        }
      }
      if (buffer == null)
        return C.JSString_methods.substring$2(host, start, end);
      if (sectionStart < end) {
        slice = C.JSString_methods.substring$2(host, sectionStart, end);
        buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__makeScheme: function(scheme, start, end) {
      var i, containsUpperCase, codeUnit, t1;
      if (start === end)
        return "";
      if (!P._Uri__isAlphabeticCharacter(J.getInterceptor$s(scheme)._codeUnitAt$1(scheme, start)))
        P._Uri__fail(scheme, start, "Scheme not starting with alphabetic character");
      for (i = start, containsUpperCase = false; i < end; ++i) {
        codeUnit = C.JSString_methods._codeUnitAt$1(scheme, i);
        if (codeUnit < 128) {
          t1 = codeUnit >>> 4;
          if (t1 >= 8)
            return H.ioore(C.List_JYB, t1);
          t1 = (C.List_JYB[t1] & 1 << (codeUnit & 15)) !== 0;
        } else
          t1 = false;
        if (!t1)
          P._Uri__fail(scheme, i, "Illegal scheme character");
        if (65 <= codeUnit && codeUnit <= 90)
          containsUpperCase = true;
      }
      scheme = C.JSString_methods.substring$2(scheme, start, end);
      return P._Uri__canonicalizeScheme(containsUpperCase ? scheme.toLowerCase() : scheme);
    },
    _Uri__canonicalizeScheme: function(scheme) {
      if (scheme === "http")
        return "http";
      if (scheme === "file")
        return "file";
      if (scheme === "https")
        return "https";
      if (scheme === "package")
        return "package";
      return scheme;
    },
    _Uri__makeUserInfo: function(userInfo, start, end) {
      if (userInfo == null)
        return "";
      return P._Uri__normalizeOrSubstring(userInfo, start, end, C.List_gRj, false);
    },
    _Uri__makePath: function(path, start, end, pathSegments, scheme, hasAuthority) {
      var result,
        isFile = scheme === "file",
        ensureLeadingSlash = isFile || hasAuthority,
        t1 = path == null;
      if (t1 && true)
        return isFile ? "/" : "";
      result = !t1 ? P._Uri__normalizeOrSubstring(path, start, end, C.List_qg4, true) : C.JSNull_methods.map$1$1(pathSegments, new P._Uri__makePath_closure(), P.String).join$1(0, "/");
      if (result.length === 0) {
        if (isFile)
          return "/";
      } else if (ensureLeadingSlash && !C.JSString_methods.startsWith$1(result, "/"))
        result = "/" + result;
      return P._Uri__normalizePath(result, scheme, hasAuthority);
    },
    _Uri__normalizePath: function(path, scheme, hasAuthority) {
      var t1 = scheme.length === 0;
      if (t1 && !hasAuthority && !C.JSString_methods.startsWith$1(path, "/"))
        return P._Uri__normalizeRelativePath(path, !t1 || hasAuthority);
      return P._Uri__removeDotSegments(path);
    },
    _Uri__makeQuery: function(query, start, end, queryParameters) {
      if (query != null)
        return P._Uri__normalizeOrSubstring(query, start, end, C.List_CVk, true);
      return;
    },
    _Uri__makeFragment: function(fragment, start, end) {
      if (fragment == null)
        return;
      return P._Uri__normalizeOrSubstring(fragment, start, end, C.List_CVk, true);
    },
    _Uri__normalizeEscape: function(source, index, lowerCase) {
      var firstDigit, secondDigit, firstDigitValue, secondDigitValue, value,
        t1 = index + 2;
      if (t1 >= source.length)
        return "%";
      firstDigit = C.JSString_methods.codeUnitAt$1(source, index + 1);
      secondDigit = C.JSString_methods.codeUnitAt$1(source, t1);
      firstDigitValue = H.hexDigitValue(firstDigit);
      secondDigitValue = H.hexDigitValue(secondDigit);
      if (firstDigitValue < 0 || secondDigitValue < 0)
        return "%";
      value = firstDigitValue * 16 + secondDigitValue;
      if (value < 127) {
        t1 = C.JSInt_methods._shrOtherPositive$1(value, 4);
        if (t1 >= 8)
          return H.ioore(C.List_nxB, t1);
        t1 = (C.List_nxB[t1] & 1 << (value & 15)) !== 0;
      } else
        t1 = false;
      if (t1)
        return H.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
      if (firstDigit >= 97 || secondDigit >= 97)
        return C.JSString_methods.substring$2(source, index, index + 3).toUpperCase();
      return;
    },
    _Uri__escapeChar: function(char) {
      var t1, codeUnits, flag, encodedBytes, index, byte,
        _s16_ = "0123456789ABCDEF";
      if (char < 128) {
        t1 = new Array(3);
        t1.fixed$length = Array;
        codeUnits = H.setRuntimeTypeInfo(t1, [P.int]);
        C.JSArray_methods.$indexSet(codeUnits, 0, 37);
        C.JSArray_methods.$indexSet(codeUnits, 1, C.JSString_methods._codeUnitAt$1(_s16_, char >>> 4));
        C.JSArray_methods.$indexSet(codeUnits, 2, C.JSString_methods._codeUnitAt$1(_s16_, char & 15));
      } else {
        if (char > 2047)
          if (char > 65535) {
            flag = 240;
            encodedBytes = 4;
          } else {
            flag = 224;
            encodedBytes = 3;
          }
        else {
          flag = 192;
          encodedBytes = 2;
        }
        t1 = new Array(3 * encodedBytes);
        t1.fixed$length = Array;
        codeUnits = H.setRuntimeTypeInfo(t1, [P.int]);
        for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
          byte = C.JSInt_methods._shrReceiverPositive$1(char, 6 * encodedBytes) & 63 | flag;
          C.JSArray_methods.$indexSet(codeUnits, index, 37);
          C.JSArray_methods.$indexSet(codeUnits, index + 1, C.JSString_methods._codeUnitAt$1(_s16_, byte >>> 4));
          C.JSArray_methods.$indexSet(codeUnits, index + 2, C.JSString_methods._codeUnitAt$1(_s16_, byte & 15));
          index += 3;
        }
      }
      return P.String_String$fromCharCodes(codeUnits, 0, null);
    },
    _Uri__normalizeOrSubstring: function(component, start, end, charTable, escapeDelimiters) {
      var t1 = P._Uri__normalize(component, start, end, H.assertSubtype(charTable, "$isList", [P.int], "$asList"), escapeDelimiters);
      return t1 == null ? C.JSString_methods.substring$2(component, start, end) : t1;
    },
    _Uri__normalize: function(component, start, end, charTable, escapeDelimiters) {
      var t1, index, sectionStart, buffer, char, t2, replacement, sourceLength, tail;
      H.assertSubtype(charTable, "$isList", [P.int], "$asList");
      t1 = !escapeDelimiters;
      index = start;
      sectionStart = index;
      buffer = null;
      while (true) {
        if (typeof index !== "number")
          return index.$lt();
        if (typeof end !== "number")
          return H.iae(end);
        if (!(index < end))
          break;
        c$0: {
          char = C.JSString_methods.codeUnitAt$1(component, index);
          if (char < 127) {
            t2 = char >>> 4;
            if (t2 >= 8)
              return H.ioore(charTable, t2);
            t2 = (charTable[t2] & 1 << (char & 15)) !== 0;
          } else
            t2 = false;
          if (t2)
            ++index;
          else {
            if (char === 37) {
              replacement = P._Uri__normalizeEscape(component, index, false);
              if (replacement == null) {
                index += 3;
                break c$0;
              }
              if ("%" === replacement) {
                replacement = "%25";
                sourceLength = 1;
              } else
                sourceLength = 3;
            } else {
              if (t1)
                if (char <= 93) {
                  t2 = char >>> 4;
                  if (t2 >= 8)
                    return H.ioore(C.List_2Vk, t2);
                  t2 = (C.List_2Vk[t2] & 1 << (char & 15)) !== 0;
                } else
                  t2 = false;
              else
                t2 = false;
              if (t2) {
                P._Uri__fail(component, index, "Invalid character");
                replacement = null;
                sourceLength = null;
              } else {
                if ((char & 64512) === 55296) {
                  t2 = index + 1;
                  if (t2 < end) {
                    tail = C.JSString_methods.codeUnitAt$1(component, t2);
                    if ((tail & 64512) === 56320) {
                      char = 65536 | (char & 1023) << 10 | tail & 1023;
                      sourceLength = 2;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                } else
                  sourceLength = 1;
                replacement = P._Uri__escapeChar(char);
              }
            }
            if (buffer == null)
              buffer = new P.StringBuffer("");
            buffer._contents += C.JSString_methods.substring$2(component, sectionStart, index);
            buffer._contents += H.S(replacement);
            if (typeof sourceLength !== "number")
              return H.iae(sourceLength);
            index += sourceLength;
            sectionStart = index;
          }
        }
      }
      if (buffer == null)
        return;
      if (typeof sectionStart !== "number")
        return sectionStart.$lt();
      if (sectionStart < end)
        buffer._contents += C.JSString_methods.substring$2(component, sectionStart, end);
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__mayContainDotSegments: function(path) {
      if (C.JSString_methods.startsWith$1(path, "."))
        return true;
      return C.JSString_methods.indexOf$1(path, "/.") !== -1;
    },
    _Uri__removeDotSegments: function(path) {
      var output, t1, t2, appendSlash, _i, segment, t3;
      if (!P._Uri__mayContainDotSegments(path))
        return path;
      output = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t2; ++_i) {
        segment = t1[_i];
        if (J.$eq$(segment, "..")) {
          t3 = output.length;
          if (t3 !== 0) {
            if (0 >= t3)
              return H.ioore(output, -1);
            output.pop();
            if (output.length === 0)
              C.JSArray_methods.add$1(output, "");
          }
          appendSlash = true;
        } else if ("." === segment)
          appendSlash = true;
        else {
          C.JSArray_methods.add$1(output, segment);
          appendSlash = false;
        }
      }
      if (appendSlash)
        C.JSArray_methods.add$1(output, "");
      return C.JSArray_methods.join$1(output, "/");
    },
    _Uri__normalizeRelativePath: function(path, allowScheme) {
      var output, t1, t2, appendSlash, _i, segment;
      if (!P._Uri__mayContainDotSegments(path))
        return !allowScheme ? P._Uri__escapeScheme(path) : path;
      output = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t2; ++_i) {
        segment = t1[_i];
        if (".." === segment)
          if (output.length !== 0 && C.JSArray_methods.get$last(output) !== "..") {
            if (0 >= output.length)
              return H.ioore(output, -1);
            output.pop();
            appendSlash = true;
          } else {
            C.JSArray_methods.add$1(output, "..");
            appendSlash = false;
          }
        else if ("." === segment)
          appendSlash = true;
        else {
          C.JSArray_methods.add$1(output, segment);
          appendSlash = false;
        }
      }
      t1 = output.length;
      if (t1 !== 0)
        if (t1 === 1) {
          if (0 >= t1)
            return H.ioore(output, 0);
          t1 = output[0].length === 0;
        } else
          t1 = false;
      else
        t1 = true;
      if (t1)
        return "./";
      if (appendSlash || C.JSArray_methods.get$last(output) === "..")
        C.JSArray_methods.add$1(output, "");
      if (!allowScheme) {
        if (0 >= output.length)
          return H.ioore(output, 0);
        C.JSArray_methods.$indexSet(output, 0, P._Uri__escapeScheme(output[0]));
      }
      return C.JSArray_methods.join$1(output, "/");
    },
    _Uri__escapeScheme: function(path) {
      var i, char, t2,
        t1 = path.length;
      if (t1 >= 2 && P._Uri__isAlphabeticCharacter(J._codeUnitAt$1$s(path, 0)))
        for (i = 1; i < t1; ++i) {
          char = C.JSString_methods._codeUnitAt$1(path, i);
          if (char === 58)
            return C.JSString_methods.substring$2(path, 0, i) + "%3A" + C.JSString_methods.substring$1(path, i + 1);
          if (char <= 127) {
            t2 = char >>> 4;
            if (t2 >= 8)
              return H.ioore(C.List_JYB, t2);
            t2 = (C.List_JYB[t2] & 1 << (char & 15)) === 0;
          } else
            t2 = true;
          if (t2)
            break;
        }
      return path;
    },
    _Uri__isAlphabeticCharacter: function(codeUnit) {
      var lowerCase = codeUnit | 32;
      return 97 <= lowerCase && lowerCase <= 122;
    },
    UriData__parse: function(text, start, sourceUri) {
      var t1, i, slashIndex, char, equalsIndex, lastSeparator, t2, data,
        _s17_ = "Invalid MIME type",
        indices = H.setRuntimeTypeInfo([start - 1], [P.int]);
      for (t1 = text.length, i = start, slashIndex = -1, char = null; i < t1; ++i) {
        char = C.JSString_methods._codeUnitAt$1(text, i);
        if (char === 44 || char === 59)
          break;
        if (char === 47) {
          if (slashIndex < 0) {
            slashIndex = i;
            continue;
          }
          throw H.wrapException(P.FormatException$(_s17_, text, i));
        }
      }
      if (slashIndex < 0 && i > start)
        throw H.wrapException(P.FormatException$(_s17_, text, i));
      for (; char !== 44;) {
        C.JSArray_methods.add$1(indices, i);
        ++i;
        for (equalsIndex = -1; i < t1; ++i) {
          char = C.JSString_methods._codeUnitAt$1(text, i);
          if (char === 61) {
            if (equalsIndex < 0)
              equalsIndex = i;
          } else if (char === 59 || char === 44)
            break;
        }
        if (equalsIndex >= 0)
          C.JSArray_methods.add$1(indices, equalsIndex);
        else {
          lastSeparator = C.JSArray_methods.get$last(indices);
          if (char !== 44 || i !== lastSeparator + 7 || !C.JSString_methods.startsWith$2(text, "base64", lastSeparator + 1))
            throw H.wrapException(P.FormatException$("Expecting '='", text, i));
          break;
        }
      }
      C.JSArray_methods.add$1(indices, i);
      t2 = i + 1;
      if ((indices.length & 1) === 1)
        text = C.C_Base64Codec.normalize$3(0, text, t2, t1);
      else {
        data = P._Uri__normalize(text, t2, t1, C.List_CVk, true);
        if (data != null)
          text = C.JSString_methods.replaceRange$3(text, t2, t1, data);
      }
      return new P.UriData(text, indices, sourceUri);
    },
    _createTables: function() {
      var _s77_ = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=",
        _s1_ = ".", _s1_0 = ":", _s1_1 = "/", _s1_2 = "?", _s1_3 = "#",
        tables = P.List_List$generate(22, new P._createTables_closure(), P.Uint8List),
        t1 = new P._createTables_build(tables),
        t2 = new P._createTables_setChars(),
        t3 = new P._createTables_setRange(),
        b = H.interceptedTypeCheck(t1.call$2(0, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_, 14);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 3);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(14, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_, 15);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(15, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, "%", 225);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 9);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(1, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 10);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(2, 235), "$isUint8List");
      t2.call$3(b, _s77_, 139);
      t2.call$3(b, _s1_1, 131);
      t2.call$3(b, _s1_, 146);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(3, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 68);
      t2.call$3(b, _s1_, 18);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(4, 229), "$isUint8List");
      t2.call$3(b, _s77_, 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, _s1_0, 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "[", 232);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(5, 229), "$isUint8List");
      t2.call$3(b, _s77_, 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, _s1_0, 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(6, 231), "$isUint8List");
      t3.call$3(b, "19", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(7, 231), "$isUint8List");
      t3.call$3(b, "09", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      t2.call$3(H.interceptedTypeCheck(t1.call$2(8, 8), "$isUint8List"), "]", 5);
      b = H.interceptedTypeCheck(t1.call$2(9, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 16);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(16, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 17);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(17, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 9);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(10, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 18);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(18, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 19);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(19, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(11, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 10);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(12, 236), "$isUint8List");
      t2.call$3(b, _s77_, 12);
      t2.call$3(b, _s1_2, 12);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(13, 237), "$isUint8List");
      t2.call$3(b, _s77_, 13);
      t2.call$3(b, _s1_2, 13);
      t3.call$3(H.interceptedTypeCheck(t1.call$2(20, 245), "$isUint8List"), "az", 21);
      b = H.interceptedTypeCheck(t1.call$2(21, 245), "$isUint8List");
      t3.call$3(b, "az", 21);
      t3.call$3(b, "09", 21);
      t2.call$3(b, "+-.", 21);
      return tables;
    },
    _scan: function(uri, start, end, state, indices) {
      var tables, t1, i, table, char, transition;
      H.assertSubtype(indices, "$isList", [P.int], "$asList");
      tables = $.$get$_scannerTables();
      for (t1 = J.getInterceptor$s(uri), i = start; i < end; ++i) {
        if (state < 0 || state >= tables.length)
          return H.ioore(tables, state);
        table = tables[state];
        char = t1._codeUnitAt$1(uri, i) ^ 96;
        if (char > 95)
          char = 31;
        if (char >= table.length)
          return H.ioore(table, char);
        transition = table[char];
        state = transition & 31;
        C.JSArray_methods.$indexSet(indices, transition >>> 5, i);
      }
      return state;
    },
    NoSuchMethodError_toString_closure: function NoSuchMethodError_toString_closure(t0, t1) {
      this._box_0 = t0;
      this.sb = t1;
    },
    bool: function bool() {
    },
    Comparable: function Comparable() {
    },
    DateTime: function DateTime(t0, t1) {
      this._core$_value = t0;
      this.isUtc = t1;
    },
    double: function double() {
    },
    Duration: function Duration(t0) {
      this._duration = t0;
    },
    Duration_toString_sixDigits: function Duration_toString_sixDigits() {
    },
    Duration_toString_twoDigits: function Duration_toString_twoDigits() {
    },
    Error: function Error() {
    },
    AssertionError: function AssertionError(t0) {
      this.message = t0;
    },
    NullThrownError: function NullThrownError() {
    },
    ArgumentError: function ArgumentError(t0, t1, t2, t3) {
      var _ = this;
      _._hasValue = t0;
      _.invalidValue = t1;
      _.name = t2;
      _.message = t3;
    },
    RangeError: function RangeError(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.start = t0;
      _.end = t1;
      _._hasValue = t2;
      _.invalidValue = t3;
      _.name = t4;
      _.message = t5;
    },
    IndexError: function IndexError(t0, t1, t2, t3, t4) {
      var _ = this;
      _.length = t0;
      _._hasValue = t1;
      _.invalidValue = t2;
      _.name = t3;
      _.message = t4;
    },
    NoSuchMethodError: function NoSuchMethodError(t0, t1, t2, t3) {
      var _ = this;
      _._core$_receiver = t0;
      _._core$_memberName = t1;
      _._core$_arguments = t2;
      _._namedArguments = t3;
    },
    UnsupportedError: function UnsupportedError(t0) {
      this.message = t0;
    },
    UnimplementedError: function UnimplementedError(t0) {
      this.message = t0;
    },
    StateError: function StateError(t0) {
      this.message = t0;
    },
    ConcurrentModificationError: function ConcurrentModificationError(t0) {
      this.modifiedObject = t0;
    },
    OutOfMemoryError: function OutOfMemoryError() {
    },
    StackOverflowError: function StackOverflowError() {
    },
    CyclicInitializationError: function CyclicInitializationError(t0) {
      this.variableName = t0;
    },
    _Exception: function _Exception(t0) {
      this.message = t0;
    },
    FormatException: function FormatException(t0, t1, t2) {
      this.message = t0;
      this.source = t1;
      this.offset = t2;
    },
    Function: function Function() {
    },
    int: function int() {
    },
    Iterable: function Iterable() {
    },
    Iterator: function Iterator() {
    },
    List: function List() {
    },
    Map: function Map() {
    },
    Null: function Null() {
    },
    num: function num() {
    },
    Object: function Object() {
    },
    Set: function Set() {
    },
    StackTrace: function StackTrace() {
    },
    Stopwatch: function Stopwatch() {
      this._stop = this._core$_start = 0;
    },
    String: function String() {
    },
    StringBuffer: function StringBuffer(t0) {
      this._contents = t0;
    },
    Symbol0: function Symbol0() {
    },
    Type: function Type() {
    },
    Uri__parseIPv4Address_error: function Uri__parseIPv4Address_error(t0) {
      this.host = t0;
    },
    Uri_parseIPv6Address_error: function Uri_parseIPv6Address_error(t0) {
      this.host = t0;
    },
    Uri_parseIPv6Address_parseHex: function Uri_parseIPv6Address_parseHex(t0, t1) {
      this.error = t0;
      this.host = t1;
    },
    _Uri: function _Uri(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.scheme = t0;
      _._userInfo = t1;
      _._host = t2;
      _._port = t3;
      _.path = t4;
      _._query = t5;
      _._fragment = t6;
      _._hashCodeCache = _._core$_text = null;
    },
    _Uri__Uri$notSimple_closure: function _Uri__Uri$notSimple_closure(t0, t1) {
      this.uri = t0;
      this.portStart = t1;
    },
    _Uri__makePath_closure: function _Uri__makePath_closure() {
    },
    UriData: function UriData(t0, t1, t2) {
      this._core$_text = t0;
      this._separatorIndices = t1;
      this._uriCache = t2;
    },
    _createTables_closure: function _createTables_closure() {
    },
    _createTables_build: function _createTables_build(t0) {
      this.tables = t0;
    },
    _createTables_setChars: function _createTables_setChars() {
    },
    _createTables_setRange: function _createTables_setRange() {
    },
    _SimpleUri: function _SimpleUri(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _._uri = t0;
      _._schemeEnd = t1;
      _._hostStart = t2;
      _._portStart = t3;
      _._pathStart = t4;
      _._queryStart = t5;
      _._fragmentStart = t6;
      _._schemeCache = t7;
      _._hashCodeCache = null;
    },
    _DataUri: function _DataUri(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.scheme = t0;
      _._userInfo = t1;
      _._host = t2;
      _._port = t3;
      _.path = t4;
      _._query = t5;
      _._fragment = t6;
      _._hashCodeCache = _._core$_text = null;
    },
    ServiceExtensionResponse__validateErrorCode: function(errorCode) {
      var _s9_ = "errorCode";
      if (errorCode == null)
        H.throwExpression(P.ArgumentError$notNull(_s9_));
      if (errorCode === -32602)
        return;
      if (typeof errorCode !== "number")
        return errorCode.$ge();
      if (errorCode >= -32016 && errorCode <= -32000)
        return;
      throw H.wrapException(P.ArgumentError$value(errorCode, _s9_, "Out of range"));
    },
    registerExtension: function(method, handler) {
      var t1;
      H.functionTypeCheck(handler, {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [P.String, [P.Map, P.String, P.String]]});
      if (!C.JSString_methods.startsWith$1(method, "ext."))
        throw H.wrapException(P.ArgumentError$value(method, "method", "Must begin with ext."));
      t1 = $.$get$_extensions();
      if (t1.$index(0, method) != null)
        throw H.wrapException(P.ArgumentError$("Extension already registered: " + method));
      t1.$indexSet(0, method, handler);
    },
    postEvent: function(eventKind, eventData) {
      C.C_JsonCodec.encode$1(eventData);
    },
    Timeline_startSync: function($name, $arguments, flow) {
      var t1 = $.$get$Timeline__stack();
      (t1 && C.JSArray_methods).add$1(t1, null);
      return;
    },
    Timeline_finishSync: function() {
      var block,
        t1 = $.$get$Timeline__stack(),
        t2 = t1.length;
      if (t2 === 0)
        throw H.wrapException(P.StateError$("Uneven calls to startSync and finishSync"));
      if (0 >= t2)
        return H.ioore(t1, -1);
      block = t1.pop();
      if (block == null)
        return;
      P._argumentsAsJson(block._developer$_arguments);
      if (block._flow != null)
        P._argumentsAsJson(null);
    },
    Timeline_instantSync: function($name) {
      return;
    },
    _argumentsAsJson: function($arguments) {
      if ($arguments == null || $arguments.get$length($arguments) === 0)
        return "{}";
      return C.C_JsonCodec.encode$1($arguments);
    },
    ServiceExtensionResponse: function ServiceExtensionResponse(t0, t1, t2) {
      this._result = t0;
      this._errorCode = t1;
      this._errorDetail = t2;
    },
    _SyncBlock: function _SyncBlock() {
    },
    convertNativeToDart_Dictionary: function(object) {
      var dict, keys, t1, _i, key;
      if (object == null)
        return;
      dict = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
      keys = Object.getOwnPropertyNames(object);
      for (t1 = keys.length, _i = 0; _i < keys.length; keys.length === t1 || (0, H.throwConcurrentModificationError)(keys), ++_i) {
        key = H.stringTypeCheck(keys[_i]);
        dict.$indexSet(0, key, object[key]);
      }
      return dict;
    },
    convertDartToNative_Dictionary: function(dict) {
      var object = {};
      dict.forEach$1(0, new P.convertDartToNative_Dictionary_closure(object));
      return object;
    },
    convertNativePromiseToDartFuture: function(promise) {
      var t1 = new P._Future($.Zone__current, [null]),
        completer = new P._AsyncCompleter(t1, [null]);
      promise.then(H.convertDartClosureToJS(new P.convertNativePromiseToDartFuture_closure(completer), 1))["catch"](H.convertDartClosureToJS(new P.convertNativePromiseToDartFuture_closure0(completer), 1));
      return t1;
    },
    Device_isOpera: function() {
      var t1 = $.Device__isOpera;
      return t1 == null ? $.Device__isOpera = J.contains$2$asx(window.navigator.userAgent, "Opera", 0) : t1;
    },
    Device_cssPrefix: function() {
      var t1,
        prefix = $.Device__cachedCssPrefix;
      if (prefix != null)
        return prefix;
      t1 = $.Device__isFirefox;
      if (t1 == null ? $.Device__isFirefox = J.contains$2$asx(window.navigator.userAgent, "Firefox", 0) : t1)
        prefix = "-moz-";
      else {
        t1 = $.Device__isIE;
        if (t1 == null)
          t1 = $.Device__isIE = !H.boolConversionCheck(P.Device_isOpera()) && J.contains$2$asx(window.navigator.userAgent, "Trident/", 0);
        if (t1)
          prefix = "-ms-";
        else
          prefix = H.boolConversionCheck(P.Device_isOpera()) ? "-o-" : "-webkit-";
      }
      return $.Device__cachedCssPrefix = prefix;
    },
    _StructuredClone: function _StructuredClone() {
    },
    _StructuredClone_walk_closure: function _StructuredClone_walk_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _AcceptStructuredClone: function _AcceptStructuredClone() {
    },
    _AcceptStructuredClone_walk_closure: function _AcceptStructuredClone_walk_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    convertDartToNative_Dictionary_closure: function convertDartToNative_Dictionary_closure(t0) {
      this.object = t0;
    },
    _StructuredCloneDart2Js: function _StructuredCloneDart2Js(t0, t1) {
      this.values = t0;
      this.copies = t1;
    },
    _AcceptStructuredCloneDart2Js: function _AcceptStructuredCloneDart2Js(t0, t1) {
      this.values = t0;
      this.copies = t1;
      this.mustCopy = false;
    },
    convertNativePromiseToDartFuture_closure: function convertNativePromiseToDartFuture_closure(t0) {
      this.completer = t0;
    },
    convertNativePromiseToDartFuture_closure0: function convertNativePromiseToDartFuture_closure0(t0) {
      this.completer = t0;
    },
    FilteredElementList: function FilteredElementList(t0, t1) {
      this._node = t0;
      this._childNodes = t1;
    },
    FilteredElementList__iterable_closure: function FilteredElementList__iterable_closure() {
    },
    FilteredElementList__iterable_closure0: function FilteredElementList__iterable_closure0() {
    },
    _JenkinsSmiHash_combine0: function(hash, value) {
      hash = 536870911 & hash + value;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    Point: function Point(t0, t1, t2) {
      this.x = t0;
      this.y = t1;
      this.$ti = t2;
    },
    _RectangleBase: function _RectangleBase() {
    },
    Rectangle: function Rectangle() {
    },
    Length: function Length() {
    },
    LengthList: function LengthList() {
    },
    Number: function Number() {
    },
    NumberList: function NumberList() {
    },
    PointList: function PointList() {
    },
    ScriptElement0: function ScriptElement0() {
    },
    StringList: function StringList() {
    },
    SvgElement: function SvgElement() {
    },
    Transform: function Transform() {
    },
    TransformList: function TransformList() {
    },
    _LengthList_Interceptor_ListMixin: function _LengthList_Interceptor_ListMixin() {
    },
    _LengthList_Interceptor_ListMixin_ImmutableListMixin: function _LengthList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _NumberList_Interceptor_ListMixin: function _NumberList_Interceptor_ListMixin() {
    },
    _NumberList_Interceptor_ListMixin_ImmutableListMixin: function _NumberList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _StringList_Interceptor_ListMixin: function _StringList_Interceptor_ListMixin() {
    },
    _StringList_Interceptor_ListMixin_ImmutableListMixin: function _StringList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _TransformList_Interceptor_ListMixin: function _TransformList_Interceptor_ListMixin() {
    },
    _TransformList_Interceptor_ListMixin_ImmutableListMixin: function _TransformList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    ByteBuffer: function ByteBuffer() {
    },
    Endian: function Endian() {
    },
    ByteData: function ByteData() {
    },
    Int8List: function Int8List() {
    },
    Uint8List: function Uint8List() {
    },
    Uint8ClampedList: function Uint8ClampedList() {
    },
    Int16List: function Int16List() {
    },
    Uint16List: function Uint16List() {
    },
    Int32List: function Int32List() {
    },
    Uint32List: function Uint32List() {
    },
    Float32List: function Float32List() {
    },
    Float64List: function Float64List() {
    },
    AudioBuffer: function AudioBuffer() {
    },
    AudioParamMap: function AudioParamMap() {
    },
    AudioParamMap_keys_closure: function AudioParamMap_keys_closure(t0) {
      this.keys = t0;
    },
    AudioTrackList: function AudioTrackList() {
    },
    BaseAudioContext: function BaseAudioContext() {
    },
    OfflineAudioContext: function OfflineAudioContext() {
    },
    _AudioParamMap_Interceptor_MapMixin: function _AudioParamMap_Interceptor_MapMixin() {
    },
    SqlError: function SqlError() {
    },
    SqlResultSetRowList: function SqlResultSetRowList() {
    },
    _SqlResultSetRowList_Interceptor_ListMixin: function _SqlResultSetRowList_Interceptor_ListMixin() {
    },
    _SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin: function _SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _convertDartFunctionFast: function(f) {
      var ret,
        existing = f.$dart_jsFunction;
      if (existing != null)
        return existing;
      ret = function(_call, f) {
        return function() {
          return _call(f, Array.prototype.slice.apply(arguments));
        };
      }(P._callDartFunctionFast, f);
      ret[$.$get$DART_CLOSURE_PROPERTY_NAME()] = f;
      f.$dart_jsFunction = ret;
      return ret;
    },
    _callDartFunctionFast: function(callback, $arguments) {
      H.listTypeCheck($arguments);
      return P.Function_apply(H.interceptedTypeCheck(callback, "$isFunction"), $arguments);
    },
    allowInterop: function(f, $F) {
      H.assertIsSubtype($F, P.Function, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'F' in 'allowInterop'.");
      H.assertSubtypeOfRuntimeType(f, $F);
      if (typeof f == "function")
        return f;
      else
        return H.assertSubtypeOfRuntimeType(P._convertDartFunctionFast(f), $F);
    }
  },
  W = {
    document: function() {
      return document;
    },
    promiseToFuture: function(jsPromise, $T) {
      var t1 = new P._Future($.Zone__current, [$T]),
        completer = new P._AsyncCompleter(t1, [$T]);
      jsPromise.then(H.convertDartClosureToJS(new W.promiseToFuture_closure(completer, $T), 1), H.convertDartClosureToJS(new W.promiseToFuture_closure0(completer), 1));
      return t1;
    },
    CanvasElement_CanvasElement: function(height, width) {
      var e = document.createElement("canvas");
      if (width != null)
        e.width = width;
      if (height != null)
        e.height = height;
      return e;
    },
    Element_Element$html: function(html, treeSanitizer, validator) {
      var t1 = document.body,
        fragment = (t1 && C.BodyElement_methods).createFragment$3$treeSanitizer$validator(t1, html, treeSanitizer, validator);
      fragment.toString;
      t1 = W.Node;
      t1 = new H.WhereIterable(new W._ChildNodeListLazy(fragment), H.functionTypeCheck(new W.Element_Element$html_closure(), {func: 1, ret: P.bool, args: [t1]}), [t1]);
      return H.interceptedTypeCheck(t1.get$single(t1), "$isElement0");
    },
    Element_Element$tag: function(tag) {
      return H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(tag, null), "$isElement0");
    },
    Element__safeTagName: function(element) {
      var t1, t2, exception,
        result = "element tag unavailable";
      try {
        t1 = J.getInterceptor$x(element);
        t2 = t1.get$tagName(element);
        if (typeof t2 === "string")
          result = t1.get$tagName(element);
      } catch (exception) {
        H.unwrapException(exception);
      }
      return result;
    },
    _ElementFactoryProvider_createElement_tag: function(tag, typeExtension) {
      return document.createElement(tag);
    },
    FontFace_FontFace: function(family, source, descriptors) {
      var t1 = new FontFace(family, source, P.convertDartToNative_Dictionary(descriptors));
      return t1;
    },
    HttpRequest_request: function(url, responseType) {
      var t3,
        t1 = W.HttpRequest,
        t2 = new P._Future($.Zone__current, [t1]),
        completer = new P._AsyncCompleter(t2, [t1]),
        xhr = new XMLHttpRequest();
      C.HttpRequest_methods.open$3$async(xhr, "GET", url, true);
      xhr.responseType = responseType;
      t1 = W.ProgressEvent;
      t3 = {func: 1, ret: -1, args: [t1]};
      W._EventStreamSubscription$(xhr, "load", H.functionTypeCheck(new W.HttpRequest_request_closure(xhr, completer), t3), false, t1);
      W._EventStreamSubscription$(xhr, "error", H.functionTypeCheck(completer.get$completeError(), t3), false, t1);
      xhr.send();
      return t2;
    },
    InputElement_InputElement: function() {
      var exception, type = null,
        t1 = document.createElement("input"),
        e = H.interceptedTypeCheck(t1, "$isInputElement");
      if (type != null)
        try {
          e.type = H.stringTypeCheck(type);
        } catch (exception) {
          H.unwrapException(exception);
        }
      return e;
    },
    _JenkinsSmiHash_combine: function(hash, value) {
      hash = 536870911 & hash + value;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    _JenkinsSmiHash_hash4: function(a, b, c, d) {
      var t1 = W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, a), b), c), d),
        hash = 536870911 & t1 + ((67108863 & t1) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    _EventStreamSubscription$: function(_target, _eventType, onData, _useCapture, $T) {
      var t1 = W._wrapZone(new W._EventStreamSubscription_closure(onData), W.Event);
      t1 = new W._EventStreamSubscription(_target, _eventType, t1, false, [$T]);
      t1._tryResume$0();
      return t1;
    },
    _Html5NodeValidator$: function(uriPolicy) {
      var e = document.createElement("a"),
        t1 = new W._SameOriginUriPolicy(e, window.location);
      t1 = new W._Html5NodeValidator(t1);
      t1._Html5NodeValidator$1$uriPolicy(uriPolicy);
      return t1;
    },
    _Html5NodeValidator__standardAttributeValidator: function(element, attributeName, value, context) {
      H.interceptedTypeCheck(element, "$isElement0");
      H.stringTypeCheck(attributeName);
      H.stringTypeCheck(value);
      H.interceptedTypeCheck(context, "$is_Html5NodeValidator");
      return true;
    },
    _Html5NodeValidator__uriAttributeValidator: function(element, attributeName, value, context) {
      var t1, t2, t3;
      H.interceptedTypeCheck(element, "$isElement0");
      H.stringTypeCheck(attributeName);
      H.stringTypeCheck(value);
      t1 = H.interceptedTypeCheck(context, "$is_Html5NodeValidator").uriPolicy;
      t2 = t1._hiddenAnchor;
      t2.href = value;
      t3 = t2.hostname;
      t1 = t1._loc;
      if (!(t3 == t1.hostname && t2.port == t1.port && t2.protocol == t1.protocol))
        if (t3 === "")
          if (t2.port === "") {
            t1 = t2.protocol;
            t1 = t1 === ":" || t1 === "";
          } else
            t1 = false;
        else
          t1 = false;
      else
        t1 = true;
      return t1;
    },
    _TemplatingNodeValidator$: function() {
      var t1 = P.String,
        t2 = P.LinkedHashSet_LinkedHashSet$from(C.List_wSV, t1),
        t3 = H.getTypeArgumentByIndex(C.List_wSV, 0),
        t4 = H.functionTypeCheck(new W._TemplatingNodeValidator_closure(), {func: 1, ret: t1, args: [t3]}),
        t5 = H.setRuntimeTypeInfo(["TEMPLATE"], [t1]);
      t2 = new W._TemplatingNodeValidator(t2, P.LinkedHashSet_LinkedHashSet(t1), P.LinkedHashSet_LinkedHashSet(t1), P.LinkedHashSet_LinkedHashSet(t1), null);
      t2._SimpleNodeValidator$4$allowedAttributes$allowedElements$allowedUriAttributes(null, new H.MappedListIterable(C.List_wSV, t4, [t3, t1]), t5, null);
      return t2;
    },
    _convertNativeToDart_EventTarget: function(e) {
      var $window;
      if ("postMessage" in e) {
        $window = W._DOMWindowCrossFrame__createSafe(e);
        return $window;
      } else
        return H.interceptedTypeCheck(e, "$isEventTarget");
    },
    _convertNativeToDart_XHR_Response: function(o) {
      if (!!J.getInterceptor$(o).$isDocument)
        return o;
      return new P._AcceptStructuredCloneDart2Js([], []).convertNativeToDart_AcceptStructuredClone$2$mustCopy(o, true);
    },
    _DOMWindowCrossFrame__createSafe: function(w) {
      if (w === window)
        return H.interceptedTypeCheck(w, "$isWindowBase");
      else
        return new W._DOMWindowCrossFrame();
    },
    _wrapZone: function(callback, $T) {
      var t1;
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [$T]});
      t1 = $.Zone__current;
      if (t1 === C.C__RootZone)
        return callback;
      return t1.bindUnaryCallbackGuarded$1$1(callback, $T);
    },
    promiseToFuture_closure: function promiseToFuture_closure(t0, t1) {
      this.completer = t0;
      this.T = t1;
    },
    promiseToFuture_closure0: function promiseToFuture_closure0(t0) {
      this.completer = t0;
    },
    HtmlElement: function HtmlElement() {
    },
    AccessibleNodeList: function AccessibleNodeList() {
    },
    AnchorElement: function AnchorElement() {
    },
    ApplicationCacheErrorEvent: function ApplicationCacheErrorEvent() {
    },
    AreaElement: function AreaElement() {
    },
    BaseElement: function BaseElement() {
    },
    Blob: function Blob() {
    },
    BodyElement: function BodyElement() {
    },
    CanvasElement: function CanvasElement() {
    },
    CanvasRenderingContext2D: function CanvasRenderingContext2D() {
    },
    CharacterData: function CharacterData() {
    },
    CssNumericValue: function CssNumericValue() {
    },
    CssPerspective: function CssPerspective() {
    },
    CssRule: function CssRule() {
    },
    CssStyleDeclaration: function CssStyleDeclaration() {
    },
    CssStyleDeclarationBase: function CssStyleDeclarationBase() {
    },
    CssStyleSheet: function CssStyleSheet() {
    },
    CssStyleValue: function CssStyleValue() {
    },
    CssTransformComponent: function CssTransformComponent() {
    },
    CssTransformValue: function CssTransformValue() {
    },
    CssUnparsedValue: function CssUnparsedValue() {
    },
    DataTransferItemList: function DataTransferItemList() {
    },
    DeprecationReport: function DeprecationReport() {
    },
    DivElement: function DivElement() {
    },
    Document: function Document() {
    },
    DomError: function DomError() {
    },
    DomException: function DomException() {
    },
    DomRectList: function DomRectList() {
    },
    DomRectReadOnly: function DomRectReadOnly() {
    },
    DomStringList: function DomStringList() {
    },
    DomTokenList: function DomTokenList() {
    },
    _ChildrenElementList: function _ChildrenElementList(t0, t1) {
      this._html$_element = t0;
      this._childElements = t1;
    },
    _FrozenElementList: function _FrozenElementList(t0, t1) {
      this._nodeList = t0;
      this.$ti = t1;
    },
    Element0: function Element0() {
    },
    Element_Element$html_closure: function Element_Element$html_closure() {
    },
    ErrorEvent: function ErrorEvent() {
    },
    Event: function Event() {
    },
    EventTarget: function EventTarget() {
    },
    File: function File() {
    },
    FileList: function FileList() {
    },
    FileWriter: function FileWriter() {
    },
    FontFace: function FontFace() {
    },
    FontFaceSet: function FontFaceSet() {
    },
    FormElement: function FormElement() {
    },
    Gamepad: function Gamepad() {
    },
    History: function History() {
    },
    HtmlCollection: function HtmlCollection() {
    },
    HttpRequest: function HttpRequest() {
    },
    HttpRequest_request_closure: function HttpRequest_request_closure(t0, t1) {
      this.xhr = t0;
      this.completer = t1;
    },
    HttpRequestEventTarget: function HttpRequestEventTarget() {
    },
    ImageData: function ImageData() {
    },
    InputElement: function InputElement() {
    },
    InterventionReport: function InterventionReport() {
    },
    KeyboardEvent: function KeyboardEvent() {
    },
    LabelElement: function LabelElement() {
    },
    Location: function Location() {
    },
    MediaError: function MediaError() {
    },
    MediaKeyMessageEvent: function MediaKeyMessageEvent() {
    },
    MediaList: function MediaList() {
    },
    MessagePort: function MessagePort() {
    },
    MetaElement: function MetaElement() {
    },
    MidiInputMap: function MidiInputMap() {
    },
    MidiInputMap_keys_closure: function MidiInputMap_keys_closure(t0) {
      this.keys = t0;
    },
    MidiOutputMap: function MidiOutputMap() {
    },
    MidiOutputMap_keys_closure: function MidiOutputMap_keys_closure(t0) {
      this.keys = t0;
    },
    MimeType: function MimeType() {
    },
    MimeTypeArray: function MimeTypeArray() {
    },
    MouseEvent: function MouseEvent() {
    },
    NavigatorUserMediaError: function NavigatorUserMediaError() {
    },
    _ChildNodeListLazy: function _ChildNodeListLazy(t0) {
      this._this = t0;
    },
    Node: function Node() {
    },
    NodeList: function NodeList() {
    },
    OverconstrainedError: function OverconstrainedError() {
    },
    ParagraphElement: function ParagraphElement() {
    },
    Plugin: function Plugin() {
    },
    PluginArray: function PluginArray() {
    },
    PointerEvent0: function PointerEvent0() {
    },
    PopStateEvent: function PopStateEvent() {
    },
    PositionError: function PositionError() {
    },
    PresentationConnectionCloseEvent: function PresentationConnectionCloseEvent() {
    },
    ProgressEvent: function ProgressEvent() {
    },
    ReportBody: function ReportBody() {
    },
    RtcStatsReport: function RtcStatsReport() {
    },
    RtcStatsReport_keys_closure: function RtcStatsReport_keys_closure(t0) {
      this.keys = t0;
    },
    ScriptElement: function ScriptElement() {
    },
    SelectElement: function SelectElement() {
    },
    SourceBuffer: function SourceBuffer() {
    },
    SourceBufferList: function SourceBufferList() {
    },
    SpanElement: function SpanElement() {
    },
    SpeechGrammar: function SpeechGrammar() {
    },
    SpeechGrammarList: function SpeechGrammarList() {
    },
    SpeechRecognitionError: function SpeechRecognitionError() {
    },
    SpeechRecognitionResult: function SpeechRecognitionResult() {
    },
    Storage: function Storage() {
    },
    Storage_keys_closure: function Storage_keys_closure(t0) {
      this.keys = t0;
    },
    StyleElement: function StyleElement() {
    },
    StyleSheet: function StyleSheet() {
    },
    TableElement: function TableElement() {
    },
    TableRowElement: function TableRowElement() {
    },
    TableSectionElement: function TableSectionElement() {
    },
    TemplateElement: function TemplateElement() {
    },
    TextAreaElement: function TextAreaElement() {
    },
    TextTrack: function TextTrack() {
    },
    TextTrackCue: function TextTrackCue() {
    },
    TextTrackCueList: function TextTrackCueList() {
    },
    TextTrackList: function TextTrackList() {
    },
    TimeRanges: function TimeRanges() {
    },
    Touch: function Touch() {
    },
    TouchEvent: function TouchEvent() {
    },
    TouchList: function TouchList() {
    },
    TrackDefaultList: function TrackDefaultList() {
    },
    UIEvent: function UIEvent() {
    },
    Url: function Url() {
    },
    VideoTrackList: function VideoTrackList() {
    },
    WheelEvent: function WheelEvent() {
    },
    Window0: function Window0() {
    },
    Window_animationFrame_closure: function Window_animationFrame_closure(t0) {
      this.completer = t0;
    },
    _Attr: function _Attr() {
    },
    _CssRuleList: function _CssRuleList() {
    },
    _DomRect: function _DomRect() {
    },
    _GamepadList: function _GamepadList() {
    },
    _NamedNodeMap: function _NamedNodeMap() {
    },
    _SpeechRecognitionResultList: function _SpeechRecognitionResultList() {
    },
    _StyleSheetList: function _StyleSheetList() {
    },
    _AttributeMap: function _AttributeMap() {
    },
    _ElementAttributeMap: function _ElementAttributeMap(t0) {
      this._html$_element = t0;
    },
    _EventStream: function _EventStream(t0, t1, t2, t3) {
      var _ = this;
      _._html$_target = t0;
      _._eventType = t1;
      _._useCapture = t2;
      _.$ti = t3;
    },
    _ElementEventStreamImpl: function _ElementEventStreamImpl(t0, t1, t2, t3) {
      var _ = this;
      _._html$_target = t0;
      _._eventType = t1;
      _._useCapture = t2;
      _.$ti = t3;
    },
    _EventStreamSubscription: function _EventStreamSubscription(t0, t1, t2, t3, t4) {
      var _ = this;
      _._pauseCount = 0;
      _._html$_target = t0;
      _._eventType = t1;
      _._onData = t2;
      _._useCapture = t3;
      _.$ti = t4;
    },
    _EventStreamSubscription_closure: function _EventStreamSubscription_closure(t0) {
      this.onData = t0;
    },
    _Html5NodeValidator: function _Html5NodeValidator(t0) {
      this.uriPolicy = t0;
    },
    ImmutableListMixin: function ImmutableListMixin() {
    },
    NodeValidatorBuilder: function NodeValidatorBuilder(t0) {
      this._validators = t0;
    },
    NodeValidatorBuilder_allowsElement_closure: function NodeValidatorBuilder_allowsElement_closure(t0) {
      this.element = t0;
    },
    NodeValidatorBuilder_allowsAttribute_closure: function NodeValidatorBuilder_allowsAttribute_closure(t0, t1, t2) {
      this.element = t0;
      this.attributeName = t1;
      this.value = t2;
    },
    _SimpleNodeValidator: function _SimpleNodeValidator() {
    },
    _SimpleNodeValidator_closure: function _SimpleNodeValidator_closure() {
    },
    _SimpleNodeValidator_closure0: function _SimpleNodeValidator_closure0() {
    },
    _TemplatingNodeValidator: function _TemplatingNodeValidator(t0, t1, t2, t3, t4) {
      var _ = this;
      _._templateAttrs = t0;
      _.allowedElements = t1;
      _.allowedAttributes = t2;
      _.allowedUriAttributes = t3;
      _.uriPolicy = t4;
    },
    _TemplatingNodeValidator_closure: function _TemplatingNodeValidator_closure() {
    },
    _SvgNodeValidator: function _SvgNodeValidator() {
    },
    FixedSizeListIterator: function FixedSizeListIterator(t0, t1, t2) {
      var _ = this;
      _._array = t0;
      _._html$_length = t1;
      _._html$_position = -1;
      _._html$_current = null;
      _.$ti = t2;
    },
    _DOMWindowCrossFrame: function _DOMWindowCrossFrame() {
    },
    NodeValidator: function NodeValidator() {
    },
    _SameOriginUriPolicy: function _SameOriginUriPolicy(t0, t1) {
      this._hiddenAnchor = t0;
      this._loc = t1;
    },
    _ValidatingTreeSanitizer: function _ValidatingTreeSanitizer(t0) {
      this.validator = t0;
    },
    _ValidatingTreeSanitizer_sanitizeTree_walk: function _ValidatingTreeSanitizer_sanitizeTree_walk(t0) {
      this.$this = t0;
    },
    _CssStyleDeclaration_Interceptor_CssStyleDeclarationBase: function _CssStyleDeclaration_Interceptor_CssStyleDeclarationBase() {
    },
    _DomRectList_Interceptor_ListMixin: function _DomRectList_Interceptor_ListMixin() {
    },
    _DomRectList_Interceptor_ListMixin_ImmutableListMixin: function _DomRectList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _DomStringList_Interceptor_ListMixin: function _DomStringList_Interceptor_ListMixin() {
    },
    _DomStringList_Interceptor_ListMixin_ImmutableListMixin: function _DomStringList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _FileList_Interceptor_ListMixin: function _FileList_Interceptor_ListMixin() {
    },
    _FileList_Interceptor_ListMixin_ImmutableListMixin: function _FileList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _HtmlCollection_Interceptor_ListMixin: function _HtmlCollection_Interceptor_ListMixin() {
    },
    _HtmlCollection_Interceptor_ListMixin_ImmutableListMixin: function _HtmlCollection_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _MidiInputMap_Interceptor_MapMixin: function _MidiInputMap_Interceptor_MapMixin() {
    },
    _MidiOutputMap_Interceptor_MapMixin: function _MidiOutputMap_Interceptor_MapMixin() {
    },
    _MimeTypeArray_Interceptor_ListMixin: function _MimeTypeArray_Interceptor_ListMixin() {
    },
    _MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin: function _MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _NodeList_Interceptor_ListMixin: function _NodeList_Interceptor_ListMixin() {
    },
    _NodeList_Interceptor_ListMixin_ImmutableListMixin: function _NodeList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _PluginArray_Interceptor_ListMixin: function _PluginArray_Interceptor_ListMixin() {
    },
    _PluginArray_Interceptor_ListMixin_ImmutableListMixin: function _PluginArray_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _RtcStatsReport_Interceptor_MapMixin: function _RtcStatsReport_Interceptor_MapMixin() {
    },
    _SourceBufferList_EventTarget_ListMixin: function _SourceBufferList_EventTarget_ListMixin() {
    },
    _SourceBufferList_EventTarget_ListMixin_ImmutableListMixin: function _SourceBufferList_EventTarget_ListMixin_ImmutableListMixin() {
    },
    _SpeechGrammarList_Interceptor_ListMixin: function _SpeechGrammarList_Interceptor_ListMixin() {
    },
    _SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin: function _SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _Storage_Interceptor_MapMixin: function _Storage_Interceptor_MapMixin() {
    },
    _TextTrackCueList_Interceptor_ListMixin: function _TextTrackCueList_Interceptor_ListMixin() {
    },
    _TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin: function _TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _TextTrackList_EventTarget_ListMixin: function _TextTrackList_EventTarget_ListMixin() {
    },
    _TextTrackList_EventTarget_ListMixin_ImmutableListMixin: function _TextTrackList_EventTarget_ListMixin_ImmutableListMixin() {
    },
    _TouchList_Interceptor_ListMixin: function _TouchList_Interceptor_ListMixin() {
    },
    _TouchList_Interceptor_ListMixin_ImmutableListMixin: function _TouchList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    __CssRuleList_Interceptor_ListMixin: function __CssRuleList_Interceptor_ListMixin() {
    },
    __CssRuleList_Interceptor_ListMixin_ImmutableListMixin: function __CssRuleList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    __GamepadList_Interceptor_ListMixin: function __GamepadList_Interceptor_ListMixin() {
    },
    __GamepadList_Interceptor_ListMixin_ImmutableListMixin: function __GamepadList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    __NamedNodeMap_Interceptor_ListMixin: function __NamedNodeMap_Interceptor_ListMixin() {
    },
    __NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin: function __NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin() {
    },
    __SpeechRecognitionResultList_Interceptor_ListMixin: function __SpeechRecognitionResultList_Interceptor_ListMixin() {
    },
    __SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin: function __SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    __StyleSheetList_Interceptor_ListMixin: function __StyleSheetList_Interceptor_ListMixin() {
    },
    __StyleSheetList_Interceptor_ListMixin_ImmutableListMixin: function __StyleSheetList_Interceptor_ListMixin_ImmutableListMixin() {
    }
  },
  Y = {HeapPriorityQueue: function HeapPriorityQueue(t0, t1, t2) {
      var _ = this;
      _.comparison = t0;
      _._priority_queue$_queue = t1;
      _._length = 0;
      _.$ti = t2;
    },
    TextTreeConfiguration$: function(addBlankLineIfNoChildren, afterDescriptionIfBody, afterName, afterProperties, beforeName, beforeProperties, bodyIndent, footer, isBlankLineBetweenPropertiesAndChildren, isNameOnOwnLine, lineBreak, lineBreakProperties, linkCharacter, manditoryFooter, prefixLastChildLineOne, prefixLineOne, prefixOtherLines, prefixOtherLinesRootNode, propertyPrefixIfChildren, propertyPrefixNoChildren, propertySeparator, showChildren, suffixLineOne) {
      return new Y.TextTreeConfiguration(prefixLineOne, suffixLineOne, prefixOtherLines, prefixLastChildLineOne, prefixOtherLinesRootNode, propertyPrefixIfChildren, propertyPrefixNoChildren, linkCharacter, C.JSString_methods.$mul(" ", linkCharacter.length), lineBreak, lineBreakProperties, beforeName, afterName, afterDescriptionIfBody, beforeProperties, afterProperties, propertySeparator, bodyIndent, showChildren, addBlankLineIfNoChildren, isNameOnOwnLine, footer, manditoryFooter, isBlankLineBetweenPropertiesAndChildren);
    },
    _PrefixedStringBuilder__wordWrapLine: function(message, wrapRanges, width, otherLineOffset, startOffset) {
      return Y._PrefixedStringBuilder__wordWrapLine$body(message, H.assertSubtype(wrapRanges, "$isList", [P.int], "$asList"), width, otherLineOffset, startOffset);
    },
    _PrefixedStringBuilder__wordWrapLine$body: function($async$message, $async$wrapRanges, $async$width, $async$otherLineOffset, $async$startOffset) {
      return P._makeSyncStarIterable(function() {
        var message = $async$message,
          wrapRanges = $async$wrapRanges,
          width = $async$width,
          otherLineOffset = $async$otherLineOffset,
          startOffset = $async$startOffset;
        var $async$goto = 0, $async$handler = 2, $async$currentError, startForLengthCalculations, noWrap, addPrefix, index, mode, lastWordStart, lastWordEnd, start, t2, _box_0, t1;
        return function $async$_PrefixedStringBuilder__wordWrapLine($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            $async$outer:
              switch ($async$goto) {
                case 0:
                  // Function start
                  _box_0 = {};
                  t1 = message.length;
                  $async$goto = t1 + startOffset < width ? 3 : 4;
                  break;
                case 3:
                  // then
                  $async$goto = 5;
                  return message;
                case 5:
                  // after yield
                  // goto return
                  $async$goto = 1;
                  break;
                case 4:
                  // join
                  startForLengthCalculations = -startOffset;
                  _box_0.currentChunk = 0;
                  noWrap = new Y._PrefixedStringBuilder__wordWrapLine_noWrap(_box_0, wrapRanges);
                  addPrefix = false, index = 0, mode = C._WordWrapParseMode_0, lastWordStart = null, lastWordEnd = null, start = 0;
                case 6:
                  // for condition
                  // trivial condition
                case 8:
                  // switch
                  switch (mode) {
                    case C._WordWrapParseMode_0:
                      // goto case
                      $async$goto = 10;
                      break;
                    case C._WordWrapParseMode_1:
                      // goto case
                      $async$goto = 11;
                      break;
                    case C._WordWrapParseMode_2:
                      // goto case
                      $async$goto = 12;
                      break;
                    default:
                      // goto after switch
                      $async$goto = 9;
                      break;
                  }
                  break;
                case 10:
                  // case
                  while (true) {
                    if (index < t1) {
                      if (index < 0) {
                        H.ioore(message, index);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                      t2 = message[index] === " ";
                    } else
                      t2 = false;
                    if (!t2)
                      break;
                    ++index;
                  }
                  lastWordStart = index;
                  mode = C._WordWrapParseMode_1;
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 11:
                  // case
                  while (true) {
                    if (index < t1) {
                      if (index < 0) {
                        H.ioore(message, index);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                      t2 = message[index] !== " " || H.boolConversionCheck(noWrap.call$1(index));
                    } else
                      t2 = false;
                    if (!t2)
                      break;
                    ++index;
                  }
                  mode = C._WordWrapParseMode_2;
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 12:
                  // case
                  t2 = index - startForLengthCalculations;
                  $async$goto = t2 > width || index === t1 ? 13 : 15;
                  break;
                case 13:
                  // then
                  if (t2 <= width || lastWordEnd == null)
                    lastWordEnd = index;
                  $async$goto = 16;
                  return C.JSString_methods.substring$2(message, start, lastWordEnd);
                case 16:
                  // after yield
                  if (lastWordEnd >= t1) {
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  if (lastWordEnd === index) {
                    while (true) {
                      if (index < t1) {
                        if (index < 0) {
                          H.ioore(message, index);
                          // goto return
                          $async$goto = 1;
                          break $async$outer;
                        }
                        t2 = message[index] === " ";
                      } else
                        t2 = false;
                      if (!t2)
                        break;
                      ++index;
                    }
                    start = index;
                    mode = C._WordWrapParseMode_1;
                  } else {
                    start = lastWordStart;
                    mode = C._WordWrapParseMode_2;
                  }
                  if (typeof start !== "number") {
                    start.$sub();
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  startForLengthCalculations = start - otherLineOffset;
                  addPrefix = true;
                  lastWordEnd = null;
                  // goto join
                  $async$goto = 14;
                  break;
                case 15:
                  // else
                  lastWordEnd = index;
                  mode = C._WordWrapParseMode_0;
                case 14:
                  // join
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 9:
                  // after switch
                  // goto for condition
                  $async$goto = 6;
                  break;
                case 7:
                  // after for
                case 1:
                  // return
                  return P._IterationMarker_endOfIteration();
                case 2:
                  // rethrow
                  return P._IterationMarker_uncaughtError($async$currentError);
              }
        };
      }, P.String);
    },
    DiagnosticsNode_DiagnosticsNode$message: function(message, allowWrap) {
      var _null = null;
      return Y.DiagnosticsProperty$("", _null, allowWrap, C.C__NoDefaultValue, message, false, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_7, _null, -1);
    },
    StringProperty$: function($name, value, defaultValue, quoted, showName) {
      var _null = null;
      return new Y.StringProperty(quoted, _null, false, true, _null, _null, _null, false, value, defaultValue, C.DiagnosticLevel_3, $name, true, showName, _null, C.DiagnosticsTreeStyle_7);
    },
    DoubleProperty$: function($name, value, defaultValue, level, tooltip, unit) {
      var _null = null;
      return new Y.DoubleProperty(unit, _null, false, true, _null, _null, tooltip, false, value, defaultValue, level, $name, true, true, _null, C.DiagnosticsTreeStyle_7);
    },
    IntProperty$: function($name, value, defaultValue, ifNull, level) {
      var t1, _null = null;
      if (ifNull == null)
        t1 = _null;
      else
        t1 = ifNull;
      return new Y.IntProperty(_null, _null, false, true, t1, _null, _null, false, value, defaultValue, level, $name, true, true, _null, C.DiagnosticsTreeStyle_7);
    },
    IterableProperty$: function($name, value, defaultValue, ifEmpty, $T) {
      var _null = null;
      return new Y.IterableProperty(_null, false, true, _null, ifEmpty, _null, false, value, defaultValue, C.DiagnosticLevel_3, $name, true, true, _null, C.DiagnosticsTreeStyle_7, [$T]);
    },
    ObjectFlagProperty$: function($name, value, ifNull, $T) {
      var _null = null;
      return new Y.ObjectFlagProperty(_null, false, true, ifNull, _null, _null, false, value, C.C__NoDefaultValue, C.DiagnosticLevel_3, $name, true, false, _null, C.DiagnosticsTreeStyle_7, [$T]);
    },
    DiagnosticsProperty$: function($name, value, allowWrap, defaultValue, description, expandableValue, ifEmpty, ifNull, level, missingIfNull, showName, showSeparator, style, tooltip, $T) {
      var t1;
      if (ifNull == null)
        t1 = missingIfNull ? "MISSING" : null;
      else
        t1 = ifNull;
      return new Y.DiagnosticsProperty(description, false, allowWrap, t1, ifEmpty, tooltip, missingIfNull, value, defaultValue, level, $name, showSeparator, showName, null, style, [$T]);
    },
    shortHash: function(object) {
      return C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(J.get$hashCode$(object) & 1048575, 16), 5, "0");
    },
    describeEnum: function(enumEntry) {
      var description = J.toString$0$(enumEntry);
      return C.JSString_methods.substring$1(description, J.getInterceptor$s(description).indexOf$1(description, ".") + 1);
    },
    debugPrintDouble: function(value) {
      if (J.getInterceptor$n(value).floor$0(value) === value)
        return H.S(value) + ".0";
      else
        return C.JSNumber_methods.toString$0(value);
    },
    DiagnosticLevel: function DiagnosticLevel(t0, t1) {
      this.index = t0;
      this._diagnostics$_name = t1;
    },
    DiagnosticsTreeStyle: function DiagnosticsTreeStyle(t0) {
      this._diagnostics$_name = t0;
    },
    TextTreeConfiguration: function TextTreeConfiguration(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23) {
      var _ = this;
      _.prefixLineOne = t0;
      _.suffixLineOne = t1;
      _.prefixOtherLines = t2;
      _.prefixLastChildLineOne = t3;
      _.prefixOtherLinesRootNode = t4;
      _.propertyPrefixIfChildren = t5;
      _.propertyPrefixNoChildren = t6;
      _.linkCharacter = t7;
      _.childLinkSpace = t8;
      _.lineBreak = t9;
      _.lineBreakProperties = t10;
      _.beforeName = t11;
      _.afterName = t12;
      _.afterDescriptionIfBody = t13;
      _.beforeProperties = t14;
      _.afterProperties = t15;
      _.propertySeparator = t16;
      _.bodyIndent = t17;
      _.showChildren = t18;
      _.addBlankLineIfNoChildren = t19;
      _.isNameOnOwnLine = t20;
      _.footer = t21;
      _.manditoryFooter = t22;
      _.isBlankLineBetweenPropertiesAndChildren = t23;
    },
    _WordWrapParseMode: function _WordWrapParseMode(t0) {
      this._diagnostics$_name = t0;
    },
    _PrefixedStringBuilder: function _PrefixedStringBuilder(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.prefixLineOne = t0;
      _._prefixOtherLines = t1;
      _._nextPrefixOtherLines = null;
      _.wrapWidth = t2;
      _._buffer = t3;
      _._currentLine = t4;
      _._wrappableRanges = t5;
      _._numLines = 0;
    },
    _PrefixedStringBuilder__wordWrapLine_noWrap: function _PrefixedStringBuilder__wordWrapLine_noWrap(t0, t1) {
      this._box_0 = t0;
      this.wrapRanges = t1;
    },
    _NoDefaultValue: function _NoDefaultValue() {
    },
    TextTreeRenderer: function TextTreeRenderer(t0, t1, t2, t3) {
      var _ = this;
      _._wrapWidth = t0;
      _._wrapWidthProperties = t1;
      _._minLevel = t2;
      _._maxDescendentsTruncatableNode = t3;
    },
    TextTreeRenderer_render_visitor: function TextTreeRenderer_render_visitor(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.maxLines = t1;
      _.descendants = t2;
      _.maxDepth = t3;
    },
    TextTreeRenderer_render_closure: function TextTreeRenderer_render_closure(t0) {
      this.$this = t0;
    },
    DiagnosticsNode: function DiagnosticsNode() {
    },
    StringProperty: function StringProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) {
      var _ = this;
      _.quoted = t0;
      _._description = t1;
      _.expandableValue = t2;
      _.allowWrap = t3;
      _.ifNull = t4;
      _.ifEmpty = t5;
      _.tooltip = t6;
      _.missingIfNull = t7;
      _._value = t8;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t9;
      _._defaultLevel = t10;
      _.name = t11;
      _.showSeparator = t12;
      _.showName = t13;
      _.linePrefix = t14;
      _.style = t15;
    },
    _NumProperty: function _NumProperty() {
    },
    DoubleProperty: function DoubleProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) {
      var _ = this;
      _.unit = t0;
      _._description = t1;
      _.expandableValue = t2;
      _.allowWrap = t3;
      _.ifNull = t4;
      _.ifEmpty = t5;
      _.tooltip = t6;
      _.missingIfNull = t7;
      _._value = t8;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t9;
      _._defaultLevel = t10;
      _.name = t11;
      _.showSeparator = t12;
      _.showName = t13;
      _.linePrefix = t14;
      _.style = t15;
    },
    IntProperty: function IntProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) {
      var _ = this;
      _.unit = t0;
      _._description = t1;
      _.expandableValue = t2;
      _.allowWrap = t3;
      _.ifNull = t4;
      _.ifEmpty = t5;
      _.tooltip = t6;
      _.missingIfNull = t7;
      _._value = t8;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t9;
      _._defaultLevel = t10;
      _.name = t11;
      _.showSeparator = t12;
      _.showName = t13;
      _.linePrefix = t14;
      _.style = t15;
    },
    FlagProperty: function FlagProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) {
      var _ = this;
      _.ifTrue = t0;
      _.ifFalse = t1;
      _._description = t2;
      _.expandableValue = t3;
      _.allowWrap = t4;
      _.ifNull = t5;
      _.ifEmpty = t6;
      _.tooltip = t7;
      _.missingIfNull = t8;
      _._value = t9;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t10;
      _._defaultLevel = t11;
      _.name = t12;
      _.showSeparator = t13;
      _.showName = t14;
      _.linePrefix = t15;
      _.style = t16;
    },
    IterableProperty: function IterableProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) {
      var _ = this;
      _._description = t0;
      _.expandableValue = t1;
      _.allowWrap = t2;
      _.ifNull = t3;
      _.ifEmpty = t4;
      _.tooltip = t5;
      _.missingIfNull = t6;
      _._value = t7;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t8;
      _._defaultLevel = t9;
      _.name = t10;
      _.showSeparator = t11;
      _.showName = t12;
      _.linePrefix = t13;
      _.style = t14;
      _.$ti = t15;
    },
    EnumProperty: function EnumProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) {
      var _ = this;
      _._description = t0;
      _.expandableValue = t1;
      _.allowWrap = t2;
      _.ifNull = t3;
      _.ifEmpty = t4;
      _.tooltip = t5;
      _.missingIfNull = t6;
      _._value = t7;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t8;
      _._defaultLevel = t9;
      _.name = t10;
      _.showSeparator = t11;
      _.showName = t12;
      _.linePrefix = t13;
      _.style = t14;
      _.$ti = t15;
    },
    ObjectFlagProperty: function ObjectFlagProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) {
      var _ = this;
      _._description = t0;
      _.expandableValue = t1;
      _.allowWrap = t2;
      _.ifNull = t3;
      _.ifEmpty = t4;
      _.tooltip = t5;
      _.missingIfNull = t6;
      _._value = t7;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t8;
      _._defaultLevel = t9;
      _.name = t10;
      _.showSeparator = t11;
      _.showName = t12;
      _.linePrefix = t13;
      _.style = t14;
      _.$ti = t15;
    },
    DiagnosticsProperty: function DiagnosticsProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) {
      var _ = this;
      _._description = t0;
      _.expandableValue = t1;
      _.allowWrap = t2;
      _.ifNull = t3;
      _.ifEmpty = t4;
      _.tooltip = t5;
      _.missingIfNull = t6;
      _._value = t7;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t8;
      _._defaultLevel = t9;
      _.name = t10;
      _.showSeparator = t11;
      _.showName = t12;
      _.linePrefix = t13;
      _.style = t14;
      _.$ti = t15;
    },
    DiagnosticableNode: function DiagnosticableNode(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.value = t0;
      _._cachedBuilder = null;
      _.name = t1;
      _.showSeparator = t2;
      _.showName = t3;
      _.linePrefix = t4;
      _.style = t5;
      _.$ti = t6;
    },
    _DiagnosticableTreeNode: function _DiagnosticableTreeNode(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.value = t0;
      _._cachedBuilder = null;
      _.name = t1;
      _.showSeparator = t2;
      _.showName = t3;
      _.linePrefix = t4;
      _.style = t5;
    },
    DiagnosticPropertiesBuilder: function DiagnosticPropertiesBuilder(t0, t1) {
      this.properties = t0;
      this.defaultDiagnosticsTreeStyle = t1;
    },
    Diagnosticable: function Diagnosticable() {
    },
    DiagnosticableMixin: function DiagnosticableMixin() {
    },
    DiagnosticableTree: function DiagnosticableTree() {
    },
    DiagnosticableTreeMixin: function DiagnosticableTreeMixin() {
    },
    DiagnosticsBlock: function DiagnosticsBlock() {
    },
    _Diagnosticable_Object_DiagnosticableMixin: function _Diagnosticable_Object_DiagnosticableMixin() {
    },
    MouseTrackerAnnotation: function MouseTrackerAnnotation() {
    },
    _TrackedAnnotation: function _TrackedAnnotation() {
    },
    MouseTracker: function MouseTracker(t0, t1, t2, t3) {
      var _ = this;
      _.annotationFinder = t0;
      _._trackedAnnotations = t1;
      _._postFrameCheckScheduled = false;
      _._lastMouseEvent = t2;
      _.ChangeNotifier__listeners = t3;
    },
    MouseTracker__scheduleMousePositionCheck_closure: function MouseTracker__scheduleMousePositionCheck_closure(t0) {
      this.$this = t0;
    },
    MouseTracker_collectMousePositions_exitAnnotation: function MouseTracker_collectMousePositions_exitAnnotation(t0) {
      this.$this = t0;
    },
    MouseTracker_collectMousePositions_exitAllDevices: function MouseTracker_collectMousePositions_exitAllDevices(t0) {
      this.exitAnnotation = t0;
    },
    MouseTracker_collectMousePositions_closure: function MouseTracker_collectMousePositions_closure(t0) {
      this.$this = t0;
    }
  },
  Z = {Curve: function Curve() {
    }, Cubic: function Cubic(t0, t1, t2, t3) {
      var _ = this;
      _.a = t0;
      _.b = t1;
      _.c = t2;
      _.d = t3;
    }, ClipContext: function ClipContext() {
    }},
  U = {
    FlutterErrorDetails$: function(context, exception, informationCollector, library, silent, stack) {
      return new U.FlutterErrorDetails(exception, stack, library, context, informationCollector, false);
    },
    FlutterError_FlutterError: function(message) {
      var t3, _null = null,
        lines = H.setRuntimeTypeInfo(message.split("\n"), [P.String]),
        t1 = Y.DiagnosticsNode,
        parts = H.setRuntimeTypeInfo([], [t1]),
        t2 = H.setRuntimeTypeInfo([C.JSArray_methods.get$first(lines)], [P.Object]);
      C.JSArray_methods.add$1(parts, new U.ErrorSummary(_null, false, true, _null, _null, _null, false, t2, _null, C.DiagnosticLevel_6, _null, false, false, _null, C.DiagnosticsTreeStyle_6));
      if (lines.length > 1) {
        t2 = H.SubListIterable$(lines, 1, _null, H.getTypeArgumentByIndex(lines, 0));
        t3 = H.getTypeArgumentByIndex(t2, 0);
        C.JSArray_methods.addAll$1(parts, new H.MappedListIterable(t2, H.functionTypeCheck(new U.FlutterError_FlutterError_closure(), {func: 1, ret: t1, args: [t3]}), [t3, t1]));
      }
      return new U.FlutterError(parts);
    },
    FlutterError_dumpErrorToConsole: function(details, forceReport) {
      if ($.FlutterError__errorCount === 0 || false)
        D.print__debugPrintThrottled$closure().call$1(C.JSString_methods.trimRight$0(new Y.TextTreeRenderer(100, 100, C.DiagnosticLevel_2, 5).render$1(new Y.DiagnosticableNode(details, null, true, true, null, C.DiagnosticsTreeStyle_4, [Y.Diagnosticable]))));
      else
        D.print__debugPrintThrottled$closure().call$1("Another exception was thrown: " + details.get$summary().toString$0(0));
      $.FlutterError__errorCount = $.FlutterError__errorCount + 1;
    },
    FlutterError_defaultStackFilter: function($frames) {
      var stackParser, packageParser, t2, result, skipped, t3, match, t4, packageMatch, where,
        t1 = P.String;
      H.assertSubtype($frames, "$isIterable", [t1], "$asIterable");
      stackParser = P.RegExp_RegExp("^#[0-9]+ +([^.]+).* \\(([^/\\\\]*)[/\\\\].+:[0-9]+(?::[0-9]+)?\\)$");
      packageParser = P.RegExp_RegExp("^([^:]+):(.+)$");
      t2 = [t1];
      result = H.setRuntimeTypeInfo([], t2);
      skipped = H.setRuntimeTypeInfo([], t2);
      for (t2 = J.get$iterator$ax($frames); t2.moveNext$0();) {
        t3 = t2.get$current(t2);
        match = stackParser.firstMatch$1(t3);
        if (match != null) {
          t4 = match._match;
          if (2 >= t4.length)
            return H.ioore(t4, 2);
          if (C.JSArray_methods.contains$1(C.List_cg9, t4[2])) {
            if (2 >= t4.length)
              return H.ioore(t4, 2);
            packageMatch = packageParser.firstMatch$1(t4[2]);
            if (packageMatch != null) {
              t3 = packageMatch._match;
              if (1 >= t3.length)
                return H.ioore(t3, 1);
              t3 = t3[1] === "package";
            } else
              t3 = false;
            if (t3) {
              t3 = packageMatch._match;
              if (2 >= t3.length)
                return H.ioore(t3, 2);
              C.JSArray_methods.add$1(skipped, "package " + H.S(t3[2]));
            } else {
              if (2 >= t4.length)
                return H.ioore(t4, 2);
              C.JSArray_methods.add$1(skipped, "package " + H.S(t4[2]));
            }
            continue;
          }
          if (1 >= t4.length)
            return H.ioore(t4, 1);
          if (C.JSArray_methods.contains$1(C.List_ifn, t4[1])) {
            if (1 >= t4.length)
              return H.ioore(t4, 1);
            C.JSArray_methods.add$1(skipped, "class " + H.S(t4[1]));
            continue;
          }
        }
        C.JSArray_methods.add$1(result, t3);
      }
      t2 = skipped.length;
      if (t2 === 1)
        C.JSArray_methods.add$1(result, "(elided one frame from " + C.JSArray_methods.get$single(skipped) + ")");
      else if (t2 > 1) {
        where = P.LinkedHashSet_LinkedHashSet$from(skipped, t1).toList$0(0);
        C.JSArray_methods.sort$0(where);
        t1 = where.length;
        if (t1 > 1)
          C.JSArray_methods.$indexSet(where, t1 - 1, "and " + H.S(C.JSArray_methods.get$last(where)));
        t1 = where.length;
        t2 = skipped.length;
        if (t1 > 2)
          C.JSArray_methods.add$1(result, "(elided " + t2 + " frames from " + C.JSArray_methods.join$1(where, ", ") + ")");
        else
          C.JSArray_methods.add$1(result, "(elided " + t2 + " frames from " + C.JSArray_methods.join$1(where, " ") + ")");
      }
      return result;
    },
    DiagnosticsStackTrace$: function($name, stack, stackFilter) {
      var t1 = J.map$1$1$ax(U.assertions_FlutterError_defaultStackFilter$closure().call$1(H.setRuntimeTypeInfo(C.JSString_methods.trimRight$0(J.toString$0$(stack)).split("\n"), [P.String])), U.assertions_DiagnosticsStackTrace__createStackFrame$closure(), Y.DiagnosticsNode).toList$0(0);
      return new U.DiagnosticsStackTrace(C.List_empty, t1, stack, true, $name, true, true, null, C.DiagnosticsTreeStyle_6);
    },
    DiagnosticsStackTrace__createStackFrame: function(frame) {
      return Y.DiagnosticsNode_DiagnosticsNode$message(H.stringTypeCheck(frame), false);
    },
    _ErrorDiagnostic: function _ErrorDiagnostic() {
    },
    ErrorDescription: function ErrorDescription(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) {
      var _ = this;
      _._description = t0;
      _.expandableValue = t1;
      _.allowWrap = t2;
      _.ifNull = t3;
      _.ifEmpty = t4;
      _.tooltip = t5;
      _.missingIfNull = t6;
      _._value = t7;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t8;
      _._defaultLevel = t9;
      _.name = t10;
      _.showSeparator = t11;
      _.showName = t12;
      _.linePrefix = t13;
      _.style = t14;
    },
    ErrorSummary: function ErrorSummary(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) {
      var _ = this;
      _._description = t0;
      _.expandableValue = t1;
      _.allowWrap = t2;
      _.ifNull = t3;
      _.ifEmpty = t4;
      _.tooltip = t5;
      _.missingIfNull = t6;
      _._value = t7;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t8;
      _._defaultLevel = t9;
      _.name = t10;
      _.showSeparator = t11;
      _.showName = t12;
      _.linePrefix = t13;
      _.style = t14;
    },
    ErrorHint: function ErrorHint(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) {
      var _ = this;
      _._description = t0;
      _.expandableValue = t1;
      _.allowWrap = t2;
      _.ifNull = t3;
      _.ifEmpty = t4;
      _.tooltip = t5;
      _.missingIfNull = t6;
      _._value = t7;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t8;
      _._defaultLevel = t9;
      _.name = t10;
      _.showSeparator = t11;
      _.showName = t12;
      _.linePrefix = t13;
      _.style = t14;
    },
    FlutterErrorDetails: function FlutterErrorDetails(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.exception = t0;
      _.stack = t1;
      _.library = t2;
      _.context = t3;
      _.informationCollector = t4;
      _.silent = t5;
    },
    FlutterErrorDetails_summary_closure: function FlutterErrorDetails_summary_closure() {
    },
    FlutterErrorDetails_summary_closure0: function FlutterErrorDetails_summary_closure0() {
    },
    FlutterError: function FlutterError(t0) {
      this.diagnostics = t0;
    },
    FlutterError_FlutterError_closure: function FlutterError_FlutterError_closure() {
    },
    FlutterError_toString_closure: function FlutterError_toString_closure(t0) {
      this.renderer = t0;
    },
    DiagnosticsStackTrace: function DiagnosticsStackTrace(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _._diagnostics$_children = t0;
      _._properties = t1;
      _.value = t2;
      _.allowTruncate = t3;
      _.name = t4;
      _.showSeparator = t5;
      _.showName = t6;
      _.linePrefix = t7;
      _.style = t8;
    },
    _FlutterError_Error_DiagnosticableTreeMixin: function _FlutterError_Error_DiagnosticableTreeMixin() {
    },
    TextPainter$: function(ellipsis, locale, maxLines, strutStyle, text, textAlign, textDirection, textScaleFactor, textWidthBasis) {
      return new U.TextPainter(text, textAlign, textDirection, textScaleFactor, ellipsis, locale, maxLines, strutStyle, textWidthBasis);
    },
    TextWidthBasis: function TextWidthBasis(t0) {
      this._text_painter$_name = t0;
    },
    TextPainter: function TextPainter(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _._text_painter$_paragraph = null;
      _._text_painter$_needsLayout = true;
      _._text = t0;
      _._text_painter$_textAlign = t1;
      _._text_painter$_textDirection = t2;
      _._textScaleFactor = t3;
      _._text_painter$_ellipsis = t4;
      _._text_painter$_locale = t5;
      _._text_painter$_maxLines = t6;
      _._text_painter$_strutStyle = t7;
      _._textWidthBasis = t8;
      _._lastMaxWidth = _._lastMinWidth = null;
    },
    StringCodec: function StringCodec() {
    },
    JSONMessageCodec: function JSONMessageCodec() {
    },
    JSONMethodCodec: function JSONMethodCodec() {
    },
    profile: function($function) {
      H.functionTypeCheck($function, {func: 1, ret: -1});
      $function.call$0();
    }
  },
  N = {BindingBase: function BindingBase() {
    }, BindingBase_lockEvents_closure: function BindingBase_lockEvents_closure(t0) {
      this.$this = t0;
    }, BindingBase_registerSignalServiceExtension_closure: function BindingBase_registerSignalServiceExtension_closure(t0) {
      this.callback = t0;
    }, BindingBase_registerNumericServiceExtension_closure: function BindingBase_registerNumericServiceExtension_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.name = t1;
      _.setter = t2;
      _.getter = t3;
    }, BindingBase_registerServiceExtension_closure: function BindingBase_registerServiceExtension_closure(t0, t1) {
      this.methodName = t0;
      this.callback = t1;
    }, BindingBase_registerServiceExtension__closure: function BindingBase_registerServiceExtension__closure() {
    },
    FlutterErrorDetailsForPointerEventDispatcher$: function(context, $event, exception, hitTestEntry, informationCollector, library, stack) {
      return new N.FlutterErrorDetailsForPointerEventDispatcher(exception, stack, library, context, informationCollector, false);
    },
    GestureBinding: function GestureBinding() {
    },
    GestureBinding_dispatchEvent_closure: function GestureBinding_dispatchEvent_closure(t0) {
      this.event = t0;
    },
    GestureBinding_dispatchEvent_closure0: function GestureBinding_dispatchEvent_closure0(t0, t1) {
      this.event = t0;
      this.entry = t1;
    },
    FlutterErrorDetailsForPointerEventDispatcher: function FlutterErrorDetailsForPointerEventDispatcher(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.exception = t0;
      _.stack = t1;
      _.library = t2;
      _.context = t3;
      _.informationCollector = t4;
      _.silent = t5;
    },
    PaintingBinding: function PaintingBinding() {
    },
    debugDumpSemanticsTree: function(childOrder) {
      var t1 = $.RendererBinding__instance;
      if (t1 != null)
        t1.RendererBinding__pipelineOwner._rootNode;
      D.print__debugPrintThrottled$closure().call$1("Semantics not collected.");
    },
    RendererBinding: function RendererBinding() {
    },
    RendererBinding__createMouseTracker_closure: function RendererBinding__createMouseTracker_closure(t0) {
      this.$this = t0;
    },
    timeDilation: function(value) {
      var t1;
      if ($._timeDilation == value)
        return;
      t1 = $.SchedulerBinding__instance;
      if (t1 != null)
        t1.resetEpoch$0();
      $._timeDilation = value;
    },
    SchedulerBinding__parseAppLifecycleMessage: function(message) {
      switch (message) {
        case "AppLifecycleState.paused":
          return C.AppLifecycleState_2;
        case "AppLifecycleState.resumed":
          return C.AppLifecycleState_0;
        case "AppLifecycleState.inactive":
          return C.AppLifecycleState_1;
        case "AppLifecycleState.suspending":
          return C.AppLifecycleState_3;
      }
      return;
    },
    SchedulerBinding__taskSorter: function(e1, e2) {
      H.interceptedTypeCheck(e1, "$is_TaskEntry");
      H.interceptedTypeCheck(e2, "$is_TaskEntry");
      return -C.JSInt_methods.compareTo$1(e1.priority, e2.priority);
    },
    defaultSchedulingStrategy: function(priority, scheduler) {
      var t1 = scheduler.SchedulerBinding__transientCallbacks;
      if (t1.get$length(t1) > 0)
        return priority >= 100000;
      return true;
    },
    _TaskEntry: function _TaskEntry() {
    },
    _FrameCallbackEntry: function _FrameCallbackEntry() {
    },
    SchedulerPhase: function SchedulerPhase(t0) {
      this._binding$_name = t0;
    },
    SchedulerBinding: function SchedulerBinding() {
    },
    SchedulerBinding_endOfFrame_closure: function SchedulerBinding_endOfFrame_closure(t0) {
      this.$this = t0;
    },
    SchedulerBinding_scheduleWarmUpFrame_closure: function SchedulerBinding_scheduleWarmUpFrame_closure(t0) {
      this.$this = t0;
    },
    SchedulerBinding_scheduleWarmUpFrame_closure0: function SchedulerBinding_scheduleWarmUpFrame_closure0(t0, t1) {
      this.$this = t0;
      this.hadScheduledFrame = t1;
    },
    SchedulerBinding_scheduleWarmUpFrame_closure1: function SchedulerBinding_scheduleWarmUpFrame_closure1(t0) {
      this.$this = t0;
    },
    SchedulerBinding_handleBeginFrame_closure: function SchedulerBinding_handleBeginFrame_closure(t0) {
      this.$this = t0;
    },
    SemanticsBinding: function SemanticsBinding() {
    },
    ServicesBinding__parseLicenses: function(rawLicenses) {
      var _licenseSeparator, result, licenses, t1, _i, license, t2, split;
      H.stringTypeCheck(rawLicenses);
      _licenseSeparator = "\n" + C.JSString_methods.$mul("-", 80) + "\n";
      result = H.setRuntimeTypeInfo([], [F.LicenseEntry]);
      licenses = rawLicenses.split(_licenseSeparator);
      for (t1 = licenses.length, _i = 0; _i < t1; ++_i) {
        license = licenses[_i];
        t2 = J.getInterceptor$s(license);
        split = t2.indexOf$1(license, "\n\n");
        if (split >= 0) {
          t2.substring$2(license, 0, split).split("\n");
          t2.substring$1(license, split + 2);
          C.JSArray_methods.add$1(result, new F.LicenseEntryWithLineBreaks());
        } else
          C.JSArray_methods.add$1(result, new F.LicenseEntryWithLineBreaks());
      }
      return result;
    },
    ServicesBinding: function ServicesBinding() {
    },
    ServicesBinding__addLicenses_closure: function ServicesBinding__addLicenses_closure(t0) {
      this.rawLicenses = t0;
    },
    ServicesBinding__addLicenses_closure0: function ServicesBinding__addLicenses_closure0(t0, t1) {
      this.parsedLicenses = t0;
      this.rawLicenses = t1;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure0: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure0() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure1: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure1() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure0: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure0() {
    },
    WidgetsBindingObserver: function WidgetsBindingObserver() {
    },
    WidgetsBinding: function WidgetsBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure0: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure0(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure(t0) {
      this.$this = t0;
    },
    RenderObjectToWidgetAdapter: function RenderObjectToWidgetAdapter(t0, t1, t2, t3, t4) {
      var _ = this;
      _.child = t0;
      _.container = t1;
      _.debugShortDescription = t2;
      _.key = t3;
      _.$ti = t4;
    },
    RenderObjectToWidgetAdapter_attachToRenderTree_closure: function RenderObjectToWidgetAdapter_attachToRenderTree_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.owner = t2;
    },
    RenderObjectToWidgetAdapter_attachToRenderTree_closure0: function RenderObjectToWidgetAdapter_attachToRenderTree_closure0(t0) {
      this._box_0 = t0;
    },
    RenderObjectToWidgetElement: function RenderObjectToWidgetElement(t0, t1, t2, t3) {
      var _ = this;
      _._parent = _._ancestorRenderObjectElement = _._renderObject = _._newWidget = _._child = null;
      _._cachedHash = t0;
      _._depth = _._slot = null;
      _._widget = t1;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t2;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
      _.$ti = t3;
    },
    WidgetsFlutterBinding: function WidgetsFlutterBinding(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38) {
      var _ = this;
      _.WidgetsBinding__buildOwner = t0;
      _.WidgetsBinding__observers = t1;
      _.WidgetsBinding__needToReportFirstFrame = t2;
      _.WidgetsBinding__deferFirstFrameReportCount = t3;
      _.WidgetsBinding_debugBuildingDirtyElements = t4;
      _.WidgetsBinding__renderViewElement = t5;
      _.RendererBinding__mouseTracker = t6;
      _.RendererBinding__pipelineOwner = t7;
      _.RendererBinding__semanticsHandle = t8;
      _.SemanticsBinding__accessibilityFeatures = t9;
      _.PaintingBinding__imageCache = t10;
      _.PaintingBinding__kDecodedCacheRatioCap = t11;
      _.SchedulerBinding__lifecycleState = t12;
      _.SchedulerBinding_schedulingStrategy = t13;
      _.SchedulerBinding__taskQueue = t14;
      _.SchedulerBinding__hasRequestedAnEventLoopCallback = t15;
      _.SchedulerBinding__nextFrameCallbackId = t16;
      _.SchedulerBinding__transientCallbacks = t17;
      _.SchedulerBinding__removedIds = t18;
      _.SchedulerBinding__persistentCallbacks = t19;
      _.SchedulerBinding__postFrameCallbacks = t20;
      _.SchedulerBinding__nextFrameCompleter = t21;
      _.SchedulerBinding__hasScheduledFrame = t22;
      _.SchedulerBinding__schedulerPhase = t23;
      _.SchedulerBinding__framesEnabled = t24;
      _.SchedulerBinding__warmUpFrame = t25;
      _.SchedulerBinding__firstRawTimeStampInEpoch = t26;
      _.SchedulerBinding__epochStart = t27;
      _.SchedulerBinding__lastRawTimeStamp = t28;
      _.SchedulerBinding__currentFrameTimeStamp = t29;
      _.SchedulerBinding__profileFrameNumber = t30;
      _.SchedulerBinding__profileFrameStopwatch = t31;
      _.SchedulerBinding__debugBanner = t32;
      _.SchedulerBinding__ignoreNextEngineDrawFrame = t33;
      _.GestureBinding__pendingPointerEvents = t34;
      _.GestureBinding_pointerRouter = t35;
      _.GestureBinding_gestureArena = t36;
      _.GestureBinding_pointerSignalResolver = t37;
      _.GestureBinding__hitTests = t38;
      _._lockCount = 0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding() {
    },
    Widget_canUpdate: function(oldWidget, newWidget) {
      return J.get$runtimeType$(oldWidget).$eq(0, new H.TypeImpl(H.getRti(newWidget))) && J.$eq$(oldWidget.key, newWidget.key);
    },
    _InactiveElements__deactivateRecursively: function(element) {
      element.deactivate$0();
      element.visitChildren$1(N.framework__InactiveElements__deactivateRecursively$closure());
    },
    Element__sort: function(a, b) {
      var t1, t2;
      H.interceptedTypeCheck(a, "$isElement");
      H.interceptedTypeCheck(b, "$isElement");
      t1 = a._depth;
      t2 = b._depth;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 < t2)
        return -1;
      if (t2 < t1)
        return 1;
      t1 = b._dirty;
      if (t1 && !a._dirty)
        return -1;
      if (a._dirty && !t1)
        return 1;
      return 0;
    },
    Element__activateRecursively: function(element) {
      element.activate$0();
      element.visitChildren$1(N.framework_Element__activateRecursively$closure());
    },
    ErrorWidget__stringify: function(exception) {
      var t1, exception;
      try {
        t1 = J.toString$0$(exception);
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
      }
      return "Error";
    },
    _debugReportException: function(context, exception, stack, informationCollector) {
      var details;
      H.interceptedTypeCheck(stack, "$isStackTrace");
      details = U.FlutterErrorDetails$(context, exception, H.functionTypeCheck(informationCollector, {func: 1, ret: [P.Iterable, Y.DiagnosticsNode]}), "widgets library", false, stack);
      U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(details);
      return details;
    },
    UniqueKey: function UniqueKey() {
    },
    GlobalKey: function GlobalKey() {
    },
    GlobalObjectKey: function GlobalObjectKey(t0, t1) {
      this.value = t0;
      this.$ti = t1;
    },
    Widget: function Widget() {
    },
    StatelessWidget: function StatelessWidget() {
    },
    StatefulWidget: function StatefulWidget() {
    },
    State: function State() {
    },
    ProxyWidget: function ProxyWidget() {
    },
    InheritedWidget: function InheritedWidget() {
    },
    RenderObjectWidget: function RenderObjectWidget() {
    },
    LeafRenderObjectWidget: function LeafRenderObjectWidget() {
    },
    _ElementLifecycle: function _ElementLifecycle(t0) {
      this._framework$_name = t0;
    },
    _InactiveElements: function _InactiveElements(t0) {
      this._locked = false;
      this._elements = t0;
    },
    _InactiveElements__unmount_closure: function _InactiveElements__unmount_closure(t0, t1) {
      this.$this = t0;
      this.element = t1;
    },
    BuildContext: function BuildContext() {
    },
    BuildOwner: function BuildOwner(t0, t1, t2) {
      var _ = this;
      _.onBuildScheduled = null;
      _._inactiveElements = t0;
      _._dirtyElements = t1;
      _._scheduledFlushDirtyElements = false;
      _._dirtyElementsNeedsResorting = null;
      _.focusManager = t2;
      _._debugStateLockLevel = 0;
      _._debugBuilding = false;
      _._debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans = _._debugCurrentBuildTarget = null;
    },
    BuildOwner_buildScope_closure: function BuildOwner_buildScope_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    BuildOwner_finalizeTree_closure: function BuildOwner_finalizeTree_closure(t0) {
      this.$this = t0;
    },
    Element: function Element() {
    },
    Element_updateSlotForChild_visit: function Element_updateSlotForChild_visit(t0) {
      this.newSlot = t0;
    },
    Element__updateDepth_closure: function Element__updateDepth_closure(t0) {
      this.expectedDepth = t0;
    },
    Element_detachRenderObject_closure: function Element_detachRenderObject_closure() {
    },
    Element_attachRenderObject_closure: function Element_attachRenderObject_closure(t0) {
      this.newSlot = t0;
    },
    Element_debugFillProperties_closure: function Element_debugFillProperties_closure() {
    },
    Element_debugDescribeChildren_closure: function Element_debugDescribeChildren_closure(t0) {
      this.children = t0;
    },
    ErrorWidget: function ErrorWidget(t0, t1, t2) {
      this.message = t0;
      this._flutterError = t1;
      this.key = t2;
    },
    ErrorWidget_closure: function ErrorWidget_closure() {
    },
    ComponentElement: function ComponentElement() {
    },
    StatelessElement: function StatelessElement(t0, t1, t2) {
      var _ = this;
      _._parent = _._framework$_child = null;
      _._cachedHash = t0;
      _._depth = _._slot = null;
      _._widget = t1;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t2;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    },
    ProxyElement: function ProxyElement() {
    },
    InheritedElement: function InheritedElement() {
    },
    RenderObjectElement: function RenderObjectElement() {
    },
    RootRenderObjectElement: function RootRenderObjectElement() {
    },
    LeafRenderObjectElement: function LeafRenderObjectElement(t0, t1, t2) {
      var _ = this;
      _._parent = _._ancestorRenderObjectElement = _._renderObject = null;
      _._cachedHash = t0;
      _._depth = _._slot = null;
      _._widget = t1;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t2;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    }
  },
  B = {ChangeNotifier: function ChangeNotifier() {
    }, ChangeNotifier_notifyListeners_closure: function ChangeNotifier_notifyListeners_closure(t0) {
      this.$this = t0;
    }, AbstractNode: function AbstractNode() {
    },
    BinaryMessages__sendPlatformMessage: function(channel, message) {
      var t1 = P.ByteData,
        t2 = new P._Future($.Zone__current, [t1]);
      $.$get$window().sendPlatformMessage$3(channel, message, new B.BinaryMessages__sendPlatformMessage_closure(new P._AsyncCompleter(t2, [t1])));
      return t2;
    },
    BinaryMessages_handlePlatformMessage: function(channel, data, callback) {
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.ByteData]});
      return B.BinaryMessages_handlePlatformMessage$body(channel, data, callback);
    },
    BinaryMessages_handlePlatformMessage$body: function(channel, data, callback) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$handler = 1, $async$currentError, $async$next = [], handler, exception, stack, exception0, t1, response, $async$exception0;
      var $async$BinaryMessages_handlePlatformMessage = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              response = null;
              $async$handler = 3;
              handler = $.BinaryMessages__handlers.$index(0, channel);
              $async$goto = handler != null ? 6 : 7;
              break;
            case 6:
              // then
              $async$goto = 8;
              return P._asyncAwait(handler.call$1(data), $async$BinaryMessages_handlePlatformMessage);
            case 8:
              // returning from await.
              response = $async$result;
            case 7:
              // join
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception0 = $async$currentError;
              exception = H.unwrapException($async$exception0);
              stack = H.getTraceFromException($async$exception0);
              t1 = H.setRuntimeTypeInfo(["during a platform message callback"], [P.Object]);
              U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(U.FlutterErrorDetails$(new U.ErrorDescription(null, false, true, null, null, null, false, t1, null, C.DiagnosticLevel_3, null, false, false, null, C.DiagnosticsTreeStyle_6), exception, null, "services library", false, stack));
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 2:
              // uncaught
              $async$next = [1];
            case 4:
              // finally
              $async$handler = 1;
              callback.call$1(response);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$BinaryMessages_handlePlatformMessage, $async$completer);
    },
    BinaryMessages_send: function(channel, message) {
      $.BinaryMessages__mockHandlers.$index(0, channel);
      return B.BinaryMessages__sendPlatformMessage(channel, message);
    },
    BinaryMessages_setMessageHandler: function(channel, handler) {
      H.functionTypeCheck(handler, {func: 1, ret: [P.Future, P.ByteData], args: [P.ByteData]});
      if (handler == null)
        $.BinaryMessages__handlers.remove$1(0, channel);
      else
        $.BinaryMessages__handlers.$indexSet(0, channel, handler);
    },
    BinaryMessages__sendPlatformMessage_closure: function BinaryMessages__sendPlatformMessage_closure(t0) {
      this.completer = t0;
    },
    RawKeyEvent_RawKeyEvent$fromMessage: function(message) {
      var t1, keymap, t2, t3, t4, data, t5, t6, t7, type,
        _s9_ = "codePoint";
      H.assertSubtype(message, "$isMap", [P.String, null], "$asMap");
      t1 = J.getInterceptor$asx(message);
      keymap = H.stringTypeCheck(t1.$index(message, "keymap"));
      switch (keymap) {
        case "fuchsia":
          t2 = t1.$index(message, "hidUsage");
          t2 = H.intTypeCheck(t2 == null ? 0 : t2);
          t3 = t1.$index(message, _s9_);
          t3 = H.intTypeCheck(t3 == null ? 0 : t3);
          t4 = t1.$index(message, "modifiers");
          data = new Q.RawKeyEventDataFuchsia(t2, t3, H.intTypeCheck(t4 == null ? 0 : t4));
          break;
        case "android":
          t2 = t1.$index(message, "flags");
          t2 = H.intTypeCheck(t2 == null ? 0 : t2);
          t3 = t1.$index(message, _s9_);
          t3 = H.intTypeCheck(t3 == null ? 0 : t3);
          t4 = t1.$index(message, "keyCode");
          t4 = H.intTypeCheck(t4 == null ? 0 : t4);
          t5 = t1.$index(message, "plainCodePoint");
          t5 = H.intTypeCheck(t5 == null ? 0 : t5);
          t6 = t1.$index(message, "scanCode");
          t6 = H.intTypeCheck(t6 == null ? 0 : t6);
          t7 = t1.$index(message, "metaState");
          data = new Q.RawKeyEventDataAndroid(t2, t3, t5, t4, t6, H.intTypeCheck(t7 == null ? 0 : t7));
          break;
        default:
          throw H.wrapException(U.FlutterError_FlutterError("Unknown keymap for key events: " + H.S(keymap)));
      }
      type = H.stringTypeCheck(t1.$index(message, "type"));
      switch (type) {
        case "keydown":
          H.stringTypeCheck(t1.$index(message, "character"));
          return new B.RawKeyDownEvent(data);
        case "keyup":
          return new B.RawKeyUpEvent(data);
        default:
          throw H.wrapException(U.FlutterError_FlutterError("Unknown key event type: " + H.S(type)));
      }
    },
    KeyboardSide: function KeyboardSide(t0) {
      this._raw_keyboard$_name = t0;
    },
    ModifierKey: function ModifierKey(t0) {
      this._raw_keyboard$_name = t0;
    },
    RawKeyEventData: function RawKeyEventData() {
    },
    RawKeyEvent: function RawKeyEvent() {
    },
    RawKeyDownEvent: function RawKeyDownEvent(t0) {
      this.data = t0;
    },
    RawKeyUpEvent: function RawKeyUpEvent(t0) {
      this.data = t0;
    },
    RawKeyboard: function RawKeyboard(t0, t1) {
      this._listeners = t0;
      this._keysPressed = t1;
    }
  },
  D = {Key: function Key() {
    }, LocalKey: function LocalKey() {
    }, GestureArenaMember: function GestureArenaMember() {
    }, _GestureArena: function _GestureArena() {
    }, GestureArenaManager: function GestureArenaManager(t0) {
      this._arenas = t0;
    },
    debugPrintThrottled: function(message, wrapWidth) {
      var messageLines = H.setRuntimeTypeInfo(message.split("\n"), [P.String]);
      $.$get$_debugPrintBuffer().addAll$1(0, messageLines);
      if (!$._debugPrintScheduled)
        D._debugPrintTask();
    },
    _debugPrintTask: function() {
      var line,
        t1 = $._debugPrintScheduled = false,
        t2 = $.$get$_debugPrintStopwatch();
      if (P.Duration$(t2.get$elapsedMicroseconds(), 0, 0)._duration > 1000000) {
        t2.stop$0(0);
        t2.reset$0(0);
        $._debugPrintedCharacters = 0;
      }
      while (true) {
        if ($._debugPrintedCharacters < 12288) {
          t2 = $.$get$_debugPrintBuffer();
          t2 = !t2.get$isEmpty(t2);
        } else
          t2 = t1;
        if (!t2)
          break;
        line = $.$get$_debugPrintBuffer().removeFirst$0();
        $._debugPrintedCharacters = $._debugPrintedCharacters + line.length;
        H.printString(H.S(line));
      }
      t1 = $.$get$_debugPrintBuffer();
      if (!t1.get$isEmpty(t1)) {
        $._debugPrintScheduled = true;
        $._debugPrintedCharacters = 0;
        P.Timer_Timer(C.Duration_1000000, D.print___debugPrintTask$closure());
        if ($._debugPrintCompleter == null) {
          t1 = -1;
          $._debugPrintCompleter = new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]);
        }
      } else {
        $.$get$_debugPrintStopwatch().start$0(0);
        t1 = $._debugPrintCompleter;
        if (t1 != null)
          t1.complete$0(0);
        $._debugPrintCompleter = null;
      }
    },
    debugPrintDone: function() {
      var t1 = $._debugPrintCompleter;
      t1 = t1 == null ? null : t1.future;
      if (t1 == null) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
      }
      return t1;
    }
  },
  F = {LicenseEntry: function LicenseEntry() {
    }, LicenseEntryWithLineBreaks: function LicenseEntryWithLineBreaks() {
    }, PointerEvent: function PointerEvent() {
    }, PointerAddedEvent: function PointerAddedEvent(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) {
      var _ = this;
      _.timeStamp = t0;
      _.pointer = t1;
      _.kind = t2;
      _.device = t3;
      _.position = t4;
      _.delta = t5;
      _.buttons = t6;
      _.down = t7;
      _.obscured = t8;
      _.pressure = t9;
      _.pressureMin = t10;
      _.pressureMax = t11;
      _.distance = t12;
      _.distanceMax = t13;
      _.size = t14;
      _.radiusMajor = t15;
      _.radiusMinor = t16;
      _.radiusMin = t17;
      _.radiusMax = t18;
      _.orientation = t19;
      _.tilt = t20;
      _.platformData = t21;
      _.synthesized = t22;
    }, PointerRemovedEvent: function PointerRemovedEvent(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) {
      var _ = this;
      _.timeStamp = t0;
      _.pointer = t1;
      _.kind = t2;
      _.device = t3;
      _.position = t4;
      _.delta = t5;
      _.buttons = t6;
      _.down = t7;
      _.obscured = t8;
      _.pressure = t9;
      _.pressureMin = t10;
      _.pressureMax = t11;
      _.distance = t12;
      _.distanceMax = t13;
      _.size = t14;
      _.radiusMajor = t15;
      _.radiusMinor = t16;
      _.radiusMin = t17;
      _.radiusMax = t18;
      _.orientation = t19;
      _.tilt = t20;
      _.platformData = t21;
      _.synthesized = t22;
    }, PointerHoverEvent: function PointerHoverEvent(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) {
      var _ = this;
      _.timeStamp = t0;
      _.pointer = t1;
      _.kind = t2;
      _.device = t3;
      _.position = t4;
      _.delta = t5;
      _.buttons = t6;
      _.down = t7;
      _.obscured = t8;
      _.pressure = t9;
      _.pressureMin = t10;
      _.pressureMax = t11;
      _.distance = t12;
      _.distanceMax = t13;
      _.size = t14;
      _.radiusMajor = t15;
      _.radiusMinor = t16;
      _.radiusMin = t17;
      _.radiusMax = t18;
      _.orientation = t19;
      _.tilt = t20;
      _.platformData = t21;
      _.synthesized = t22;
    }, PointerDownEvent: function PointerDownEvent(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) {
      var _ = this;
      _.timeStamp = t0;
      _.pointer = t1;
      _.kind = t2;
      _.device = t3;
      _.position = t4;
      _.delta = t5;
      _.buttons = t6;
      _.down = t7;
      _.obscured = t8;
      _.pressure = t9;
      _.pressureMin = t10;
      _.pressureMax = t11;
      _.distance = t12;
      _.distanceMax = t13;
      _.size = t14;
      _.radiusMajor = t15;
      _.radiusMinor = t16;
      _.radiusMin = t17;
      _.radiusMax = t18;
      _.orientation = t19;
      _.tilt = t20;
      _.platformData = t21;
      _.synthesized = t22;
    }, PointerMoveEvent: function PointerMoveEvent(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) {
      var _ = this;
      _.timeStamp = t0;
      _.pointer = t1;
      _.kind = t2;
      _.device = t3;
      _.position = t4;
      _.delta = t5;
      _.buttons = t6;
      _.down = t7;
      _.obscured = t8;
      _.pressure = t9;
      _.pressureMin = t10;
      _.pressureMax = t11;
      _.distance = t12;
      _.distanceMax = t13;
      _.size = t14;
      _.radiusMajor = t15;
      _.radiusMinor = t16;
      _.radiusMin = t17;
      _.radiusMax = t18;
      _.orientation = t19;
      _.tilt = t20;
      _.platformData = t21;
      _.synthesized = t22;
    }, PointerUpEvent: function PointerUpEvent(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) {
      var _ = this;
      _.timeStamp = t0;
      _.pointer = t1;
      _.kind = t2;
      _.device = t3;
      _.position = t4;
      _.delta = t5;
      _.buttons = t6;
      _.down = t7;
      _.obscured = t8;
      _.pressure = t9;
      _.pressureMin = t10;
      _.pressureMax = t11;
      _.distance = t12;
      _.distanceMax = t13;
      _.size = t14;
      _.radiusMajor = t15;
      _.radiusMinor = t16;
      _.radiusMin = t17;
      _.radiusMax = t18;
      _.orientation = t19;
      _.tilt = t20;
      _.platformData = t21;
      _.synthesized = t22;
    }, PointerSignalEvent: function PointerSignalEvent() {
    }, PointerScrollEvent: function PointerScrollEvent(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23) {
      var _ = this;
      _.scrollDelta = t0;
      _.timeStamp = t1;
      _.pointer = t2;
      _.kind = t3;
      _.device = t4;
      _.position = t5;
      _.delta = t6;
      _.buttons = t7;
      _.down = t8;
      _.obscured = t9;
      _.pressure = t10;
      _.pressureMin = t11;
      _.pressureMax = t12;
      _.distance = t13;
      _.distanceMax = t14;
      _.size = t15;
      _.radiusMajor = t16;
      _.radiusMinor = t17;
      _.radiusMin = t18;
      _.radiusMax = t19;
      _.orientation = t20;
      _.tilt = t21;
      _.platformData = t22;
      _.synthesized = t23;
    }, PointerCancelEvent: function PointerCancelEvent(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) {
      var _ = this;
      _.timeStamp = t0;
      _.pointer = t1;
      _.kind = t2;
      _.device = t3;
      _.position = t4;
      _.delta = t5;
      _.buttons = t6;
      _.down = t7;
      _.obscured = t8;
      _.pressure = t9;
      _.pressureMin = t10;
      _.pressureMax = t11;
      _.distance = t12;
      _.distanceMax = t13;
      _.size = t14;
      _.radiusMajor = t15;
      _.radiusMinor = t16;
      _.radiusMin = t17;
      _.radiusMax = t18;
      _.orientation = t19;
      _.tilt = t20;
      _.platformData = t21;
      _.synthesized = t22;
    },
    PlatformException$: function(code, details, message) {
      return new F.PlatformException(code, message, details);
    },
    MethodCall0: function MethodCall0(t0, t1) {
      this.method = t0;
      this.$arguments = t1;
    },
    PlatformException: function PlatformException(t0, t1, t2) {
      this.code = t0;
      this.message = t1;
      this.details = t2;
    },
    MissingPluginException: function MissingPluginException(t0) {
      this.message = t0;
    },
    MediaQuery_of: function(context, nullOk) {
      H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type_MediaQuery_nDB), "$isMediaQuery");
      return;
    },
    MediaQuery: function MediaQuery() {
    },
    compute: function(callback, message, debugLabel, $Q, $R) {
      return F.compute$body(H.functionTypeCheck(callback, {func: 1, ret: $R, args: [$Q]}), H.assertSubtypeOfRuntimeType(message, $Q), debugLabel, $Q, $R, $R);
    },
    compute$body: function(callback, message, debugLabel, $Q, $R, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue;
      var $async$compute = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = callback.call$1(message);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$compute, $async$completer);
    },
    main: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        t1, t2, t3, t4, t5, t6, t7, t8, t9, t10;
      var $async$main = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(Q.webOnlyInitializePlatform(), $async$main);
            case 2:
              // returning from await.
              if ($.WidgetsBinding__instance == null) {
                t1 = N.Element;
                t2 = P.HashSet_HashSet(t1);
                t1 = H.setRuntimeTypeInfo([], [t1]);
                t3 = O.FocusNode;
                t4 = [t3];
                t5 = {func: 1, ret: -1};
                t5 = new O.FocusScopeNode(H.setRuntimeTypeInfo([], t4), null, H.setRuntimeTypeInfo([], t4), new R.ObserverList(H.setRuntimeTypeInfo([], [t5]), [t5]));
                t3 = t5._manager = new O.FocusManager(t5, P.LinkedHashSet_LinkedHashSet$_empty(t3));
                t5 = $.$get$RawKeyboard_instance();
                t5.toString;
                t4 = H.functionTypeCheck(t3.get$_handleRawKeyEvent(), {func: 1, ret: -1, args: [B.RawKeyEvent]});
                C.JSArray_methods.add$1(t5._listeners, t4);
                t4 = H.setRuntimeTypeInfo([], [N.WidgetsBindingObserver]);
                t5 = [N._TaskEntry,,];
                t6 = new Array(7);
                t6.fixed$length = Array;
                t6 = H.setRuntimeTypeInfo(t6, [t5]);
                t7 = P.int;
                t8 = P.HashSet_HashSet(t7);
                t9 = [{func: 1, ret: -1, args: [P.Duration]}];
                t10 = H.setRuntimeTypeInfo([], t9);
                t9 = H.setRuntimeTypeInfo([], t9);
                if ($.Stopwatch__frequency == null) {
                  H.Primitives_initTicker();
                  $.Stopwatch__frequency = $.Primitives_timerFrequency;
                }
                new N.WidgetsFlutterBinding(new N.BuildOwner(new N._InactiveElements(t2), t1, t3), t4, true, 0, false, null, null, null, null, null, null, 25, null, N.binding__defaultSchedulingStrategy$closure(), new Y.HeapPriorityQueue(N.binding_SchedulerBinding__taskSorter$closure(), t6, [t5]), false, 0, P.LinkedHashMap_LinkedHashMap$_empty(t7, N._FrameCallbackEntry), t8, t10, t9, null, false, C.SchedulerPhase_0, true, false, null, C.Duration_0, C.Duration_0, null, 0, new P.Stopwatch(), null, false, P.ListQueue$(F.PointerEvent), new O.PointerRouter(P.LinkedHashMap_LinkedHashMap$_empty(t7, [P.LinkedHashSet, {func: 1, ret: -1, args: [F.PointerEvent]}]), P.LinkedHashSet_LinkedHashSet({func: 1, ret: -1, args: [F.PointerEvent]})), new D.GestureArenaManager(P.LinkedHashMap_LinkedHashMap$_empty(t7, D._GestureArena)), new G.PointerSignalResolver(), P.LinkedHashMap_LinkedHashMap$_empty(t7, O.HitTestResult)).BindingBase$0();
              }
              t1 = $.WidgetsBinding__instance;
              t2 = t1.RendererBinding__pipelineOwner._rootNode;
              t3 = S.RenderBox;
              t1.WidgetsBinding__renderViewElement = new N.RenderObjectToWidgetAdapter(new L.Text("Hello World", C.TextDirection_1, null), t2, "[root]", new N.GlobalObjectKey(t2, [[N.State, N.StatefulWidget]]), [t3]).attachToRenderTree$2(t1.WidgetsBinding__buildOwner, H.assertSubtype(t1.WidgetsBinding__renderViewElement, "$isRenderObjectToWidgetElement", [t3], "$asRenderObjectToWidgetElement"));
              t1.scheduleWarmUpFrame$0();
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$main, $async$completer);
    }
  },
  R = {ObserverList: function ObserverList(t0, t1) {
      var _ = this;
      _._list = t0;
      _._isDirty = false;
      _._set = null;
      _.$ti = t1;
    }},
  T = {
    defaultTargetPlatform: function() {
      return C.TargetPlatform_0;
    },
    TargetPlatform: function TargetPlatform(t0) {
      this._platform$_name = t0;
    },
    MatrixUtils_getAsTranslation: function(transform) {
      var values = transform._m4storage;
      if (values[0] === 1 && values[1] === 0 && values[2] === 0 && values[3] === 0 && values[4] === 0 && values[5] === 1 && values[6] === 0 && values[7] === 0 && values[8] === 0 && values[9] === 0 && values[10] === 1 && values[11] === 0 && values[14] === 0 && values[15] === 1)
        return new Q.Offset(values[12], values[13]);
      return;
    },
    MatrixUtils_getAsScale: function(transform) {
      var values = transform._m4storage;
      if (values[1] === 0 && values[2] === 0 && values[3] === 0 && values[4] === 0 && values[6] === 0 && values[7] === 0 && values[8] === 0 && values[9] === 0 && values[10] === 1 && values[11] === 0 && values[12] === 0 && values[13] === 0 && values[14] === 0 && values[15] === 1 && values[0] === values[5])
        return values[0];
      return;
    },
    MatrixUtils_matrixEquals: function(a, b) {
      var t1, t2, t3;
      if (a == b)
        return true;
      if (a == null)
        return T.MatrixUtils_isIdentity(b);
      if (b == null)
        return T.MatrixUtils_isIdentity(a);
      t1 = a._m4storage;
      t2 = t1[0];
      t3 = b._m4storage;
      return t2 === t3[0] && t1[1] === t3[1] && t1[2] === t3[2] && t1[3] === t3[3] && t1[4] === t3[4] && t1[5] === t3[5] && t1[6] === t3[6] && t1[7] === t3[7] && t1[8] === t3[8] && t1[9] === t3[9] && t1[10] === t3[10] && t1[11] === t3[11] && t1[12] === t3[12] && t1[13] === t3[13] && t1[14] === t3[14] && t1[15] === t3[15];
    },
    MatrixUtils_isIdentity: function(a) {
      var t1 = a._m4storage;
      return t1[0] === 1 && t1[1] === 0 && t1[2] === 0 && t1[3] === 0 && t1[4] === 0 && t1[5] === 1 && t1[6] === 0 && t1[7] === 0 && t1[8] === 0 && t1[9] === 0 && t1[10] === 1 && t1[11] === 0 && t1[12] === 0 && t1[13] === 0 && t1[14] === 0 && t1[15] === 1;
    },
    MatrixUtils_transformPoint: function(transform, point) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, w_,
        t1 = new Float64Array(3);
      new E.Vector3(t1).setValues$3(point._dx, point._dy, 0);
      t2 = transform._m4storage;
      t3 = t2[0];
      t4 = t1[0];
      t5 = t2[4];
      t6 = t1[1];
      t7 = t2[8];
      t8 = t1[2];
      t9 = t2[12];
      t10 = t2[1];
      t11 = t2[5];
      t12 = t2[9];
      t13 = t2[13];
      t14 = t2[2];
      t15 = t2[6];
      t16 = t2[10];
      t17 = t2[14];
      w_ = 1 / (t2[3] * t4 + t2[7] * t6 + t2[11] * t8 + t2[15]);
      t1[0] = (t3 * t4 + t5 * t6 + t7 * t8 + t9) * w_;
      t1[1] = (t10 * t4 + t11 * t6 + t12 * t8 + t13) * w_;
      t1[2] = (t14 * t4 + t15 * t6 + t16 * t8 + t17) * w_;
      return new Q.Offset(t1[0], t1[1]);
    },
    MatrixUtils_transformRect: function(transform, rect) {
      var point3, point4, t4, t5, t6,
        t1 = rect.left,
        t2 = rect.top,
        point1 = T.MatrixUtils_transformPoint(transform, new Q.Offset(t1, t2)),
        t3 = rect.right,
        point2 = T.MatrixUtils_transformPoint(transform, new Q.Offset(t3, t2));
      t2 = rect.bottom;
      point3 = T.MatrixUtils_transformPoint(transform, new Q.Offset(t1, t2));
      point4 = T.MatrixUtils_transformPoint(transform, new Q.Offset(t3, t2));
      t2 = point1._dx;
      t3 = point2._dx;
      t1 = point3._dx;
      t4 = point4._dx;
      t5 = Math.min(H.checkNum(t1), H.checkNum(t4));
      t5 = Math.min(H.checkNum(t3), t5);
      t5 = Math.min(H.checkNum(t2), t5);
      point1 = point1._dy;
      point2 = point2._dy;
      point3 = point3._dy;
      point4 = point4._dy;
      t6 = Math.min(H.checkNum(point3), H.checkNum(point4));
      t6 = Math.min(H.checkNum(point2), t6);
      t6 = Math.min(H.checkNum(point1), t6);
      t4 = Math.max(H.checkNum(t1), H.checkNum(t4));
      t4 = Math.max(H.checkNum(t3), t4);
      t4 = Math.max(H.checkNum(t2), t4);
      point4 = Math.max(H.checkNum(point3), H.checkNum(point4));
      point4 = Math.max(H.checkNum(point2), point4);
      return new Q.Rect(t5, t6, t4, Math.max(H.checkNum(point1), point4));
    },
    MatrixUtils_inverseTransformRect: function(transform, rect) {
      var transform0;
      if (T.MatrixUtils_isIdentity(transform))
        return rect;
      transform0 = new E.Matrix4(new Float64Array(16));
      transform0.setFrom$1(transform);
      transform0.copyInverse$1(transform0);
      return T.MatrixUtils_transformRect(transform0, rect);
    },
    debugDescribeTransform: function(transform) {
      if (transform == null)
        return C.List_null;
      return H.setRuntimeTypeInfo([T._transformRowToString(transform, 0), T._transformRowToString(transform, 1), T._transformRowToString(transform, 2), T._transformRowToString(transform, 3)], [P.String]);
    },
    _transformRowToString: function(transform, rowIndex) {
      var t1 = transform.getRow$1(rowIndex)._v4storage;
      return "[" + rowIndex + "] " + Y.debugPrintDouble(t1[0]) + "," + Y.debugPrintDouble(t1[1]) + "," + Y.debugPrintDouble(t1[2]) + "," + Y.debugPrintDouble(t1[3]);
    },
    TransformProperty: function TransformProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) {
      var _ = this;
      _._description = t0;
      _.expandableValue = t1;
      _.allowWrap = t2;
      _.ifNull = t3;
      _.ifEmpty = t4;
      _.tooltip = t5;
      _.missingIfNull = t6;
      _._value = t7;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t8;
      _._defaultLevel = t9;
      _.name = t10;
      _.showSeparator = t11;
      _.showName = t12;
      _.linePrefix = t13;
      _.style = t14;
    },
    TransformProperty_valueToString_closure: function TransformProperty_valueToString_closure() {
    },
    TransformProperty_valueToString__closure: function TransformProperty_valueToString__closure() {
    },
    Layer: function Layer() {
    },
    PictureLayer: function PictureLayer(t0) {
      var _ = this;
      _.canvasBounds = t0;
      _._picture = null;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    ContainerLayer: function ContainerLayer() {
    },
    OffsetLayer: function OffsetLayer(t0) {
      var _ = this;
      _._layer$_offset = t0;
      _._lastChild = _._firstChild = null;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    TransformLayer: function TransformLayer(t0, t1) {
      var _ = this;
      _._layer$_transform = t0;
      _._invertedTransform = _._lastEffectiveTransform = null;
      _._inverseDirty = true;
      _._layer$_offset = t1;
      _._lastChild = _._firstChild = null;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _Layer_AbstractNode_DiagnosticableTreeMixin: function _Layer_AbstractNode_DiagnosticableTreeMixin() {
    },
    RichText: function RichText(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.text = t0;
      _.textAlign = t1;
      _.textDirection = t2;
      _.softWrap = t3;
      _.overflow = t4;
      _.textScaleFactor = t5;
      _.maxLines = t6;
      _.locale = t7;
      _.key = t8;
    },
    registerHotRestartListener: function(listener) {
      C.JSArray_methods.add$1($._hotRestartListeners, H.functionTypeCheck(listener, {func: 1, ret: -1}));
    },
    webOnlyInitializeEngine: function() {
      var t1 = {};
      if ($._engineInitialized)
        return;
      P.registerExtension("ext.flutter.disassemble", new T.webOnlyInitializeEngine_closure());
      $._engineInitialized = true;
      $.$get$domRenderer();
      t1.waitingForAnimation = false;
      $.webOnlyScheduleFrameCallback = new T.webOnlyInitializeEngine_closure0(t1);
      if ($.Keyboard__instance == null)
        $.Keyboard__instance = T.Keyboard$_();
    },
    _stringForBlendMode: function(blendMode) {
      if (blendMode == null)
        return;
      switch (blendMode) {
        case C.BlendMode_3:
          return "source-over";
        case C.BlendMode_5:
          return "source-in";
        case C.BlendMode_7:
          return "source-out";
        case C.BlendMode_9:
          return "source-atop";
        case C.BlendMode_4:
          return "destination-over";
        case C.BlendMode_6:
          return "destination-in";
        case C.BlendMode_8:
          return "destination-out";
        case C.BlendMode_10:
          return "destination-atop";
        case C.BlendMode_12:
          return "lighten";
        case C.BlendMode_1:
          return "copy";
        case C.BlendMode_11:
          return "xor";
        case C.BlendMode_24:
        case C.BlendMode_13:
          return "multiply";
        case C.BlendMode_14:
          return "screen";
        case C.BlendMode_15:
          return "overlay";
        case C.BlendMode_16:
          return "darken";
        case C.BlendMode_17:
          return "lighten";
        case C.BlendMode_18:
          return "color-dodge";
        case C.BlendMode_19:
          return "color-burn";
        case C.BlendMode_20:
          return "hard-light";
        case C.BlendMode_21:
          return "soft-light";
        case C.BlendMode_22:
          return "difference";
        case C.BlendMode_23:
          return "exclusion";
        case C.BlendMode_25:
          return "hue";
        case C.BlendMode_26:
          return "saturation";
        case C.BlendMode_27:
          return "color";
        case C.BlendMode_28:
          return "luminosity";
        default:
          throw H.wrapException(P.UnimplementedError$("Flutter Web does not support the blend mode: " + blendMode.toString$0(0)));
      }
    },
    _clipContent: function(clipStack, $content, offset, currentTransform) {
      var t1, clipDefs, len, root, curElement, clipIndex, entry, t2, newElement, rect, newClipTransform, clipOffsetX, clipOffsetY, t3, newClipTransform0, t4, value, reverseTransformDiv,
        _s9_ = "transform",
        _s16_ = "transform-origin";
      H.assertSubtype(clipStack, "$isList", [T._SaveClipEntry], "$asList");
      t1 = [W.Element0];
      clipDefs = H.setRuntimeTypeInfo([], t1);
      len = clipStack.length;
      for (root = null, curElement = null, clipIndex = 0; clipIndex < len; ++clipIndex, curElement = reverseTransformDiv) {
        if (clipIndex >= clipStack.length)
          return H.ioore(clipStack, clipIndex);
        entry = clipStack[clipIndex];
        t2 = document;
        newElement = t2.createElement("div");
        if (root == null)
          root = newElement;
        else {
          $.$get$domRenderer().toString;
          curElement.appendChild(newElement);
        }
        rect = entry.rect;
        newClipTransform = entry.currentTransform;
        clipOffsetX = rect.left;
        clipOffsetY = rect.top;
        t3 = new Float64Array(16);
        newClipTransform0 = new T.Matrix40(t3);
        newClipTransform0.setFrom$1(newClipTransform);
        newClipTransform0.translate$2(0, clipOffsetX, clipOffsetY);
        t4 = newElement.style;
        t4.overflow = "hidden";
        value = T.float64ListToCssTransform(t3);
        t3 = (t4 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t4, _s9_);
        t4.setProperty(t3, value, "");
        t3 = C.CssStyleDeclaration_methods._browserPropertyName$1(t4, _s16_);
        t4.setProperty(t3, "0 0 0", "");
        if (typeof clipOffsetX !== "number")
          return H.iae(clipOffsetX);
        t3 = H.S(rect.right - clipOffsetX) + "px";
        t4.width = t3;
        if (typeof clipOffsetY !== "number")
          return H.iae(clipOffsetY);
        t3 = H.S(rect.bottom - clipOffsetY) + "px";
        t4.height = t3;
        newClipTransform = newClipTransform0;
        reverseTransformDiv = t2.createElement("div");
        t2 = reverseTransformDiv.style;
        t3 = new T.Matrix40(new Float64Array(16));
        t3.setFrom$1(newClipTransform);
        t3.copyInverse$1(t3);
        value = T.float64ListToCssTransform(T.transformWithOffset(t3, new Q.Offset(0, 0))._engine$_m4storage);
        t3 = (t2 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t2, _s9_);
        t2.setProperty(t3, value, "");
        t3 = C.CssStyleDeclaration_methods._browserPropertyName$1(t2, _s16_);
        t2.setProperty(t3, "0 0 0", "");
        newElement.appendChild(reverseTransformDiv);
      }
      t2 = root.style;
      t2.position = "absolute";
      $.$get$domRenderer().toString;
      curElement.appendChild($content);
      t2 = $content.style;
      t3 = T.float64ListToCssTransform(T.transformWithOffset(currentTransform, new Q.Offset(offset._dx, offset._dy))._engine$_m4storage);
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t2, (t2 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t2, _s9_), t3, "");
      t1 = H.setRuntimeTypeInfo([root], t1);
      C.JSArray_methods.addAll$1(t1, clipDefs);
      return t1;
    },
    _detectBrowserEngine: function() {
      var vendor = window.navigator.vendor;
      if (vendor === "Google Inc.")
        return C.BrowserEngine_0;
      else if (vendor === "Apple Computer, Inc.")
        return C.BrowserEngine_1;
      P.print("WARNING: failed to detect current browser engine.");
      return C.BrowserEngine_2;
    },
    ensureLeading: function(str, leading) {
      return C.JSString_methods.startsWith$1(str, leading) ? str : leading + str;
    },
    transformWithOffset: function(transform, offset) {
      var effectiveTransform;
      if (offset.$eq(0, C.Offset_0_0))
        return transform;
      effectiveTransform = new T.Matrix40(new Float64Array(16));
      effectiveTransform.setFrom$1(transform);
      effectiveTransform.translate$3(0, offset._dx, offset._dy, 0);
      return effectiveTransform;
    },
    _drawParagraphElement: function(paragraph, offset, transform) {
      var t1,
        paragraphElement = H.interceptedTypeCheck(paragraph._paragraphElement.cloneNode(true), "$isElement0"),
        paragraphStyle = paragraphElement.style;
      paragraphStyle.position = "absolute";
      paragraphStyle.whiteSpace = "pre-wrap";
      C.CssStyleDeclaration_methods._setPropertyHelper$3(paragraphStyle, (paragraphStyle && C.CssStyleDeclaration_methods)._browserPropertyName$1(paragraphStyle, "overflow-wrap"), "break-word", "");
      paragraphStyle.overflow = "hidden";
      t1 = H.S(paragraph.get$height(paragraph)) + "px";
      paragraphStyle.height = t1;
      t1 = H.S(paragraph.get$width(paragraph)) + "px";
      paragraphStyle.width = t1;
      if (transform != null) {
        C.CssStyleDeclaration_methods._setPropertyHelper$3(paragraphStyle, C.CssStyleDeclaration_methods._browserPropertyName$1(paragraphStyle, "transform-origin"), "0 0 0", "");
        t1 = T.float64ListToCssTransform(T.transformWithOffset(transform, offset)._engine$_m4storage);
        C.CssStyleDeclaration_methods._setPropertyHelper$3(paragraphStyle, C.CssStyleDeclaration_methods._browserPropertyName$1(paragraphStyle, "transform"), t1, "");
      }
      if (paragraph._paragraphGeometricStyle.ellipsis != null)
        t1 = true;
      else
        t1 = false;
      if (t1) {
        paragraphStyle.whiteSpace = "pre";
        C.CssStyleDeclaration_methods._setPropertyHelper$3(paragraphStyle, C.CssStyleDeclaration_methods._browserPropertyName$1(paragraphStyle, "text-overflow"), "ellipsis", "");
      }
      return paragraphElement;
    },
    _isFlutterEntry: function(state) {
      var t1 = J.getInterceptor$(state);
      return !!t1.$isMap && J.$eq$(t1.$index(state, "flutter"), true);
    },
    Keyboard$_: function() {
      var t1 = new T.Keyboard();
      t1.Keyboard$_$0();
      return t1;
    },
    _noopCallback: function(data) {
      H.interceptedTypeCheck(data, "$isByteData");
    },
    handlePlatformViewCall: function(data, callback) {
      var decoded, args, t1, id, viewType, t2, element;
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.ByteData]});
      decoded = C.C_StandardMethodCodec.decodeMethodCall$1(data);
      switch (decoded.method) {
        case "create":
          args = H.interceptedTypeCheck(decoded.$arguments, "$isMap");
          t1 = J.getInterceptor$asx(args);
          id = H.intTypeCheck(t1.$index(args, "id"));
          viewType = H.stringTypeCheck(t1.$index(args, "viewType"));
          t1 = $.$get$platformViewRegistry();
          t2 = t1._registeredFactories;
          if (!t2.containsKey$1(0, viewType))
            callback.call$1(null);
          element = t2.$index(0, viewType).call$1(id);
          t1._createdViews.$indexSet(0, id, element);
          return;
      }
      callback.call$1(null);
    },
    _pointerButtonFromHtmlEvent: function($event) {
      var t1 = J.getInterceptor$($event);
      if (!!t1.$isPointerEvent0)
        return $event.button === 2 ? 2 : 1;
      else if (!!t1.$isMouseEvent)
        return $event.button === 2 ? 2 : 1;
      return 1;
    },
    _eventTimeStampToDuration: function(milliseconds) {
      var ms = J.toInt$0$n(milliseconds);
      return P.Duration$(C.JSNumber_methods.toInt$0((milliseconds - ms) * 1000), ms, 0);
    },
    _convertWheelEventToPointerData: function($event) {
      var t1, t2, data, t3,
        deltaX = ($event && C.WheelEvent_methods).get$deltaX($event),
        deltaY = C.WheelEvent_methods.get$deltaY($event);
      switch (C.WheelEvent_methods.get$deltaMode($event)) {
        case 1:
          if (typeof deltaX !== "number")
            return deltaX.$mul();
          deltaX *= 32;
          if (typeof deltaY !== "number")
            return deltaY.$mul();
          deltaY *= 32;
          break;
        case 2:
          t1 = $.$get$window();
          t2 = t1.get$physicalSize()._dx;
          if (typeof deltaX !== "number")
            return deltaX.$mul();
          if (typeof t2 !== "number")
            return H.iae(t2);
          deltaX *= t2;
          t1 = t1.get$physicalSize()._dy;
          if (typeof deltaY !== "number")
            return deltaY.$mul();
          if (typeof t1 !== "number")
            return H.iae(t1);
          deltaY *= t1;
          break;
        case 0:
        default:
          break;
      }
      data = H.setRuntimeTypeInfo([], [Q.PointerData]);
      if (!$._isWheelDeviceAdded) {
        $._isWheelDeviceAdded = true;
        t1 = T._eventTimeStampToDuration($event.timeStamp);
        t2 = $event.clientX;
        t3 = $event.clientY;
        C.JSArray_methods.add$1(data, Q.PointerData$($event.buttons, C.PointerChange_1, -1, C.PointerDeviceKind_1, t2, t3, 1, 1, 0, deltaX, deltaY, C.PointerSignalKind_0, 0, t1));
      }
      t1 = T._eventTimeStampToDuration($event.timeStamp);
      t2 = $event.clientX;
      t3 = $event.clientY;
      C.JSArray_methods.add$1(data, Q.PointerData$($event.buttons, C.PointerChange_3, -1, C.PointerDeviceKind_1, t2, t3, 1, 1, 0, deltaX, deltaY, C.PointerSignalKind_1, 0, t1));
      return data;
    },
    _addWheelEventListener: function(listener) {
      var eventOptions, t2,
        t1 = {func: 1, ret: -1, args: [W.WheelEvent]};
      H.functionTypeCheck(listener, t1);
      eventOptions = {};
      eventOptions.passive = false;
      t2 = $.PointerBinding__instance.domRenderer._glassPaneElement;
      t2.addEventListener.apply(t2, ["wheel", P.allowInterop(new T._addWheelEventListener_closure(listener), t1), eventOptions]);
    },
    AccessibilityAnnouncements$_: function() {
      var t1 = new T.AccessibilityAnnouncements();
      t1.AccessibilityAnnouncements$_$0();
      return t1;
    },
    Incrementable$: function(semanticsObject) {
      var t1 = new T.Incrementable(W.InputElement_InputElement(), semanticsObject);
      t1.Incrementable$1(semanticsObject);
      return t1;
    },
    SemanticsObject$: function(id, owner) {
      var t1 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("flt-semantics", null), "$isElement0"),
        t2 = t1.style;
      t2.position = "absolute";
      if (id === 0) {
        t2 = t1.style;
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t2, (t2 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t2, "filter"), "opacity(0%)", "");
        t2 = t1.style;
        t2.color = "rgba(0,0,0,0)";
      }
      return new T.SemanticsObject(id, owner, t1, P.LinkedHashMap_LinkedHashMap$_empty(T.Role, T.RoleManager));
    },
    EngineSemanticsOwner$_: function() {
      var t1 = P.int,
        t2 = T.SemanticsObject;
      t2 = new T.EngineSemanticsOwner(P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), H.setRuntimeTypeInfo([], [t2]), H.setRuntimeTypeInfo([], [{func: 1, ret: -1}]), new T.EngineSemanticsOwner_closure(), C.GestureMode_1, H.setRuntimeTypeInfo([], [{func: 1, ret: -1, args: [T.GestureMode]}]));
      t2.EngineSemanticsOwner$_$0();
      return t2;
    },
    EngineSemanticsOwner_instance: function() {
      var t1 = $.EngineSemanticsOwner__instance;
      return t1 == null ? $.EngineSemanticsOwner__instance = T.EngineSemanticsOwner$_() : t1;
    },
    longestIncreasingSubsequence: function(list) {
      var len, predecessors, mins, longest, i, elem, t3, hi, lo, mid, t4, seq, k,
        t1 = P.int,
        t2 = [t1];
      H.assertSubtype(list, "$isList", t2, "$asList");
      len = list.length;
      predecessors = H.setRuntimeTypeInfo([], t2);
      mins = H.setRuntimeTypeInfo([0], t2);
      for (longest = 0, i = 0; i < len; ++i) {
        t2 = list.length;
        if (i >= t2)
          return H.ioore(list, i);
        elem = list[i];
        for (t3 = mins.length, hi = longest, lo = 1; lo <= hi;) {
          mid = C.JSInt_methods._tdivFast$1(lo + hi, 2);
          if (mid < 0 || mid >= t3)
            return H.ioore(mins, mid);
          t4 = mins[mid];
          if (t4 >= t2)
            return H.ioore(list, t4);
          if (list[t4] < elem)
            lo = mid + 1;
          else
            hi = mid - 1;
        }
        t2 = lo - 1;
        if (t2 < 0 || t2 >= t3)
          return H.ioore(mins, t2);
        C.JSArray_methods.add$1(predecessors, mins[t2]);
        if (lo >= mins.length)
          C.JSArray_methods.add$1(mins, i);
        else
          C.JSArray_methods.$indexSet(mins, lo, i);
        if (lo > longest)
          longest = lo;
      }
      t2 = new Array(longest);
      t2.fixed$length = Array;
      seq = H.setRuntimeTypeInfo(t2, [t1]);
      if (longest < 0 || longest >= mins.length)
        return H.ioore(mins, longest);
      k = mins[longest];
      for (i = longest - 1; i >= 0; --i) {
        C.JSArray_methods.$indexSet(seq, i, k);
        if (k < 0 || k >= predecessors.length)
          return H.ioore(predecessors, k);
        k = predecessors[k];
      }
      return seq;
    },
    _recycleCanvas: function(canvas) {
      var removedCanvas, t1;
      if (canvas instanceof T.BitmapCanvas && canvas._devicePixelRatio == window.devicePixelRatio) {
        C.JSArray_methods.add$1($._recycledCanvases, canvas);
        if ($._recycledCanvases.length > 30) {
          removedCanvas = C.JSArray_methods.removeAt$1($._recycledCanvases, 0);
          removedCanvas.super$EngineCanvas$dispose();
          t1 = $._browserEngine;
          if ((t1 == null ? $._browserEngine = T._detectBrowserEngine() : t1) === C.BrowserEngine_1) {
            t1 = removedCanvas._engine$_canvas;
            t1.width = t1.height = 0;
          }
        }
      }
    },
    standardPictureFactory: function(dx, dy, picture, hints) {
      var t1 = new T.FrameReference(false, [P.bool]);
      C.JSArray_methods.add$1($._frameReferences, t1);
      return new T.PersistedStandardPicture(t1, dx, dy, picture, picture.get$recordingCanvas()._paintBounds.computeBounds$0(), C.PersistedSurfaceState_0);
    },
    PersistedStandardPicture__doesCanvasFitBounds: function(canvas, newBounds) {
      var t3, t4,
        canvasBounds = canvas._bounds,
        t1 = canvasBounds.right,
        t2 = canvasBounds.left;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = newBounds.right;
      t4 = newBounds.left;
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (t1 - t2 >= t3 - t4) {
        t1 = canvasBounds.bottom;
        t2 = canvasBounds.top;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = newBounds.bottom;
        t4 = newBounds.top;
        if (typeof t4 !== "number")
          return H.iae(t4);
        t4 = t1 - t2 >= t3 - t4;
        t1 = t4;
      } else
        t1 = false;
      return t1;
    },
    commitScene: function(scene) {
      var _i, i,
        t1 = $._paintQueue,
        t2 = t1.length;
      if (t2 !== 0) {
        if (t2 > 1)
          C.JSArray_methods.sort$1(t1, new T.commitScene_closure());
        for (t1 = $._paintQueue, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          t1[_i].paintCallback.call$0();
        $._paintQueue = H.setRuntimeTypeInfo([], [T._PaintRequest]);
      }
      t1 = $._retainedSurfaces;
      t2 = t1.length;
      if (t2 !== 0) {
        for (i = 0; i < t2; ++i)
          t1[i]._engine$_state = C.PersistedSurfaceState_1;
        $._retainedSurfaces = H.setRuntimeTypeInfo([], [T.PersistedSurface]);
      }
      for (i = 0; t1 = $._frameReferences, i < t1.length; ++i)
        t1[i].set$value(0, null);
      $._frameReferences = H.setRuntimeTypeInfo([], [[T.FrameReference,,]]);
    },
    PersistedContainerSurface__discardActiveChildren: function(surface) {
      var i, child,
        t1 = surface._engine$_children,
        $length = t1.length;
      for (i = 0; i < $length; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        child = t1[i];
        if (child._engine$_state === C.PersistedSurfaceState_1)
          child.discard$0();
      }
    },
    _FontManager__FontManager: function() {
      var t1 = [[P.Future, -1]];
      if ($.$get$supportsFontLoadingApi())
        return new T._FontManager(H.setRuntimeTypeInfo([], t1));
      else
        return new T._PolyfillFontManager(H.setRuntimeTypeInfo([], t1));
    },
    nextLineBreak: function(text, index) {
      var index0, t1, curr, prev, t2;
      for (; index0 = index + 1, t1 = text.length, index < t1; index = index0) {
        curr = index0 < t1 ? C.JSString_methods.codeUnitAt$1(text, index0) : null;
        prev = index0 > 0 ? C.JSString_methods.codeUnitAt$1(text, index0 - 1) : null;
        if (prev === 11 || prev === 12)
          return new T.LineBreakResult(index0, C.LineBreakType_1);
        t2 = prev === 13;
        if (t2 && curr === 10)
          continue;
        if (t2 || prev === 10 || prev === 133)
          return new T.LineBreakResult(index0, C.LineBreakType_1);
        if (curr === 11 || curr === 12 || curr === 13 || curr === 10 || curr === 133)
          continue;
        if (index0 >= t1)
          return new T.LineBreakResult(t1, C.LineBreakType_2);
        if (curr === 32 || curr === 9)
          continue;
        if (prev === 32 || prev === 9 || prev === 45)
          return new T.LineBreakResult(index0, C.LineBreakType_0);
      }
      return new T.LineBreakResult(t1, C.LineBreakType_2);
    },
    _whitespacePredicate: function(char) {
      return char === 32 || char === 9 || T._newlinePredicate(char);
    },
    _newlinePredicate: function(char) {
      return char === 13 || char === 10 || char === 133;
    },
    TextMeasurementService_forParagraph: function(paragraph) {
      var t1 = $.DomTextMeasurementService__instance;
      return t1 == null ? $.DomTextMeasurementService__instance = new T.DomTextMeasurementService() : t1;
    },
    DomTextMeasurementService__applySubPixelRoundingHack: function(minIntrinsicWidth, maxIntrinsicWidth) {
      if (minIntrinsicWidth <= maxIntrinsicWidth)
        return maxIntrinsicWidth;
      if (minIntrinsicWidth - maxIntrinsicWidth < 2)
        return minIntrinsicWidth;
      throw H.wrapException(P.Exception_Exception("minIntrinsicWidth (" + H.S(minIntrinsicWidth) + ") is greater than maxIntrinsicWidth (" + H.S(maxIntrinsicWidth) + ")."));
    },
    _measureSubstring: function(_canvasContext, text, start, end) {
      var width;
      if (start === end)
        return 0;
      if (start === $._lastStart && end === $._lastEnd && text == $._lastText)
        return $._lastWidth;
      $._lastStart = start;
      $._lastEnd = end;
      $._lastText = text;
      width = _canvasContext.measureText(J.substring$2$s(text, start, end)).width;
      if (typeof width !== "number")
        return width.$mul();
      return $._lastWidth = C.JSNumber_methods.round$0(width * 100) / 100;
    },
    _excludeTrailing: function(text, start, end, predicate) {
      var t1;
      H.functionTypeCheck(predicate, {func: 1, ret: P.bool, args: [P.int]});
      t1 = J.getInterceptor$s(text);
      while (true) {
        if (!(start < end && H.boolConversionCheck(predicate.call$1(t1.codeUnitAt$1(text, end - 1)))))
          break;
        --end;
      }
      return end;
    },
    ParagraphGeometricStyle$: function(decoration, ellipsis, fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, maxLines, wordSpacing) {
      return new T.ParagraphGeometricStyle(fontWeight, fontStyle, fontFamily, fontSize, lineHeight, maxLines, letterSpacing, wordSpacing, decoration, ellipsis);
    },
    MeasurementResult$: function(constraintWidth, alphabeticBaseline, height, ideographicBaseline, isSingleLine, lines, maxIntrinsicWidth, minIntrinsicWidth, naturalHeight, width) {
      return new T.MeasurementResult(constraintWidth, isSingleLine, width, height, naturalHeight, minIntrinsicWidth, maxIntrinsicWidth, alphabeticBaseline, ideographicBaseline);
    },
    _emptyCallback: function(_) {
    },
    _styleEditingElement: function(domElement) {
      var t1 = domElement.style;
      t1.position = "fixed";
      t1.whiteSpace = "pre";
      t1 = domElement.style;
      t1.overflow = "hidden";
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "transform"), "translate(-99999px, -99999px)", "");
      t1.width = "1px";
      t1.height = "1px";
      t1 = $._browserEngine;
      if ((t1 == null ? $._browserEngine = T._detectBrowserEngine() : t1) === C.BrowserEngine_1)
        C.Window_methods.get$animationFrame(window).then$1$1(new T._styleEditingElement_closure(domElement), null);
    },
    _getInputTypeFromString: function(inputType) {
      switch (inputType) {
        case "TextInputType.multiline":
          return C.InputType_1;
        case "TextInputType.text":
        default:
          return C.InputType_0;
      }
    },
    _getTypeFromElement: function(domElement) {
      var contentEditable,
        t1 = J.getInterceptor$(domElement);
      if (!!t1.$isInputElement)
        return C.ElementType_0;
      if (!!t1.$isTextAreaElement)
        return C.ElementType_1;
      contentEditable = domElement.contentEditable;
      if (contentEditable != null && contentEditable.length !== 0 && contentEditable !== "inherit")
        return C.ElementType_2;
      return;
    },
    TextEditingElement$: function() {
      return new T.TextEditingElement(H.setRuntimeTypeInfo([], [[P.StreamSubscription, W.Event]]));
    },
    float64ListToCssTransform: function(matrix) {
      var tx, ty,
        t1 = matrix[0];
      if (t1 === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 0 && matrix[4] === 0 && matrix[5] === 1 && matrix[6] === 0 && matrix[7] === 0 && matrix[8] === 0 && matrix[9] === 0 && matrix[10] === 1 && matrix[11] === 0 && matrix[14] === 0 && matrix[15] === 1) {
        tx = matrix[12];
        ty = matrix[13];
        return "translate(" + H.S(tx) + "px, " + H.S(ty) + "px)";
      } else
        return "matrix3d(" + H.S(t1) + "," + H.S(matrix[1]) + "," + H.S(matrix[2]) + "," + H.S(matrix[3]) + "," + H.S(matrix[4]) + "," + H.S(matrix[5]) + "," + H.S(matrix[6]) + "," + H.S(matrix[7]) + "," + H.S(matrix[8]) + "," + H.S(matrix[9]) + "," + H.S(matrix[10]) + "," + H.S(matrix[11]) + "," + H.S(matrix[12]) + "," + H.S(matrix[13]) + "," + H.S(matrix[14]) + "," + H.S(matrix[15]) + ")";
    },
    localClipRectToGlobalClip: function(localClip, transform) {
      return T.localClipToGlobalClip(localClip.bottom, localClip.left, localClip.right, localClip.top, transform);
    },
    localClipToGlobalClip: function(localBottom, localLeft, localRight, localTop, transform) {
      var t1, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33, argStorage, t2, t3, t4, t5, t6, t7, t8, t9, t10,
        pointData = new Float64Array(16);
      C.NativeFloat64List_methods.$indexSet(pointData, 0, localLeft);
      C.NativeFloat64List_methods.$indexSet(pointData, 4, localTop);
      t1 = pointData.length;
      if (12 >= t1)
        return H.ioore(pointData, 12);
      pointData[12] = 1;
      pointData[1] = localRight;
      C.NativeFloat64List_methods.$indexSet(pointData, 5, localTop);
      if (13 >= t1)
        return H.ioore(pointData, 13);
      pointData[13] = 1;
      C.NativeFloat64List_methods.$indexSet(pointData, 2, localLeft);
      pointData[6] = localBottom;
      if (14 >= t1)
        return H.ioore(pointData, 14);
      pointData[14] = 1;
      pointData[3] = localRight;
      pointData[7] = localBottom;
      if (15 >= t1)
        return H.ioore(pointData, 15);
      pointData[15] = 1;
      m00 = pointData[0];
      m01 = pointData[4];
      m02 = pointData[8];
      m03 = pointData[12];
      m10 = pointData[1];
      m11 = pointData[5];
      m12 = pointData[9];
      m13 = pointData[13];
      m20 = pointData[2];
      m21 = pointData[6];
      m22 = pointData[10];
      m23 = pointData[14];
      m30 = pointData[3];
      m31 = pointData[7];
      m32 = pointData[11];
      m33 = pointData[15];
      argStorage = transform._engine$_m4storage;
      pointData[0] = m00 * argStorage[0] + m01 * argStorage[4] + m02 * argStorage[8] + m03 * argStorage[12];
      pointData[4] = m00 * argStorage[1] + m01 * argStorage[5] + m02 * argStorage[9] + m03 * argStorage[13];
      pointData[8] = m00 * argStorage[2] + m01 * argStorage[6] + m02 * argStorage[10] + m03 * argStorage[14];
      pointData[12] = m00 * argStorage[3] + m01 * argStorage[7] + m02 * argStorage[11] + m03 * argStorage[15];
      pointData[1] = m10 * argStorage[0] + m11 * argStorage[4] + m12 * argStorage[8] + m13 * argStorage[12];
      pointData[5] = m10 * argStorage[1] + m11 * argStorage[5] + m12 * argStorage[9] + m13 * argStorage[13];
      pointData[9] = m10 * argStorage[2] + m11 * argStorage[6] + m12 * argStorage[10] + m13 * argStorage[14];
      pointData[13] = m10 * argStorage[3] + m11 * argStorage[7] + m12 * argStorage[11] + m13 * argStorage[15];
      pointData[2] = m20 * argStorage[0] + m21 * argStorage[4] + m22 * argStorage[8] + m23 * argStorage[12];
      pointData[6] = m20 * argStorage[1] + m21 * argStorage[5] + m22 * argStorage[9] + m23 * argStorage[13];
      pointData[10] = m20 * argStorage[2] + m21 * argStorage[6] + m22 * argStorage[10] + m23 * argStorage[14];
      pointData[14] = m20 * argStorage[3] + m21 * argStorage[7] + m22 * argStorage[11] + m23 * argStorage[15];
      pointData[3] = m30 * argStorage[0] + m31 * argStorage[4] + m32 * argStorage[8] + m33 * argStorage[12];
      pointData[7] = m30 * argStorage[1] + m31 * argStorage[5] + m32 * argStorage[9] + m33 * argStorage[13];
      pointData[11] = m30 * argStorage[2] + m31 * argStorage[6] + m32 * argStorage[10] + m33 * argStorage[14];
      pointData[15] = m30 * argStorage[3] + m31 * argStorage[7] + m32 * argStorage[11] + m33 * argStorage[15];
      t1 = pointData[0];
      t2 = pointData[1];
      t3 = Math.min(t1, t2);
      t4 = pointData[2];
      t3 = Math.min(t3, t4);
      t5 = pointData[3];
      t3 = Math.min(t3, t5);
      t6 = pointData[4];
      t7 = pointData[5];
      t8 = Math.min(t6, t7);
      t9 = pointData[6];
      t8 = Math.min(t8, t9);
      t10 = pointData[7];
      return new Q.Rect(t3, Math.min(t8, t10), Math.max(Math.max(Math.max(t1, t2), t4), t5), Math.max(Math.max(Math.max(t6, t7), t9), t10));
    },
    Matrix4_Matrix4$translationValues: function(x, y, z) {
      var t1 = new T.Matrix40(new Float64Array(16));
      t1.setIdentity$0();
      t1.setTranslationRaw$3(x, y, z);
      return t1;
    },
    webOnlyInitializeEngine_closure: function webOnlyInitializeEngine_closure() {
    },
    webOnlyInitializeEngine_closure0: function webOnlyInitializeEngine_closure0(t0) {
      this._box_0 = t0;
    },
    webOnlyInitializeEngine__closure: function webOnlyInitializeEngine__closure(t0) {
      this._box_0 = t0;
    },
    AlarmClock: function AlarmClock(t0) {
      var _ = this;
      _._timestampFunction = t0;
      _.callback = _._datetime = _._timer = null;
    },
    AssetManager: function AssetManager() {
    },
    AssetManagerException: function AssetManagerException(t0, t1) {
      this.url = t0;
      this.httpStatus = t1;
    },
    BitmapCanvas: function BitmapCanvas(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._bounds = t0;
      _.rootElement = t1;
      _._cachedLastStyle = _._ctx = _._engine$_canvas = null;
      _._engine$_children = t2;
      _._heightInBitmapPixels = _._widthInBitmapPixels = null;
      _._saveCount = 0;
      _._devicePixelRatio = t3;
      _._prevFilter = "none";
      _._prevStrokeStyle = _._prevFillStyle = null;
      _.SaveStackTracking__saveStack = t4;
      _.SaveStackTracking__clipStack = t5;
      _.SaveStackTracking__currentTransform = t6;
    },
    BrowserEngine: function BrowserEngine(t0) {
      this._engine$_name = t0;
    },
    LocationStrategy: function LocationStrategy() {
    },
    HashLocationStrategy: function HashLocationStrategy() {
    },
    HashLocationStrategy_onPopState_closure: function HashLocationStrategy_onPopState_closure(t0, t1) {
      this.$this = t0;
      this.fn = t1;
    },
    HashLocationStrategy__waitForPopState_closure: function HashLocationStrategy__waitForPopState_closure(t0, t1) {
      this._box_0 = t0;
      this.completer = t1;
    },
    PlatformLocation: function PlatformLocation() {
    },
    BrowserPlatformLocation: function BrowserPlatformLocation() {
    },
    DomCanvas: function DomCanvas(t0, t1, t2, t3) {
      var _ = this;
      _.rootElement = t0;
      _.SaveElementStackTracking__saveStack = t1;
      _.SaveElementStackTracking__elementStack = t2;
      _.SaveElementStackTracking__currentTransform = t3;
    },
    DomRenderer: function DomRenderer(t0) {
      var _ = this;
      _._glassPaneElement = _._staleHotRestartState = _._sceneElement = _._sceneHostElement = _._canvasKitScript = _._viewportMeta = _._styleElement = _._resizeSubscription = null;
      _.rootElement = t0;
      _._debugFrameStatistics = null;
    },
    DomRenderer_reset_closure: function DomRenderer_reset_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.initialInnerWidth = t2;
    },
    EngineCanvas: function EngineCanvas() {
    },
    _SaveStackEntry: function _SaveStackEntry(t0, t1) {
      this.transform = t0;
      this.clipStack = t1;
    },
    _SaveClipEntry: function _SaveClipEntry(t0, t1) {
      this.rect = t0;
      this.currentTransform = t1;
    },
    SaveStackTracking: function SaveStackTracking() {
    },
    BrowserHistory: function BrowserHistory() {
      this._userProvidedRouteName = this._unsubscribe = this._locationStrategy = null;
    },
    BrowserHistory__popStateListener_closure: function BrowserHistory__popStateListener_closure() {
    },
    BrowserHistory__popStateListener_closure0: function BrowserHistory__popStateListener_closure0() {
    },
    _SaveElementStackEntry: function _SaveElementStackEntry(t0, t1) {
      this.savedElement = t0;
      this.transform = t1;
    },
    SaveElementStackTracking: function SaveElementStackTracking() {
    },
    Keyboard: function Keyboard() {
      this._keyupListener = this._keydownListener = null;
    },
    Keyboard$__closure: function Keyboard$__closure(t0) {
      this.$this = t0;
    },
    Keyboard$__closure0: function Keyboard$__closure0(t0) {
      this.$this = t0;
    },
    Keyboard$__closure1: function Keyboard$__closure1(t0) {
      this.$this = t0;
    },
    PlatformViewRegistry: function PlatformViewRegistry(t0, t1) {
      this._registeredFactories = t0;
      this._createdViews = t1;
    },
    PointerBinding: function PointerBinding(t0) {
      this.domRenderer = t0;
      this._adapter = this._detector = null;
    },
    PointerSupportDetector: function PointerSupportDetector() {
    },
    BaseAdapter: function BaseAdapter() {
    },
    BaseAdapter__addEventListener_closure: function BaseAdapter__addEventListener_closure(t0) {
      this.handler = t0;
    },
    PointerAdapter: function PointerAdapter(t0, t1, t2) {
      this.domRenderer = t0;
      this._callback = t1;
      this._isDownMap = t2;
    },
    PointerAdapter__setup_closure: function PointerAdapter__setup_closure(t0) {
      this.$this = t0;
    },
    PointerAdapter__setup_closure0: function PointerAdapter__setup_closure0(t0) {
      this.$this = t0;
    },
    PointerAdapter__setup_closure1: function PointerAdapter__setup_closure1(t0) {
      this.$this = t0;
    },
    PointerAdapter__setup_closure2: function PointerAdapter__setup_closure2(t0) {
      this.$this = t0;
    },
    PointerAdapter__setup_closure3: function PointerAdapter__setup_closure3(t0) {
      this.$this = t0;
    },
    TouchAdapter: function TouchAdapter(t0, t1, t2) {
      this.domRenderer = t0;
      this._callback = t1;
      this._isDownMap = t2;
    },
    TouchAdapter__setup_closure: function TouchAdapter__setup_closure(t0) {
      this.$this = t0;
    },
    TouchAdapter__setup_closure0: function TouchAdapter__setup_closure0(t0) {
      this.$this = t0;
    },
    TouchAdapter__setup_closure1: function TouchAdapter__setup_closure1(t0) {
      this.$this = t0;
    },
    TouchAdapter__setup_closure2: function TouchAdapter__setup_closure2(t0) {
      this.$this = t0;
    },
    MouseAdapter: function MouseAdapter(t0, t1, t2) {
      this.domRenderer = t0;
      this._callback = t1;
      this._isDownMap = t2;
    },
    MouseAdapter__setup_closure: function MouseAdapter__setup_closure(t0) {
      this.$this = t0;
    },
    MouseAdapter__setup_closure0: function MouseAdapter__setup_closure0(t0) {
      this.$this = t0;
    },
    MouseAdapter__setup_closure1: function MouseAdapter__setup_closure1(t0) {
      this.$this = t0;
    },
    MouseAdapter__setup_closure2: function MouseAdapter__setup_closure2(t0) {
      this.$this = t0;
    },
    _addWheelEventListener_closure: function _addWheelEventListener_closure(t0) {
      this.listener = t0;
    },
    RecordingCanvas: function RecordingCanvas(t0, t1) {
      var _ = this;
      _._paintBounds = t0;
      _._commands = t1;
      _._didDraw = _._hasArbitraryPaint = false;
      _.saveCount = 1;
    },
    PaintCommand: function PaintCommand() {
    },
    PaintSave: function PaintSave() {
    },
    PaintRestore: function PaintRestore() {
    },
    PaintTranslate: function PaintTranslate(t0, t1) {
      this.dx = t0;
      this.dy = t1;
    },
    PaintClipRect: function PaintClipRect(t0) {
      this.rect = t0;
    },
    PaintDrawRect: function PaintDrawRect(t0, t1) {
      this.rect = t0;
      this.paint = t1;
    },
    PaintDrawParagraph: function PaintDrawParagraph(t0, t1) {
      this.paragraph = t0;
      this.offset = t1;
    },
    _PaintBounds: function _PaintBounds(t0, t1) {
      var _ = this;
      _.maxPaintBounds = t0;
      _._didPaintInsideClipArea = false;
      _._clipStack = _._transforms = _._bottom = _._right = _._top = _._left = null;
      _._currentMatrixIsIdentity = true;
      _._currentMatrix = t1;
      _._clipRectInitialized = false;
      _._currentClipBottom = _._currentClipRight = _._currentClipTop = _._currentClipLeft = 0;
    },
    AccessibilityAnnouncements: function AccessibilityAnnouncements() {
      this._element = this._removeElementTimer = null;
    },
    AccessibilityAnnouncements$__closure: function AccessibilityAnnouncements$__closure(t0) {
      this.$this = t0;
    },
    AccessibilityAnnouncements_handleMessage_closure: function AccessibilityAnnouncements_handleMessage_closure(t0) {
      this.$this = t0;
    },
    _CheckableKind: function _CheckableKind(t0) {
      this._engine$_name = t0;
    },
    Checkable: function Checkable(t0) {
      this._engine$_kind = null;
      this.semanticsObject = t0;
    },
    ImageRoleManager: function ImageRoleManager(t0) {
      this._auxiliaryImageElement = null;
      this.semanticsObject = t0;
    },
    Incrementable: function Incrementable(t0, t1) {
      var _ = this;
      _._element = t0;
      _._currentSurrogateValue = 1;
      _._gestureModeListener = null;
      _._pendingResync = false;
      _.semanticsObject = t1;
    },
    Incrementable_closure: function Incrementable_closure(t0, t1) {
      this.$this = t0;
      this.semanticsObject = t1;
    },
    Incrementable_closure0: function Incrementable_closure0(t0) {
      this.$this = t0;
    },
    LabelAndValue: function LabelAndValue(t0) {
      this._auxiliaryValueElement = null;
      this.semanticsObject = t0;
    },
    LiveRegion: function LiveRegion(t0) {
      this.semanticsObject = t0;
    },
    Scrollable: function Scrollable(t0) {
      var _ = this;
      _._scrollListener = _._gestureModeListener = null;
      _._effectiveNeutralScrollPosition = 0;
      _.semanticsObject = t0;
    },
    Scrollable_update_closure: function Scrollable_update_closure(t0) {
      this.$this = t0;
    },
    Scrollable_update_closure0: function Scrollable_update_closure0(t0) {
      this.$this = t0;
    },
    Scrollable_update_closure1: function Scrollable_update_closure1(t0) {
      this.$this = t0;
    },
    SemanticsUpdate: function SemanticsUpdate(t0) {
      this._engine$_nodeUpdates = t0;
    },
    SemanticsNodeUpdate: function SemanticsNodeUpdate(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) {
      var _ = this;
      _.id = t0;
      _.flags = t1;
      _.actions = t2;
      _.textSelectionBase = t3;
      _.textSelectionExtent = t4;
      _.scrollChildren = t5;
      _.scrollIndex = t6;
      _.scrollPosition = t7;
      _.scrollExtentMax = t8;
      _.scrollExtentMin = t9;
      _.rect = t10;
      _.label = t11;
      _.hint = t12;
      _.value = t13;
      _.increasedValue = t14;
      _.decreasedValue = t15;
      _.textDirection = t16;
      _.transform = t17;
      _.childrenInTraversalOrder = t18;
      _.childrenInHitTestOrder = t19;
      _.additionalActions = t20;
    },
    Role: function Role(t0) {
      this._engine$_name = t0;
    },
    closure: function closure() {
    },
    closure0: function closure0() {
    },
    closure1: function closure1() {
    },
    closure2: function closure2() {
    },
    closure3: function closure3() {
    },
    closure4: function closure4() {
    },
    closure5: function closure5() {
    },
    closure6: function closure6() {
    },
    RoleManager: function RoleManager() {
    },
    SemanticsObject: function SemanticsObject(t0, t1, t2, t3) {
      var _ = this;
      _._additionalActions = _._childrenInHitTestOrder = _._engine$_childrenInTraversalOrder = _._engine$_transform = _._engine$_textDirection = _._engine$_decreasedValue = _._engine$_increasedValue = _._engine$_value = _._engine$_hint = _._engine$_label = _._engine$_rect = _._engine$_scrollExtentMin = _._engine$_scrollExtentMax = _._engine$_scrollPosition = _._engine$_scrollIndex = _._scrollChildren = _._textSelectionExtent = _._textSelectionBase = _._engine$_actions = _._engine$_flags = null;
      _.id = t0;
      _.owner = t1;
      _.element = t2;
      _._dirtyFields = -1;
      _._engine$_parent = _._childContainerElement = null;
      _._roleManagers = t3;
      _.horizontalContainerAdjustment = _.verticalContainerAdjustment = 0;
      _._previousChildrenInTraversalOrder = null;
    },
    AccessibilityMode: function AccessibilityMode(t0) {
      this._engine$_name = t0;
    },
    GestureMode: function GestureMode(t0) {
      this._engine$_name = t0;
    },
    EngineSemanticsOwner: function EngineSemanticsOwner(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._semanticsTree = t0;
      _._attachments = t1;
      _._detachments = t2;
      _._oneTimePostUpdateCallbacks = t3;
      _._rootSemanticsElement = null;
      _._now = t4;
      _._semanticsActivationTimer = _._semanticsPlaceholder = null;
      _._semanticsActivationAttempts = 0;
      _._semanticsEnabled = _._schedulePlaceholderRemoval = false;
      _._gestureMode = t5;
      _._gestureModeClock = null;
      _._gestureModeListeners = t6;
    },
    EngineSemanticsOwner$__closure: function EngineSemanticsOwner$__closure(t0) {
      this.$this = t0;
    },
    EngineSemanticsOwner_closure: function EngineSemanticsOwner_closure() {
    },
    EngineSemanticsOwner__tryEnableSemantics_closure: function EngineSemanticsOwner__tryEnableSemantics_closure(t0) {
      this.$this = t0;
    },
    EngineSemanticsOwner_autoEnableOnTap_closure: function EngineSemanticsOwner_autoEnableOnTap_closure(t0) {
      this.$this = t0;
    },
    EngineSemanticsOwner__getGestureModeClock_closure: function EngineSemanticsOwner__getGestureModeClock_closure(t0) {
      this.$this = t0;
    },
    Tappable: function Tappable(t0) {
      this._clickListener = null;
      this.semanticsObject = t0;
    },
    Tappable_update_closure: function Tappable_update_closure(t0) {
      this.$this = t0;
    },
    TextField: function TextField(t0) {
      this.persistentTextEditingElement = null;
      this.semanticsObject = t0;
    },
    TextField__initializeForBlink_closure: function TextField__initializeForBlink_closure(t0) {
      this.$this = t0;
    },
    TextField__initializeForWebkit_closure: function TextField__initializeForWebkit_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    TextField__initializeForWebkit_closure0: function TextField__initializeForWebkit_closure0(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    MethodCall: function MethodCall(t0, t1) {
      this.method = t0;
      this.$arguments = t1;
    },
    StringCodec0: function StringCodec0() {
    },
    JSONMessageCodec0: function JSONMessageCodec0() {
    },
    JSONMethodCodec0: function JSONMethodCodec0() {
    },
    StandardMessageCodec: function StandardMessageCodec() {
    },
    StandardMethodCodec: function StandardMethodCodec() {
    },
    ReadBuffer: function ReadBuffer(t0) {
      this.data = t0;
      this._engine$_position = 0;
    },
    PersistedOffset: function PersistedOffset(t0, t1, t2, t3, t4) {
      var _ = this;
      _.dx = t0;
      _.dy = t1;
      _._oldLayer = t2;
      _._engine$_children = t3;
      _._engine$_state = t4;
      _._globalClip = _._engine$_transform = _.parent = _.rootElement = null;
    },
    _PaintRequest: function _PaintRequest(t0, t1) {
      this.canvasSize = t0;
      this.paintCallback = t1;
    },
    PersistedStandardPicture: function PersistedStandardPicture(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._didApplyPaint = t0;
      _._engine$_canvas = null;
      _.dx = t1;
      _.dy = t2;
      _.picture = t3;
      _.localPaintBounds = t4;
      _._exactLocalCullRect = _._exactGlobalCullRect = _._optimalLocalCullRect = null;
      _._engine$_state = t5;
      _._globalClip = _._engine$_transform = _.parent = _.rootElement = null;
    },
    PersistedStandardPicture__applyBitmapPaint_closure: function PersistedStandardPicture__applyBitmapPaint_closure(t0) {
      this.$this = t0;
    },
    PersistedPicture: function PersistedPicture() {
    },
    PersistedScene: function PersistedScene(t0, t1, t2) {
      var _ = this;
      _._oldLayer = t0;
      _._engine$_children = t1;
      _._engine$_state = t2;
      _._globalClip = _._engine$_transform = _.parent = _.rootElement = null;
    },
    FrameReference: function FrameReference(t0, t1) {
      this.value = t0;
      this.$ti = t1;
    },
    commitScene_closure: function commitScene_closure() {
    },
    PersistedSurfaceState: function PersistedSurfaceState(t0) {
      this._engine$_name = t0;
    },
    PersistedSurface: function PersistedSurface() {
    },
    PersistedLeafSurface: function PersistedLeafSurface() {
    },
    PersistedContainerSurface: function PersistedContainerSurface() {
    },
    PersistedContainerSurface__updateManyToMany_insertDomNodeIfMoved: function PersistedContainerSurface__updateManyToMany_insertDomNodeIfMoved(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.containerElement = t2;
    },
    PersistedContainerSurface__matchChildren_closure: function PersistedContainerSurface__matchChildren_closure() {
    },
    _PersistedSurfaceMatch: function _PersistedSurfaceMatch(t0, t1, t2) {
      this.newChild = t0;
      this.oldChildIndex = t1;
      this.matchQuality = t2;
    },
    PersistedTransform: function PersistedTransform(t0, t1, t2, t3) {
      var _ = this;
      _.matrix4 = t0;
      _._oldLayer = t1;
      _._engine$_children = t2;
      _._engine$_state = t3;
      _._globalClip = _._engine$_transform = _.parent = _.rootElement = null;
    },
    FontCollection: function FontCollection() {
      this._testFontManager = this._assetFontManager = null;
    },
    _FontManager: function _FontManager(t0) {
      this._fontLoadingFutures = t0;
    },
    _FontManager_registerAsset_closure: function _FontManager_registerAsset_closure(t0) {
      this.fontFace = t0;
    },
    _FontManager_registerAsset_closure0: function _FontManager_registerAsset_closure0(t0) {
      this.family = t0;
    },
    _PolyfillFontManager: function _PolyfillFontManager(t0) {
      this._fontLoadingFutures = t0;
    },
    _PolyfillFontManager_registerAsset__watchWidth: function _PolyfillFontManager_registerAsset__watchWidth(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.paragraph = t1;
      _.sansSerifWidth = t2;
      _.completer = t3;
      _.family = t4;
    },
    _PolyfillFontManager_registerAsset_closure: function _PolyfillFontManager_registerAsset_closure(t0) {
      this.fontStyleMap = t0;
    },
    LineBreakType: function LineBreakType(t0) {
      this._engine$_name = t0;
    },
    LineBreakResult: function LineBreakResult(t0, t1) {
      this.index = t0;
      this.type = t1;
    },
    RulerManager: function RulerManager(t0, t1, t2) {
      var _ = this;
      _.rulerCacheCapacity = t0;
      _._rulerHost = t1;
      _._rulers = t2;
      _._rulerCacheCleanupScheduled = false;
    },
    RulerManager__scheduleRulerCacheCleanup_closure: function RulerManager__scheduleRulerCacheCleanup_closure(t0) {
      this.$this = t0;
    },
    RulerManager_cleanUpRulerCache_closure: function RulerManager_cleanUpRulerCache_closure() {
    },
    TextMeasurementService: function TextMeasurementService() {
    },
    DomTextMeasurementService: function DomTextMeasurementService() {
    },
    CanvasTextMeasurementService: function CanvasTextMeasurementService(t0) {
      this._canvasContext = t0;
    },
    LinesCalculator: function LinesCalculator(t0, t1, t2, t3, t4) {
      var _ = this;
      _._canvasContext = t0;
      _._engine$_text = t1;
      _._style = t2;
      _._maxWidth = t3;
      _.lines = t4;
      _._chunkStart = _._lineStart = 0;
      _._reachedMaxLines = false;
      _._cachedEllipsisWidth = null;
    },
    MaxIntrinsicCalculator: function MaxIntrinsicCalculator(t0, t1) {
      var _ = this;
      _._canvasContext = t0;
      _._engine$_text = t1;
      _._lastHardLineEnd = _.value = 0;
    },
    ParagraphGeometricStyle: function ParagraphGeometricStyle(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.fontWeight = t0;
      _.fontStyle = t1;
      _.fontFamily = t2;
      _.fontSize = t3;
      _.lineHeight = t4;
      _.maxLines = t5;
      _.letterSpacing = t6;
      _.wordSpacing = t7;
      _.decoration = t8;
      _.ellipsis = t9;
      _._cssFontString = _._cachedHashCode = null;
    },
    TextDimensions: function TextDimensions(t0) {
      this._element = t0;
      this._cachedBoundingClientRect = null;
    },
    ParagraphRuler: function ParagraphRuler(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _.style = t0;
      _.rulerManager = t1;
      _._probe = t2;
      _._cachedAlphabeticBaseline = null;
      _._singleLineHost = t3;
      _.singleLineDimensions = t4;
      _._minIntrinsicHost = t5;
      _.minIntrinsicDimensions = t6;
      _._constrainedHost = t7;
      _.constrainedDimensions = t8;
      _._lineHeightDimensions = _._lineHeightHost = null;
      _._hitCount = 0;
      _._debugIsDisposed = false;
      _._engine$_paragraph = null;
      _._measurementCache = t9;
      _._mruList = t10;
    },
    MeasurementResult: function MeasurementResult(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.constraintWidth = t0;
      _.isSingleLine = t1;
      _.width = t2;
      _.height = t3;
      _.naturalHeight = t4;
      _.minIntrinsicWidth = t5;
      _.maxIntrinsicWidth = t6;
      _.alphabeticBaseline = t7;
      _.ideographicBaseline = t8;
    },
    _styleEditingElement_closure: function _styleEditingElement_closure(t0) {
      this.domElement = t0;
    },
    EditingState: function EditingState(t0, t1, t2) {
      this.text = t0;
      this.baseOffset = t1;
      this.extentOffset = t2;
    },
    InputType: function InputType(t0) {
      this._engine$_name = t0;
    },
    InputConfiguration: function InputConfiguration(t0) {
      this.inputType = t0;
    },
    ElementType: function ElementType(t0) {
      this._engine$_name = t0;
    },
    TextEditingElement: function TextEditingElement(t0) {
      var _ = this;
      _._enabled = false;
      _._onChange = _._lastEditingState = _.domElement = null;
      _._subscriptions = t0;
    },
    TextEditingElement_enable_closure: function TextEditingElement_enable_closure(t0) {
      this.$this = t0;
    },
    PersistentTextEditingElement: function PersistentTextEditingElement(t0) {
      var _ = this;
      _._enabled = false;
      _._onChange = _._lastEditingState = _.domElement = null;
      _._subscriptions = t0;
    },
    HybridTextEditing: function HybridTextEditing(t0) {
      var _ = this;
      _._defaultEditingElement = t0;
      _._clientId = _._customEditingElement = null;
      _._isEditing = false;
      _._configuration = null;
    },
    Matrix40: function Matrix40(t0) {
      this._engine$_m4storage = t0;
    },
    Vector30: function Vector30(t0) {
      this._engine$_v3storage = t0;
    },
    EngineWindow: function EngineWindow(t0, t1, t2, t3) {
      var _ = this;
      _._devicePixelRatio = 1;
      _._physicalSize = t0;
      _._lastKnownWindowInnerHeight = _._lastKnownWindowInnerWidth = -1;
      _._browserHistory = t1;
      _._onPlatformMessage = _._onSemanticsAction = _._onSemanticsEnabledChanged = _._onPointerDataPacket = _._onDrawFrame = _._onBeginFrame = _._onMetricsChanged = null;
      _._accessibilityFeatures = t2;
      _._rasterizer = t3;
    },
    EngineWindow_sendPlatformMessage_closure: function EngineWindow_sendPlatformMessage_closure(t0, t1) {
      this.$this = t0;
      this.callback = t1;
    },
    EngineWindow_sendPlatformMessage_closure0: function EngineWindow_sendPlatformMessage_closure0(t0, t1) {
      this.$this = t0;
      this.callback = t1;
    },
    EngineWindow_sendPlatformMessage_closure1: function EngineWindow_sendPlatformMessage_closure1(t0, t1, t2) {
      this.$this = t0;
      this.callback = t1;
      this.codec = t2;
    },
    EngineWindow__replyToPlatformMessage_closure: function EngineWindow__replyToPlatformMessage_closure(t0, t1) {
      this.callback = t0;
      this.data = t1;
    },
    _BitmapCanvas_EngineCanvas_SaveStackTracking: function _BitmapCanvas_EngineCanvas_SaveStackTracking() {
    },
    _DomCanvas_EngineCanvas_SaveElementStackTracking: function _DomCanvas_EngineCanvas_SaveElementStackTracking() {
    }
  },
  G = {
    _synthesiseDownButtons: function(buttons, kind) {
      switch (kind) {
        case C.PointerDeviceKind_1:
          return buttons;
        case C.PointerDeviceKind_0:
        case C.PointerDeviceKind_2:
        case C.PointerDeviceKind_3:
          if (typeof buttons !== "number")
            return buttons.$or();
          return (buttons | 1) >>> 0;
        default:
          return buttons === 0 ? 1 : buttons;
      }
    },
    PointerEventConverter__ensureStateForPointer: function(datum, position) {
      return $.PointerEventConverter__pointers.putIfAbsent$2(0, datum.device, new G.PointerEventConverter__ensureStateForPointer_closure(position));
    },
    PointerEventConverter_expand: function(data, devicePixelRatio) {
      return G.PointerEventConverter_expand$body(H.assertSubtype(data, "$isIterable", [Q.PointerData], "$asIterable"), devicePixelRatio);
    },
    PointerEventConverter_expand$body: function($async$data, $async$devicePixelRatio) {
      return P._makeSyncStarIterable(function() {
        var data = $async$data,
          devicePixelRatio = $async$devicePixelRatio;
        var $async$goto = 0, $async$handler = 2, $async$currentError, t1, radiusMax, _i, datum, t2, t3, position, timeStamp, kind, t4, alreadyAdded, state, t5, t6, t7, t8, t9, t10, t11, t12;
        return function $async$PointerEventConverter_expand($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = data.length, radiusMax = 0 / devicePixelRatio, _i = 0;
              case 3:
                // for condition
                if (!(_i < data.length)) {
                  // goto after for
                  $async$goto = 5;
                  break;
                }
                datum = data[_i];
                t2 = datum.physicalX;
                t3 = datum.physicalY;
                if (typeof t2 !== "number") {
                  t2.$div();
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t2 /= devicePixelRatio;
                if (typeof t3 !== "number") {
                  t3.$div();
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t3 /= devicePixelRatio;
                position = new Q.Offset(t2, t3);
                timeStamp = datum.timeStamp;
                kind = datum.kind;
                t4 = datum.signalKind;
                $async$goto = t4 == null || t4 === C.PointerSignalKind_0 ? 6 : 8;
                break;
              case 6:
                // then
                t4 = datum.change;
              case 9:
                // switch
                switch (t4) {
                  case C.PointerChange_1:
                    // goto case
                    $async$goto = 11;
                    break;
                  case C.PointerChange_3:
                    // goto case
                    $async$goto = 12;
                    break;
                  case C.PointerChange_4:
                    // goto case
                    $async$goto = 13;
                    break;
                  case C.PointerChange_5:
                    // goto case
                    $async$goto = 14;
                    break;
                  case C.PointerChange_6:
                    // goto case
                    $async$goto = 15;
                    break;
                  case C.PointerChange_0:
                    // goto case
                    $async$goto = 16;
                    break;
                  case C.PointerChange_2:
                    // goto case
                    $async$goto = 17;
                    break;
                  default:
                    // goto after switch
                    $async$goto = 10;
                    break;
                }
                break;
              case 11:
                // case
                G.PointerEventConverter__ensureStateForPointer(datum, position);
                $async$goto = 18;
                return new F.PointerAddedEvent(timeStamp, 0, kind, datum.device, position, C.Offset_0_0, 0, false, false, 0, datum.pressureMin, datum.pressureMax, 0, 0, 0, 0, 0, radiusMax, radiusMax, 0, datum.tilt, 0, false);
              case 18:
                // after yield
                // goto after switch
                $async$goto = 10;
                break;
              case 12:
                // case
                t4 = datum.device;
                alreadyAdded = $.PointerEventConverter__pointers.containsKey$1(0, t4);
                state = G.PointerEventConverter__ensureStateForPointer(datum, position);
                $async$goto = !alreadyAdded ? 19 : 20;
                break;
              case 19:
                // then
                $async$goto = 21;
                return new F.PointerAddedEvent(timeStamp, 0, kind, t4, position, C.Offset_0_0, 0, false, false, 0, datum.pressureMin, datum.pressureMax, 0, 0, 0, 0, 0, radiusMax, radiusMax, 0, datum.tilt, 0, false);
              case 21:
                // after yield
              case 20:
                // join
                t5 = state.lastPosition;
                t6 = t5._dx;
                if (typeof t6 !== "number") {
                  H.iae(t6);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = t5._dy;
                if (typeof t5 !== "number") {
                  H.iae(t5);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 22;
                return new F.PointerHoverEvent(timeStamp, 0, kind, t4, position, new Q.Offset(t2 - t6, t3 - t5), datum.buttons, false, false, 0, datum.pressureMin, datum.pressureMax, 0, 0, 0, radiusMax, radiusMax, radiusMax, radiusMax, 0, datum.tilt, 0, false);
              case 22:
                // after yield
                state.lastPosition = position;
                // goto after switch
                $async$goto = 10;
                break;
              case 13:
                // case
                t4 = datum.device;
                alreadyAdded = $.PointerEventConverter__pointers.containsKey$1(0, t4);
                state = G.PointerEventConverter__ensureStateForPointer(datum, position);
                $async$goto = !alreadyAdded ? 23 : 24;
                break;
              case 23:
                // then
                $async$goto = 25;
                return new F.PointerAddedEvent(timeStamp, 0, kind, t4, position, C.Offset_0_0, 0, false, false, 0, datum.pressureMin, datum.pressureMax, 0, 0, 0, 0, 0, radiusMax, radiusMax, 0, datum.tilt, 0, false);
              case 25:
                // after yield
              case 24:
                // join
                $async$goto = !state.lastPosition.$eq(0, position) ? 26 : 27;
                break;
              case 26:
                // then
                t5 = state.lastPosition;
                t6 = t5._dx;
                if (typeof t6 !== "number") {
                  H.iae(t6);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = t5._dy;
                if (typeof t5 !== "number") {
                  H.iae(t5);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 28;
                return new F.PointerHoverEvent(timeStamp, 0, kind, t4, position, new Q.Offset(t2 - t6, t3 - t5), datum.buttons, false, false, 0, datum.pressureMin, datum.pressureMax, 0, 0, 0, radiusMax, radiusMax, radiusMax, radiusMax, 0, datum.tilt, 0, true);
              case 28:
                // after yield
                state.lastPosition = position;
              case 27:
                // join
                t2 = $._PointerState__pointerCount + 1;
                state._pointer = $._PointerState__pointerCount = t2;
                state._down = true;
                $async$goto = 29;
                return new F.PointerDownEvent(timeStamp, t2, kind, t4, position, C.Offset_0_0, G._synthesiseDownButtons(datum.buttons, kind), true, false, datum.pressure, datum.pressureMin, datum.pressureMax, 0, 0, 0, radiusMax, radiusMax, radiusMax, radiusMax, 0, datum.tilt, 0, false);
              case 29:
                // after yield
                // goto after switch
                $async$goto = 10;
                break;
              case 14:
                // case
                t4 = datum.device;
                state = $.PointerEventConverter__pointers.$index(0, t4);
                t5 = state._pointer;
                t6 = state.lastPosition;
                t7 = t6._dx;
                if (typeof t7 !== "number") {
                  H.iae(t7);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t6 = t6._dy;
                if (typeof t6 !== "number") {
                  H.iae(t6);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t8 = G._synthesiseDownButtons(datum.buttons, kind);
                t9 = datum.pressure;
                t10 = datum.pressureMin;
                t11 = datum.pressureMax;
                t12 = datum.tilt;
                datum.toString;
                $async$goto = 30;
                return new F.PointerMoveEvent(timeStamp, t5, kind, t4, position, new Q.Offset(t2 - t7, t3 - t6), t8, true, false, t9, t10, t11, 0, 0, 0, radiusMax, radiusMax, radiusMax, radiusMax, 0, t12, 0, false);
              case 30:
                // after yield
                state.lastPosition = position;
                // goto after switch
                $async$goto = 10;
                break;
              case 15:
                // case
              case 16:
                // case
                t5 = datum.device;
                state = $.PointerEventConverter__pointers.$index(0, t5);
                $async$goto = !position.$eq(0, state.lastPosition) ? 31 : 32;
                break;
              case 31:
                // then
                t6 = state._pointer;
                t7 = state.lastPosition;
                t8 = t7._dx;
                if (typeof t8 !== "number") {
                  H.iae(t8);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t7 = t7._dy;
                if (typeof t7 !== "number") {
                  H.iae(t7);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 33;
                return new F.PointerMoveEvent(timeStamp, t6, kind, t5, position, new Q.Offset(t2 - t8, t3 - t7), G._synthesiseDownButtons(datum.buttons, kind), true, false, datum.pressure, datum.pressureMin, datum.pressureMax, 0, 0, 0, radiusMax, radiusMax, radiusMax, radiusMax, 0, datum.tilt, 0, true);
              case 33:
                // after yield
                state.lastPosition = position;
              case 32:
                // join
                state._down = false;
                $async$goto = t4 === C.PointerChange_6 ? 34 : 36;
                break;
              case 34:
                // then
                $async$goto = 37;
                return new F.PointerUpEvent(timeStamp, state._pointer, kind, t5, position, C.Offset_0_0, datum.buttons, false, false, datum.pressure, datum.pressureMin, datum.pressureMax, 0, 0, 0, radiusMax, radiusMax, radiusMax, radiusMax, 0, datum.tilt, 0, false);
              case 37:
                // after yield
                // goto join
                $async$goto = 35;
                break;
              case 36:
                // else
                $async$goto = 38;
                return new F.PointerCancelEvent(timeStamp, state._pointer, kind, t5, position, C.Offset_0_0, datum.buttons, false, false, 0, datum.pressureMin, datum.pressureMax, 0, 0, 0, radiusMax, radiusMax, radiusMax, radiusMax, 0, datum.tilt, 0, false);
              case 38:
                // after yield
              case 35:
                // join
                // goto after switch
                $async$goto = 10;
                break;
              case 17:
                // case
                t4 = datum.device;
                state = $.PointerEventConverter__pointers.$index(0, t4);
                $async$goto = state._down ? 39 : 40;
                break;
              case 39:
                // then
                $async$goto = 41;
                return new F.PointerCancelEvent(timeStamp, state._pointer, kind, t4, state.lastPosition, C.Offset_0_0, datum.buttons, false, false, 0, datum.pressureMin, datum.pressureMax, 0, 0, 0, radiusMax, radiusMax, radiusMax, radiusMax, 0, datum.tilt, 0, false);
              case 41:
                // after yield
              case 40:
                // join
                $async$goto = !position.$eq(0, state.lastPosition) ? 42 : 43;
                break;
              case 42:
                // then
                t5 = state.lastPosition;
                t6 = t5._dx;
                if (typeof t6 !== "number") {
                  H.iae(t6);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = t5._dy;
                if (typeof t5 !== "number") {
                  H.iae(t5);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 44;
                return new F.PointerHoverEvent(timeStamp, 0, kind, t4, position, new Q.Offset(t2 - t6, t3 - t5), datum.buttons, false, false, 0, datum.pressureMin, datum.pressureMax, 0, 0, 0, radiusMax, radiusMax, radiusMax, radiusMax, 0, datum.tilt, 0, true);
              case 44:
                // after yield
              case 43:
                // join
                $.PointerEventConverter__pointers.remove$1(0, t4);
                t2 = datum.pressureMin;
                t3 = datum.pressureMax;
                datum.toString;
                $async$goto = 45;
                return new F.PointerRemovedEvent(timeStamp, 0, kind, t4, position, C.Offset_0_0, 0, false, false, 0, t2, t3, 0, 0, 0, 0, 0, radiusMax, radiusMax, 0, 0, 0, false);
              case 45:
                // after yield
                // goto after switch
                $async$goto = 10;
                break;
              case 10:
                // after switch
                // goto join
                $async$goto = 7;
                break;
              case 8:
                // else
              case 46:
                // switch
                switch (t4) {
                  case C.PointerSignalKind_1:
                    // goto case
                    $async$goto = 48;
                    break;
                  case C.PointerSignalKind_0:
                    // goto case
                    $async$goto = 49;
                    break;
                  case C.PointerSignalKind_2:
                    // goto case
                    $async$goto = 50;
                    break;
                  default:
                    // goto after switch
                    $async$goto = 47;
                    break;
                }
                break;
              case 48:
                // case
                state = G.PointerEventConverter__ensureStateForPointer(datum, position);
                $async$goto = !state.lastPosition.$eq(0, position) ? 51 : 52;
                break;
              case 51:
                // then
                $async$goto = state._down ? 53 : 55;
                break;
              case 53:
                // then
                t4 = state._pointer;
                t5 = datum.device;
                t6 = state.lastPosition;
                t7 = t6._dx;
                if (typeof t7 !== "number") {
                  H.iae(t7);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t6 = t6._dy;
                if (typeof t6 !== "number") {
                  H.iae(t6);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 56;
                return new F.PointerMoveEvent(timeStamp, t4, kind, t5, position, new Q.Offset(t2 - t7, t3 - t6), G._synthesiseDownButtons(datum.buttons, kind), true, false, datum.pressure, datum.pressureMin, datum.pressureMax, 0, 0, 0, radiusMax, radiusMax, radiusMax, radiusMax, 0, datum.tilt, 0, true);
              case 56:
                // after yield
                // goto join
                $async$goto = 54;
                break;
              case 55:
                // else
                t4 = datum.device;
                t5 = state.lastPosition;
                t6 = t5._dx;
                if (typeof t6 !== "number") {
                  H.iae(t6);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = t5._dy;
                if (typeof t5 !== "number") {
                  H.iae(t5);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 57;
                return new F.PointerHoverEvent(timeStamp, 0, kind, t4, position, new Q.Offset(t2 - t6, t3 - t5), datum.buttons, false, false, 0, datum.pressureMin, datum.pressureMax, 0, 0, 0, radiusMax, radiusMax, radiusMax, radiusMax, 0, datum.tilt, 0, true);
              case 57:
                // after yield
              case 54:
                // join
                state.lastPosition = position;
              case 52:
                // join
                t2 = datum.scrollDeltaX;
                t3 = datum.scrollDeltaY;
                if (typeof t2 !== "number") {
                  t2.$div();
                  // goto return
                  $async$goto = 1;
                  break;
                }
                if (typeof t3 !== "number") {
                  t3.$div();
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 58;
                return new F.PointerScrollEvent(new Q.Offset(t2 / devicePixelRatio, t3 / devicePixelRatio), timeStamp, 0, kind, datum.device, position, C.Offset_0_0, 0, false, false, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false);
              case 58:
                // after yield
                // goto after switch
                $async$goto = 47;
                break;
              case 49:
                // case
                // goto after switch
                $async$goto = 47;
                break;
              case 50:
                // case
                // goto after switch
                $async$goto = 47;
                break;
              case 47:
                // after switch
              case 7:
                // join
              case 4:
                // for update
                data.length === t1 || (0, H.throwConcurrentModificationError)(data), ++_i;
                // goto for condition
                $async$goto = 3;
                break;
              case 5:
                // after for
              case 1:
                // return
                return P._IterationMarker_endOfIteration();
              case 2:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, F.PointerEvent);
    },
    _PointerState: function _PointerState(t0) {
      this._pointer = null;
      this._down = false;
      this.lastPosition = t0;
    },
    PointerEventConverter__ensureStateForPointer_closure: function PointerEventConverter__ensureStateForPointer_closure(t0) {
      this.position = t0;
    },
    PointerSignalResolver: function PointerSignalResolver() {
      this._currentEvent = this._firstRegisteredCallback = null;
    },
    RenderComparison: function RenderComparison(t0, t1) {
      this.index = t0;
      this._basic_types$_name = t1;
    },
    LogicalKeyboardKey_isControlCharacter: function(label) {
      var codeUnit, t1;
      if (label.length > 1)
        return false;
      codeUnit = J._codeUnitAt$1$s(label, 0);
      if (!(codeUnit <= 31 && true))
        t1 = codeUnit >= 127 && codeUnit <= 159;
      else
        t1 = true;
      return t1;
    },
    LogicalKeyboardKey: function LogicalKeyboardKey(t0, t1, t2) {
      this.keyId = t0;
      this.debugName = t1;
      this.keyLabel = t2;
    }
  },
  O = {HitTestTarget: function HitTestTarget() {
    }, HitTestEntry: function HitTestEntry(t0) {
      this.target = t0;
    }, HitTestResult: function HitTestResult(t0) {
      this._path = t0;
    }, PointerRouter: function PointerRouter(t0, t1) {
      this._routeMap = t0;
      this._globalRoutes = t1;
    }, PointerRouter__dispatch_closure: function PointerRouter__dispatch_closure(t0) {
      this.event = t0;
    }, FlutterErrorDetailsForPointerRouter: function FlutterErrorDetailsForPointerRouter(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.exception = t0;
      _.stack = t1;
      _.library = t2;
      _.context = t3;
      _.informationCollector = t4;
      _.silent = t5;
    }, FocusNode: function FocusNode() {
    }, FocusNode_debugDescribeChildren_closure: function FocusNode_debugDescribeChildren_closure(t0) {
      this._box_0 = t0;
    }, FocusScopeNode: function FocusScopeNode(t0, t1, t2, t3) {
      var _ = this;
      _._focusedChildren = t0;
      _._onKey = t1;
      _._manager = null;
      _._children = t2;
      _._debugLabel = null;
      _.ChangeNotifier__listeners = t3;
    }, FocusManager: function FocusManager(t0, t1) {
      this.rootScope = t0;
      this._dirtyNodes = t1;
    }, _FocusManager_Object_DiagnosticableTreeMixin: function _FocusManager_Object_DiagnosticableTreeMixin() {
    }, _FocusNode_Object_DiagnosticableTreeMixin: function _FocusNode_Object_DiagnosticableTreeMixin() {
    }, _FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier: function _FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier() {
    }},
  S = {GestureRecognizer: function GestureRecognizer() {
    }, _GestureRecognizer_GestureArenaMember_DiagnosticableTreeMixin: function _GestureRecognizer_GestureArenaMember_DiagnosticableTreeMixin() {
    }, BoxConstraints: function BoxConstraints(t0, t1, t2, t3) {
      var _ = this;
      _.minWidth = t0;
      _.maxWidth = t1;
      _.minHeight = t2;
      _.maxHeight = t3;
    }, BoxHitTestResult: function BoxHitTestResult(t0) {
      this._path = t0;
    }, BoxHitTestEntry: function BoxHitTestEntry(t0, t1) {
      this.localPosition = t0;
      this.target = t1;
    }, BoxParentData: function BoxParentData() {
    }, _IntrinsicDimensionsCacheEntry: function _IntrinsicDimensionsCacheEntry() {
    }, RenderBox: function RenderBox() {
    },
    setEquals: function(a, b, $T) {
      var t1 = [$T];
      H.assertSubtype(a, "$isSet", t1, "$asSet");
      H.assertSubtype(b, "$isSet", t1, "$asSet");
      if (a == null)
        return b == null;
      if (b == null || a._collection$_length !== b._collection$_length)
        return false;
      for (t1 = P._LinkedHashSetIterator$(a, a._collection$_modifications, H.getTypeArgumentByIndex(a, 0)); t1.moveNext$0();)
        if (!b.contains$1(0, t1._collection$_current))
          return false;
      return true;
    },
    listEquals: function(a, b, $T) {
      var index,
        t1 = [$T];
      H.assertSubtype(a, "$isList", t1, "$asList");
      H.assertSubtype(b, "$isList", t1, "$asList");
      if (a == null)
        return b == null;
      if (b == null || false)
        return false;
      for (index = 0; index < 1; ++index)
        b[index];
      return true;
    }
  },
  E = {ImageCache: function ImageCache(t0, t1) {
      this._pendingImages = t0;
      this._cache = t1;
    }, _CachedImage: function _CachedImage() {
    },
    Matrix4_tryInvert: function(other) {
      var r = new E.Matrix4(new Float64Array(16));
      if (r.copyInverse$1(other) === 0)
        return;
      return r;
    },
    Matrix4_Matrix4$identity: function() {
      var t1 = new E.Matrix4(new Float64Array(16));
      t1.setIdentity$0();
      return t1;
    },
    Matrix4_Matrix4$translationValues0: function(x, y, z) {
      var t1 = new Float64Array(16),
        t2 = new E.Matrix4(t1);
      t2.setIdentity$0();
      t1[14] = z;
      C.NativeFloat64List_methods.$indexSet(t1, 13, y);
      C.NativeFloat64List_methods.$indexSet(t1, 12, x);
      return t2;
    },
    Matrix4: function Matrix4(t0) {
      this._m4storage = t0;
    },
    Vector3: function Vector3(t0) {
      this._v3storage = t0;
    },
    Vector4: function Vector4(t0) {
      this._v4storage = t0;
    },
    debugInstrumentAction: function(description, action, $T) {
      var t1 = H.functionTypeCheck(action, {func: 1, ret: [P.Future, $T]}).call$0();
      return t1;
    }
  },
  L = {ImageStreamCompleter: function ImageStreamCompleter() {
    },
    Localizations_localeOf: function(context, nullOk) {
      H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type__LocalizationsScope_Lpb), "$is_LocalizationsScope");
      return;
    },
    _LocalizationsScope: function _LocalizationsScope() {
    },
    DefaultTextStyle: function DefaultTextStyle() {
    },
    Text: function Text(t0, t1, t2) {
      this.data = t0;
      this.textDirection = t1;
      this.key = t2;
    }
  },
  Q = {
    TextSpan$: function(children, style, text) {
      return new Q.TextSpan(style, text, children);
    },
    TextSpan: function TextSpan(t0, t1, t2) {
      this.style = t0;
      this.text = t1;
      this.children = t2;
    },
    TextSpan_getSpanForPosition_closure: function TextSpan_getSpanForPosition_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.targetOffset = t1;
      this.affinity = t2;
    },
    TextSpan_toPlainText_closure: function TextSpan_toPlainText_closure(t0, t1) {
      this.includeSemanticsLabels = t0;
      this.buffer = t1;
    },
    TextSpan_debugDescribeChildren_closure: function TextSpan_debugDescribeChildren_closure() {
    },
    TextOverflow: function TextOverflow(t0) {
      this._paragraph$_name = t0;
    },
    RenderParagraph: function RenderParagraph(t0, t1, t2, t3, t4) {
      var _ = this;
      _._textPainter = t0;
      _._softWrap = t1;
      _._overflow = t2;
      _._needsClipping = false;
      _._overflowShader = null;
      _._recognizerOffsets = t3;
      _._recognizers = t4;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._constraints = _._relayoutBoundary = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderParagraph_describeSemanticsConfiguration_closure: function RenderParagraph_describeSemanticsConfiguration_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderParagraph_assembleSemanticsNode_buildSemanticsConfig: function RenderParagraph_assembleSemanticsNode_buildSemanticsConfig(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.rawLabel = t2;
    },
    AssetBundle: function AssetBundle() {
    },
    CachingAssetBundle: function CachingAssetBundle() {
    },
    PlatformAssetBundle: function PlatformAssetBundle(t0, t1) {
      this._stringCache = t0;
      this._structuredDataCache = t1;
    },
    RawKeyEventDataAndroid: function RawKeyEventDataAndroid(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.flags = t0;
      _.codePoint = t1;
      _.plainCodePoint = t2;
      _.keyCode = t3;
      _.scanCode = t4;
      _.metaState = t5;
    },
    RawKeyEventDataAndroid_getModifierSide_findSide: function RawKeyEventDataAndroid_getModifierSide_findSide(t0) {
      this.$this = t0;
    },
    RawKeyEventDataFuchsia: function RawKeyEventDataFuchsia(t0, t1, t2) {
      this.hidUsage = t0;
      this.codePoint = t1;
      this.modifiers = t2;
    },
    RawKeyEventDataFuchsia_getModifierSide_findSide: function RawKeyEventDataFuchsia_getModifierSide_findSide(t0) {
      this.$this = t0;
    },
    PictureRecorder_PictureRecorder: function() {
      return new Q.PictureRecorder();
    },
    Canvas$: function(recorder) {
      var t1 = new Q.Canvas();
      if (recorder.get$isRecording())
        H.throwExpression(P.ArgumentError$('"recorder" must not already be associated with another Canvas.'));
      t1._ui$_canvas = recorder.beginRecording$1(C.Rect_aha);
      return t1;
    },
    SceneBuilder_SceneBuilder: function() {
      var t1 = H.setRuntimeTypeInfo([], [T.PersistedContainerSurface]),
        t2 = $.SceneBuilder__lastFrameScene,
        t3 = T.PersistedSurface,
        t4 = H.setRuntimeTypeInfo([], [t3]);
      t2 = t2 != null && t2._engine$_state === C.PersistedSurfaceState_1 ? t2 : null;
      t3 = new T.FrameReference(t2, [t3]);
      C.JSArray_methods.add$1($._frameReferences, t3);
      t4 = new T.PersistedScene(t3, t4, C.PersistedSurfaceState_0);
      t2 = new T.Matrix40(new Float64Array(16));
      t2.setIdentity$0();
      t4._engine$_transform = t2;
      C.JSArray_methods.add$1(t1, t4);
      return new Q.SceneBuilder(t1);
    },
    hashValues: function(arg01, arg02, arg03, arg04, arg05, arg06, arg07, arg08, arg09, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20) {
      var t1,
        result = 37 * (13801 + J.get$hashCode$(arg01)) + J.get$hashCode$(arg02);
      if (arg03 !== C.C__HashEnd) {
        result = 37 * result + J.get$hashCode$(arg03);
        if (arg04 !== C.C__HashEnd) {
          result = 37 * result + J.get$hashCode$(arg04);
          t1 = J.getInterceptor$(arg05);
          if (!t1.$eq(arg05, C.C__HashEnd)) {
            result = 37 * result + t1.get$hashCode(arg05);
            if (arg06 !== C.C__HashEnd) {
              result = 37 * result + J.get$hashCode$(arg06);
              if (arg07 !== C.C__HashEnd) {
                result = 37 * result + J.get$hashCode$(arg07);
                if (arg08 !== C.C__HashEnd) {
                  result = 37 * result + J.get$hashCode$(arg08);
                  t1 = J.getInterceptor$(arg09);
                  if (!t1.$eq(arg09, C.C__HashEnd)) {
                    result = 37 * result + t1.get$hashCode(arg09);
                    if (arg10 !== C.C__HashEnd) {
                      result = 37 * result + J.get$hashCode$(arg10);
                      if (arg11 !== C.C__HashEnd) {
                        result = 37 * result + J.get$hashCode$(arg11);
                        if (arg12 !== C.C__HashEnd) {
                          result = 37 * result + J.get$hashCode$(arg12);
                          if (arg13 !== C.C__HashEnd) {
                            result = 37 * result + J.get$hashCode$(arg13);
                            if (arg14 !== C.C__HashEnd) {
                              result = 37 * result + J.get$hashCode$(arg14);
                              if (arg15 !== C.C__HashEnd) {
                                result = 37 * result + J.get$hashCode$(arg15);
                                if (arg16 !== C.C__HashEnd) {
                                  result = 37 * result + J.get$hashCode$(arg16);
                                  if (arg17 !== C.C__HashEnd) {
                                    result = 37 * result + J.get$hashCode$(arg17);
                                    t1 = J.getInterceptor$(arg18);
                                    if (!t1.$eq(arg18, C.C__HashEnd)) {
                                      result = 37 * result + t1.get$hashCode(arg18);
                                      if (arg19 !== C.C__HashEnd) {
                                        result = 37 * result + J.get$hashCode$(arg19);
                                        if (arg20 !== C.C__HashEnd)
                                          result = 37 * result + J.get$hashCode$(arg20);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    },
    hashList: function(args) {
      var t1, result, _i;
      H.assertSubtype(args, "$isIterable", [P.Object], "$asIterable");
      if (args != null)
        for (t1 = args.length, result = 373, _i = 0; _i < args.length; args.length === t1 || (0, H.throwConcurrentModificationError)(args), ++_i)
          result = 37 * result + J.get$hashCode$(args[_i]);
      else
        result = 373;
      return result;
    },
    webOnlyInitializePlatform: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        t1, t2;
      var $async$webOnlyInitializePlatform = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $.$get$window()._browserHistory;
              t2 = t1._locationStrategy;
              if (C.C_HashLocationStrategy !== t2) {
                t1._tearoffStrategy$1(t2);
                t1._locationStrategy = C.C_HashLocationStrategy;
                t1._setupStrategy$1(C.C_HashLocationStrategy);
              }
              $async$goto = 2;
              return P._asyncAwait(Q.webOnlySetAssetManager(C.C_AssetManager), $async$webOnlyInitializePlatform);
            case 2:
              // returning from await.
              $async$goto = 3;
              return P._asyncAwait($._fontCollection.ensureFontsLoaded$0(), $async$webOnlyInitializePlatform);
            case 3:
              // returning from await.
              T.webOnlyInitializeEngine();
              $._webOnlyIsInitialized = true;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$webOnlyInitializePlatform, $async$completer);
    },
    webOnlySetAssetManager: function(assetManager) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, t1;
      var $async$webOnlySetAssetManager = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (assetManager === $._assetManager) {
                // goto return
                $async$goto = 1;
                break;
              }
              $._assetManager = assetManager;
              t1 = $._fontCollection;
              if (t1 == null)
                t1 = $._fontCollection = new T.FontCollection();
              t1._testFontManager = t1._assetFontManager = null;
              if ($.$get$supportsFontLoadingApi())
                document.fonts.clear();
              t1 = $._assetManager;
              $async$goto = t1 != null ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return P._asyncAwait($._fontCollection.registerFonts$1(t1), $async$webOnlySetAssetManager);
            case 5:
              // returning from await.
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$webOnlySetAssetManager, $async$completer);
    },
    Gradient_Gradient$linear: function(from, to, colors) {
      H.assertSubtype(colors, "$isList", [Q.Color], "$asList");
      return new Q._GradientLinear(from, to, colors, null);
    },
    PointerData$: function(buttons, change, device, kind, physicalX, physicalY, pressure, pressureMax, pressureMin, scrollDeltaX, scrollDeltaY, signalKind, tilt, timeStamp) {
      return new Q.PointerData(timeStamp, change, kind, signalKind, device, physicalX, physicalY, buttons, pressure, pressureMin, pressureMax, tilt, scrollDeltaX, scrollDeltaY);
    },
    textAlignToCssValue: function(align, textDirection) {
      switch (align) {
        case C.TextAlign_0:
          return "left";
        case C.TextAlign_1:
          return "right";
        case C.TextAlign_2:
          return "center";
        case C.TextAlign_3:
          return "justify";
        case C.TextAlign_4:
          switch (textDirection) {
            case C.TextDirection_1:
              return;
            case C.TextDirection_0:
              return "right";
          }
          break;
        case C.TextAlign_5:
          switch (textDirection) {
            case C.TextDirection_1:
              return "end";
            case C.TextDirection_0:
              return "left";
          }
          break;
      }
      throw H.wrapException(P.AssertionError$("Unsupported TextAlign value " + H.S(align)));
    },
    _listEquals: function(a, b, $T) {
      return true;
    },
    TextStyle$: function(background, color, decoration, decorationColor, decorationStyle, decorationThickness, fontFamily, fontFamilyFallback, fontSize, fontStyle, fontWeight, foreground, height, letterSpacing, locale, shadows, textBaseline, wordSpacing) {
      var t1 = fontFamily == null,
        t2 = t1 ? "" : fontFamily;
      return new Q.TextStyle(color, decoration, decorationColor, decorationStyle, fontWeight, fontStyle, textBaseline, !t1, t2, fontFamilyFallback, fontSize, letterSpacing, wordSpacing, height, locale, background, foreground, shadows);
    },
    ParagraphStyle$: function(ellipsis, fontFamily, fontSize, fontStyle, fontWeight, height, locale, maxLines, strutStyle, textAlign, textDirection) {
      return new Q.ParagraphStyle(textAlign, textDirection, fontWeight, fontStyle, maxLines, fontFamily, fontSize, height, strutStyle, ellipsis, locale);
    },
    Paragraph$_: function(background, paint, paragraphElement, paragraphGeometricStyle, plainText, textAlign, textDirection) {
      return new Q.Paragraph(paragraphElement, paragraphGeometricStyle, plainText, paint, textAlign, textDirection, background);
    },
    ParagraphBuilder$: function(style) {
      var strutFontFamilies, cssStyle, t3,
        t1 = H.interceptedTypeCheck($.$get$domRenderer().createElement$1(0, "p"), "$isHtmlElement"),
        t2 = style._strutStyle;
      if (t2 != null) {
        strutFontFamilies = H.setRuntimeTypeInfo([], [P.String]);
        C.JSArray_methods.add$1(strutFontFamilies, t2._fontFamily);
        C.JSArray_methods.addAll$1(strutFontFamilies, t2._fontFamilyFallback);
      }
      cssStyle = t1.style;
      t2 = style._textAlign;
      if (t2 != null) {
        t3 = style._ui$_textDirection;
        t2 = Q.textAlignToCssValue(t2, t3 == null ? C.TextDirection_1 : t3);
        cssStyle.toString;
        cssStyle.textAlign = t2 == null ? "" : t2;
      }
      if (style.get$_webOnlyLineHeight() != null) {
        t2 = H.S(style.get$_webOnlyLineHeight());
        cssStyle.lineHeight = t2;
      }
      t2 = style._ui$_textDirection;
      if (t2 != null) {
        t2 = t2 === C.TextDirection_1 ? null : "rtl";
        cssStyle.toString;
        cssStyle.direction = t2 == null ? "" : t2;
      }
      t2 = style._fontSize;
      if (t2 != null) {
        t2 = "" + C.JSInt_methods.floor$0(t2) + "px";
        cssStyle.fontSize = t2;
      }
      t2 = style._fontWeight;
      if (t2 != null) {
        t2 = Q.webOnlyFontWeightToCss(t2);
        cssStyle.toString;
        cssStyle.fontWeight = t2 == null ? "" : t2;
      }
      if (style.get$_effectiveFontFamily() != null) {
        t2 = style.get$_effectiveFontFamily();
        cssStyle.toString;
        cssStyle.fontFamily = t2 == null ? "" : t2;
      }
      return new Q.ParagraphBuilder(t1, style, []);
    },
    applyTextBackgroundToElement: function(element, style) {
      var newBackground = style._background;
      if (newBackground != null)
        $.$get$domRenderer().setElementStyle$3(element, "background-color", newBackground._paintData.color.toCssString$0());
    },
    applyTextStyleToElement: function(element, style) {
      var t1,
        cssStyle = element.style,
        color = style._color;
      if (color != null) {
        t1 = color.toCssString$0();
        cssStyle.color = t1;
      }
      t1 = style._fontSize;
      if (t1 != null) {
        t1 = "" + C.JSInt_methods.floor$0(t1) + "px";
        cssStyle.fontSize = t1;
      }
      t1 = style._fontWeight;
      if (t1 != null) {
        t1 = Q.webOnlyFontWeightToCss(t1);
        cssStyle.toString;
        cssStyle.fontWeight = t1 == null ? "" : t1;
      }
      style.get$_effectiveFontFamily();
      t1 = style.get$_effectiveFontFamily();
      cssStyle.fontFamily = t1;
    },
    _textDecorationToCssString: function(decoration, decorationStyle) {
      return;
    },
    webOnlyFontWeightToCss: function(fontWeight) {
      if (fontWeight == null)
        return;
      switch (fontWeight.index) {
        case 0:
          return "100";
        case 1:
          return "200";
        case 2:
          return "300";
        case 3:
          return "normal";
        case 4:
          return "500";
        case 5:
          return "600";
        case 6:
          return "bold";
        case 7:
          return "800";
        case 8:
          return "900";
      }
      return "";
    },
    Locale__replaceDeprecatedLanguageSubtag: function(languageCode) {
      var _s3_ = "dtp";
      switch (languageCode) {
        case "in":
          return "id";
        case "iw":
          return "he";
        case "ji":
          return "yi";
        case "jw":
          return "jv";
        case "mo":
          return "ro";
        case "aam":
          return "aas";
        case "adp":
          return "dz";
        case "aue":
          return "ktz";
        case "ayx":
          return "nun";
        case "bgm":
          return "bcg";
        case "bjd":
          return "drl";
        case "ccq":
          return "rki";
        case "cjr":
          return "mom";
        case "cka":
          return "cmr";
        case "cmk":
          return "xch";
        case "coy":
          return "pij";
        case "cqu":
          return "quh";
        case "drh":
          return "khk";
        case "drw":
          return "prs";
        case "gav":
          return "dev";
        case "gfx":
          return "vaj";
        case "ggn":
          return "gvr";
        case "gti":
          return "nyc";
        case "guv":
          return "duz";
        case "hrr":
          return "jal";
        case "ibi":
          return "opa";
        case "ilw":
          return "gal";
        case "jeg":
          return "oyb";
        case "kgc":
          return "tdf";
        case "kgh":
          return "kml";
        case "koj":
          return "kwv";
        case "krm":
          return "bmf";
        case "ktr":
          return _s3_;
        case "kvs":
          return "gdj";
        case "kwq":
          return "yam";
        case "kxe":
          return "tvd";
        case "kzj":
          return _s3_;
        case "kzt":
          return _s3_;
        case "lii":
          return "raq";
        case "lmm":
          return "rmx";
        case "meg":
          return "cir";
        case "mst":
          return "mry";
        case "mwj":
          return "vaj";
        case "myt":
          return "mry";
        case "nad":
          return "xny";
        case "ncp":
          return "kdz";
        case "nnx":
          return "ngv";
        case "nts":
          return "pij";
        case "oun":
          return "vaj";
        case "pcr":
          return "adx";
        case "pmc":
          return "huw";
        case "pmu":
          return "phr";
        case "ppa":
          return "bfy";
        case "ppr":
          return "lcq";
        case "pry":
          return "prt";
        case "puz":
          return "pub";
        case "sca":
          return "hle";
        case "skk":
          return "oyb";
        case "tdu":
          return _s3_;
        case "thc":
          return "tpo";
        case "thx":
          return "oyb";
        case "tie":
          return "ras";
        case "tkk":
          return "twm";
        case "tlw":
          return "weo";
        case "tmp":
          return "tyj";
        case "tne":
          return "kak";
        case "tnf":
          return "prs";
        case "tsf":
          return "taj";
        case "uok":
          return "ema";
        case "xba":
          return "cax";
        case "xia":
          return "acn";
        case "xkh":
          return "waw";
        case "xsj":
          return "suj";
        case "ybd":
          return "rki";
        case "yma":
          return "lrr";
        case "ymt":
          return "mtm";
        case "yos":
          return "zom";
        case "yuu":
          return "yug";
        default:
          return languageCode;
      }
    },
    Locale__replaceDeprecatedRegionSubtag: function(regionCode) {
      switch (regionCode) {
        case "BU":
          return "MM";
        case "DD":
          return "DE";
        case "FX":
          return "FR";
        case "TP":
          return "TL";
        case "YD":
          return "YE";
        case "ZR":
          return "CD";
        default:
          return regionCode;
      }
    },
    ClipOp: function ClipOp(t0) {
      this._name = t0;
    },
    PictureRecorder: function PictureRecorder() {
      this.cullRect = this._ui$_canvas = null;
      this._isRecording = false;
    },
    Canvas: function Canvas() {
      this._ui$_canvas = null;
    },
    Picture: function Picture(t0, t1) {
      this.recordingCanvas = t0;
      this.cullRect = t1;
    },
    Scene: function Scene(t0) {
      this.webOnlyRootElement = t0;
    },
    SceneBuilder: function SceneBuilder(t0) {
      this._surfaceStack = t0;
    },
    OffsetBase: function OffsetBase() {
    },
    Offset: function Offset(t0, t1) {
      this._dx = t0;
      this._dy = t1;
    },
    Size: function Size(t0, t1) {
      this._dx = t0;
      this._dy = t1;
    },
    Rect: function Rect(t0, t1, t2, t3) {
      var _ = this;
      _.left = t0;
      _.top = t1;
      _.right = t2;
      _.bottom = t3;
    },
    _HashEnd: function _HashEnd() {
    },
    Color: function Color(t0) {
      this._ui$_value = t0;
    },
    PaintingStyle: function PaintingStyle(t0) {
      this._name = t0;
    },
    BlendMode: function BlendMode(t0) {
      this._name = t0;
    },
    PaintData: function PaintData() {
      var _ = this;
      _.strokeJoin = _.strokeCap = _.strokeWidth = _.style = _.blendMode = null;
      _.isAntiAlias = true;
      _.colorFilter = _.filterQuality = _.maskFilter = _.shader = _.color = null;
    },
    Paint: function Paint(t0) {
      this._paintData = t0;
      this._frozen = false;
    },
    Shader: function Shader() {
    },
    Gradient: function Gradient() {
    },
    _GradientLinear: function _GradientLinear(t0, t1, t2, t3) {
      var _ = this;
      _.from = t0;
      _.to = t1;
      _.colors = t2;
      _.colorStops = t3;
    },
    Shadow: function Shadow() {
    },
    PointerChange: function PointerChange(t0) {
      this._name = t0;
    },
    PointerDeviceKind: function PointerDeviceKind(t0) {
      this._name = t0;
    },
    PointerSignalKind: function PointerSignalKind(t0) {
      this._name = t0;
    },
    PointerData: function PointerData(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) {
      var _ = this;
      _.timeStamp = t0;
      _.change = t1;
      _.kind = t2;
      _.signalKind = t3;
      _.device = t4;
      _.physicalX = t5;
      _.physicalY = t6;
      _.buttons = t7;
      _.pressure = t8;
      _.pressureMin = t9;
      _.pressureMax = t10;
      _.tilt = t11;
      _.scrollDeltaX = t12;
      _.scrollDeltaY = t13;
    },
    PointerDataPacket: function PointerDataPacket(t0) {
      this.data = t0;
    },
    SemanticsAction: function SemanticsAction(t0) {
      this.index = t0;
    },
    SemanticsFlag: function SemanticsFlag(t0) {
      this.index = t0;
    },
    SemanticsUpdateBuilder: function SemanticsUpdateBuilder(t0) {
      this._nodeUpdates = t0;
    },
    FontStyle: function FontStyle() {
    },
    FontWeight: function FontWeight(t0) {
      this.index = t0;
    },
    TextAlign: function TextAlign(t0) {
      this._name = t0;
    },
    TextBaseline: function TextBaseline() {
    },
    TextStyle: function TextStyle(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17) {
      var _ = this;
      _._color = t0;
      _._decoration = t1;
      _._decorationColor = t2;
      _._decorationStyle = t3;
      _._fontWeight = t4;
      _._fontStyle = t5;
      _._textBaseline = t6;
      _._webOnlyIsFontFamilyProvided = t7;
      _._fontFamily = t8;
      _._fontFamilyFallback = t9;
      _._fontSize = t10;
      _._letterSpacing = t11;
      _._wordSpacing = t12;
      _._height = t13;
      _._locale = t14;
      _._background = t15;
      _._foreground = t16;
      _._shadows = t17;
    },
    ParagraphStyle: function ParagraphStyle(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _._textAlign = t0;
      _._ui$_textDirection = t1;
      _._fontWeight = t2;
      _._fontStyle = t3;
      _._maxLines = t4;
      _._fontFamily = t5;
      _._fontSize = t6;
      _._height = t7;
      _._strutStyle = t8;
      _._ellipsis = t9;
      _._locale = t10;
    },
    TextDirection: function TextDirection(t0) {
      this._name = t0;
    },
    TextBox: function TextBox(t0, t1, t2, t3, t4) {
      var _ = this;
      _.left = t0;
      _.top = t1;
      _.right = t2;
      _.bottom = t3;
      _.direction = t4;
    },
    TextAffinity: function TextAffinity(t0) {
      this._name = t0;
    },
    TextPosition: function TextPosition(t0, t1) {
      this.offset = t0;
      this.affinity = t1;
    },
    ParagraphConstraints: function ParagraphConstraints(t0) {
      this.width = t0;
    },
    Paragraph: function Paragraph(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._paragraphElement = t0;
      _._paragraphGeometricStyle = t1;
      _._plainText = t2;
      _._paint = t3;
      _._textAlign = t4;
      _._ui$_textDirection = t5;
      _._background = t6;
      _._measurementResult = null;
      _._didExceedMaxLines = false;
      _._lastUsedConstraints = null;
      _.webOnlyAlignOffset = 0;
    },
    ParagraphBuilder: function ParagraphBuilder(t0, t1, t2) {
      this._paragraphElement = t0;
      this._paragraphStyle = t1;
      this._ops = t2;
    },
    ParagraphBuilder__buildRichText_currentElement: function ParagraphBuilder__buildRichText_currentElement(t0, t1) {
      this.$this = t0;
      this.elementStack = t1;
    },
    TileMode: function TileMode(t0) {
      this._name = t0;
    },
    AppLifecycleState: function AppLifecycleState(t0) {
      this._name = t0;
    },
    Locale: function Locale(t0, t1) {
      this._languageCode = t0;
      this._countryCode = t1;
    },
    Window: function Window() {
    },
    AccessibilityFeatures: function AccessibilityFeatures(t0) {
      this._ui$_index = t0;
    }
  },
  A = {
    TextStyle$0: function(background, backgroundColor, color, debugLabel, decoration, decorationColor, decorationStyle, decorationThickness, fontFamily, fontFamilyFallback, fontSize, fontStyle, fontWeight, foreground, height, inherit, letterSpacing, locale, shadows, textBaseline, wordSpacing) {
      return new A.TextStyle0(true, color, backgroundColor, fontFamily, fontFamilyFallback, fontSize, fontWeight, fontStyle, letterSpacing, wordSpacing, textBaseline, height, locale, foreground, background, decoration, decorationColor, decorationStyle, decorationThickness, debugLabel, shadows);
    },
    TextStyle0: function TextStyle0(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) {
      var _ = this;
      _.inherit = t0;
      _.color = t1;
      _.backgroundColor = t2;
      _.fontFamily = t3;
      _._text_style$_fontFamilyFallback = t4;
      _.fontSize = t5;
      _.fontWeight = t6;
      _.fontStyle = t7;
      _.letterSpacing = t8;
      _.wordSpacing = t9;
      _.textBaseline = t10;
      _.height = t11;
      _.locale = t12;
      _.foreground = t13;
      _.background = t14;
      _.decoration = t15;
      _.decorationColor = t16;
      _.decorationStyle = t17;
      _.decorationThickness = t18;
      _.debugLabel = t19;
      _.shadows = t20;
    },
    TextStyle_debugFillProperties_closure: function TextStyle_debugFillProperties_closure() {
    },
    ViewConfiguration: function ViewConfiguration(t0, t1) {
      this.size = t0;
      this.devicePixelRatio = t1;
    },
    RenderView: function RenderView(t0, t1, t2, t3) {
      var _ = this;
      _._view$_size = t0;
      _._view$_configuration = t1;
      _._window = t2;
      _._rootTransform = null;
      _.RenderObjectWithChildMixin__child = t3;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._constraints = _._relayoutBoundary = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _RenderView_RenderObject_RenderObjectWithChildMixin: function _RenderView_RenderObject_RenderObjectWithChildMixin() {
    },
    CustomSemanticsAction_getIdentifier: function(action) {
      var result = $.CustomSemanticsAction__ids.$index(0, action);
      if (result == null) {
        result = $.CustomSemanticsAction__nextId;
        $.CustomSemanticsAction__nextId = result + 1;
        $.CustomSemanticsAction__ids.$indexSet(0, action, result);
        $.CustomSemanticsAction__actions.$indexSet(0, result, action);
      }
      return result;
    },
    SemanticsData__sortedListsEqual: function(left, right) {
      var i,
        t1 = [P.int];
      H.assertSubtype(left, "$isList", t1, "$asList");
      H.assertSubtype(right, "$isList", t1, "$asList");
      if (left.length !== right.length)
        return false;
      for (i = 0; i < left.length; ++i) {
        t1 = left[i];
        if (i >= right.length)
          return H.ioore(right, i);
        if (!J.$eq$(t1, right[i]))
          return false;
      }
      return true;
    },
    _pointInParentCoordinates: function(node, point) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16;
      if (node._semantics$_transform == null)
        return point;
      t1 = new Float64Array(3);
      new E.Vector3(t1).setValues$3(point._dx, point._dy, 0);
      t2 = node._semantics$_transform._m4storage;
      t3 = t2[0];
      t4 = t1[0];
      t5 = t2[4];
      t6 = t1[1];
      t7 = t2[8];
      t8 = t1[2];
      t9 = t2[12];
      t10 = t2[1];
      t11 = t2[5];
      t12 = t2[9];
      t13 = t2[13];
      t14 = t2[2];
      t15 = t2[6];
      t16 = t2[10];
      t2 = t2[14];
      t1[0] = t3 * t4 + t5 * t6 + t7 * t8 + t9;
      t1[1] = t10 * t4 + t11 * t6 + t12 * t8 + t13;
      t1[2] = t14 * t4 + t15 * t6 + t16 * t8 + t2;
      return new Q.Offset(t1[0], t1[1]);
    },
    _childrenInDefaultOrder: function(children, textDirection) {
      var edges, t2, _i, child, t3, t4, t5, t6, verticalGroups, group, depth, edge, result,
        t1 = [A.SemanticsNode];
      H.assertSubtype(children, "$isList", t1, "$asList");
      edges = H.setRuntimeTypeInfo([], [A._BoxEdge]);
      for (t2 = children.length, _i = 0; _i < children.length; children.length === t2 || (0, H.throwConcurrentModificationError)(children), ++_i) {
        child = children[_i];
        t3 = child._semantics$_rect;
        t4 = t3.left;
        if (typeof t4 !== "number")
          return t4.$sub();
        t5 = t3.top;
        if (typeof t5 !== "number")
          return t5.$sub();
        t6 = t3.right;
        t3 = t3.bottom;
        C.JSArray_methods.add$1(edges, new A._BoxEdge(true, A._pointInParentCoordinates(child, new Q.Offset(t4 - -0.1, t5 - -0.1))._dy, child));
        C.JSArray_methods.add$1(edges, new A._BoxEdge(false, A._pointInParentCoordinates(child, new Q.Offset(t6 + -0.1, t3 + -0.1))._dy, child));
      }
      C.JSArray_methods.sort$0(edges);
      verticalGroups = H.setRuntimeTypeInfo([], [A._SemanticsSortGroup]);
      for (t2 = edges.length, group = null, depth = 0, _i = 0; _i < edges.length; edges.length === t2 || (0, H.throwConcurrentModificationError)(edges), ++_i) {
        edge = edges[_i];
        if (edge.isLeadingEdge) {
          ++depth;
          if (group == null)
            group = new A._SemanticsSortGroup(edge.offset, textDirection, H.setRuntimeTypeInfo([], t1));
          C.JSArray_methods.add$1(group.nodes, edge.node);
        } else
          --depth;
        if (depth === 0) {
          C.JSArray_methods.add$1(verticalGroups, group);
          group = null;
        }
      }
      C.JSArray_methods.sort$0(verticalGroups);
      result = H.setRuntimeTypeInfo([], t1);
      for (t1 = verticalGroups.length, _i = 0; _i < verticalGroups.length; verticalGroups.length === t1 || (0, H.throwConcurrentModificationError)(verticalGroups), ++_i)
        C.JSArray_methods.addAll$1(result, verticalGroups[_i].sortedWithinVerticalGroup$0());
      return result;
    },
    SemanticsConfiguration$: function() {
      return new A.SemanticsConfiguration(P.LinkedHashMap_LinkedHashMap$_empty(Q.SemanticsAction, {func: 1, ret: -1, args: [,]}), P.LinkedHashMap_LinkedHashMap$_empty(A.CustomSemanticsAction, {func: 1, ret: -1}));
    },
    _concatStrings: function(otherString, otherTextDirection, thisString, thisTextDirection) {
      var nestedLabel;
      if (otherString.length === 0)
        return thisString;
      if (thisTextDirection != otherTextDirection && otherTextDirection != null)
        switch (otherTextDirection) {
          case C.TextDirection_0:
            nestedLabel = "\u202b" + H.S(otherString) + "\u202c";
            break;
          case C.TextDirection_1:
            nestedLabel = "\u202a" + H.S(otherString) + "\u202c";
            break;
          default:
            nestedLabel = otherString;
        }
      else
        nestedLabel = otherString;
      if (thisString.length === 0)
        return nestedLabel;
      return thisString + "\n" + H.S(nestedLabel);
    },
    SemanticsTag: function SemanticsTag() {
    },
    CustomSemanticsAction: function CustomSemanticsAction() {
    },
    SemanticsData: function SemanticsData(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) {
      var _ = this;
      _.flags = t0;
      _.actions = t1;
      _.label = t2;
      _.value = t3;
      _.increasedValue = t4;
      _.decreasedValue = t5;
      _.hint = t6;
      _.textDirection = t7;
      _.textSelection = t8;
      _.scrollChildCount = t9;
      _.scrollIndex = t10;
      _.scrollPosition = t11;
      _.scrollExtentMax = t12;
      _.scrollExtentMin = t13;
      _.platformViewId = t14;
      _.rect = t15;
      _.tags = t16;
      _.transform = t17;
      _.elevation = t18;
      _.thickness = t19;
      _.customSemanticsActionIds = t20;
    },
    SemanticsData_debugFillProperties_closure: function SemanticsData_debugFillProperties_closure() {
    },
    _SemanticsDiagnosticableNode: function _SemanticsDiagnosticableNode(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.childOrder = t0;
      _.value = t1;
      _._cachedBuilder = null;
      _.name = t2;
      _.showSeparator = t3;
      _.showName = t4;
      _.linePrefix = t5;
      _.style = t6;
    },
    SemanticsNode: function SemanticsNode(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) {
      var _ = this;
      _.id = t0;
      _._showOnScreen = t1;
      _._semantics$_transform = null;
      _._semantics$_rect = t2;
      _.indexInParent = _.elevationAdjustment = _.parentPaintClipRect = _.parentSemanticsClipRect = null;
      _._isMergedIntoParent = false;
      _._mergeAllDescendantsIntoThisNode = t3;
      _._debugPreviousSnapshot = _._semantics$_children = null;
      _._semantics$_dirty = _._dead = false;
      _._actions = t4;
      _._customSemanticsActions = t5;
      _._actionsAsBits = t6;
      _.tags = null;
      _._flags = t7;
      _._label = t8;
      _._semantics$_value = t9;
      _._decreasedValue = t10;
      _._increasedValue = t11;
      _._hint = t12;
      _._elevation = t13;
      _._thickness = t14;
      _._hintOverrides = null;
      _._textDirection = t15;
      _._isMultiline = _._platformViewId = _._scrollExtentMin = _._scrollExtentMax = _._scrollPosition = _._scrollIndex = _._scrollChildCount = _._textSelection = _._sortKey = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    SemanticsNode__childrenInTraversalOrder_closure: function SemanticsNode__childrenInTraversalOrder_closure() {
    },
    SemanticsNode_debugFillProperties_closure: function SemanticsNode_debugFillProperties_closure() {
    },
    SemanticsNode_debugFillProperties_closure0: function SemanticsNode_debugFillProperties_closure0() {
    },
    SemanticsNode_debugFillProperties_closure1: function SemanticsNode_debugFillProperties_closure1() {
    },
    SemanticsNode_debugFillProperties_closure2: function SemanticsNode_debugFillProperties_closure2(t0) {
      this.$this = t0;
    },
    SemanticsNode_debugFillProperties_closure3: function SemanticsNode_debugFillProperties_closure3() {
    },
    SemanticsNode_debugDescribeChildren_closure: function SemanticsNode_debugDescribeChildren_closure(t0) {
      this.childOrder = t0;
    },
    _BoxEdge: function _BoxEdge(t0, t1, t2) {
      this.isLeadingEdge = t0;
      this.offset = t1;
      this.node = t2;
    },
    _SemanticsSortGroup: function _SemanticsSortGroup(t0, t1, t2) {
      this.startOffset = t0;
      this.textDirection = t1;
      this.nodes = t2;
    },
    _SemanticsSortGroup_sortedWithinKnot_closure: function _SemanticsSortGroup_sortedWithinKnot_closure() {
    },
    _SemanticsSortGroup_sortedWithinKnot_search: function _SemanticsSortGroup_sortedWithinKnot_search(t0, t1, t2) {
      this.visitedIds = t0;
      this.edges = t1;
      this.sortedIds = t2;
    },
    _SemanticsSortGroup_sortedWithinKnot_closure0: function _SemanticsSortGroup_sortedWithinKnot_closure0() {
    },
    _SemanticsSortGroup_sortedWithinKnot_closure1: function _SemanticsSortGroup_sortedWithinKnot_closure1(t0) {
      this.nodeMap = t0;
    },
    _TraversalSortNode: function _TraversalSortNode(t0, t1, t2) {
      this.node = t0;
      this.sortKey = t1;
      this.position = t2;
    },
    SemanticsOwner: function SemanticsOwner(t0, t1, t2, t3, t4) {
      var _ = this;
      _._semantics$_dirtyNodes = t0;
      _._nodes = t1;
      _._detachedNodes = t2;
      _._actions = t3;
      _.ChangeNotifier__listeners = t4;
    },
    SemanticsOwner_sendSemanticsUpdate_closure: function SemanticsOwner_sendSemanticsUpdate_closure(t0) {
      this.$this = t0;
    },
    SemanticsOwner_sendSemanticsUpdate_closure0: function SemanticsOwner_sendSemanticsUpdate_closure0() {
    },
    SemanticsOwner_sendSemanticsUpdate_closure1: function SemanticsOwner_sendSemanticsUpdate_closure1() {
    },
    SemanticsOwner__getSemanticsActionHandlerForId_closure: function SemanticsOwner__getSemanticsActionHandlerForId_closure(t0, t1) {
      this._box_0 = t0;
      this.action = t1;
    },
    SemanticsConfiguration: function SemanticsConfiguration(t0, t1) {
      var _ = this;
      _._hasBeenAnnotated = _.isBlockingSemanticsOfPreviouslyPaintedNodes = _.explicitChildNodes = _._isSemanticBoundary = false;
      _._actions = t0;
      _._actionsAsBits = 0;
      _._platformViewId = _._scrollIndex = _._scrollChildCount = _._indexInParent = _._sortKey = null;
      _._isMergingSemanticsOfDescendants = false;
      _._customSemanticsActions = t1;
      _._hint = _._increasedValue = _._decreasedValue = _._semantics$_value = _._label = "";
      _._hintOverrides = null;
      _._thickness = _._elevation = 0;
      _._tagsForChildren = _._scrollExtentMin = _._scrollExtentMax = _._scrollPosition = _._textSelection = _._textDirection = null;
      _._flags = 0;
    },
    DebugSemanticsDumpOrder: function DebugSemanticsDumpOrder(t0) {
      this._semantics$_name = t0;
    },
    SemanticsSortKey: function SemanticsSortKey() {
    },
    OrdinalSortKey: function OrdinalSortKey(t0, t1) {
      this.order = t0;
      this.name = t1;
    },
    _SemanticsNode_AbstractNode_DiagnosticableTreeMixin: function _SemanticsNode_AbstractNode_DiagnosticableTreeMixin() {
    },
    BasicMessageChannel: function BasicMessageChannel(t0, t1, t2) {
      this.name = t0;
      this.codec = t1;
      this.$ti = t2;
    },
    BasicMessageChannel_setMessageHandler_closure: function BasicMessageChannel_setMessageHandler_closure(t0, t1) {
      this.$this = t0;
      this.handler = t1;
    },
    MethodChannel: function MethodChannel(t0, t1) {
      this.name = t0;
      this.codec = t1;
    },
    MethodChannel_setMethodCallHandler_closure: function MethodChannel_setMethodCallHandler_closure(t0, t1) {
      this.$this = t0;
      this.handler = t1;
    },
    OptionalMethodChannel: function OptionalMethodChannel(t0, t1) {
      this.name = t0;
      this.codec = t1;
    },
    hashObjects: function(objects) {
      var hash,
        t1 = C.NativeFloat64List_methods.fold$1$2(H.assertSubtype(objects, "$isIterable", [P.Object], "$asIterable"), 0, new A.hashObjects_closure(), P.int);
      if (typeof t1 !== "number")
        return H.iae(t1);
      hash = 536870911 & t1 + ((67108863 & t1) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    hashObjects_closure: function hashObjects_closure() {
    }
  },
  V = {
    RenderErrorBox$: function(message) {
      var t1 = new V.RenderErrorBox(message);
      t1.get$isRepaintBoundary();
      t1._needsCompositing = false;
      t1.RenderErrorBox$1(message);
      return t1;
    },
    RenderErrorBox: function RenderErrorBox(t0) {
      var _ = this;
      _.message = t0;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = _._paragraph = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._constraints = _._relayoutBoundary = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    }
  },
  K = {
    PaintingContext__repaintCompositedChild: function(child, childContext, debugAlsoPaintedParent) {
      var t1 = child._layer;
      if (t1 == null)
        child._layer = new T.OffsetLayer(C.Offset_0_0);
      else
        t1.removeAllChildren$0();
      childContext = new K.PaintingContext(child._layer, child.get$paintBounds());
      child._paintWithContext$2(childContext, C.Offset_0_0);
      childContext.stopRecordingIfNeeded$0();
    },
    _SemanticsGeometry__transformRect: function(rect, $parent, child) {
      var transform;
      if (rect == null)
        return;
      if (rect.get$isEmpty(rect))
        return C.Rect_0_0_0_0;
      transform = $._SemanticsGeometry__transformRectTransform;
      if (transform == null)
        transform = $._SemanticsGeometry__transformRectTransform = new E.Matrix4(new Float64Array(16));
      transform.setIdentity$0();
      $parent.applyPaintTransform$2(child, transform);
      return T.MatrixUtils_inverseTransformRect(transform, rect);
    },
    _SemanticsGeometry__intersectRects: function(a, b) {
      if (a == null)
        return b;
      return a;
    },
    ParentData: function ParentData() {
    },
    PaintingContext: function PaintingContext(t0, t1) {
      var _ = this;
      _._containerLayer = t0;
      _.estimatedBounds = t1;
      _._canvas = _._recorder = _._currentLayer = null;
    },
    Constraints: function Constraints() {
    },
    SemanticsHandle: function SemanticsHandle(t0, t1) {
      this._object$_owner = t0;
      this.listener = t1;
    },
    PipelineOwner: function PipelineOwner(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.onNeedVisualUpdate = t0;
      _.onSemanticsOwnerCreated = t1;
      _.onSemanticsOwnerDisposed = t2;
      _._rootNode = null;
      _._nodesNeedingLayout = t3;
      _._debugDoingLayout = false;
      _._nodesNeedingCompositingBitsUpdate = t4;
      _._nodesNeedingPaint = t5;
      _._debugDoingPaint = false;
      _._semanticsOwner = null;
      _._outstandingSemanticsHandles = 0;
      _._debugDoingSemantics = false;
      _._nodesNeedingSemantics = t6;
    },
    PipelineOwner_flushLayout_closure: function PipelineOwner_flushLayout_closure() {
    },
    PipelineOwner_flushCompositingBits_closure: function PipelineOwner_flushCompositingBits_closure() {
    },
    PipelineOwner_flushPaint_closure: function PipelineOwner_flushPaint_closure() {
    },
    PipelineOwner_flushSemantics_closure: function PipelineOwner_flushSemantics_closure() {
    },
    RenderObject: function RenderObject() {
    },
    RenderObject__debugReportException_closure: function RenderObject__debugReportException_closure(t0) {
      this.$this = t0;
    },
    RenderObject__cleanRelayoutBoundary_closure: function RenderObject__cleanRelayoutBoundary_closure() {
    },
    RenderObject__updateCompositingBits_closure: function RenderObject__updateCompositingBits_closure(t0) {
      this.$this = t0;
    },
    RenderObject_clearSemantics_closure: function RenderObject_clearSemantics_closure() {
    },
    RenderObject__getSemanticsForParent_closure: function RenderObject__getSemanticsForParent_closure(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.childrenMergeIntoParent = t2;
      _.fragments = t3;
      _.toBeMarkedExplicit = t4;
      _.config = t5;
      _.producesForkingFragment = t6;
    },
    RenderObjectWithChildMixin: function RenderObjectWithChildMixin() {
    },
    FlutterErrorDetailsForRendering: function FlutterErrorDetailsForRendering(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.exception = t0;
      _.stack = t1;
      _.library = t2;
      _.context = t3;
      _.informationCollector = t4;
      _.silent = t5;
    },
    _SemanticsFragment: function _SemanticsFragment() {
    },
    _ContainerSemanticsFragment: function _ContainerSemanticsFragment(t0, t1) {
      this.interestingFragments = t0;
      this.dropsSemanticsOfPreviousSiblings = t1;
    },
    _InterestingSemanticsFragment: function _InterestingSemanticsFragment() {
    },
    _RootSemanticsFragment: function _RootSemanticsFragment(t0, t1, t2) {
      var _ = this;
      _._object$_children = t0;
      _._ancestorChain = t1;
      _._object$_tagsForChildren = null;
      _.dropsSemanticsOfPreviousSiblings = t2;
    },
    _SwitchableSemanticsFragment: function _SwitchableSemanticsFragment(t0, t1, t2, t3, t4) {
      var _ = this;
      _._mergeIntoParent = t0;
      _._config = t1;
      _._isConfigWritable = false;
      _._object$_children = t2;
      _._isExplicit = false;
      _._ancestorChain = t3;
      _._object$_tagsForChildren = null;
      _.dropsSemanticsOfPreviousSiblings = t4;
    },
    _AbortingSemanticsFragment: function _AbortingSemanticsFragment(t0, t1) {
      this._ancestorChain = t0;
      this._object$_tagsForChildren = null;
      this.dropsSemanticsOfPreviousSiblings = t1;
    },
    _SemanticsGeometry: function _SemanticsGeometry() {
      var _ = this;
      _._rect = _._transform = _._semanticsClipRect = _._paintClipRect = null;
      _._markAsHidden = false;
    },
    _RenderObject_AbstractNode_DiagnosticableTreeMixin: function _RenderObject_AbstractNode_DiagnosticableTreeMixin() {
    }
  },
  X = {
    TextSelection$: function(baseOffset, extentOffset) {
      var t1, t2;
      if (typeof baseOffset !== "number")
        return baseOffset.$lt();
      if (typeof extentOffset !== "number")
        return H.iae(extentOffset);
      t1 = baseOffset < extentOffset;
      if (t1)
        t2 = extentOffset;
      else
        t2 = baseOffset;
      if (t1)
        t1 = baseOffset;
      else
        t1 = extentOffset;
      return new X.TextSelection(baseOffset, extentOffset, t1, t2);
    },
    TextRange: function TextRange() {
    },
    TextSelection: function TextSelection(t0, t1, t2, t3) {
      var _ = this;
      _.baseOffset = t0;
      _.extentOffset = t1;
      _.start = t2;
      _.end = t3;
    }
  },
  M = {
    SystemNavigator_pop: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1);
      var $async$SystemNavigator_pop = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(C.OptionalMethodChannel_cWd.invokeMethod$1$1("SystemNavigator.pop", null), $async$SystemNavigator_pop);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$SystemNavigator_pop, $async$completer);
    }
  };
  var holders = [C, H, J, P, W, Y, Z, U, N, B, D, F, R, T, G, O, S, E, L, Q, A, V, K, X, M];
  hunkHelpers.setFunctionNamesIfNecessary(holders);
  var $ = {};
  H.JS_CONST.prototype = {};
  J.Interceptor.prototype = {
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return "Instance of '" + H.Primitives_objectTypeName(receiver) + "'";
    },
    noSuchMethod$1: function(receiver, invocation) {
      H.interceptedTypeCheck(invocation, "$isInvocation");
      throw H.wrapException(P.NoSuchMethodError$(receiver, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments()));
    },
    get$runtimeType: function(receiver) {
      return new H.TypeImpl(H.getRti(receiver));
    }
  };
  J.JSBool.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    get$runtimeType: function(receiver) {
      return C.Type_bool_lhE;
    },
    $isbool: 1
  };
  J.JSNull.prototype = {
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    },
    get$runtimeType: function(receiver) {
      return C.Type_Null_Yyn;
    },
    noSuchMethod$1: function(receiver, invocation) {
      return this.super$Interceptor$noSuchMethod(receiver, H.interceptedTypeCheck(invocation, "$isInvocation"));
    },
    $isNull: 1
  };
  J.JSObject.prototype = {};
  J.JavaScriptObject.prototype = {
    get$hashCode: function(receiver) {
      return 0;
    },
    get$runtimeType: function(receiver) {
      return C.Type_JSObject_8k0;
    },
    toString$0: function(receiver) {
      return String(receiver);
    }
  };
  J.PlainJavaScriptObject.prototype = {};
  J.UnknownJavaScriptObject.prototype = {};
  J.JavaScriptFunction.prototype = {
    toString$0: function(receiver) {
      var dartClosure = receiver[$.$get$DART_CLOSURE_PROPERTY_NAME()];
      if (dartClosure == null)
        return this.super$JavaScriptObject$toString(receiver);
      return "JavaScript function for " + H.S(J.toString$0$(dartClosure));
    },
    $signature: function() {
      return {func: 1, opt: [,,,,,,,,,,,,,,,,]};
    },
    $isFunction: 1
  };
  J.JSArray.prototype = {
    add$1: function(receiver, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    },
    removeAt$1: function(receiver, index) {
      var t1;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeAt"));
      t1 = receiver.length;
      if (index >= t1)
        throw H.wrapException(P.RangeError$value(index, null));
      return receiver.splice(index, 1)[0];
    },
    remove$1: function(receiver, element) {
      var i;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("remove"));
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    addAll$1: function(receiver, collection) {
      var t1;
      H.assertSubtype(collection, "$isIterable", [H.getTypeArgumentByIndex(receiver, 0)], "$asIterable");
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("addAll"));
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
        receiver.push(t1.get$current(t1));
    },
    forEach$1: function(receiver, f) {
      var end, i;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(receiver, 0)]});
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        f.call$1(receiver[i]);
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    map$1$1: function(receiver, f, $T) {
      var t1 = H.getTypeArgumentByIndex(receiver, 0);
      return new H.MappedListIterable(receiver, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    join$1: function(receiver, separator) {
      var i,
        list = new Array(receiver.length);
      list.fixed$length = Array;
      for (i = 0; i < receiver.length; ++i)
        this.$indexSet(list, i, H.S(receiver[i]));
      return list.join(separator);
    },
    firstWhere$2$orElse: function(receiver, test, orElse) {
      var end, i, element,
        t1 = H.getTypeArgumentByIndex(receiver, 0);
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
      H.functionTypeCheck(orElse, {func: 1, ret: t1});
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        element = receiver[i];
        if (H.boolConversionCheck(test.call$1(element)))
          return element;
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return orElse.call$0();
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    sublist$2: function(receiver, start, end) {
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, "start", null));
      if (end == null)
        end = receiver.length;
      else if (end < start || end > receiver.length)
        throw H.wrapException(P.RangeError$range(end, start, receiver.length, "end", null));
      if (start === end)
        return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
      return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    sublist$1: function($receiver, start) {
      return this.sublist$2($receiver, start, null);
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$single: function(receiver) {
      var t1 = receiver.length;
      if (t1 === 1) {
        if (0 >= t1)
          return H.ioore(receiver, 0);
        return receiver[0];
      }
      if (t1 === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      throw H.wrapException(H.IterableElementError_tooMany());
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, t2, i,
        t1 = H.getTypeArgumentByIndex(receiver, 0);
      H.assertSubtype(iterable, "$isIterable", [t1], "$asIterable");
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("setRange"));
      P.RangeError_checkValidRange(start, end, receiver.length);
      if (typeof end !== "number")
        return end.$sub();
      if (typeof start !== "number")
        return H.iae(start);
      $length = end - start;
      if ($length === 0)
        return;
      P.RangeError_checkNotNegative(skipCount, "skipCount");
      H.assertSubtype(iterable, "$isList", [t1], "$asList");
      t1 = J.getInterceptor$asx(iterable);
      t2 = t1.get$length(iterable);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (skipCount + $length > t2)
        throw H.wrapException(H.IterableElementError_tooFew());
      if (skipCount < start)
        for (i = $length - 1; i >= 0; --i)
          receiver[start + i] = t1.$index(iterable, skipCount + i);
      else
        for (i = 0; i < $length; ++i)
          receiver[start + i] = t1.$index(iterable, skipCount + i);
    },
    any$1: function(receiver, test) {
      var end, i;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(receiver, 0)]});
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        if (H.boolConversionCheck(test.call$1(receiver[i])))
          return true;
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    sort$1: function(receiver, compare) {
      var t1 = H.getTypeArgumentByIndex(receiver, 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("sort"));
      H.Sort_sort(receiver, compare == null ? J._interceptors_JSArray__compareAny$closure() : compare, t1);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    contains$1: function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    get$iterator: function(receiver) {
      return new J.ArrayIterator(receiver, receiver.length, [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      var _s9_ = "newLength";
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("set length"));
      if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
        throw H.wrapException(P.ArgumentError$value(newLength, _s9_, null));
      if (newLength < 0)
        throw H.wrapException(P.RangeError$range(newLength, 0, null, _s9_, null));
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("indexed set"));
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      receiver[index] = value;
    },
    set$last: function(receiver, element) {
      var t1;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(receiver, 0));
      t1 = receiver.length;
      if (t1 === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      this.$indexSet(receiver, t1 - 1, element);
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  J.JSUnmodifiableArray.prototype = {};
  J.ArrayIterator.prototype = {
    get$current: function(_) {
      return this.__interceptors$_current;
    },
    moveNext$0: function() {
      var t2, _this = this,
        t1 = _this.__interceptors$_iterable,
        $length = t1.length;
      if (_this.__interceptors$_length !== $length)
        throw H.wrapException(H.throwConcurrentModificationError(t1));
      t2 = _this.__interceptors$_index;
      if (t2 >= $length) {
        _this.set$__interceptors$_current(null);
        return false;
      }
      _this.set$__interceptors$_current(t1[t2]);
      ++_this.__interceptors$_index;
      return true;
    },
    set$__interceptors$_current: function(_current) {
      this.__interceptors$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  J.JSNumber.prototype = {
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      H.numTypeCheck(b);
      if (typeof b !== "number")
        throw H.wrapException(H.argumentErrorValue(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    get$sign: function(receiver) {
      var t1;
      if (receiver > 0)
        t1 = 1;
      else
        t1 = receiver < 0 ? -1 : receiver;
      return t1;
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".toInt()"));
    },
    ceil$0: function(receiver) {
      var truncated, d;
      if (receiver >= 0) {
        if (receiver <= 2147483647) {
          truncated = receiver | 0;
          return receiver === truncated ? truncated : truncated + 1;
        }
      } else if (receiver >= -2147483648)
        return receiver | 0;
      d = Math.ceil(receiver);
      if (isFinite(d))
        return d;
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".ceil()"));
    },
    floor$0: function(receiver) {
      var truncated, d;
      if (receiver >= 0) {
        if (receiver <= 2147483647)
          return receiver | 0;
      } else if (receiver >= -2147483648) {
        truncated = receiver | 0;
        return receiver === truncated ? truncated : truncated - 1;
      }
      d = Math.floor(receiver);
      if (isFinite(d))
        return d;
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".floor()"));
    },
    round$0: function(receiver) {
      if (receiver > 0) {
        if (receiver !== 1 / 0)
          return Math.round(receiver);
      } else if (receiver > -1 / 0)
        return 0 - Math.round(0 - receiver);
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".round()"));
    },
    clamp$2: function(receiver, lowerLimit, upperLimit) {
      if (typeof lowerLimit !== "number")
        throw H.wrapException(H.argumentErrorValue(lowerLimit));
      if (typeof upperLimit !== "number")
        throw H.wrapException(H.argumentErrorValue(upperLimit));
      if (this.compareTo$1(lowerLimit, upperLimit) > 0)
        throw H.wrapException(H.argumentErrorValue(lowerLimit));
      if (this.compareTo$1(receiver, lowerLimit) < 0)
        return lowerLimit;
      if (this.compareTo$1(receiver, upperLimit) > 0)
        return upperLimit;
      return receiver;
    },
    toStringAsFixed$1: function(receiver, fractionDigits) {
      var result;
      if (fractionDigits > 20)
        throw H.wrapException(P.RangeError$range(fractionDigits, 0, 20, "fractionDigits", null));
      result = receiver.toFixed(fractionDigits);
      if (receiver === 0 && this.get$isNegative(receiver))
        return "-" + result;
      return result;
    },
    toRadixString$1: function(receiver, radix) {
      var result, match, t1, exponent;
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      result = receiver.toString(radix);
      if (C.JSString_methods.codeUnitAt$1(result, result.length - 1) !== 41)
        return result;
      match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
      if (match == null)
        H.throwExpression(P.UnsupportedError$("Unexpected toString result: " + result));
      t1 = match.length;
      if (1 >= t1)
        return H.ioore(match, 1);
      result = match[1];
      if (3 >= t1)
        return H.ioore(match, 3);
      exponent = +match[3];
      t1 = match[2];
      if (t1 != null) {
        result += t1;
        exponent -= t1.length;
      }
      return result + C.JSString_methods.$mul("0", exponent);
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      var absolute, floorLog2, factor, scaled,
        intValue = receiver | 0;
      if (receiver === intValue)
        return 536870911 & intValue;
      absolute = Math.abs(receiver);
      floorLog2 = Math.log(absolute) / 0.6931471805599453 | 0;
      factor = Math.pow(2, floorLog2);
      scaled = absolute < 1 ? absolute / factor : factor / absolute;
      return 536870911 & ((scaled * 9007199254740992 | 0) + (scaled * 3542243181176521 | 0)) * 599197 + floorLog2 * 1259;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver - other;
    },
    $mod: function(receiver, other) {
      var result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver)
        if (other >= 1 || other < -1)
          return receiver / other | 0;
      return this._tdivSlow$1(receiver, other);
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this._tdivSlow$1(receiver, other);
    },
    _tdivSlow$1: function(receiver, other) {
      var quotient = receiver / other;
      if (quotient >= -2147483648 && quotient <= 2147483647)
        return quotient | 0;
      if (quotient > 0) {
        if (quotient !== 1 / 0)
          return Math.floor(quotient);
      } else if (quotient > -1 / 0)
        return Math.ceil(quotient);
      throw H.wrapException(P.UnsupportedError$("Result of truncating division is " + H.S(quotient) + ": " + H.S(receiver) + " ~/ " + other));
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = this._shrBothPositive$1(receiver, other);
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrReceiverPositive$1: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(H.argumentErrorValue(other));
      return this._shrBothPositive$1(receiver, other);
    },
    _shrBothPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver >>> other;
    },
    $gt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver > other;
    },
    get$runtimeType: function(receiver) {
      return C.Type_num_cv7;
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    },
    $isdouble: 1,
    $isnum: 1
  };
  J.JSInt.prototype = {
    get$sign: function(receiver) {
      var t1;
      if (receiver > 0)
        t1 = 1;
      else
        t1 = receiver < 0 ? -1 : receiver;
      return t1;
    },
    get$runtimeType: function(receiver) {
      return C.Type_int_tHn;
    },
    $isint: 1
  };
  J.JSDouble.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_double_K1J;
    }
  };
  J.JSString.prototype = {
    codeUnitAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index >= receiver.length)
        H.throwExpression(H.diagnoseIndexError(receiver, index));
      return receiver.charCodeAt(index);
    },
    _codeUnitAt$1: function(receiver, index) {
      if (index >= receiver.length)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      return receiver.charCodeAt(index);
    },
    matchAsPrefix$2: function(receiver, string, start) {
      var t1, i;
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      t1 = receiver.length;
      if (start + t1 > string.length)
        return;
      for (i = 0; i < t1; ++i)
        if (this.codeUnitAt$1(string, start + i) !== this._codeUnitAt$1(receiver, i))
          return;
      return new H.StringMatch(start, receiver);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$value(other, null, null));
      return receiver + other;
    },
    endsWith$1: function(receiver, other) {
      var otherLength = other.length,
        t1 = receiver.length;
      if (otherLength > t1)
        return false;
      return other === this.substring$1(receiver, t1 - otherLength);
    },
    replaceRange$3: function(receiver, start, end, replacement) {
      var prefix, suffix;
      end = P.RangeError_checkValidRange(start, end, receiver.length);
      if (typeof end !== "number" || Math.floor(end) !== end)
        H.throwExpression(H.argumentErrorValue(end));
      prefix = receiver.substring(0, start);
      suffix = receiver.substring(end);
      return prefix + replacement + suffix;
    },
    startsWith$2: function(receiver, pattern, index) {
      var endIndex;
      if (index < 0 || index > receiver.length)
        throw H.wrapException(P.RangeError$range(index, 0, receiver.length, null, null));
      if (typeof pattern === "string") {
        endIndex = index + pattern.length;
        if (endIndex > receiver.length)
          return false;
        return pattern === receiver.substring(index, endIndex);
      }
      return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
    },
    startsWith$1: function($receiver, pattern) {
      return this.startsWith$2($receiver, pattern, 0);
    },
    substring$2: function(receiver, startIndex, endIndex) {
      if (typeof startIndex !== "number" || Math.floor(startIndex) !== startIndex)
        H.throwExpression(H.argumentErrorValue(startIndex));
      if (endIndex == null)
        endIndex = receiver.length;
      if (typeof startIndex !== "number")
        return startIndex.$lt();
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex, null));
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex, null));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex, null));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toLowerCase$0: function(receiver) {
      return receiver.toLowerCase();
    },
    trim$0: function(receiver) {
      var startIndex, t1, endIndex0,
        result = receiver.trim(),
        endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this._codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    trimLeft$0: function(receiver) {
      var result, startIndex;
      if (typeof receiver.trimLeft != "undefined") {
        result = receiver.trimLeft();
        if (result.length === 0)
          return result;
        startIndex = this._codeUnitAt$1(result, 0) === 133 ? J.JSString__skipLeadingWhitespace(result, 1) : 0;
      } else {
        startIndex = J.JSString__skipLeadingWhitespace(receiver, 0);
        result = receiver;
      }
      if (startIndex === 0)
        return result;
      if (startIndex === result.length)
        return "";
      return result.substring(startIndex);
    },
    trimRight$0: function(receiver) {
      var result, endIndex, t1;
      if (typeof receiver.trimRight != "undefined") {
        result = receiver.trimRight();
        endIndex = result.length;
        if (endIndex === 0)
          return result;
        t1 = endIndex - 1;
        if (this.codeUnitAt$1(result, t1) === 133)
          endIndex = J.JSString__skipTrailingWhitespace(result, t1);
      } else {
        endIndex = J.JSString__skipTrailingWhitespace(receiver, receiver.length);
        result = receiver;
      }
      if (endIndex === result.length)
        return result;
      if (endIndex === 0)
        return "";
      return result.substring(0, endIndex);
    },
    $mul: function(receiver, times) {
      var s, result;
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    padLeft$2: function(receiver, width, padding) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return this.$mul(padding, delta) + receiver;
    },
    indexOf$2: function(receiver, pattern, start) {
      var t1;
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      t1 = receiver.indexOf(pattern, start);
      return t1;
    },
    indexOf$1: function($receiver, pattern) {
      return this.indexOf$2($receiver, pattern, 0);
    },
    lastIndexOf$1: function(receiver, pattern) {
      var start = receiver.length,
        t1 = pattern.length;
      if (start + t1 > start)
        start -= t1;
      return receiver.lastIndexOf(pattern, start);
    },
    contains$2: function(receiver, other, startIndex) {
      if (startIndex > receiver.length)
        throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length, null, null));
      return H.stringContainsUnchecked(receiver, other, startIndex);
    },
    contains$1: function($receiver, other) {
      return this.contains$2($receiver, other, 0);
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    compareTo$1: function(receiver, other) {
      var t1;
      H.stringTypeCheck(other);
      if (typeof other !== "string")
        throw H.wrapException(H.argumentErrorValue(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    get$runtimeType: function(receiver) {
      return C.Type_String_k8F;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >= receiver.length || index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      return receiver[index];
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.String];
    },
    $isPattern: 1,
    $isString: 1
  };
  H.CodeUnits.prototype = {
    get$length: function(_) {
      return this._string.length;
    },
    $index: function(_, i) {
      return C.JSString_methods.codeUnitAt$1(this._string, H.intTypeCheck(i));
    },
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $asUnmodifiableListMixin: function() {
      return [P.int];
    },
    $asListMixin: function() {
      return [P.int];
    },
    $asIterable: function() {
      return [P.int];
    },
    $asList: function() {
      return [P.int];
    }
  };
  H.EfficientLengthIterable.prototype = {};
  H.ListIterable.prototype = {
    get$iterator: function(_) {
      var _this = this;
      return new H.ListIterator(_this, _this.get$length(_this), [H.getRuntimeTypeArgument(_this, "ListIterable", 0)]);
    },
    forEach$1: function(_, action) {
      var $length, i, _this = this;
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(_this, "ListIterable", 0)]});
      $length = _this.get$length(_this);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        action.call$1(_this.elementAt$1(0, i));
        if ($length !== _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    contains$1: function(_, element) {
      var i, _this = this,
        $length = _this.get$length(_this);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        if (J.$eq$(_this.elementAt$1(0, i), element))
          return true;
        if ($length !== _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
      return false;
    },
    join$1: function(_, separator) {
      var first, t1, i, _this = this,
        $length = _this.get$length(_this);
      if (separator.length !== 0) {
        if ($length === 0)
          return "";
        first = H.S(_this.elementAt$1(0, 0));
        if ($length != _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = first;
        i = 1;
        for (; i < $length; ++i) {
          t1 = t1 + separator + H.S(_this.elementAt$1(0, i));
          if ($length !== _this.get$length(_this))
            throw H.wrapException(P.ConcurrentModificationError$(_this));
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      } else {
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        t1 = "";
        for (; i < $length; ++i) {
          t1 += H.S(_this.elementAt$1(0, i));
          if ($length !== _this.get$length(_this))
            throw H.wrapException(P.ConcurrentModificationError$(_this));
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    },
    where$1: function(_, test) {
      return this.super$Iterable$where(0, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getRuntimeTypeArgument(this, "ListIterable", 0)]}));
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getRuntimeTypeArgument(this, "ListIterable", 0);
      return new H.MappedListIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    toList$1$growable: function(_, growable) {
      var i, t1, _this = this,
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(_this, "ListIterable", 0)]);
      C.JSArray_methods.set$length(result, _this.get$length(_this));
      i = 0;
      while (true) {
        t1 = _this.get$length(_this);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        C.JSArray_methods.$indexSet(result, i, _this.elementAt$1(0, i));
        ++i;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toSet$0: function(_) {
      var t1, _this = this,
        result = P.LinkedHashSet_LinkedHashSet(H.getRuntimeTypeArgument(_this, "ListIterable", 0)),
        i = 0;
      while (true) {
        t1 = _this.get$length(_this);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        result.add$1(0, _this.elementAt$1(0, i));
        ++i;
      }
      return result;
    }
  };
  H.SubListIterable.prototype = {
    get$_endIndex: function() {
      var t2,
        $length = J.get$length$asx(this._iterable),
        t1 = this._endOrLength;
      if (t1 != null) {
        if (typeof $length !== "number")
          return H.iae($length);
        t2 = t1 > $length;
      } else
        t2 = true;
      if (t2)
        return $length;
      return t1;
    },
    get$_startIndex: function() {
      var $length = J.get$length$asx(this._iterable),
        t1 = this._start;
      if (typeof $length !== "number")
        return H.iae($length);
      if (t1 > $length)
        return $length;
      return t1;
    },
    get$length: function(_) {
      var t2,
        $length = J.get$length$asx(this._iterable),
        t1 = this._start;
      if (typeof $length !== "number")
        return H.iae($length);
      if (t1 >= $length)
        return 0;
      t2 = this._endOrLength;
      if (t2 == null || t2 >= $length)
        return $length - t1;
      if (typeof t2 !== "number")
        return t2.$sub();
      return t2 - t1;
    },
    elementAt$1: function(_, index) {
      var realIndex, _this = this,
        t1 = _this.get$_startIndex();
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof index !== "number")
        return H.iae(index);
      realIndex = t1 + index;
      if (index >= 0) {
        t1 = _this.get$_endIndex();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = realIndex >= t1;
      } else
        t1 = true;
      if (t1)
        throw H.wrapException(P.IndexError$(index, _this, "index", null, null));
      return J.elementAt$1$ax(_this._iterable, realIndex);
    },
    toList$1$growable: function(_, growable) {
      var t3, $length, result, t4, i, _this = this,
        start = _this._start,
        t1 = _this._iterable,
        t2 = J.getInterceptor$asx(t1),
        end = t2.get$length(t1),
        end0 = _this._endOrLength;
      if (end0 != null) {
        if (typeof end !== "number")
          return H.iae(end);
        t3 = end0 < end;
      } else
        t3 = false;
      if (t3)
        end = end0;
      if (typeof end !== "number")
        return end.$sub();
      $length = end - start;
      if ($length < 0)
        $length = 0;
      t3 = _this.$ti;
      if (growable) {
        result = H.setRuntimeTypeInfo([], t3);
        C.JSArray_methods.set$length(result, $length);
      } else {
        t4 = new Array($length);
        t4.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t4, t3);
      }
      for (i = 0; i < $length; ++i) {
        C.JSArray_methods.$indexSet(result, i, t2.elementAt$1(t1, start + i));
        t3 = t2.get$length(t1);
        if (typeof t3 !== "number")
          return t3.$lt();
        if (t3 < end)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    }
  };
  H.ListIterator.prototype = {
    get$current: function(_) {
      return this._current;
    },
    moveNext$0: function() {
      var t3, _this = this,
        t1 = _this._iterable,
        t2 = J.getInterceptor$asx(t1),
        $length = t2.get$length(t1);
      if (_this.__internal$_length != $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = _this._index;
      if (typeof $length !== "number")
        return H.iae($length);
      if (t3 >= $length) {
        _this.set$_current(null);
        return false;
      }
      _this.set$_current(t2.elementAt$1(t1, t3));
      ++_this._index;
      return true;
    },
    set$_current: function(_current) {
      this._current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  H.MappedIterable.prototype = {
    get$iterator: function(_) {
      return new H.MappedIterator(J.get$iterator$ax(this._iterable), this._f, this.$ti);
    },
    get$length: function(_) {
      return J.get$length$asx(this._iterable);
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this._iterable);
    },
    elementAt$1: function(_, index) {
      return this._f.call$1(J.elementAt$1$ax(this._iterable, index));
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.EfficientLengthMappedIterable.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    }
  };
  H.MappedIterator.prototype = {
    moveNext$0: function() {
      var _this = this,
        t1 = _this._iterator;
      if (t1.moveNext$0()) {
        _this.set$_current(_this._f.call$1(t1.get$current(t1)));
        return true;
      }
      _this.set$_current(null);
      return false;
    },
    get$current: function(_) {
      return this._current;
    },
    set$_current: function(_current) {
      this._current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 1));
    },
    $asIterator: function($S, $T) {
      return [$T];
    }
  };
  H.MappedListIterable.prototype = {
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      return this._f.call$1(J.elementAt$1$ax(this._source, index));
    },
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    },
    $asListIterable: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.WhereIterable.prototype = {
    get$iterator: function(_) {
      return new H.WhereIterator(J.get$iterator$ax(this._iterable), this._f, this.$ti);
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return new H.MappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    }
  };
  H.WhereIterator.prototype = {
    moveNext$0: function() {
      var t1, t2;
      for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
        if (H.boolConversionCheck(t2.call$1(t1.get$current(t1))))
          return true;
      return false;
    },
    get$current: function(_) {
      var t1 = this._iterator;
      return t1.get$current(t1);
    }
  };
  H.TakeIterable.prototype = {
    get$iterator: function(_) {
      return new H.TakeIterator(J.get$iterator$ax(this._iterable), this._takeCount, this.$ti);
    }
  };
  H.EfficientLengthTakeIterable.prototype = {
    get$length: function(_) {
      var iterableLength = J.get$length$asx(this._iterable),
        t1 = this._takeCount;
      if (typeof iterableLength !== "number")
        return iterableLength.$gt();
      if (iterableLength > t1)
        return t1;
      return iterableLength;
    },
    $isEfficientLengthIterable: 1
  };
  H.TakeIterator.prototype = {
    moveNext$0: function() {
      if (--this._remaining >= 0)
        return this._iterator.moveNext$0();
      this._remaining = -1;
      return false;
    },
    get$current: function(_) {
      var t1;
      if (this._remaining < 0)
        return;
      t1 = this._iterator;
      return t1.get$current(t1);
    }
  };
  H.EmptyIterator.prototype = {
    moveNext$0: function() {
      return false;
    },
    get$current: function(_) {
      return;
    },
    $isIterator: 1
  };
  H.FixedLengthListMixin.prototype = {};
  H.UnmodifiableListMixin.prototype = {
    $indexSet: function(_, index, value) {
      H.intTypeCheck(index);
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0));
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    sort$1: function(_, compare) {
      var t1 = H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    }
  };
  H.UnmodifiableListBase.prototype = {};
  H.ReversedListIterable.prototype = {
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      var t1 = this._source,
        t2 = J.getInterceptor$asx(t1),
        t3 = t2.get$length(t1);
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof index !== "number")
        return H.iae(index);
      return t2.elementAt$1(t1, t3 - 1 - index);
    }
  };
  H.Symbol.prototype = {
    get$hashCode: function(_) {
      var hash = this._hashCode;
      if (hash != null)
        return hash;
      hash = 536870911 & 664597 * J.get$hashCode$(this.__internal$_name);
      this._hashCode = hash;
      return hash;
    },
    toString$0: function(_) {
      return 'Symbol("' + H.S(this.__internal$_name) + '")';
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof H.Symbol && this.__internal$_name == other.__internal$_name;
    },
    $isSymbol0: 1
  };
  H.ConstantMapView.prototype = {};
  H.ConstantMap.prototype = {
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this);
    },
    $indexSet: function(_, key, val) {
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtypeOfRuntimeType(val, H.getTypeArgumentByIndex(this, 1));
      return H.ConstantMap__throwUnmodifiable();
    },
    $isMap: 1
  };
  H.ConstantStringMap.prototype = {
    get$length: function(_) {
      return this.__js_helper$_length;
    },
    containsKey$1: function(_, key) {
      if (typeof key !== "string")
        return false;
      if ("__proto__" === key)
        return false;
      return this._jsObject.hasOwnProperty(key);
    },
    $index: function(_, key) {
      if (!this.containsKey$1(0, key))
        return;
      return this._fetch$1(key);
    },
    _fetch$1: function(key) {
      return this._jsObject[H.stringTypeCheck(key)];
    },
    forEach$1: function(_, f) {
      var keys, t2, i, key, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 1);
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0), t1]});
      keys = _this._keys;
      for (t2 = keys.length, i = 0; i < t2; ++i) {
        key = keys[i];
        f.call$2(key, H.assertSubtypeOfRuntimeType(_this._fetch$1(key), t1));
      }
    },
    get$keys: function(_) {
      return new H._ConstantMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      var _this = this;
      return H.MappedIterable_MappedIterable(_this._keys, new H.ConstantStringMap_values_closure(_this), H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1));
    }
  };
  H.ConstantStringMap_values_closure.prototype = {
    call$1: function(key) {
      var t1 = this.$this;
      return H.assertSubtypeOfRuntimeType(t1._fetch$1(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0))), H.getTypeArgumentByIndex(t1, 1));
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
    }
  };
  H._ConstantMapKeyIterable.prototype = {
    get$iterator: function(_) {
      var t1 = this._map._keys;
      return new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    get$length: function(_) {
      return this._map._keys.length;
    }
  };
  H.GeneralConstantMap.prototype = {
    _getMap$0: function() {
      var _this = this,
        backingMap = _this.$map;
      if (backingMap == null) {
        backingMap = new H.JsLinkedHashMap(_this.$ti);
        H.fillLiteralMap(_this._jsData, backingMap);
        _this.$map = backingMap;
      }
      return backingMap;
    },
    containsKey$1: function(_, key) {
      return this._getMap$0().containsKey$1(0, key);
    },
    $index: function(_, key) {
      return this._getMap$0().$index(0, key);
    },
    forEach$1: function(_, f) {
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]});
      this._getMap$0().forEach$1(0, f);
    },
    get$keys: function(_) {
      var t1 = this._getMap$0();
      return t1.get$keys(t1);
    },
    get$values: function(_) {
      var t1 = this._getMap$0();
      return t1.get$values(t1);
    },
    get$length: function(_) {
      var t1 = this._getMap$0();
      return t1.get$length(t1);
    }
  };
  H.JSInvocationMirror.prototype = {
    get$memberName: function() {
      var t1 = this._memberName;
      return t1;
    },
    get$positionalArguments: function() {
      var t1, argumentCount, list, index, _this = this;
      if (_this._kind === 1)
        return C.List_empty0;
      t1 = _this._arguments;
      argumentCount = t1.length - _this._namedArgumentNames.length - _this._typeArgumentCount;
      if (argumentCount === 0)
        return C.List_empty0;
      list = [];
      for (index = 0; index < argumentCount; ++index) {
        if (index >= t1.length)
          return H.ioore(t1, index);
        list.push(t1[index]);
      }
      list.fixed$length = Array;
      list.immutable$list = Array;
      return list;
    },
    get$namedArguments: function() {
      var t1, namedArgumentCount, t2, namedArgumentsStartIndex, t3, map, i, t4, t5, _this = this;
      if (_this._kind !== 0)
        return C.Map_empty;
      t1 = _this._namedArgumentNames;
      namedArgumentCount = t1.length;
      t2 = _this._arguments;
      namedArgumentsStartIndex = t2.length - namedArgumentCount - _this._typeArgumentCount;
      if (namedArgumentCount === 0)
        return C.Map_empty;
      t3 = P.Symbol0;
      map = new H.JsLinkedHashMap([t3, null]);
      for (i = 0; i < namedArgumentCount; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t4 = t1[i];
        t5 = namedArgumentsStartIndex + i;
        if (t5 < 0 || t5 >= t2.length)
          return H.ioore(t2, t5);
        map.$indexSet(0, new H.Symbol(t4), t2[t5]);
      }
      return new H.ConstantMapView(map, [t3, null]);
    },
    $isInvocation: 1
  };
  H.Primitives_initTicker_closure.prototype = {
    call$0: function() {
      return C.JSNumber_methods.floor$0(1000 * this.performance.now());
    },
    $signature: 33
  };
  H.Primitives_functionNoSuchMethod_closure.prototype = {
    call$2: function($name, argument) {
      var t1;
      H.stringTypeCheck($name);
      t1 = this._box_0;
      t1.names = t1.names + "$" + H.S($name);
      C.JSArray_methods.add$1(this.namedArgumentList, $name);
      C.JSArray_methods.add$1(this.$arguments, argument);
      ++t1.argumentCount;
    },
    $signature: 56
  };
  H.TypeErrorDecoder.prototype = {
    matchTypeError$1: function(message) {
      var result, t1, _this = this,
        match = new RegExp(_this._pattern).exec(message);
      if (match == null)
        return;
      result = Object.create(null);
      t1 = _this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = _this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = _this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = _this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = _this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    }
  };
  H.NullError.prototype = {
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      return "NoSuchMethodError: method not found: '" + t1 + "' on null";
    }
  };
  H.JsNoSuchMethodError.prototype = {
    toString$0: function(_) {
      var t2, _this = this,
        _s38_ = "NoSuchMethodError: method not found: '",
        t1 = _this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(_this._message);
      t2 = _this._receiver;
      if (t2 == null)
        return _s38_ + t1 + "' (" + H.S(_this._message) + ")";
      return _s38_ + t1 + "' on '" + t2 + "' (" + H.S(_this._message) + ")";
    }
  };
  H.UnknownJsTypeError.prototype = {
    toString$0: function(_) {
      var t1 = this._message;
      return t1.length === 0 ? "Error" : "Error: " + t1;
    }
  };
  H.ExceptionAndStackTrace.prototype = {};
  H.unwrapException_saveStackTrace.prototype = {
    call$1: function(error) {
      if (!!J.getInterceptor$(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this.ex;
      return error;
    },
    $signature: 15
  };
  H._StackTrace.prototype = {
    toString$0: function(_) {
      var trace,
        t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this.__js_helper$_exception;
      trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
      return this._trace = trace == null ? "" : trace;
    },
    $isStackTrace: 1
  };
  H.Closure.prototype = {
    toString$0: function(_) {
      return "Closure '" + H.Primitives_objectTypeName(this).trim() + "'";
    },
    $isFunction: 1,
    get$$call: function() {
      return this;
    },
    "call*": "call$1",
    $requiredArgCount: 1,
    $defaultValues: null
  };
  H.TearOffClosure.prototype = {};
  H.StaticClosure.prototype = {
    toString$0: function(_) {
      var $name = this.$static_name;
      if ($name == null)
        return "Closure of unknown static method";
      return "Closure '" + H.unminifyOrTag($name) + "'";
    }
  };
  H.BoundClosure.prototype = {
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof H.BoundClosure))
        return false;
      return _this._self === other._self && _this._target === other._target && _this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var receiverHashCode,
        t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      return (receiverHashCode ^ H.Primitives_objectHashCode(this._target)) >>> 0;
    },
    toString$0: function(_) {
      var receiver = this._receiver;
      if (receiver == null)
        receiver = this._self;
      return "Closure '" + H.S(this.__js_helper$_name) + "' of " + ("Instance of '" + H.Primitives_objectTypeName(receiver) + "'");
    }
  };
  H.TypeErrorImplementation.prototype = {
    toString$0: function(_) {
      return this.message;
    },
    $isAssertionError: 1,
    get$message: function(receiver) {
      return this.message;
    }
  };
  H.CastErrorImplementation.prototype = {
    toString$0: function(_) {
      return this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  H.RuntimeError.prototype = {
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  H._AssertionError.prototype = {
    toString$0: function(_) {
      return "Assertion failed: " + P.Error_safeToString(this.message);
    }
  };
  H.TypeImpl.prototype = {
    get$_typeName: function() {
      var t1 = this.__typeName;
      return t1 == null ? this.__typeName = H.runtimeTypeToString(this._rti) : t1;
    },
    toString$0: function(_) {
      return this.get$_typeName();
    },
    get$hashCode: function(_) {
      var t1 = this._hashCode;
      return t1 == null ? this._hashCode = C.JSString_methods.get$hashCode(this.get$_typeName()) : t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof H.TypeImpl && this.get$_typeName() === other.get$_typeName();
    },
    $isType: 1
  };
  H.JsLinkedHashMap.prototype = {
    get$length: function(_) {
      return this.__js_helper$_length;
    },
    get$isEmpty: function(_) {
      return this.__js_helper$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    get$keys: function(_) {
      return new H.LinkedHashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      var _this = this;
      return H.MappedIterable_MappedIterable(_this.get$keys(_this), new H.JsLinkedHashMap_values_closure(_this), H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1));
    },
    containsKey$1: function(_, key) {
      var strings, nums, _this = this;
      if (typeof key === "string") {
        strings = _this._strings;
        if (strings == null)
          return false;
        return _this._containsTableEntry$2(strings, key);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        if (nums == null)
          return false;
        return _this._containsTableEntry$2(nums, key);
      } else
        return _this.internalContainsKey$1(key);
    },
    internalContainsKey$1: function(key) {
      var _this = this,
        rest = _this._rest;
      if (rest == null)
        return false;
      return _this.internalFindBucketIndex$2(_this._getTableBucket$2(rest, _this.internalComputeHashCode$1(key)), key) >= 0;
    },
    addAll$1: function(_, other) {
      H.assertSubtype(other, "$isMap", this.$ti, "$asMap").forEach$1(0, new H.JsLinkedHashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, cell, t1, nums, _this = this;
      if (typeof key === "string") {
        strings = _this._strings;
        if (strings == null)
          return;
        cell = _this._getTableCell$2(strings, key);
        t1 = cell == null ? null : cell.hashMapCellValue;
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        if (nums == null)
          return;
        cell = _this._getTableCell$2(nums, key);
        t1 = cell == null ? null : cell.hashMapCellValue;
        return t1;
      } else
        return _this.internalGet$1(key);
    },
    internalGet$1: function(key) {
      var bucket, index, _this = this,
        rest = _this._rest;
      if (rest == null)
        return;
      bucket = _this._getTableBucket$2(rest, _this.internalComputeHashCode$1(key));
      index = _this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      return bucket[index].hashMapCellValue;
    },
    $indexSet: function(_, key, value) {
      var strings, nums, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      if (typeof key === "string") {
        strings = _this._strings;
        _this._addHashTableEntry$3(strings == null ? _this._strings = _this._newHashTable$0() : strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        _this._addHashTableEntry$3(nums == null ? _this._nums = _this._newHashTable$0() : nums, key, value);
      } else
        _this.internalSet$2(key, value);
    },
    internalSet$2: function(key, value) {
      var rest, hash, bucket, index, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      rest = _this._rest;
      if (rest == null)
        rest = _this._rest = _this._newHashTable$0();
      hash = _this.internalComputeHashCode$1(key);
      bucket = _this._getTableBucket$2(rest, hash);
      if (bucket == null)
        _this._setTableEntry$3(rest, hash, [_this._newLinkedCell$2(key, value)]);
      else {
        index = _this.internalFindBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].hashMapCellValue = value;
        else
          bucket.push(_this._newLinkedCell$2(key, value));
      }
    },
    putIfAbsent$2: function(_, key, ifAbsent) {
      var value, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.functionTypeCheck(ifAbsent, {func: 1, ret: H.getTypeArgumentByIndex(_this, 1)});
      if (_this.containsKey$1(0, key))
        return _this.$index(0, key);
      value = ifAbsent.call$0();
      _this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      var _this = this;
      if (typeof key === "string")
        return _this._removeHashTableEntry$2(_this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return _this._removeHashTableEntry$2(_this._nums, key);
      else
        return _this.internalRemove$1(key);
    },
    internalRemove$1: function(key) {
      var bucket, index, cell, _this = this,
        rest = _this._rest;
      if (rest == null)
        return;
      bucket = _this._getTableBucket$2(rest, _this.internalComputeHashCode$1(key));
      index = _this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      cell = bucket.splice(index, 1)[0];
      _this._unlinkCell$1(cell);
      return cell.hashMapCellValue;
    },
    clear$0: function(_) {
      var _this = this;
      if (_this.__js_helper$_length > 0) {
        _this._strings = _this._nums = _this._rest = _this._first = _this._last = null;
        _this.__js_helper$_length = 0;
        _this._modified$0();
      }
    },
    forEach$1: function(_, action) {
      var cell, modifications, _this = this;
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1)]});
      cell = _this._first;
      modifications = _this._modifications;
      for (; cell != null;) {
        action.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
        if (modifications !== _this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      cell = _this._getTableCell$2(table, key);
      if (cell == null)
        _this._setTableEntry$3(table, key, _this._newLinkedCell$2(key, value));
      else
        cell.hashMapCellValue = value;
    },
    _removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return;
      cell = this._getTableCell$2(table, key);
      if (cell == null)
        return;
      this._unlinkCell$1(cell);
      this._deleteTableEntry$2(table, key);
      return cell.hashMapCellValue;
    },
    _modified$0: function() {
      this._modifications = this._modifications + 1 & 67108863;
    },
    _newLinkedCell$2: function(key, value) {
      var last, _this = this,
        cell = new H.LinkedHashMapCell(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1)));
      if (_this._first == null)
        _this._first = _this._last = cell;
      else {
        last = _this._last;
        cell._previous = last;
        _this._last = last._next = cell;
      }
      ++_this.__js_helper$_length;
      _this._modified$0();
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var _this = this,
        previous = cell._previous,
        next = cell._next;
      if (previous == null)
        _this._first = next;
      else
        previous._next = next;
      if (next == null)
        _this._last = previous;
      else
        next._previous = previous;
      --_this.__js_helper$_length;
      _this._modified$0();
    },
    internalComputeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i].hashMapCellKey, key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this);
    },
    _getTableCell$2: function(table, key) {
      return table[key];
    },
    _getTableBucket$2: function(table, key) {
      return table[key];
    },
    _setTableEntry$3: function(table, key, value) {
      table[key] = value;
    },
    _deleteTableEntry$2: function(table, key) {
      delete table[key];
    },
    _containsTableEntry$2: function(table, key) {
      return this._getTableCell$2(table, key) != null;
    },
    _newHashTable$0: function() {
      var _s20_ = "<non-identifier-key>",
        table = Object.create(null);
      this._setTableEntry$3(table, _s20_, table);
      this._deleteTableEntry$2(table, _s20_);
      return table;
    },
    $isLinkedHashMap: 1
  };
  H.JsLinkedHashMap_values_closure.prototype = {
    call$1: function(each) {
      var t1 = this.$this;
      return t1.$index(0, H.assertSubtypeOfRuntimeType(each, H.getTypeArgumentByIndex(t1, 0)));
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
    }
  };
  H.JsLinkedHashMap_addAll_closure.prototype = {
    call$2: function(key, value) {
      var t1 = this.$this;
      t1.$indexSet(0, H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(t1, 1)));
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
    }
  };
  H.LinkedHashMapCell.prototype = {};
  H.LinkedHashMapKeyIterable.prototype = {
    get$length: function(_) {
      return this._map.__js_helper$_length;
    },
    get$isEmpty: function(_) {
      return this._map.__js_helper$_length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._map,
        t2 = new H.LinkedHashMapKeyIterator(t1, t1._modifications, this.$ti);
      t2._cell = t1._first;
      return t2;
    },
    contains$1: function(_, element) {
      return this._map.containsKey$1(0, element);
    },
    forEach$1: function(_, f) {
      var t1, cell, modifications;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
      t1 = this._map;
      cell = t1._first;
      modifications = t1._modifications;
      for (; cell != null;) {
        f.call$1(cell.hashMapCellKey);
        if (modifications !== t1._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        cell = cell._next;
      }
    }
  };
  H.LinkedHashMapKeyIterator.prototype = {
    get$current: function(_) {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var _this = this,
        t1 = _this._map;
      if (_this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = _this._cell;
        if (t1 == null) {
          _this.set$__js_helper$_current(null);
          return false;
        } else {
          _this.set$__js_helper$_current(t1.hashMapCellKey);
          _this._cell = _this._cell._next;
          return true;
        }
      }
    },
    set$__js_helper$_current: function(_current) {
      this.__js_helper$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  H.initHooks_closure.prototype = {
    call$1: function(o) {
      return this.getTag(o);
    },
    $signature: 15
  };
  H.initHooks_closure0.prototype = {
    call$2: function(o, tag) {
      return this.getUnknownTag(o, tag);
    },
    $signature: 98
  };
  H.initHooks_closure1.prototype = {
    call$1: function(tag) {
      return this.prototypeForTag(H.stringTypeCheck(tag));
    },
    $signature: 102
  };
  H.JSSyntaxRegExp.prototype = {
    toString$0: function(_) {
      return "RegExp/" + this.pattern + "/";
    },
    firstMatch$1: function(string) {
      var m;
      if (typeof string !== "string")
        H.throwExpression(H.argumentErrorValue(string));
      m = this._nativeRegExp.exec(string);
      if (m == null)
        return;
      return new H._MatchImplementation(m);
    },
    $isPattern: 1,
    $isRegExp: 1
  };
  H._MatchImplementation.prototype = {
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._match;
      if (index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    }
  };
  H.StringMatch.prototype = {
    $index: function(_, g) {
      H.intTypeCheck(g);
      if (g !== 0)
        H.throwExpression(P.RangeError$value(g, null));
      return this.pattern;
    }
  };
  H.NativeByteBuffer.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_ByteBuffer_RkP;
    },
    asInt64List$2: function(receiver, offsetInBytes, $length) {
      throw H.wrapException(P.UnsupportedError$("Int64List not supported by dart2js."));
    },
    $isNativeByteBuffer: 1,
    $isByteBuffer: 1
  };
  H.NativeTypedData.prototype = {$isNativeTypedData: 1};
  H.NativeByteData.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_ByteData_zNC;
    },
    getInt64$2: function(receiver, byteOffset, endian) {
      throw H.wrapException(P.UnsupportedError$("Int64 accessor not supported by dart2js."));
    },
    $isByteData: 1
  };
  H.NativeTypedArray.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
    }
  };
  H.NativeTypedArrayOfDouble.prototype = {
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.doubleTypeCheck(value);
      H._checkValidIndex(index, receiver, receiver.length);
      receiver[index] = value;
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.double];
    },
    $asFixedLengthListMixin: function() {
      return [P.double];
    },
    $asListMixin: function() {
      return [P.double];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.double];
    },
    $isList: 1,
    $asList: function() {
      return [P.double];
    }
  };
  H.NativeTypedArrayOfInt.prototype = {
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.intTypeCheck(value);
      H._checkValidIndex(index, receiver, receiver.length);
      receiver[index] = value;
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $asFixedLengthListMixin: function() {
      return [P.int];
    },
    $asListMixin: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  H.NativeFloat32List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Float32List_LB7;
    }
  };
  H.NativeFloat64List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Float64List_LB7;
    },
    $isFloat64List: 1
  };
  H.NativeInt16List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Int16List_uXf;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeInt32List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Int32List_O50;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isInt32List: 1
  };
  H.NativeInt8List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Int8List_ekJ;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeUint16List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Uint16List_2bx;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeUint32List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Uint32List_2bx;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeUint8ClampedList.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Uint8ClampedList_Jik;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeUint8List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Uint8List_WLA;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isNativeUint8List: 1,
    $isUint8List: 1
  };
  H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.prototype = {};
  H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.prototype = {};
  H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  P._AsyncRun__initializeScheduleImmediate_internalCallback.prototype = {
    call$1: function(_) {
      var t1 = this._box_0,
        f = t1.storedCallback;
      t1.storedCallback = null;
      f.call$0();
    },
    $signature: 4
  };
  P._AsyncRun__initializeScheduleImmediate_closure.prototype = {
    call$1: function(callback) {
      var t1, t2;
      this._box_0.storedCallback = H.functionTypeCheck(callback, {func: 1, ret: -1});
      t1 = this.div;
      t2 = this.span;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    },
    $signature: 81
  };
  P._AsyncRun__scheduleImmediateJsOverride_internalCallback.prototype = {
    call$0: function() {
      this.callback.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback.prototype = {
    call$0: function() {
      this.callback.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._TimerImpl.prototype = {
    _TimerImpl$2: function(milliseconds, callback) {
      if (self.setTimeout != null)
        this._handle = self.setTimeout(H.convertDartClosureToJS(new P._TimerImpl_internalCallback(this, callback), 0), milliseconds);
      else
        throw H.wrapException(P.UnsupportedError$("`setTimeout()` not found."));
    },
    _TimerImpl$periodic$2: function(milliseconds, callback) {
      if (self.setTimeout != null)
        this._handle = self.setInterval(H.convertDartClosureToJS(new P._TimerImpl$periodic_closure(this, milliseconds, Date.now(), callback), 0), milliseconds);
      else
        throw H.wrapException(P.UnsupportedError$("Periodic timer."));
    },
    cancel$0: function(_) {
      var t1;
      if (self.setTimeout != null) {
        t1 = this._handle;
        if (t1 == null)
          return;
        if (this._once)
          self.clearTimeout(t1);
        else
          self.clearInterval(t1);
        this._handle = null;
      } else
        throw H.wrapException(P.UnsupportedError$("Canceling a timer."));
    },
    $isTimer: 1
  };
  P._TimerImpl_internalCallback.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._handle = null;
      t1._tick = 1;
      this.callback.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  P._TimerImpl$periodic_closure.prototype = {
    call$0: function() {
      var duration, _this = this,
        t1 = _this.$this,
        tick = t1._tick + 1,
        t2 = _this.milliseconds;
      if (t2 > 0) {
        duration = Date.now() - _this.start;
        if (duration > (tick + 1) * t2)
          tick = C.JSInt_methods.$tdiv(duration, t2);
      }
      t1._tick = tick;
      _this.callback.call$1(t1);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._AsyncAwaitCompleter.prototype = {
    complete$1: function(_, value) {
      var t1, _this = this;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(_this, 0)});
      if (_this.isSync)
        _this._completer.complete$1(0, value);
      else if (H.checkSubtype(value, "$isFuture", _this.$ti, "$asFuture")) {
        t1 = _this._completer;
        value.then$1$2$onError(t1.get$complete(t1), t1.get$completeError(), -1);
      } else
        P.scheduleMicrotask(new P._AsyncAwaitCompleter_complete_closure(_this, value));
    },
    completeError$2: function(e, st) {
      if (this.isSync)
        this._completer.completeError$2(e, st);
      else
        P.scheduleMicrotask(new P._AsyncAwaitCompleter_completeError_closure(this, e, st));
    },
    $isCompleter: 1
  };
  P._AsyncAwaitCompleter_complete_closure.prototype = {
    call$0: function() {
      this.$this._completer.complete$1(0, this.value);
    },
    $signature: 0
  };
  P._AsyncAwaitCompleter_completeError_closure.prototype = {
    call$0: function() {
      this.$this._completer.completeError$2(this.e, this.st);
    },
    $signature: 0
  };
  P._awaitOnObject_closure.prototype = {
    call$1: function(result) {
      return this.bodyFunction.call$2(0, result);
    },
    $signature: 3
  };
  P._awaitOnObject_closure0.prototype = {
    call$2: function(error, stackTrace) {
      this.bodyFunction.call$2(1, new H.ExceptionAndStackTrace(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace")));
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 28
  };
  P._wrapJsFunctionForAsync_closure.prototype = {
    call$2: function(errorCode, result) {
      this.$protected(H.intTypeCheck(errorCode), result);
    },
    $signature: 49
  };
  P._asyncStarHelper_closure.prototype = {
    call$0: function() {
      var t1 = this.controller,
        t2 = t1.controller,
        t3 = t2._state;
      if ((t3 & 1) !== 0 ? (t2.get$_subscription()._state & 4) !== 0 : (t3 & 2) === 0) {
        t1.isSuspended = true;
        return;
      }
      this.bodyFunctionOrErrorCode.call$2(null, 0);
    },
    $signature: 0
  };
  P._asyncStarHelper_closure0.prototype = {
    call$1: function(_) {
      var errorCode = this.controller.cancelationCompleter != null ? 2 : 0;
      this.bodyFunctionOrErrorCode.call$2(errorCode, null);
    },
    $signature: 4
  };
  P._AsyncStarStreamController.prototype = {
    _AsyncStarStreamController$1: function(body, $T) {
      var t1 = new P._AsyncStarStreamController__resumeBody(body);
      this.set$controller(0, new P._AsyncStreamController(new P._AsyncStarStreamController_closure(t1), null, new P._AsyncStarStreamController_closure0(this, t1), new P._AsyncStarStreamController_closure1(this, body), [$T]));
    },
    set$controller: function(_, controller) {
      this.controller = H.assertSubtype(controller, "$isStreamController", this.$ti, "$asStreamController");
    }
  };
  P._AsyncStarStreamController__resumeBody.prototype = {
    call$0: function() {
      P.scheduleMicrotask(new P._AsyncStarStreamController__resumeBody_closure(this.body));
    },
    $signature: 0
  };
  P._AsyncStarStreamController__resumeBody_closure.prototype = {
    call$0: function() {
      this.body.call$2(0, null);
    },
    $signature: 0
  };
  P._AsyncStarStreamController_closure.prototype = {
    call$0: function() {
      this._resumeBody.call$0();
    },
    $signature: 0
  };
  P._AsyncStarStreamController_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1.isSuspended) {
        t1.isSuspended = false;
        this._resumeBody.call$0();
      }
    },
    $signature: 0
  };
  P._AsyncStarStreamController_closure1.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if ((t1.controller._state & 4) === 0) {
        t1.cancelationCompleter = new P._AsyncCompleter(new P._Future($.Zone__current, [null]), [null]);
        if (t1.isSuspended) {
          t1.isSuspended = false;
          P.scheduleMicrotask(new P._AsyncStarStreamController__closure(this.body));
        }
        return t1.cancelationCompleter.future;
      }
    },
    $signature: 103
  };
  P._AsyncStarStreamController__closure.prototype = {
    call$0: function() {
      this.body.call$2(2, null);
    },
    $signature: 0
  };
  P._IterationMarker.prototype = {
    toString$0: function(_) {
      return "IterationMarker(" + this.state + ", " + H.S(this.value) + ")";
    }
  };
  P._SyncStarIterator.prototype = {
    get$current: function(_) {
      var t1 = this._nestedIterator;
      if (t1 == null)
        return this._async$_current;
      return H.assertSubtypeOfRuntimeType(t1.get$current(t1), H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1, value, state, inner, _this = this;
      for (; true;) {
        t1 = _this._nestedIterator;
        if (t1 != null)
          if (t1.moveNext$0())
            return true;
          else
            _this._nestedIterator = null;
        value = function(body, SUCCESS, ERROR) {
          var errorValue,
            errorCode = SUCCESS;
          while (true)
            try {
              return body(errorCode, errorValue);
            } catch (error) {
              errorValue = error;
              errorCode = ERROR;
            }
        }(_this._body, 0, 1);
        if (value instanceof P._IterationMarker) {
          state = value.state;
          if (state === 2) {
            t1 = _this._suspendedBodies;
            if (t1 == null || t1.length === 0) {
              _this.set$_async$_current(null);
              return false;
            }
            if (0 >= t1.length)
              return H.ioore(t1, -1);
            _this._body = t1.pop();
            continue;
          } else {
            t1 = value.value;
            if (state === 3)
              throw t1;
            else {
              inner = J.get$iterator$ax(t1);
              if (!!inner.$is_SyncStarIterator) {
                t1 = _this._suspendedBodies;
                if (t1 == null)
                  t1 = _this._suspendedBodies = [];
                C.JSArray_methods.add$1(t1, _this._body);
                _this._body = inner._body;
                continue;
              } else {
                _this._nestedIterator = inner;
                continue;
              }
            }
          }
        } else {
          _this.set$_async$_current(value);
          return true;
        }
      }
      return false;
    },
    set$_async$_current: function(_current) {
      this._async$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P._SyncStarIterable.prototype = {
    get$iterator: function(_) {
      return new P._SyncStarIterator(this._outerHelper(), this.$ti);
    }
  };
  P.Future.prototype = {};
  P.Future_Future$delayed_closure.prototype = {
    call$0: function() {
      this.result._complete$1(null);
    },
    $signature: 0
  };
  P.Future_wait_handleError.prototype = {
    call$2: function(theError, theStackTrace) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(theStackTrace, "$isStackTrace");
      t1 = _this._box_0;
      t2 = --t1.remaining;
      if (t1.values != null) {
        t1.values = null;
        if (t1.remaining === 0 || _this.eagerError)
          _this.result._completeError$2(theError, theStackTrace);
        else {
          t1.error = theError;
          t1.stackTrace = theStackTrace;
        }
      } else if (t2 === 0 && !_this.eagerError)
        _this.result._completeError$2(t1.error, t1.stackTrace);
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 28
  };
  P.Future_wait_closure.prototype = {
    call$1: function(value) {
      var t1, t2, _this = this;
      H.assertSubtypeOfRuntimeType(value, _this.T);
      t1 = _this._box_0;
      --t1.remaining;
      t2 = t1.values;
      if (t2 != null) {
        C.JSArray_methods.$indexSet(t2, _this.pos, value);
        if (t1.remaining === 0)
          _this.result._completeWithValue$1(t1.values);
      } else if (t1.remaining === 0 && !_this.eagerError)
        _this.result._completeError$2(t1.error, t1.stackTrace);
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [this.T]};
    }
  };
  P._Completer.prototype = {
    completeError$2: function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      if (error == null)
        error = new P.NullThrownError();
      if (this.future._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      $.Zone__current.toString;
      this._completeError$2(error, stackTrace);
    },
    completeError$1: function(error) {
      return this.completeError$2(error, null);
    },
    $isCompleter: 1
  };
  P._AsyncCompleter.prototype = {
    complete$1: function(_, value) {
      var t1;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(this, 0)});
      t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncComplete$1(value);
    },
    complete$0: function($receiver) {
      return this.complete$1($receiver, null);
    },
    _completeError$2: function(error, stackTrace) {
      this.future._asyncCompleteError$2(error, stackTrace);
    }
  };
  P._SyncCompleter.prototype = {
    complete$1: function(_, value) {
      var t1;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(this, 0)});
      t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._complete$1(value);
    },
    complete$0: function($receiver) {
      return this.complete$1($receiver, null);
    },
    _completeError$2: function(error, stackTrace) {
      this.future._completeError$2(error, stackTrace);
    }
  };
  P._FutureListener.prototype = {
    matchesErrorTest$1: function(asyncError) {
      if (this.state !== 6)
        return true;
      return this.result._zone.runUnary$2$2(H.functionTypeCheck(this.callback, {func: 1, ret: P.bool, args: [P.Object]}), asyncError.error, P.bool, P.Object);
    },
    handleError$1: function(asyncError) {
      var errorCallback = this.errorCallback,
        t1 = P.Object,
        t2 = {futureOr: 1, type: H.getTypeArgumentByIndex(this, 1)},
        t3 = this.result._zone;
      if (H.functionTypeTest(errorCallback, {func: 1, args: [P.Object, P.StackTrace]}))
        return H.futureOrCheck(t3.runBinary$3$3(errorCallback, asyncError.error, asyncError.stackTrace, null, t1, P.StackTrace), t2);
      else
        return H.futureOrCheck(t3.runUnary$2$2(H.functionTypeCheck(errorCallback, {func: 1, args: [P.Object]}), asyncError.error, null, t1), t2);
    },
    get$callback: function() {
      return this.callback;
    }
  };
  P._Future.prototype = {
    then$1$2$onError: function(f, onError, $R) {
      var currentZone,
        t1 = H.getTypeArgumentByIndex(this, 0);
      H.functionTypeCheck(f, {func: 1, ret: {futureOr: 1, type: $R}, args: [t1]});
      currentZone = $.Zone__current;
      if (currentZone !== C.C__RootZone) {
        currentZone.toString;
        H.functionTypeCheck(f, {func: 1, ret: {futureOr: 1, type: $R}, args: [t1]});
        if (onError != null)
          onError = P._registerErrorHandler(onError, currentZone);
      }
      return this._thenNoZoneRegistration$1$2(f, onError, $R);
    },
    then$1$1: function(f, $R) {
      return this.then$1$2$onError(f, null, $R);
    },
    then$1: function(f) {
      return this.then$1$2$onError(f, null, null);
    },
    _thenNoZoneRegistration$1$2: function(f, onError, $E) {
      var result, t2,
        t1 = H.getTypeArgumentByIndex(this, 0);
      H.functionTypeCheck(f, {func: 1, ret: {futureOr: 1, type: $E}, args: [t1]});
      result = new P._Future($.Zone__current, [$E]);
      t2 = onError == null ? 1 : 3;
      this._addListener$1(new P._FutureListener(result, t2, f, onError, [t1, $E]));
      return result;
    },
    whenComplete$1: function(action) {
      var t1, result;
      H.functionTypeCheck(action, {func: 1});
      t1 = $.Zone__current;
      result = new P._Future(t1, this.$ti);
      if (t1 !== C.C__RootZone) {
        t1.toString;
        H.functionTypeCheck(action, {func: 1, ret: null});
      }
      t1 = H.getTypeArgumentByIndex(this, 0);
      this._addListener$1(new P._FutureListener(result, 8, action, null, [t1, t1]));
      return result;
    },
    _addListener$1: function(listener) {
      var source, _this = this,
        t1 = _this._state;
      if (t1 <= 1) {
        listener._nextListener = H.interceptedTypeCheck(_this._resultOrListeners, "$is_FutureListener");
        _this._resultOrListeners = listener;
      } else {
        if (t1 === 2) {
          source = H.interceptedTypeCheck(_this._resultOrListeners, "$is_Future");
          t1 = source._state;
          if (t1 < 4) {
            source._addListener$1(listener);
            return;
          }
          _this._state = t1;
          _this._resultOrListeners = source._resultOrListeners;
        }
        t1 = _this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, H.functionTypeCheck(new P._Future__addListener_closure(_this, listener), {func: 1, ret: -1}));
      }
    },
    _prependListeners$1: function(listeners) {
      var t1, existingListeners, cursor, cursor0, source, _this = this, _box_0 = {};
      _box_0.listeners = listeners;
      if (listeners == null)
        return;
      t1 = _this._state;
      if (t1 <= 1) {
        existingListeners = H.interceptedTypeCheck(_this._resultOrListeners, "$is_FutureListener");
        cursor = _this._resultOrListeners = listeners;
        if (existingListeners != null) {
          for (; cursor0 = cursor._nextListener, cursor0 != null; cursor = cursor0)
            ;
          cursor._nextListener = existingListeners;
        }
      } else {
        if (t1 === 2) {
          source = H.interceptedTypeCheck(_this._resultOrListeners, "$is_Future");
          t1 = source._state;
          if (t1 < 4) {
            source._prependListeners$1(listeners);
            return;
          }
          _this._state = t1;
          _this._resultOrListeners = source._resultOrListeners;
        }
        _box_0.listeners = _this._reverseListeners$1(listeners);
        t1 = _this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, H.functionTypeCheck(new P._Future__prependListeners_closure(_box_0, _this), {func: 1, ret: -1}));
      }
    },
    _removeListeners$0: function() {
      var current = H.interceptedTypeCheck(this._resultOrListeners, "$is_FutureListener");
      this._resultOrListeners = null;
      return this._reverseListeners$1(current);
    },
    _reverseListeners$1: function(listeners) {
      var current, prev, next;
      for (current = listeners, prev = null; current != null; prev = current, current = next) {
        next = current._nextListener;
        current._nextListener = prev;
      }
      return prev;
    },
    _complete$1: function(value) {
      var t2, listeners, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.futureOrCheck(value, {futureOr: 1, type: t1});
      t2 = _this.$ti;
      if (H.checkSubtype(value, "$isFuture", t2, "$asFuture"))
        if (H.checkSubtype(value, "$is_Future", t2, null))
          P._Future__chainCoreFuture(value, _this);
        else
          P._Future__chainForeignFuture(value, _this);
      else {
        listeners = _this._removeListeners$0();
        H.assertSubtypeOfRuntimeType(value, t1);
        _this._state = 4;
        _this._resultOrListeners = value;
        P._Future__propagateToListeners(_this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var listeners, _this = this;
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 0));
      listeners = _this._removeListeners$0();
      _this._state = 4;
      _this._resultOrListeners = value;
      P._Future__propagateToListeners(_this, listeners);
    },
    _completeError$2: function(error, stackTrace) {
      var listeners, _this = this;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      listeners = _this._removeListeners$0();
      _this._state = 8;
      _this._resultOrListeners = new P.AsyncError(error, stackTrace);
      P._Future__propagateToListeners(_this, listeners);
    },
    _completeError$1: function(error) {
      return this._completeError$2(error, null);
    },
    _asyncComplete$1: function(value) {
      var t1, _this = this;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(_this, 0)});
      if (H.checkSubtype(value, "$isFuture", _this.$ti, "$asFuture")) {
        _this._chainFuture$1(value);
        return;
      }
      _this._state = 1;
      t1 = _this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, H.functionTypeCheck(new P._Future__asyncComplete_closure(_this, value), {func: 1, ret: -1}));
    },
    _chainFuture$1: function(value) {
      var _this = this,
        t1 = _this.$ti;
      H.assertSubtype(value, "$isFuture", t1, "$asFuture");
      if (H.checkSubtype(value, "$is_Future", t1, null)) {
        if (value._state === 8) {
          _this._state = 1;
          t1 = _this._zone;
          t1.toString;
          P._rootScheduleMicrotask(null, null, t1, H.functionTypeCheck(new P._Future__chainFuture_closure(_this, value), {func: 1, ret: -1}));
        } else
          P._Future__chainCoreFuture(value, _this);
        return;
      }
      P._Future__chainForeignFuture(value, _this);
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      var t1;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      this._state = 1;
      t1 = this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, H.functionTypeCheck(new P._Future__asyncCompleteError_closure(this, error, stackTrace), {func: 1, ret: -1}));
    },
    $isFuture: 1
  };
  P._Future__addListener_closure.prototype = {
    call$0: function() {
      P._Future__propagateToListeners(this.$this, this.listener);
    },
    $signature: 0
  };
  P._Future__prependListeners_closure.prototype = {
    call$0: function() {
      P._Future__propagateToListeners(this.$this, this._box_0.listeners);
    },
    $signature: 0
  };
  P._Future__chainForeignFuture_closure.prototype = {
    call$1: function(value) {
      var t1 = this.target;
      t1._state = 0;
      t1._complete$1(value);
    },
    $signature: 4
  };
  P._Future__chainForeignFuture_closure0.prototype = {
    call$2: function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      this.target._completeError$2(error, stackTrace);
    },
    call$1: function(error) {
      return this.call$2(error, null);
    },
    "call*": "call$2",
    $defaultValues: function() {
      return [null];
    },
    $signature: 46
  };
  P._Future__chainForeignFuture_closure1.prototype = {
    call$0: function() {
      this.target._completeError$2(this.e, this.s);
    },
    $signature: 0
  };
  P._Future__asyncComplete_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._completeWithValue$1(H.assertSubtypeOfRuntimeType(this.value, H.getTypeArgumentByIndex(t1, 0)));
    },
    $signature: 0
  };
  P._Future__chainFuture_closure.prototype = {
    call$0: function() {
      P._Future__chainCoreFuture(this.value, this.$this);
    },
    $signature: 0
  };
  P._Future__asyncCompleteError_closure.prototype = {
    call$0: function() {
      this.$this._completeError$2(this.error, this.stackTrace);
    },
    $signature: 0
  };
  P._Future__propagateToListeners_handleWhenCompleteCallback.prototype = {
    call$0: function() {
      var e, s, t1, exception, t2, originalSource, _this = this, completeResult = null;
      try {
        t1 = _this.listener;
        completeResult = t1.result._zone.run$1$1(H.functionTypeCheck(t1.callback, {func: 1}), null);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        if (_this.hasError) {
          t1 = H.interceptedTypeCheck(_this._box_1.source._resultOrListeners, "$isAsyncError").error;
          t2 = e;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        t2 = _this._box_0;
        if (t1)
          t2.listenerValueOrError = H.interceptedTypeCheck(_this._box_1.source._resultOrListeners, "$isAsyncError");
        else
          t2.listenerValueOrError = new P.AsyncError(e, s);
        t2.listenerHasError = true;
        return;
      }
      if (!!J.getInterceptor$(completeResult).$isFuture) {
        if (completeResult instanceof P._Future && completeResult._state >= 4) {
          if (completeResult._state === 8) {
            t1 = _this._box_0;
            t1.listenerValueOrError = H.interceptedTypeCheck(completeResult._resultOrListeners, "$isAsyncError");
            t1.listenerHasError = true;
          }
          return;
        }
        originalSource = _this._box_1.source;
        t1 = _this._box_0;
        t1.listenerValueOrError = completeResult.then$1$1(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(originalSource), null);
        t1.listenerHasError = false;
      }
    },
    $signature: 1
  };
  P._Future__propagateToListeners_handleWhenCompleteCallback_closure.prototype = {
    call$1: function(_) {
      return this.originalSource;
    },
    $signature: 67
  };
  P._Future__propagateToListeners_handleValueCallback.prototype = {
    call$0: function() {
      var e, s, t1, t2, t3, t4, exception, _this = this;
      try {
        t1 = _this.listener;
        t2 = H.getTypeArgumentByIndex(t1, 0);
        t3 = H.assertSubtypeOfRuntimeType(_this.sourceResult, t2);
        t4 = H.getTypeArgumentByIndex(t1, 1);
        _this._box_0.listenerValueOrError = t1.result._zone.runUnary$2$2(H.functionTypeCheck(t1.callback, {func: 1, ret: {futureOr: 1, type: t4}, args: [t2]}), t3, {futureOr: 1, type: t4}, t2);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = _this._box_0;
        t1.listenerValueOrError = new P.AsyncError(e, s);
        t1.listenerHasError = true;
      }
    },
    $signature: 1
  };
  P._Future__propagateToListeners_handleError.prototype = {
    call$0: function() {
      var asyncError, e, s, t1, t2, exception, t3, t4, _this = this;
      try {
        asyncError = H.interceptedTypeCheck(_this._box_1.source._resultOrListeners, "$isAsyncError");
        t1 = _this.listener;
        if (H.boolConversionCheck(t1.matchesErrorTest$1(asyncError)) && t1.errorCallback != null) {
          t2 = _this._box_0;
          t2.listenerValueOrError = t1.handleError$1(asyncError);
          t2.listenerHasError = false;
        }
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = H.interceptedTypeCheck(_this._box_1.source._resultOrListeners, "$isAsyncError");
        t2 = t1.error;
        t3 = e;
        t4 = _this._box_0;
        if (t2 == null ? t3 == null : t2 === t3)
          t4.listenerValueOrError = t1;
        else
          t4.listenerValueOrError = new P.AsyncError(e, s);
        t4.listenerHasError = true;
      }
    },
    $signature: 1
  };
  P._AsyncCallbackEntry.prototype = {
    get$callback: function() {
      return this.callback;
    }
  };
  P.Stream.prototype = {
    get$length: function(_) {
      var t1 = {},
        future = new P._Future($.Zone__current, [P.int]);
      t1.count = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1, this), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    },
    get$isEmpty: function(_) {
      var t1 = {},
        future = new P._Future($.Zone__current, [P.bool]);
      t1.subscription = null;
      t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_isEmpty_closure(t1, this, future), true, new P.Stream_isEmpty_closure0(future), future.get$_completeError());
      return future;
    }
  };
  P.Stream_Stream$fromIterable_closure.prototype = {
    call$0: function() {
      return new P._IterablePendingEvents(J.get$iterator$ax(this.elements), [this.T]);
    },
    $signature: function() {
      return {func: 1, ret: [P._IterablePendingEvents, this.T]};
    }
  };
  P.Stream_length_closure.prototype = {
    call$1: function(_) {
      H.assertSubtypeOfRuntimeType(_, H.getTypeArgumentByIndex(this.$this, 0));
      ++this._box_0.count;
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  P.Stream_length_closure0.prototype = {
    call$0: function() {
      this.future._complete$1(this._box_0.count);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P.Stream_isEmpty_closure.prototype = {
    call$1: function(_) {
      H.assertSubtypeOfRuntimeType(_, H.getTypeArgumentByIndex(this.$this, 0));
      P._cancelAndValue(this._box_0.subscription, this.future, false);
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  P.Stream_isEmpty_closure0.prototype = {
    call$0: function() {
      this.future._complete$1(true);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P.StreamSubscription.prototype = {};
  P.StreamTransformerBase.prototype = {};
  P._StreamController.prototype = {
    get$_pendingEvents: function() {
      var t1, _this = this;
      if ((_this._state & 8) === 0)
        return H.assertSubtype(_this._varData, "$is_PendingEvents", _this.$ti, "$as_PendingEvents");
      t1 = _this.$ti;
      return H.assertSubtype(H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").varData, "$is_PendingEvents", t1, "$as_PendingEvents");
    },
    _ensurePendingEvents$0: function() {
      var t1, state, t2, _this = this;
      if ((_this._state & 8) === 0) {
        t1 = _this._varData;
        if (t1 == null)
          t1 = _this._varData = new P._StreamImplEvents(_this.$ti);
        return H.assertSubtype(t1, "$is_StreamImplEvents", _this.$ti, "$as_StreamImplEvents");
      }
      t1 = _this.$ti;
      state = H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState");
      t2 = state.varData;
      return H.assertSubtype(t2 == null ? state.varData = new P._StreamImplEvents(t1) : t2, "$is_StreamImplEvents", t1, "$as_StreamImplEvents");
    },
    get$_subscription: function() {
      var t1, _this = this;
      if ((_this._state & 8) !== 0) {
        t1 = _this.$ti;
        return H.assertSubtype(H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").varData, "$is_ControllerSubscription", t1, "$as_ControllerSubscription");
      }
      return H.assertSubtype(_this._varData, "$is_ControllerSubscription", _this.$ti, "$as_ControllerSubscription");
    },
    _badEventState$0: function() {
      if ((this._state & 4) !== 0)
        return new P.StateError("Cannot add event after closing");
      return new P.StateError("Cannot add event while adding a stream");
    },
    addStream$2$cancelOnError: function(_, source, cancelOnError) {
      var t2, t3, t4, t5, _this = this,
        t1 = _this.$ti;
      H.assertSubtype(source, "$isStream", t1, "$asStream");
      t2 = _this._state;
      if (t2 >= 4)
        throw H.wrapException(_this._badEventState$0());
      if ((t2 & 2) !== 0) {
        t1 = new P._Future($.Zone__current, [null]);
        t1._asyncComplete$1(null);
        return t1;
      }
      t2 = _this._varData;
      t3 = new P._Future($.Zone__current, [null]);
      t4 = source.listen$4$cancelOnError$onDone$onError(_this.get$_add(_this), false, _this.get$_close(), _this.get$_addError());
      t5 = _this._state;
      if ((t5 & 1) !== 0 ? (_this.get$_subscription()._state & 4) !== 0 : (t5 & 2) === 0)
        t4.pause$0(0);
      _this._varData = new P._StreamControllerAddStreamState(t2, t3, t4, t1);
      _this._state |= 8;
      return t3;
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 == null)
        t1 = this._doneFuture = (this._state & 2) !== 0 ? $.$get$Future__nullFuture() : new P._Future($.Zone__current, [null]);
      return t1;
    },
    close$0: function(_) {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 4) !== 0)
        return _this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw H.wrapException(_this._badEventState$0());
      t1 = _this._state = t1 | 4;
      if ((t1 & 1) !== 0)
        _this._sendDone$0();
      else if ((t1 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, C.C__DelayedDone);
      return _this._ensureDoneFuture$0();
    },
    _add$1: function(_, value) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 0));
      t1 = _this._state;
      if ((t1 & 1) !== 0)
        _this._sendData$1(value);
      else if ((t1 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, new P._DelayedData(value, _this.$ti));
    },
    _addError$2: function(error, stackTrace) {
      var t1;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      t1 = this._state;
      if ((t1 & 1) !== 0)
        this._sendError$2(error, stackTrace);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, new P._DelayedError(error, stackTrace));
    },
    _close$0: function() {
      var _this = this,
        addState = H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", _this.$ti, "$as_StreamControllerAddStreamState");
      _this._varData = addState.varData;
      _this._state &= 4294967287;
      addState.addStreamFuture._asyncComplete$1(null);
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t2, t3, t4, subscription, pendingEvents, addState, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      if ((_this._state & 3) !== 0)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      t2 = $.Zone__current;
      t3 = cancelOnError ? 1 : 0;
      t4 = _this.$ti;
      subscription = new P._ControllerSubscription(_this, t2, t3, t4);
      subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t1);
      pendingEvents = _this.get$_pendingEvents();
      t1 = _this._state |= 1;
      if ((t1 & 8) !== 0) {
        addState = H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t4, "$as_StreamControllerAddStreamState");
        addState.varData = subscription;
        addState.addSubscription.resume$0(0);
      } else
        _this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new P._StreamController__subscribe_closure(_this));
      return subscription;
    },
    _recordCancel$1: function(subscription) {
      var result, e, s, exception, result0, _this = this,
        t1 = _this.$ti;
      H.assertSubtype(subscription, "$isStreamSubscription", t1, "$asStreamSubscription");
      result = null;
      if ((_this._state & 8) !== 0)
        result = H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").cancel$0(0);
      _this._varData = null;
      _this._state = _this._state & 4294967286 | 2;
      if (result == null)
        try {
          result = H.interceptedTypeCheck(_this.onCancel.call$0(), "$isFuture");
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          result0 = new P._Future($.Zone__current, [null]);
          result0._asyncCompleteError$2(e, s);
          result = result0;
        }
      else
        result = result.whenComplete$1(_this.onCancel);
      t1 = new P._StreamController__recordCancel_complete(_this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return result;
    },
    $isStreamController: 1,
    $is_StreamControllerLifecycle: 1,
    $is_EventDispatch: 1
  };
  P._StreamController__subscribe_closure.prototype = {
    call$0: function() {
      P._runGuarded(this.$this.onListen);
    },
    $signature: 0
  };
  P._StreamController__recordCancel_complete.prototype = {
    call$0: function() {
      var t1 = this.$this._doneFuture;
      if (t1 != null && t1._state === 0)
        t1._asyncComplete$1(null);
    },
    $signature: 1
  };
  P._AsyncStreamControllerDispatch.prototype = {
    _sendData$1: function(data) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      H.assertSubtypeOfRuntimeType(data, t1);
      this.get$_subscription()._addPending$1(new P._DelayedData(data, [t1]));
    },
    _sendError$2: function(error, stackTrace) {
      this.get$_subscription()._addPending$1(new P._DelayedError(error, stackTrace));
    },
    _sendDone$0: function() {
      this.get$_subscription()._addPending$1(C.C__DelayedDone);
    }
  };
  P._AsyncStreamController.prototype = {};
  P._ControllerStream.prototype = {
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      return this._controller._subscribe$4(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]}), onError, H.functionTypeCheck(onDone, {func: 1, ret: -1}), cancelOnError);
    },
    get$hashCode: function(_) {
      return (H.Primitives_objectHashCode(this._controller) ^ 892482866) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return other instanceof P._ControllerStream && other._controller === this._controller;
    }
  };
  P._ControllerSubscription.prototype = {
    _onCancel$0: function() {
      return this._controller._recordCancel$1(this);
    },
    _onPause$0: function() {
      var t1 = this._controller,
        t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(this, "$isStreamSubscription", [t2], "$asStreamSubscription");
      if ((t1._state & 8) !== 0)
        H.assertSubtype(t1._varData, "$is_StreamControllerAddStreamState", [t2], "$as_StreamControllerAddStreamState").addSubscription.pause$0(0);
      P._runGuarded(t1.onPause);
    },
    _onResume$0: function() {
      var t1 = this._controller,
        t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(this, "$isStreamSubscription", [t2], "$asStreamSubscription");
      if ((t1._state & 8) !== 0)
        H.assertSubtype(t1._varData, "$is_StreamControllerAddStreamState", [t2], "$as_StreamControllerAddStreamState").addSubscription.resume$0(0);
      P._runGuarded(t1.onResume);
    }
  };
  P._AddStreamState.prototype = {
    cancel$0: function(_) {
      var cancel = this.addSubscription.cancel$0(0);
      if (cancel == null) {
        this.addStreamFuture._asyncComplete$1(null);
        return;
      }
      return cancel.whenComplete$1(new P._AddStreamState_cancel_closure(this));
    }
  };
  P._AddStreamState_cancel_closure.prototype = {
    call$0: function() {
      this.$this.addStreamFuture._asyncComplete$1(null);
    },
    $signature: 0
  };
  P._StreamControllerAddStreamState.prototype = {};
  P._BufferingStreamSubscription.prototype = {
    _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
      var t2, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      t2 = _this._zone;
      t2.toString;
      _this.set$_async$_onData(H.functionTypeCheck(onData, {func: 1, ret: null, args: [t1]}));
      if (H.functionTypeTest(onError, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}))
        _this._onError = t2.registerBinaryCallback$3$1(onError, null, P.Object, P.StackTrace);
      else if (H.functionTypeTest(onError, {func: 1, ret: -1, args: [P.Object]}))
        _this._onError = H.functionTypeCheck(onError, {func: 1, ret: null, args: [P.Object]});
      else
        H.throwExpression(P.ArgumentError$("handleError callback must take either an Object (the error), or both an Object (the error) and a StackTrace."));
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      _this.set$_onDone(H.functionTypeCheck(onDone, {func: 1, ret: -1}));
    },
    _setPendingEvents$1: function(pendingEvents) {
      var _this = this;
      H.assertSubtype(pendingEvents, "$is_PendingEvents", _this.$ti, "$as_PendingEvents");
      if (pendingEvents == null)
        return;
      _this.set$_pending(pendingEvents);
      if (!pendingEvents.get$isEmpty(pendingEvents)) {
        _this._state = (_this._state | 64) >>> 0;
        _this._pending.schedule$1(_this);
      }
    },
    pause$0: function(_) {
      var t2, t3, _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      t2 = (t1 + 128 | 4) >>> 0;
      _this._state = t2;
      if (t1 < 128 && _this._pending != null) {
        t3 = _this._pending;
        if (t3._state === 1)
          t3._state = 3;
      }
      if ((t1 & 4) === 0 && (t2 & 32) === 0)
        _this._guardCallback$1(_this.get$_onPause());
    },
    resume$0: function(_) {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 128) {
        t1 = _this._state = t1 - 128;
        if (t1 < 128) {
          if ((t1 & 64) !== 0) {
            t1 = _this._pending;
            t1 = !t1.get$isEmpty(t1);
          } else
            t1 = false;
          if (t1)
            _this._pending.schedule$1(_this);
          else {
            t1 = (_this._state & 4294967291) >>> 0;
            _this._state = t1;
            if ((t1 & 32) === 0)
              _this._guardCallback$1(_this.get$_onResume());
          }
        }
      }
    },
    cancel$0: function(_) {
      var _this = this,
        t1 = (_this._state & 4294967279) >>> 0;
      _this._state = t1;
      if ((t1 & 8) === 0)
        _this._cancel$0();
      t1 = _this._cancelFuture;
      return t1 == null ? $.$get$Future__nullFuture() : t1;
    },
    _cancel$0: function() {
      var t2, _this = this,
        t1 = _this._state = (_this._state | 8) >>> 0;
      if ((t1 & 64) !== 0) {
        t2 = _this._pending;
        if (t2._state === 1)
          t2._state = 3;
      }
      if ((t1 & 32) === 0)
        _this.set$_pending(null);
      _this._cancelFuture = _this._onCancel$0();
    },
    _onPause$0: function() {
    },
    _onResume$0: function() {
    },
    _onCancel$0: function() {
      return;
    },
    _addPending$1: function($event) {
      var _this = this,
        t1 = _this.$ti,
        pending = H.assertSubtype(_this._pending, "$is_StreamImplEvents", t1, "$as_StreamImplEvents");
      if (pending == null) {
        pending = new P._StreamImplEvents(t1);
        _this.set$_pending(pending);
      }
      pending.add$1(0, $event);
      t1 = _this._state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        _this._state = t1;
        if (t1 < 128)
          _this._pending.schedule$1(_this);
      }
    },
    _sendData$1: function(data) {
      var t2, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.assertSubtypeOfRuntimeType(data, t1);
      t2 = _this._state;
      _this._state = (t2 | 32) >>> 0;
      _this._zone.runUnaryGuarded$1$2(_this._async$_onData, data, t1);
      _this._state = (_this._state & 4294967263) >>> 0;
      _this._checkState$1((t2 & 4) !== 0);
    },
    _sendError$2: function(error, stackTrace) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      t1 = _this._state;
      t2 = new P._BufferingStreamSubscription__sendError_sendError(_this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        _this._state = (t1 | 16) >>> 0;
        _this._cancel$0();
        t1 = _this._cancelFuture;
        if (t1 != null && t1 !== $.$get$Future__nullFuture())
          t1.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        _this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0: function() {
      var t2, _this = this,
        t1 = new P._BufferingStreamSubscription__sendDone_sendDone(_this);
      _this._cancel$0();
      _this._state = (_this._state | 16) >>> 0;
      t2 = _this._cancelFuture;
      if (t2 != null && t2 !== $.$get$Future__nullFuture())
        t2.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1: function(callback) {
      var t1, _this = this;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      t1 = _this._state;
      _this._state = (t1 | 32) >>> 0;
      callback.call$0();
      _this._state = (_this._state & 4294967263) >>> 0;
      _this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1: function(wasInputPaused) {
      var t1, isInputPaused, _this = this;
      if ((_this._state & 64) !== 0) {
        t1 = _this._pending;
        t1 = t1.get$isEmpty(t1);
      } else
        t1 = false;
      if (t1) {
        t1 = _this._state = (_this._state & 4294967231) >>> 0;
        if ((t1 & 4) !== 0)
          if (t1 < 128) {
            t1 = _this._pending;
            t1 = t1 == null || t1.get$isEmpty(t1);
          } else
            t1 = false;
        else
          t1 = false;
        if (t1)
          _this._state = (_this._state & 4294967291) >>> 0;
      }
      for (; true; wasInputPaused = isInputPaused) {
        t1 = _this._state;
        if ((t1 & 8) !== 0) {
          _this.set$_pending(null);
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        _this._state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          _this._onPause$0();
        else
          _this._onResume$0();
        _this._state = (_this._state & 4294967263) >>> 0;
      }
      t1 = _this._state;
      if ((t1 & 64) !== 0 && t1 < 128)
        _this._pending.schedule$1(_this);
    },
    set$_async$_onData: function(_onData) {
      this._async$_onData = H.functionTypeCheck(_onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
    },
    set$_onDone: function(_onDone) {
      this._onDone = H.functionTypeCheck(_onDone, {func: 1, ret: -1});
    },
    set$_pending: function(_pending) {
      this._pending = H.assertSubtype(_pending, "$is_PendingEvents", this.$ti, "$as_PendingEvents");
    },
    $isStreamSubscription: 1,
    $is_EventDispatch: 1
  };
  P._BufferingStreamSubscription__sendError_sendError.prototype = {
    call$0: function() {
      var onError, t3, t4,
        t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 32) >>> 0;
      onError = t1._onError;
      t2 = this.error;
      t3 = P.Object;
      t4 = t1._zone;
      if (H.functionTypeTest(onError, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}))
        t4.runBinaryGuarded$2$3(onError, t2, this.stackTrace, t3, P.StackTrace);
      else
        t4.runUnaryGuarded$1$2(H.functionTypeCheck(t1._onError, {func: 1, ret: -1, args: [P.Object]}), t2, t3);
      t1._state = (t1._state & 4294967263) >>> 0;
    },
    $signature: 1
  };
  P._BufferingStreamSubscription__sendDone_sendDone.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967263) >>> 0;
    },
    $signature: 1
  };
  P._StreamImpl.prototype = {
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return this._createSubscription$4(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]}), onError, H.functionTypeCheck(onDone, {func: 1, ret: -1}), cancelOnError);
    },
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return P._BufferingStreamSubscription$(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]}), onError, H.functionTypeCheck(onDone, {func: 1, ret: -1}), cancelOnError, t1);
    }
  };
  P._GeneratedStreamImpl.prototype = {
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      if (_this._isUsed)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      _this._isUsed = true;
      t1 = P._BufferingStreamSubscription$(onData, onError, onDone, cancelOnError, t1);
      t1._setPendingEvents$1(_this._pending.call$0());
      return t1;
    }
  };
  P._IterablePendingEvents.prototype = {
    get$isEmpty: function(_) {
      return this._async$_iterator == null;
    },
    handleNext$1: function(dispatch) {
      var hasMore, e, s, t1, exception, _this = this;
      H.assertSubtype(dispatch, "$is_EventDispatch", _this.$ti, "$as_EventDispatch");
      t1 = _this._async$_iterator;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No events pending."));
      hasMore = null;
      try {
        hasMore = t1.moveNext$0();
        if (H.boolConversionCheck(hasMore)) {
          t1 = _this._async$_iterator;
          dispatch._sendData$1(t1.get$current(t1));
        } else {
          _this.set$_async$_iterator(null);
          dispatch._sendDone$0();
        }
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        if (hasMore == null) {
          _this.set$_async$_iterator(C.C_EmptyIterator);
          dispatch._sendError$2(e, s);
        } else
          dispatch._sendError$2(e, s);
      }
    },
    set$_async$_iterator: function(_iterator) {
      this._async$_iterator = H.assertSubtype(_iterator, "$isIterator", this.$ti, "$asIterator");
    }
  };
  P._DelayedEvent.prototype = {
    set$next: function(_, next) {
      this.next = H.interceptedTypeCheck(next, "$is_DelayedEvent");
    },
    get$next: function(receiver) {
      return this.next;
    }
  };
  P._DelayedData.prototype = {
    perform$1: function(dispatch) {
      H.assertSubtype(dispatch, "$is_EventDispatch", this.$ti, "$as_EventDispatch")._sendData$1(this.value);
    }
  };
  P._DelayedError.prototype = {
    perform$1: function(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    },
    $as_DelayedEvent: function() {
    }
  };
  P._DelayedDone.prototype = {
    perform$1: function(dispatch) {
      dispatch._sendDone$0();
    },
    get$next: function(_) {
      return;
    },
    set$next: function(_, _0) {
      throw H.wrapException(P.StateError$("No events after a done."));
    },
    $is_DelayedEvent: 1,
    $as_DelayedEvent: function() {
    }
  };
  P._PendingEvents.prototype = {
    schedule$1: function(dispatch) {
      var t1, _this = this;
      H.assertSubtype(dispatch, "$is_EventDispatch", _this.$ti, "$as_EventDispatch");
      t1 = _this._state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        _this._state = 1;
        return;
      }
      P.scheduleMicrotask(new P._PendingEvents_schedule_closure(_this, dispatch));
      _this._state = 1;
    }
  };
  P._PendingEvents_schedule_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t1.handleNext$1(this.dispatch);
    },
    $signature: 0
  };
  P._StreamImplEvents.prototype = {
    get$isEmpty: function(_) {
      return this.lastPendingEvent == null;
    },
    add$1: function(_, $event) {
      var _this = this,
        t1 = _this.lastPendingEvent;
      if (t1 == null)
        _this.firstPendingEvent = _this.lastPendingEvent = $event;
      else {
        t1.set$next(0, $event);
        _this.lastPendingEvent = $event;
      }
    },
    handleNext$1: function(dispatch) {
      var $event, t1, _this = this;
      H.assertSubtype(dispatch, "$is_EventDispatch", _this.$ti, "$as_EventDispatch");
      $event = _this.firstPendingEvent;
      t1 = $event.get$next($event);
      _this.firstPendingEvent = t1;
      if (t1 == null)
        _this.lastPendingEvent = null;
      $event.perform$1(dispatch);
    }
  };
  P._StreamIterator.prototype = {};
  P._cancelAndValue_closure.prototype = {
    call$0: function() {
      return this.future._complete$1(this.value);
    },
    $signature: 1
  };
  P.Timer.prototype = {};
  P.AsyncError.prototype = {
    toString$0: function(_) {
      return H.S(this.error);
    },
    $isError: 1
  };
  P._Zone.prototype = {$isZone: 1};
  P._rootHandleUncaughtError_closure.prototype = {
    call$0: function() {
      var error,
        t1 = this._box_0,
        t2 = t1.error;
      t1 = t2 == null ? t1.error = new P.NullThrownError() : t2;
      t2 = this.stackTrace;
      if (t2 == null)
        throw H.wrapException(t1);
      error = H.wrapException(t1);
      error.stack = t2.toString$0(0);
      throw error;
    },
    $signature: 0
  };
  P._RootZone.prototype = {
    runGuarded$1: function(f) {
      var e, s, exception, _null = null;
      H.functionTypeCheck(f, {func: 1, ret: -1});
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$0();
          return;
        }
        P._rootRun(_null, _null, this, f, -1);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    runUnaryGuarded$1$2: function(f, arg, $T) {
      var e, s, exception, _null = null;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$1(arg);
          return;
        }
        P._rootRunUnary(_null, _null, this, f, arg, -1, $T);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    runBinaryGuarded$2$3: function(f, arg1, arg2, T1, T2) {
      var e, s, exception, _null = null;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$2(arg1, arg2);
          return;
        }
        P._rootRunBinary(_null, _null, this, f, arg1, arg2, -1, T1, T2);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    bindCallback$1$1: function(f, $R) {
      return new P._RootZone_bindCallback_closure(this, H.functionTypeCheck(f, {func: 1, ret: $R}), $R);
    },
    bindCallbackGuarded$1: function(f) {
      return new P._RootZone_bindCallbackGuarded_closure(this, H.functionTypeCheck(f, {func: 1, ret: -1}));
    },
    bindUnaryCallbackGuarded$1$1: function(f, $T) {
      return new P._RootZone_bindUnaryCallbackGuarded_closure(this, H.functionTypeCheck(f, {func: 1, ret: -1, args: [$T]}), $T);
    },
    $index: function(_, key) {
      return;
    },
    run$1$1: function(f, $R) {
      H.functionTypeCheck(f, {func: 1, ret: $R});
      if ($.Zone__current === C.C__RootZone)
        return f.call$0();
      return P._rootRun(null, null, this, f, $R);
    },
    runUnary$2$2: function(f, arg, $R, $T) {
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      if ($.Zone__current === C.C__RootZone)
        return f.call$1(arg);
      return P._rootRunUnary(null, null, this, f, arg, $R, $T);
    },
    runBinary$3$3: function(f, arg1, arg2, $R, T1, T2) {
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      if ($.Zone__current === C.C__RootZone)
        return f.call$2(arg1, arg2);
      return P._rootRunBinary(null, null, this, f, arg1, arg2, $R, T1, T2);
    },
    registerBinaryCallback$3$1: function(f, $R, T1, T2) {
      return H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
    }
  };
  P._RootZone_bindCallback_closure.prototype = {
    call$0: function() {
      return this.$this.run$1$1(this.f, this.R);
    },
    $signature: function() {
      return {func: 1, ret: this.R};
    }
  };
  P._RootZone_bindCallbackGuarded_closure.prototype = {
    call$0: function() {
      return this.$this.runGuarded$1(this.f);
    },
    $signature: 1
  };
  P._RootZone_bindUnaryCallbackGuarded_closure.prototype = {
    call$1: function(arg) {
      var t1 = this.T;
      return this.$this.runUnaryGuarded$1$2(this.f, H.assertSubtypeOfRuntimeType(arg, t1), t1);
    },
    $signature: function() {
      return {func: 1, ret: -1, args: [this.T]};
    }
  };
  P._HashSet.prototype = {
    get$iterator: function(_) {
      return new P._HashSetIterator(this, this._computeElements$0(), this.$ti);
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._collection$_strings;
        return strings == null ? false : strings[object] != null;
      } else if (typeof object === "number" && (object & 1073741823) === object) {
        nums = this._collection$_nums;
        return nums == null ? false : nums[object] != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(this._getBucket$2(rest, object), object) >= 0;
    },
    add$1: function(_, element) {
      var strings, nums, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      if (typeof element === "string" && element !== "__proto__") {
        strings = _this._collection$_strings;
        return _this._collection$_addHashTableEntry$2(strings == null ? _this._collection$_strings = P._HashSet__newHashTable() : strings, element);
      } else if (typeof element === "number" && (element & 1073741823) === element) {
        nums = _this._collection$_nums;
        return _this._collection$_addHashTableEntry$2(nums == null ? _this._collection$_nums = P._HashSet__newHashTable() : nums, element);
      } else
        return _this._collection$_add$1(0, element);
    },
    _collection$_add$1: function(_, element) {
      var rest, hash, bucket, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = P._HashSet__newHashTable();
      hash = _this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [element];
      else {
        if (_this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(element);
      }
      ++_this._collection$_length;
      _this._collection$_elements = null;
      return true;
    },
    addAll$1: function(_, objects) {
      var t1;
      for (t1 = J.get$iterator$ax(H.assertSubtype(objects, "$isIterable", this.$ti, "$asIterable")); t1.moveNext$0();)
        this.add$1(0, t1.get$current(t1));
    },
    remove$1: function(_, object) {
      var _this = this;
      if (typeof object === "string" && object !== "__proto__")
        return _this._collection$_removeHashTableEntry$2(_this._collection$_strings, object);
      else if (typeof object === "number" && (object & 1073741823) === object)
        return _this._collection$_removeHashTableEntry$2(_this._collection$_nums, object);
      else
        return _this._remove$1(0, object);
    },
    _remove$1: function(_, object) {
      var bucket, index, _this = this,
        rest = _this._collection$_rest;
      if (rest == null)
        return false;
      bucket = _this._getBucket$2(rest, object);
      index = _this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      --_this._collection$_length;
      _this._collection$_elements = null;
      bucket.splice(index, 1);
      return true;
    },
    clear$0: function(_) {
      var _this = this;
      if (_this._collection$_length > 0) {
        _this._collection$_strings = _this._collection$_nums = _this._collection$_rest = _this._collection$_elements = null;
        _this._collection$_length = 0;
      }
    },
    _computeElements$0: function() {
      var result, strings, names, entries, index, i, nums, rest, bucket, $length, i0, _this = this,
        t1 = _this._collection$_elements;
      if (t1 != null)
        return t1;
      result = new Array(_this._collection$_length);
      result.fixed$length = Array;
      strings = _this._collection$_strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = _this._collection$_nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = _this._collection$_rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; ++i0) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      return _this._collection$_elements = result;
    },
    _collection$_addHashTableEntry$2: function(table, element) {
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      if (table[element] != null)
        return false;
      table[element] = 0;
      ++this._collection$_length;
      this._collection$_elements = null;
      return true;
    },
    _collection$_removeHashTableEntry$2: function(table, element) {
      if (table != null && table[element] != null) {
        delete table[element];
        --this._collection$_length;
        this._collection$_elements = null;
        return true;
      } else
        return false;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 1073741823;
    },
    _getBucket$2: function(table, element) {
      return table[this._computeHashCode$1(element)];
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i], element))
          return i;
      return -1;
    },
    $isHashSet: 1
  };
  P._HashSetIterator.prototype = {
    get$current: function(_) {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var _this = this,
        elements = _this._collection$_elements,
        offset = _this._offset,
        t1 = _this._collection$_set;
      if (elements !== t1._collection$_elements)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= elements.length) {
        _this.set$_collection$_current(null);
        return false;
      } else {
        _this.set$_collection$_current(elements[offset]);
        _this._offset = offset + 1;
        return true;
      }
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P._LinkedHashSet.prototype = {
    get$iterator: function(_) {
      return P._LinkedHashSetIterator$(this, this._collection$_modifications, H.getTypeArgumentByIndex(this, 0));
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._collection$_strings;
        if (strings == null)
          return false;
        return H.interceptedTypeCheck(strings[object], "$is_LinkedHashSetCell") != null;
      } else if (typeof object === "number" && (object & 1073741823) === object) {
        nums = this._collection$_nums;
        if (nums == null)
          return false;
        return H.interceptedTypeCheck(nums[object], "$is_LinkedHashSetCell") != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(this._getBucket$2(rest, object), object) >= 0;
    },
    forEach$1: function(_, action) {
      var cell, modifications, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [t1]});
      cell = _this._collection$_first;
      modifications = _this._collection$_modifications;
      for (; cell != null;) {
        action.call$1(H.assertSubtypeOfRuntimeType(cell._collection$_element, t1));
        if (modifications !== _this._collection$_modifications)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        cell = cell._collection$_next;
      }
    },
    add$1: function(_, element) {
      var strings, nums, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      if (typeof element === "string" && element !== "__proto__") {
        strings = _this._collection$_strings;
        return _this._collection$_addHashTableEntry$2(strings == null ? _this._collection$_strings = P._LinkedHashSet__newHashTable() : strings, element);
      } else if (typeof element === "number" && (element & 1073741823) === element) {
        nums = _this._collection$_nums;
        return _this._collection$_addHashTableEntry$2(nums == null ? _this._collection$_nums = P._LinkedHashSet__newHashTable() : nums, element);
      } else
        return _this._collection$_add$1(0, element);
    },
    _collection$_add$1: function(_, element) {
      var rest, hash, bucket, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = P._LinkedHashSet__newHashTable();
      hash = _this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [_this._collection$_newLinkedCell$1(element)];
      else {
        if (_this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(_this._collection$_newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      var _this = this;
      if (typeof object === "string" && object !== "__proto__")
        return _this._collection$_removeHashTableEntry$2(_this._collection$_strings, object);
      else if (typeof object === "number" && (object & 1073741823) === object)
        return _this._collection$_removeHashTableEntry$2(_this._collection$_nums, object);
      else
        return _this._remove$1(0, object);
    },
    _remove$1: function(_, object) {
      var bucket, index, _this = this,
        rest = _this._collection$_rest;
      if (rest == null)
        return false;
      bucket = _this._getBucket$2(rest, object);
      index = _this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      _this._collection$_unlinkCell$1(bucket.splice(index, 1)[0]);
      return true;
    },
    clear$0: function(_) {
      var _this = this;
      if (_this._collection$_length > 0) {
        _this._collection$_strings = _this._collection$_nums = _this._collection$_rest = _this._collection$_first = _this._collection$_last = null;
        _this._collection$_length = 0;
        _this._collection$_modified$0();
      }
    },
    _collection$_addHashTableEntry$2: function(table, element) {
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      if (H.interceptedTypeCheck(table[element], "$is_LinkedHashSetCell") != null)
        return false;
      table[element] = this._collection$_newLinkedCell$1(element);
      return true;
    },
    _collection$_removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = H.interceptedTypeCheck(table[element], "$is_LinkedHashSetCell");
      if (cell == null)
        return false;
      this._collection$_unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _collection$_modified$0: function() {
      this._collection$_modifications = 1073741823 & this._collection$_modifications + 1;
    },
    _collection$_newLinkedCell$1: function(element) {
      var last, _this = this,
        cell = new P._LinkedHashSetCell(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0)));
      if (_this._collection$_first == null)
        _this._collection$_first = _this._collection$_last = cell;
      else {
        last = _this._collection$_last;
        cell._collection$_previous = last;
        _this._collection$_last = last._collection$_next = cell;
      }
      ++_this._collection$_length;
      _this._collection$_modified$0();
      return cell;
    },
    _collection$_unlinkCell$1: function(cell) {
      var _this = this,
        previous = cell._collection$_previous,
        next = cell._collection$_next;
      if (previous == null)
        _this._collection$_first = next;
      else
        previous._collection$_next = next;
      if (next == null)
        _this._collection$_last = previous;
      else
        next._collection$_previous = previous;
      --_this._collection$_length;
      _this._collection$_modified$0();
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 1073741823;
    },
    _getBucket$2: function(table, element) {
      return table[this._computeHashCode$1(element)];
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i]._collection$_element, element))
          return i;
      return -1;
    },
    $isLinkedHashSet: 1
  };
  P._LinkedHashSetCell.prototype = {};
  P._LinkedHashSetIterator.prototype = {
    get$current: function(_) {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var _this = this,
        t1 = _this._collection$_set;
      if (_this._collection$_modifications !== t1._collection$_modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = _this._collection$_cell;
        if (t1 == null) {
          _this.set$_collection$_current(null);
          return false;
        } else {
          _this.set$_collection$_current(H.assertSubtypeOfRuntimeType(t1._collection$_element, H.getTypeArgumentByIndex(_this, 0)));
          _this._collection$_cell = _this._collection$_cell._collection$_next;
          return true;
        }
      }
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P.IterableBase.prototype = {};
  P.LinkedHashMap_LinkedHashMap$from_closure.prototype = {
    call$2: function(k, v) {
      this.result.$indexSet(0, H.assertSubtypeOfRuntimeType(k, this.K), H.assertSubtypeOfRuntimeType(v, this.V));
    },
    $signature: 5
  };
  P.LinkedHashSet.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1, $isSet: 1};
  P.ListBase.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1, $isList: 1};
  P.ListMixin.prototype = {
    get$iterator: function(receiver) {
      return new H.ListIterator(receiver, this.get$length(receiver), [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    forEach$1: function(receiver, action) {
      var $length, i, _this = this;
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)]});
      $length = _this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        action.call$1(_this.$index(receiver, i));
        if ($length !== _this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    get$isEmpty: function(receiver) {
      return this.get$length(receiver) === 0;
    },
    get$isNotEmpty: function(receiver) {
      return !this.get$isEmpty(receiver);
    },
    get$first: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return this.$index(receiver, 0);
    },
    contains$1: function(receiver, element) {
      var i,
        $length = this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        if (J.$eq$(this.$index(receiver, i), element))
          return true;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    join$1: function(receiver, separator) {
      var t1;
      if (this.get$length(receiver) === 0)
        return "";
      t1 = P.StringBuffer__writeAll("", receiver, separator);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    map$1$1: function(receiver, f, $T) {
      var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
      return new H.MappedListIterable(receiver, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    fold$1$2: function(receiver, initialValue, combine, $T) {
      var $length, value, i, _this = this;
      H.assertSubtypeOfRuntimeType(initialValue, $T);
      H.functionTypeCheck(combine, {func: 1, ret: $T, args: [$T, H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)]});
      $length = _this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      value = initialValue;
      i = 0;
      for (; i < $length; ++i) {
        value = combine.call$2(value, _this.$index(receiver, i));
        if ($length !== _this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    toList$1$growable: function(receiver, growable) {
      var i, t1, _this = this,
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)]);
      C.JSArray_methods.set$length(result, _this.get$length(receiver));
      i = 0;
      while (true) {
        t1 = _this.get$length(receiver);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        C.JSArray_methods.$indexSet(result, i, _this.$index(receiver, i));
        ++i;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    sort$1: function(receiver, compare) {
      var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      H.Sort_sort(receiver, compare == null ? P.collection_ListMixin__compareAny$closure() : compare, t1);
    },
    fillRange$3: function(receiver, start, end, fill) {
      var i;
      H.assertSubtypeOfRuntimeType(fill, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
      P.RangeError_checkValidRange(start, end, this.get$length(receiver));
      for (i = start; i < end; ++i)
        this.$indexSet(receiver, i, fill);
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    }
  };
  P.MapBase.prototype = {};
  P.MapBase_mapToString_closure.prototype = {
    call$2: function(k, v) {
      var t2,
        t1 = this._box_0;
      if (!t1.first)
        this.result._contents += ", ";
      t1.first = false;
      t1 = this.result;
      t2 = t1._contents += H.S(k);
      t1._contents = t2 + ": ";
      t1._contents += H.S(v);
    },
    $signature: 5
  };
  P.MapMixin.prototype = {
    forEach$1: function(receiver, action) {
      var t1, key, _this = this;
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "MapMixin", 0), H.getRuntimeTypeArgumentIntercepted(_this, receiver, "MapMixin", 1)]});
      for (t1 = J.get$iterator$ax(_this.get$keys(receiver)); t1.moveNext$0();) {
        key = t1.get$current(t1);
        action.call$2(key, _this.$index(receiver, key));
      }
    },
    containsKey$1: function(receiver, key) {
      return J.contains$1$asx(this.get$keys(receiver), key);
    },
    get$length: function(receiver) {
      return J.get$length$asx(this.get$keys(receiver));
    },
    get$isEmpty: function(receiver) {
      return J.get$isEmpty$asx(this.get$keys(receiver));
    },
    toString$0: function(receiver) {
      return P.MapBase_mapToString(receiver);
    },
    $isMap: 1
  };
  P._UnmodifiableMapMixin.prototype = {
    $indexSet: function(_, key, value) {
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    }
  };
  P.MapView.prototype = {
    $index: function(_, key) {
      return this._collection$_map.$index(0, key);
    },
    $indexSet: function(_, key, value) {
      this._collection$_map.$indexSet(0, H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)));
    },
    containsKey$1: function(_, key) {
      return this._collection$_map.containsKey$1(0, key);
    },
    forEach$1: function(_, action) {
      this._collection$_map.forEach$1(0, H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]}));
    },
    get$isEmpty: function(_) {
      var t1 = this._collection$_map;
      return t1.get$isEmpty(t1);
    },
    get$length: function(_) {
      var t1 = this._collection$_map;
      return t1.get$length(t1);
    },
    get$keys: function(_) {
      var t1 = this._collection$_map;
      return t1.get$keys(t1);
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this._collection$_map);
    },
    get$values: function(_) {
      var t1 = this._collection$_map;
      return t1.get$values(t1);
    },
    $isMap: 1
  };
  P.UnmodifiableMapView.prototype = {};
  P.ListQueue.prototype = {
    get$iterator: function(_) {
      var _this = this;
      return new P._ListQueueIterator(_this, _this._tail, _this._modificationCount, _this._head, _this.$ti);
    },
    forEach$1: function(_, f) {
      var modificationCount, i, t1, _this = this;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0)]});
      modificationCount = _this._modificationCount;
      for (i = _this._head; i !== _this._tail; i = (i + 1 & _this._table.length - 1) >>> 0) {
        t1 = _this._table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        f.call$1(t1[i]);
        if (modificationCount !== _this._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(_this));
      }
    },
    get$isEmpty: function(_) {
      return this._head === this._tail;
    },
    get$length: function(_) {
      return (this._tail - this._head & this._table.length - 1) >>> 0;
    },
    elementAt$1: function(_, index) {
      var t1, t2, t3, _this = this,
        $length = _this.get$length(_this);
      if (typeof index !== "number")
        return H.iae(index);
      if (0 > index || index >= $length)
        H.throwExpression(P.IndexError$(index, _this, "index", null, $length));
      t1 = _this._table;
      t2 = t1.length;
      t3 = (_this._head + index & t2 - 1) >>> 0;
      if (t3 < 0 || t3 >= t2)
        return H.ioore(t1, t3);
      return t1[t3];
    },
    addAll$1: function(_, elements) {
      var addCount, $length, t2, t3, t4, newCapacity, newTable, endSpace, preSpace, element, t5, split, _this = this,
        t1 = _this.$ti;
      H.assertSubtype(elements, "$isIterable", t1, "$asIterable");
      if (H.checkSubtype(elements, "$isList", t1, "$asList")) {
        addCount = elements.length;
        $length = _this.get$length(_this);
        t2 = $length + addCount;
        t3 = _this._table;
        t4 = t3.length;
        if (t2 >= t4) {
          newCapacity = P.ListQueue__nextPowerOf2(t2 + (t2 >>> 1));
          if (typeof newCapacity !== "number")
            return H.iae(newCapacity);
          t3 = new Array(newCapacity);
          t3.fixed$length = Array;
          newTable = H.setRuntimeTypeInfo(t3, t1);
          _this._tail = _this._writeToList$1(newTable);
          _this.set$_table(newTable);
          _this._head = 0;
          C.JSArray_methods.setRange$4(_this._table, $length, t2, elements, 0);
          _this._tail += addCount;
        } else {
          t1 = _this._tail;
          endSpace = t4 - t1;
          if (addCount < endSpace) {
            C.JSArray_methods.setRange$4(t3, t1, t1 + addCount, elements, 0);
            _this._tail += addCount;
          } else {
            preSpace = addCount - endSpace;
            C.JSArray_methods.setRange$4(t3, t1, t1 + endSpace, elements, 0);
            C.JSArray_methods.setRange$4(_this._table, 0, preSpace, elements, endSpace);
            _this._tail = preSpace;
          }
        }
        ++_this._modificationCount;
      } else
        for (t2 = J.get$iterator$ax(elements), t3 = H.getTypeArgumentByIndex(_this, 0); t2.moveNext$0();) {
          element = H.assertSubtypeOfRuntimeType(t2.get$current(t2), t3);
          C.JSArray_methods.$indexSet(_this._table, _this._tail, element);
          t4 = _this._tail;
          t5 = _this._table.length;
          t4 = (t4 + 1 & t5 - 1) >>> 0;
          _this._tail = t4;
          if (_this._head === t4) {
            t4 = new Array(t5 * 2);
            t4.fixed$length = Array;
            newTable = H.setRuntimeTypeInfo(t4, t1);
            t4 = _this._table;
            t5 = _this._head;
            split = t4.length - t5;
            C.JSArray_methods.setRange$4(newTable, 0, split, t4, t5);
            C.JSArray_methods.setRange$4(newTable, split, split + _this._head, _this._table, 0);
            _this._head = 0;
            _this._tail = _this._table.length;
            _this.set$_table(newTable);
          }
          ++_this._modificationCount;
        }
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    removeFirst$0: function() {
      var t2, result, _this = this,
        t1 = _this._head;
      if (t1 === _this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      ++_this._modificationCount;
      t2 = _this._table;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      result = t2[t1];
      C.JSArray_methods.$indexSet(t2, t1, null);
      _this._head = (_this._head + 1 & _this._table.length - 1) >>> 0;
      return result;
    },
    _writeToList$1: function(target) {
      var t1, t2, t3, $length, firstPartSize, _this = this;
      H.assertSubtype(target, "$isList", _this.$ti, "$asList");
      t1 = _this._head;
      t2 = _this._tail;
      t3 = _this._table;
      if (t1 <= t2) {
        $length = t2 - t1;
        C.JSArray_methods.setRange$4(target, 0, $length, t3, t1);
        return $length;
      } else {
        firstPartSize = t3.length - t1;
        C.JSArray_methods.setRange$4(target, 0, firstPartSize, t3, t1);
        C.JSArray_methods.setRange$4(target, firstPartSize, firstPartSize + _this._tail, _this._table, 0);
        return _this._tail + firstPartSize;
      }
    },
    set$_table: function(_table) {
      this._table = H.assertSubtype(_table, "$isList", this.$ti, "$asList");
    },
    $isQueue: 1
  };
  P._ListQueueIterator.prototype = {
    get$current: function(_) {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t2, t3, _this = this,
        t1 = _this._queue;
      if (_this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = _this._position;
      if (t2 === _this._end) {
        _this.set$_collection$_current(null);
        return false;
      }
      t3 = t1._table;
      if (t2 >= t3.length)
        return H.ioore(t3, t2);
      _this.set$_collection$_current(t3[t2]);
      _this._position = (_this._position + 1 & t1._table.length - 1) >>> 0;
      return true;
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P._SetBase.prototype = {
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    addAll$1: function(_, elements) {
      var t1;
      for (t1 = J.get$iterator$ax(H.assertSubtype(elements, "$isIterable", this.$ti, "$asIterable")); t1.moveNext$0();)
        this.add$1(0, t1.get$current(t1));
    },
    toList$1$growable: function(_, growable) {
      var t1, i, i0, _this = this,
        result = H.setRuntimeTypeInfo([], _this.$ti);
      C.JSArray_methods.set$length(result, _this.get$length(_this));
      for (t1 = _this.get$iterator(_this), i = 0; t1.moveNext$0(); i = i0) {
        i0 = i + 1;
        C.JSArray_methods.$indexSet(result, i, t1.get$current(t1));
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return new H.EfficientLengthMappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    forEach$1: function(_, f) {
      var t1;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current(t1));
    },
    join$1: function(_, separator) {
      var t1,
        iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      if (separator === "") {
        t1 = "";
        do
          t1 += H.S(iterator.get$current(iterator));
        while (iterator.moveNext$0());
      } else {
        t1 = H.S(iterator.get$current(iterator));
        for (; iterator.moveNext$0();)
          t1 = t1 + separator + H.S(iterator.get$current(iterator));
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    elementAt$1: function(_, index) {
      var t1, elementIndex, element, _s5_ = "index";
      if (index == null)
        H.throwExpression(P.ArgumentError$notNull(_s5_));
      P.RangeError_checkNotNegative(index, _s5_);
      for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
        element = t1.get$current(t1);
        if (index === elementIndex)
          return element;
        ++elementIndex;
      }
      throw H.wrapException(P.IndexError$(index, this, _s5_, null, elementIndex));
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isSet: 1
  };
  P._ListBase_Object_ListMixin.prototype = {};
  P._UnmodifiableMapView_MapView__UnmodifiableMapMixin.prototype = {};
  P._JsonMap.prototype = {
    $index: function(_, key) {
      var result,
        t1 = this._processed;
      if (t1 == null)
        return this._data.$index(0, key);
      else if (typeof key !== "string")
        return;
      else {
        result = t1[key];
        return typeof result == "undefined" ? this._process$1(key) : result;
      }
    },
    get$length: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._computeKeys$0().length;
      return t1;
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$keys: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        return t1.get$keys(t1);
      }
      return new P._JsonMapKeyIterable(this);
    },
    $indexSet: function(_, key, value) {
      var processed, original, _this = this;
      if (_this._processed == null)
        _this._data.$indexSet(0, key, value);
      else if (_this.containsKey$1(0, key)) {
        processed = _this._processed;
        processed[key] = value;
        original = _this._original;
        if (original == null ? processed != null : original !== processed)
          original[key] = null;
      } else
        _this._upgrade$0().$indexSet(0, key, value);
    },
    containsKey$1: function(_, key) {
      if (this._processed == null)
        return this._data.containsKey$1(0, key);
      return Object.prototype.hasOwnProperty.call(this._original, key);
    },
    forEach$1: function(_, f) {
      var keys, i, key, value, _this = this;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
      if (_this._processed == null)
        return _this._data.forEach$1(0, f);
      keys = _this._computeKeys$0();
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        value = _this._processed[key];
        if (typeof value == "undefined") {
          value = P._convertJsonToDartLazy(_this._original[key]);
          _this._processed[key] = value;
        }
        f.call$2(key, value);
        if (keys !== _this._data)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
    },
    _computeKeys$0: function() {
      var keys = H.listTypeCheck(this._data);
      if (keys == null)
        keys = this._data = H.setRuntimeTypeInfo(Object.keys(this._original), [P.String]);
      return keys;
    },
    _upgrade$0: function() {
      var result, keys, i, t1, key, _this = this;
      if (_this._processed == null)
        return _this._data;
      result = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
      keys = _this._computeKeys$0();
      for (i = 0; t1 = keys.length, i < t1; ++i) {
        key = keys[i];
        result.$indexSet(0, key, _this.$index(0, key));
      }
      if (t1 === 0)
        C.JSArray_methods.add$1(keys, null);
      else
        C.JSArray_methods.set$length(keys, 0);
      _this._original = _this._processed = null;
      return _this._data = result;
    },
    _process$1: function(key) {
      var result;
      if (!Object.prototype.hasOwnProperty.call(this._original, key))
        return;
      result = P._convertJsonToDartLazy(this._original[key]);
      return this._processed[key] = result;
    },
    $asMapMixin: function() {
      return [P.String, null];
    },
    $asMap: function() {
      return [P.String, null];
    }
  };
  P._JsonMapKeyIterable.prototype = {
    get$length: function(_) {
      var t1 = this._convert$_parent;
      return t1.get$length(t1);
    },
    elementAt$1: function(_, index) {
      var t1 = this._convert$_parent;
      return t1._processed == null ? t1.get$keys(t1).elementAt$1(0, index) : C.JSArray_methods.$index(t1._computeKeys$0(), index);
    },
    get$iterator: function(_) {
      var t1 = this._convert$_parent;
      if (t1._processed == null) {
        t1 = t1.get$keys(t1);
        t1 = t1.get$iterator(t1);
      } else {
        t1 = t1._computeKeys$0();
        t1 = new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
      }
      return t1;
    },
    contains$1: function(_, key) {
      return this._convert$_parent.containsKey$1(0, key);
    },
    $asEfficientLengthIterable: function() {
      return [P.String];
    },
    $asListIterable: function() {
      return [P.String];
    },
    $asIterable: function() {
      return [P.String];
    }
  };
  P.Base64Codec.prototype = {
    normalize$3: function(_, source, start, end) {
      var inverseAlphabet, i, sliceStart, buffer, firstPadding, firstPaddingSourceIndex, paddingCount, i0, char, i1, digit1, digit2, char0, value, t1, t2, endLength, $length,
        _s31_ = "Invalid base64 encoding length ";
      end = P.RangeError_checkValidRange(start, end, source.length);
      inverseAlphabet = $.$get$_Base64Decoder__inverseAlphabet();
      if (typeof end !== "number")
        return H.iae(end);
      i = start;
      sliceStart = i;
      buffer = null;
      firstPadding = -1;
      firstPaddingSourceIndex = -1;
      paddingCount = 0;
      for (; i < end; i = i0) {
        i0 = i + 1;
        char = C.JSString_methods._codeUnitAt$1(source, i);
        if (char === 37) {
          i1 = i0 + 2;
          if (i1 <= end) {
            digit1 = H.hexDigitValue(C.JSString_methods._codeUnitAt$1(source, i0));
            digit2 = H.hexDigitValue(C.JSString_methods._codeUnitAt$1(source, i0 + 1));
            char0 = digit1 * 16 + digit2 - (digit2 & 256);
            if (char0 === 37)
              char0 = -1;
            i0 = i1;
          } else
            char0 = -1;
        } else
          char0 = char;
        if (0 <= char0 && char0 <= 127) {
          if (char0 < 0 || char0 >= inverseAlphabet.length)
            return H.ioore(inverseAlphabet, char0);
          value = inverseAlphabet[char0];
          if (value >= 0) {
            char0 = C.JSString_methods.codeUnitAt$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", value);
            if (char0 === char)
              continue;
            char = char0;
          } else {
            if (value === -1) {
              if (firstPadding < 0) {
                t1 = buffer == null ? null : buffer._contents.length;
                if (t1 == null)
                  t1 = 0;
                firstPadding = t1 + (i - sliceStart);
                firstPaddingSourceIndex = i;
              }
              ++paddingCount;
              if (char === 61)
                continue;
            }
            char = char0;
          }
          if (value !== -2) {
            if (buffer == null)
              buffer = new P.StringBuffer("");
            buffer._contents += C.JSString_methods.substring$2(source, sliceStart, i);
            buffer._contents += H.Primitives_stringFromCharCode(char);
            sliceStart = i0;
            continue;
          }
        }
        throw H.wrapException(P.FormatException$("Invalid base64 data", source, i));
      }
      if (buffer != null) {
        t1 = buffer._contents += C.JSString_methods.substring$2(source, sliceStart, end);
        t2 = t1.length;
        if (firstPadding >= 0)
          P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, t2);
        else {
          endLength = C.JSInt_methods.$mod(t2 - 1, 4) + 1;
          if (endLength === 1)
            throw H.wrapException(P.FormatException$(_s31_, source, end));
          for (; endLength < 4;) {
            t1 += "=";
            buffer._contents = t1;
            ++endLength;
          }
        }
        t1 = buffer._contents;
        return C.JSString_methods.replaceRange$3(source, start, end, t1.charCodeAt(0) == 0 ? t1 : t1);
      }
      $length = end - start;
      if (firstPadding >= 0)
        P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, $length);
      else {
        endLength = C.JSInt_methods.$mod($length, 4);
        if (endLength === 1)
          throw H.wrapException(P.FormatException$(_s31_, source, end));
        if (endLength > 1)
          source = C.JSString_methods.replaceRange$3(source, end, end, endLength === 2 ? "==" : "=");
      }
      return source;
    },
    $asCodec: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P.Base64Encoder.prototype = {
    $asConverter: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P.Codec.prototype = {};
  P.Converter.prototype = {};
  P.Encoding.prototype = {
    $asCodec: function() {
      return [P.String, [P.List, P.int]];
    }
  };
  P.JsonUnsupportedObjectError.prototype = {
    toString$0: function(_) {
      var safeString = P.Error_safeToString(this.unsupportedObject);
      return (this.cause != null ? "Converting object to an encodable object failed:" : "Converting object did not return an encodable object:") + " " + safeString;
    }
  };
  P.JsonCyclicError.prototype = {
    toString$0: function(_) {
      return "Cyclic error in JSON stringify";
    }
  };
  P.JsonCodec.prototype = {
    decode$1: function(_, source) {
      var t1 = P._parseJson(source, this.get$decoder()._reviver);
      return t1;
    },
    encode$1: function(value) {
      var t1 = P._JsonStringStringifier_stringify(value, this.get$encoder()._toEncodable, null);
      return t1;
    },
    get$encoder: function() {
      return C.JsonEncoder_null;
    },
    get$decoder: function() {
      return C.JsonDecoder_null;
    },
    $asCodec: function() {
      return [P.Object, P.String];
    }
  };
  P.JsonEncoder.prototype = {
    $asConverter: function() {
      return [P.Object, P.String];
    }
  };
  P.JsonDecoder.prototype = {
    $asConverter: function() {
      return [P.String, P.Object];
    }
  };
  P._JsonStringifier.prototype = {
    writeStringContent$1: function(s) {
      var t1, t2, offset, i, charCode, t3,
        $length = s.length;
      for (t1 = J.getInterceptor$s(s), t2 = this._sink, offset = 0, i = 0; i < $length; ++i) {
        charCode = t1._codeUnitAt$1(s, i);
        if (charCode > 92)
          continue;
        if (charCode < 32) {
          if (i > offset)
            t2._contents += C.JSString_methods.substring$2(s, offset, i);
          offset = i + 1;
          t2._contents += H.Primitives_stringFromCharCode(92);
          switch (charCode) {
            case 8:
              t2._contents += H.Primitives_stringFromCharCode(98);
              break;
            case 9:
              t2._contents += H.Primitives_stringFromCharCode(116);
              break;
            case 10:
              t2._contents += H.Primitives_stringFromCharCode(110);
              break;
            case 12:
              t2._contents += H.Primitives_stringFromCharCode(102);
              break;
            case 13:
              t2._contents += H.Primitives_stringFromCharCode(114);
              break;
            default:
              t2._contents += H.Primitives_stringFromCharCode(117);
              t2._contents += H.Primitives_stringFromCharCode(48);
              t2._contents += H.Primitives_stringFromCharCode(48);
              t3 = charCode >>> 4 & 15;
              t2._contents += H.Primitives_stringFromCharCode(t3 < 10 ? 48 + t3 : 87 + t3);
              t3 = charCode & 15;
              t2._contents += H.Primitives_stringFromCharCode(t3 < 10 ? 48 + t3 : 87 + t3);
              break;
          }
        } else if (charCode === 34 || charCode === 92) {
          if (i > offset)
            t2._contents += C.JSString_methods.substring$2(s, offset, i);
          offset = i + 1;
          t2._contents += H.Primitives_stringFromCharCode(92);
          t2._contents += H.Primitives_stringFromCharCode(charCode);
        }
      }
      if (offset === 0)
        t2._contents += H.S(s);
      else if (offset < $length)
        t2._contents += t1.substring$2(s, offset, $length);
    },
    _checkCycle$1: function(object) {
      var t1, t2, i, t3;
      for (t1 = this._seen, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i];
        if (object == null ? t3 == null : object === t3)
          throw H.wrapException(new P.JsonCyclicError(object, null));
      }
      C.JSArray_methods.add$1(t1, object);
    },
    writeObject$1: function(object) {
      var customJson, e, t1, exception, _this = this;
      if (_this.writeJsonValue$1(object))
        return;
      _this._checkCycle$1(object);
      try {
        customJson = _this._toEncodable.call$1(object);
        if (!_this.writeJsonValue$1(customJson)) {
          t1 = P.JsonUnsupportedObjectError$(object, null, _this.get$_partialResult());
          throw H.wrapException(t1);
        }
        t1 = _this._seen;
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        t1.pop();
      } catch (exception) {
        e = H.unwrapException(exception);
        t1 = P.JsonUnsupportedObjectError$(object, e, _this.get$_partialResult());
        throw H.wrapException(t1);
      }
    },
    writeJsonValue$1: function(object) {
      var t1, success, _this = this;
      if (typeof object === "number") {
        if (!isFinite(object))
          return false;
        _this._sink._contents += C.JSNumber_methods.toString$0(object);
        return true;
      } else if (object === true) {
        _this._sink._contents += "true";
        return true;
      } else if (object === false) {
        _this._sink._contents += "false";
        return true;
      } else if (object == null) {
        _this._sink._contents += "null";
        return true;
      } else if (typeof object === "string") {
        t1 = _this._sink;
        t1._contents += '"';
        _this.writeStringContent$1(object);
        t1._contents += '"';
        return true;
      } else {
        t1 = J.getInterceptor$(object);
        if (!!t1.$isList) {
          _this._checkCycle$1(object);
          _this.writeList$1(object);
          t1 = _this._seen;
          if (0 >= t1.length)
            return H.ioore(t1, -1);
          t1.pop();
          return true;
        } else if (!!t1.$isMap) {
          _this._checkCycle$1(object);
          success = _this.writeMap$1(object);
          t1 = _this._seen;
          if (0 >= t1.length)
            return H.ioore(t1, -1);
          t1.pop();
          return success;
        } else
          return false;
      }
    },
    writeList$1: function(list) {
      var t2, i, t3,
        t1 = this._sink;
      t1._contents += "[";
      t2 = J.getInterceptor$asx(list);
      if (t2.get$isNotEmpty(list)) {
        this.writeObject$1(t2.$index(list, 0));
        i = 1;
        while (true) {
          t3 = t2.get$length(list);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          t1._contents += ",";
          this.writeObject$1(t2.$index(list, i));
          ++i;
        }
      }
      t1._contents += "]";
    },
    writeMap$1: function(map) {
      var t2, keyValueList, i, separator, t3, _this = this, _box_0 = {},
        t1 = J.getInterceptor$asx(map);
      if (t1.get$isEmpty(map)) {
        _this._sink._contents += "{}";
        return true;
      }
      t2 = t1.get$length(map);
      if (typeof t2 !== "number")
        return t2.$mul();
      t2 *= 2;
      keyValueList = new Array(t2);
      keyValueList.fixed$length = Array;
      i = _box_0.i = 0;
      _box_0.allStringKeys = true;
      t1.forEach$1(map, new P._JsonStringifier_writeMap_closure(_box_0, keyValueList));
      if (!_box_0.allStringKeys)
        return false;
      t1 = _this._sink;
      t1._contents += "{";
      for (separator = '"'; i < t2; i += 2, separator = ',"') {
        t1._contents += separator;
        _this.writeStringContent$1(H.stringTypeCheck(keyValueList[i]));
        t1._contents += '":';
        t3 = i + 1;
        if (t3 >= t2)
          return H.ioore(keyValueList, t3);
        _this.writeObject$1(keyValueList[t3]);
      }
      t1._contents += "}";
      return true;
    }
  };
  P._JsonStringifier_writeMap_closure.prototype = {
    call$2: function(key, value) {
      var t1, t2;
      if (typeof key !== "string")
        this._box_0.allStringKeys = false;
      t1 = this.keyValueList;
      t2 = this._box_0;
      C.JSArray_methods.$indexSet(t1, t2.i++, key);
      C.JSArray_methods.$indexSet(t1, t2.i++, value);
    },
    $signature: 5
  };
  P._JsonStringStringifier.prototype = {
    get$_partialResult: function() {
      var t1 = this._sink._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  P.Utf8Codec.prototype = {
    decode$1: function(_, codeUnits) {
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      return new P.Utf8Decoder(false).convert$1(codeUnits);
    },
    get$encoder: function() {
      return C.C_Utf8Encoder;
    }
  };
  P.Utf8Encoder.prototype = {
    convert$1: function(string) {
      var $length, t1, encoder,
        end = P.RangeError_checkValidRange(0, null, string.length);
      if (typeof end !== "number")
        return end.$sub();
      $length = end - 0;
      if ($length === 0)
        return new Uint8Array(0);
      t1 = new Uint8Array($length * 3);
      encoder = new P._Utf8Encoder(t1);
      if (encoder._fillBuffer$3(string, 0, end) !== end)
        encoder._writeSurrogate$2(C.JSString_methods.codeUnitAt$1(string, end - 1), 0);
      return new Uint8Array(t1.subarray(0, H._checkValidRange(0, encoder._bufferIndex, t1.length)));
    },
    $asConverter: function() {
      return [P.String, [P.List, P.int]];
    }
  };
  P._Utf8Encoder.prototype = {
    _writeSurrogate$2: function(leadingSurrogate, nextCodeUnit) {
      var rune, _this = this,
        t1 = _this._convert$_buffer,
        t2 = _this._bufferIndex,
        t3 = t2 + 1,
        t4 = t1.length;
      if ((nextCodeUnit & 64512) === 56320) {
        rune = 65536 + ((leadingSurrogate & 1023) << 10) | nextCodeUnit & 1023;
        _this._bufferIndex = t3;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 240 | rune >>> 18;
        t2 = _this._bufferIndex = t3 + 1;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | rune >>> 12 & 63;
        t3 = _this._bufferIndex = t2 + 1;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 128 | rune >>> 6 & 63;
        _this._bufferIndex = t3 + 1;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | rune & 63;
        return true;
      } else {
        _this._bufferIndex = t3;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 224 | leadingSurrogate >>> 12;
        t2 = _this._bufferIndex = t3 + 1;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | leadingSurrogate >>> 6 & 63;
        _this._bufferIndex = t2 + 1;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 128 | leadingSurrogate & 63;
        return false;
      }
    },
    _fillBuffer$3: function(str, start, end) {
      var t1, t2, stringIndex, codeUnit, t3, stringIndex0, t4, _this = this;
      if (start !== end && (C.JSString_methods.codeUnitAt$1(str, end - 1) & 64512) === 55296)
        --end;
      for (t1 = _this._convert$_buffer, t2 = t1.length, stringIndex = start; stringIndex < end; ++stringIndex) {
        codeUnit = C.JSString_methods._codeUnitAt$1(str, stringIndex);
        if (codeUnit <= 127) {
          t3 = _this._bufferIndex;
          if (t3 >= t2)
            break;
          _this._bufferIndex = t3 + 1;
          t1[t3] = codeUnit;
        } else if ((codeUnit & 64512) === 55296) {
          if (_this._bufferIndex + 3 >= t2)
            break;
          stringIndex0 = stringIndex + 1;
          if (_this._writeSurrogate$2(codeUnit, C.JSString_methods._codeUnitAt$1(str, stringIndex0)))
            stringIndex = stringIndex0;
        } else if (codeUnit <= 2047) {
          t3 = _this._bufferIndex;
          t4 = t3 + 1;
          if (t4 >= t2)
            break;
          _this._bufferIndex = t4;
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = 192 | codeUnit >>> 6;
          _this._bufferIndex = t4 + 1;
          t1[t4] = 128 | codeUnit & 63;
        } else {
          t3 = _this._bufferIndex;
          if (t3 + 2 >= t2)
            break;
          t4 = _this._bufferIndex = t3 + 1;
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = 224 | codeUnit >>> 12;
          t3 = _this._bufferIndex = t4 + 1;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 128 | codeUnit >>> 6 & 63;
          _this._bufferIndex = t3 + 1;
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = 128 | codeUnit & 63;
        }
      }
      return stringIndex;
    }
  };
  P.Utf8Decoder.prototype = {
    convert$1: function(codeUnits) {
      var result, end, oneBytes, firstPart, buffer, start, isFirstCharacter, decoder, t1;
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      result = P.Utf8Decoder__convertIntercepted(false, codeUnits, 0, null);
      if (result != null)
        return result;
      end = P.RangeError_checkValidRange(0, null, codeUnits.length);
      oneBytes = P._scanOneByteCharacters(codeUnits, 0, end);
      if (oneBytes > 0) {
        firstPart = P.String_String$fromCharCodes(codeUnits, 0, oneBytes);
        if (oneBytes === end)
          return firstPart;
        buffer = new P.StringBuffer(firstPart);
        start = oneBytes;
        isFirstCharacter = false;
      } else {
        start = 0;
        buffer = null;
        isFirstCharacter = true;
      }
      if (buffer == null)
        buffer = new P.StringBuffer("");
      decoder = new P._Utf8Decoder(false, buffer);
      decoder._isFirstCharacter = isFirstCharacter;
      decoder.convert$3(codeUnits, start, end);
      if (decoder._expectedUnits > 0) {
        H.throwExpression(P.FormatException$("Unfinished UTF-8 octet sequence", codeUnits, end));
        buffer._contents += H.Primitives_stringFromCharCode(65533);
        decoder._extraUnits = decoder._expectedUnits = decoder._convert$_value = 0;
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $asConverter: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P._Utf8Decoder.prototype = {
    convert$3: function(codeUnits, startIndex, endIndex) {
      var value, expectedUnits, extraUnits, t1, t2, i, unit, t3, oneBytes, i0, i1, t4, _this = this,
        _s21_ = "Bad UTF-8 encoding 0x";
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      value = _this._convert$_value;
      expectedUnits = _this._expectedUnits;
      extraUnits = _this._extraUnits;
      _this._extraUnits = _this._expectedUnits = _this._convert$_value = 0;
      $label0$0:
        for (t1 = codeUnits.length, t2 = _this._stringSink, i = startIndex; true; i = i1) {
          $label1$1:
            if (expectedUnits > 0) {
              do {
                if (i === endIndex)
                  break $label0$0;
                if (i < 0 || i >= t1)
                  return H.ioore(codeUnits, i);
                unit = codeUnits[i];
                if ((unit & 192) !== 128) {
                  t3 = P.FormatException$(_s21_ + C.JSInt_methods.toRadixString$1(unit, 16), codeUnits, i);
                  throw H.wrapException(t3);
                } else {
                  value = (value << 6 | unit & 63) >>> 0;
                  --expectedUnits;
                  ++i;
                }
              } while (expectedUnits > 0);
              t3 = extraUnits - 1;
              if (t3 < 0 || t3 >= 4)
                return H.ioore(C.List_127_2047_65535_1114111, t3);
              if (value <= C.List_127_2047_65535_1114111[t3]) {
                t3 = P.FormatException$("Overlong encoding of 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                throw H.wrapException(t3);
              }
              if (value > 1114111) {
                t3 = P.FormatException$("Character outside valid Unicode range: 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                throw H.wrapException(t3);
              }
              if (!_this._isFirstCharacter || value !== 65279)
                t2._contents += H.Primitives_stringFromCharCode(value);
              _this._isFirstCharacter = false;
            }
          if (typeof endIndex !== "number")
            return H.iae(endIndex);
          t3 = i < endIndex;
          for (; t3;) {
            oneBytes = P._scanOneByteCharacters(codeUnits, i, endIndex);
            if (oneBytes > 0) {
              _this._isFirstCharacter = false;
              i0 = i + oneBytes;
              t2._contents += P.String_String$fromCharCodes(codeUnits, i, i0);
              if (i0 === endIndex)
                break;
            } else
              i0 = i;
            i1 = i0 + 1;
            if (i0 < 0 || i0 >= t1)
              return H.ioore(codeUnits, i0);
            unit = codeUnits[i0];
            if ((unit & 224) === 192) {
              value = unit & 31;
              expectedUnits = 1;
              extraUnits = 1;
              continue $label0$0;
            }
            if ((unit & 240) === 224) {
              value = unit & 15;
              expectedUnits = 2;
              extraUnits = 2;
              continue $label0$0;
            }
            if ((unit & 248) === 240 && unit < 245) {
              value = unit & 7;
              expectedUnits = 3;
              extraUnits = 3;
              continue $label0$0;
            }
            t4 = P.FormatException$(_s21_ + C.JSInt_methods.toRadixString$1(unit, 16), codeUnits, i1 - 1);
            throw H.wrapException(t4);
          }
          break $label0$0;
        }
      if (expectedUnits > 0) {
        _this._convert$_value = value;
        _this._expectedUnits = expectedUnits;
        _this._extraUnits = extraUnits;
      }
    }
  };
  P.NoSuchMethodError_toString_closure.prototype = {
    call$2: function(key, value) {
      var t1, t2, t3;
      H.interceptedTypeCheck(key, "$isSymbol0");
      t1 = this.sb;
      t2 = this._box_0;
      t1._contents += t2.comma;
      t3 = t1._contents += H.S(key.__internal$_name);
      t1._contents = t3 + ": ";
      t1._contents += P.Error_safeToString(value);
      t2.comma = ", ";
    },
    $signature: 88
  };
  P.bool.prototype = {};
  P.Comparable.prototype = {};
  P.DateTime.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof P.DateTime && this._core$_value === other._core$_value && this.isUtc === other.isUtc;
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this._core$_value, H.interceptedTypeCheck(other, "$isDateTime")._core$_value);
    },
    DateTime$_withValue$2$isUtc: function(_value, isUtc) {
      var t2,
        t1 = this._core$_value;
      if (Math.abs(t1) <= 864e13)
        t2 = false;
      else
        t2 = true;
      if (t2)
        throw H.wrapException(P.ArgumentError$("DateTime is outside valid range: " + t1));
    },
    get$hashCode: function(_) {
      var t1 = this._core$_value;
      return (t1 ^ C.JSInt_methods._shrOtherPositive$1(t1, 30)) & 1073741823;
    },
    toString$0: function(_) {
      var _this = this,
        y = P.DateTime__fourDigits(H.Primitives_getYear(_this)),
        m = P.DateTime__twoDigits(H.Primitives_getMonth(_this)),
        d = P.DateTime__twoDigits(H.Primitives_getDay(_this)),
        h = P.DateTime__twoDigits(H.Primitives_getHours(_this)),
        min = P.DateTime__twoDigits(H.Primitives_getMinutes(_this)),
        sec = P.DateTime__twoDigits(H.Primitives_getSeconds(_this)),
        ms = P.DateTime__threeDigits(H.Primitives_getMilliseconds(_this));
      if (_this.isUtc)
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z";
      else
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.DateTime];
    }
  };
  P.double.prototype = {};
  P.Duration.prototype = {
    $gt: function(_, other) {
      return this._duration > other._duration;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof P.Duration && this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this._duration);
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    toString$0: function(_) {
      var twoDigitMinutes, twoDigitSeconds, sixDigitUs,
        t1 = new P.Duration_toString_twoDigits(),
        t2 = this._duration;
      if (t2 < 0)
        return "-" + new P.Duration(0 - t2).toString$0(0);
      twoDigitMinutes = t1.call$1(C.JSInt_methods._tdivFast$1(t2, 60000000) % 60);
      twoDigitSeconds = t1.call$1(C.JSInt_methods._tdivFast$1(t2, 1000000) % 60);
      sixDigitUs = new P.Duration_toString_sixDigits().call$1(t2 % 1000000);
      return "" + C.JSInt_methods._tdivFast$1(t2, 3600000000) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.Duration];
    }
  };
  P.Duration_toString_sixDigits.prototype = {
    call$1: function(n) {
      if (n >= 100000)
        return "" + n;
      if (n >= 10000)
        return "0" + n;
      if (n >= 1000)
        return "00" + n;
      if (n >= 100)
        return "000" + n;
      if (n >= 10)
        return "0000" + n;
      return "00000" + n;
    },
    $signature: 16
  };
  P.Duration_toString_twoDigits.prototype = {
    call$1: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    },
    $signature: 16
  };
  P.Error.prototype = {};
  P.AssertionError.prototype = {
    toString$0: function(_) {
      return "Assertion failed";
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.NullThrownError.prototype = {
    toString$0: function(_) {
      return "Throw of null.";
    }
  };
  P.ArgumentError.prototype = {
    get$_errorName: function() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation: function() {
      return "";
    },
    toString$0: function(_) {
      var message, prefix, explanation, errorValue, _this = this,
        t1 = _this.name,
        nameString = t1 != null ? " (" + t1 + ")" : "";
      t1 = _this.message;
      message = t1 == null ? "" : ": " + H.S(t1);
      prefix = _this.get$_errorName() + nameString + message;
      if (!_this._hasValue)
        return prefix;
      explanation = _this.get$_errorExplanation();
      errorValue = P.Error_safeToString(_this.invalidValue);
      return prefix + explanation + ": " + errorValue;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.RangeError.prototype = {
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var explanation, t2,
        t1 = this.start;
      if (t1 == null) {
        t1 = this.end;
        explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
      } else {
        t2 = this.end;
        if (t2 == null)
          explanation = ": Not greater than or equal to " + H.S(t1);
        else if (t2 > t1)
          explanation = ": Not in range " + H.S(t1) + ".." + H.S(t2) + ", inclusive";
        else
          explanation = t2 < t1 ? ": Valid value range is empty" : ": Only valid value is " + H.S(t1);
      }
      return explanation;
    }
  };
  P.IndexError.prototype = {
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var t1,
        invalidValue = H.intTypeCheck(this.invalidValue);
      if (typeof invalidValue !== "number")
        return invalidValue.$lt();
      if (invalidValue < 0)
        return ": index must not be negative";
      t1 = this.length;
      if (t1 === 0)
        return ": no indices are valid";
      return ": index should be less than " + H.S(t1);
    },
    get$length: function(receiver) {
      return this.length;
    }
  };
  P.NoSuchMethodError.prototype = {
    toString$0: function(_) {
      var t1, t2, _i, t3, t4, argument, receiverText, actualParameters, _this = this, _box_0 = {},
        sb = new P.StringBuffer("");
      _box_0.comma = "";
      for (t1 = _this._core$_arguments, t2 = t1.length, _i = 0, t3 = "", t4 = ""; _i < t2; ++_i, t4 = ", ") {
        argument = t1[_i];
        sb._contents = t3 + t4;
        t3 = sb._contents += P.Error_safeToString(argument);
        _box_0.comma = ", ";
      }
      _this._namedArguments.forEach$1(0, new P.NoSuchMethodError_toString_closure(_box_0, sb));
      receiverText = P.Error_safeToString(_this._core$_receiver);
      actualParameters = sb.toString$0(0);
      t1 = "NoSuchMethodError: method not found: '" + H.S(_this._core$_memberName.__internal$_name) + "'\nReceiver: " + receiverText + "\nArguments: [" + actualParameters + "]";
      return t1;
    }
  };
  P.UnsupportedError.prototype = {
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.UnimplementedError.prototype = {
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + t1 : "UnimplementedError";
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.StateError.prototype = {
    toString$0: function(_) {
      return "Bad state: " + this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.ConcurrentModificationError.prototype = {
    toString$0: function(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + P.Error_safeToString(t1) + ".";
    }
  };
  P.OutOfMemoryError.prototype = {
    toString$0: function(_) {
      return "Out of Memory";
    },
    $isError: 1
  };
  P.StackOverflowError.prototype = {
    toString$0: function(_) {
      return "Stack Overflow";
    },
    $isError: 1
  };
  P.CyclicInitializationError.prototype = {
    toString$0: function(_) {
      var t1 = this.variableName;
      return t1 == null ? "Reading static variable during its initialization" : "Reading static variable '" + t1 + "' during its initialization";
    }
  };
  P._Exception.prototype = {
    toString$0: function(_) {
      return "Exception: " + this.message;
    },
    $isException: 1,
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.FormatException.prototype = {
    toString$0: function(_) {
      var source, lineNum, lineStart, previousCharWasCR, i, char, lineEnd, end, start, prefix, postfix, slice,
        t1 = this.message,
        report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException",
        offset = this.offset,
        objectSource = this.source;
      if (typeof objectSource === "string") {
        if (offset != null)
          t1 = offset < 0 || offset > objectSource.length;
        else
          t1 = false;
        if (t1)
          offset = null;
        if (offset == null) {
          source = objectSource.length > 78 ? C.JSString_methods.substring$2(objectSource, 0, 75) + "..." : objectSource;
          return report + "\n" + source;
        }
        for (lineNum = 1, lineStart = 0, previousCharWasCR = false, i = 0; i < offset; ++i) {
          char = C.JSString_methods._codeUnitAt$1(objectSource, i);
          if (char === 10) {
            if (lineStart !== i || !previousCharWasCR)
              ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = false;
          } else if (char === 13) {
            ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = true;
          }
        }
        report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + (offset - lineStart + 1) + ")\n") : report + (" (at character " + (offset + 1) + ")\n");
        lineEnd = objectSource.length;
        for (i = offset; i < lineEnd; ++i) {
          char = C.JSString_methods.codeUnitAt$1(objectSource, i);
          if (char === 10 || char === 13) {
            lineEnd = i;
            break;
          }
        }
        if (lineEnd - lineStart > 78)
          if (offset - lineStart < 75) {
            end = lineStart + 75;
            start = lineStart;
            prefix = "";
            postfix = "...";
          } else {
            if (lineEnd - offset < 75) {
              start = lineEnd - 75;
              end = lineEnd;
              postfix = "";
            } else {
              start = offset - 36;
              end = offset + 36;
              postfix = "...";
            }
            prefix = "...";
          }
        else {
          end = lineEnd;
          start = lineStart;
          prefix = "";
          postfix = "";
        }
        slice = C.JSString_methods.substring$2(objectSource, start, end);
        return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
      } else
        return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
    },
    $isException: 1,
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.Function.prototype = {};
  P.int.prototype = {};
  P.Iterable.prototype = {
    map$1$1: function(_, f, $T) {
      var t1 = H.getRuntimeTypeArgument(this, "Iterable", 0);
      return H.MappedIterable_MappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), t1, $T);
    },
    where$1: function(_, test) {
      var t1 = H.getRuntimeTypeArgument(this, "Iterable", 0);
      return new H.WhereIterable(this, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]}), [t1]);
    },
    contains$1: function(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq$(t1.get$current(t1), element))
          return true;
      return false;
    },
    forEach$1: function(_, f) {
      var t1;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "Iterable", 0)]});
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current(t1));
    },
    join$1: function(_, separator) {
      var t1,
        iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      if (separator === "") {
        t1 = "";
        do
          t1 += H.S(iterator.get$current(iterator));
        while (iterator.moveNext$0());
      } else {
        t1 = H.S(iterator.get$current(iterator));
        for (; iterator.moveNext$0();)
          t1 = t1 + separator + H.S(iterator.get$current(iterator));
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    toList$1$growable: function(_, growable) {
      return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "Iterable", 0));
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toSet$0: function(_) {
      return P.LinkedHashSet_LinkedHashSet$from(this, H.getRuntimeTypeArgument(this, "Iterable", 0));
    },
    get$length: function(_) {
      var count,
        it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty: function(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    get$single: function(_) {
      var result,
        it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      result = it.get$current(it);
      if (it.moveNext$0())
        throw H.wrapException(H.IterableElementError_tooMany());
      return result;
    },
    elementAt$1: function(_, index) {
      var t1, elementIndex, element, _s5_ = "index";
      if (index == null)
        H.throwExpression(P.ArgumentError$notNull(_s5_));
      P.RangeError_checkNotNegative(index, _s5_);
      for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
        element = t1.get$current(t1);
        if (index === elementIndex)
          return element;
        ++elementIndex;
      }
      throw H.wrapException(P.IndexError$(index, this, _s5_, null, elementIndex));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    }
  };
  P.Iterator.prototype = {};
  P.List.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1};
  P.Map.prototype = {};
  P.Null.prototype = {
    get$hashCode: function(_) {
      return P.Object.prototype.get$hashCode.call(this, this);
    },
    toString$0: function(_) {
      return "null";
    }
  };
  P.num.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  };
  P.Object.prototype = {constructor: P.Object, $isObject: 1,
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return "Instance of '" + H.Primitives_objectTypeName(this) + "'";
    },
    noSuchMethod$1: function(_, invocation) {
      H.interceptedTypeCheck(invocation, "$isInvocation");
      throw H.wrapException(P.NoSuchMethodError$(this, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments()));
    },
    get$runtimeType: function(_) {
      return new H.TypeImpl(H.getRti(this));
    },
    toString: function() {
      return this.toString$0(this);
    }
  };
  P.Set.prototype = {};
  P.StackTrace.prototype = {};
  P.Stopwatch.prototype = {
    get$elapsedMicroseconds: function() {
      var t2, ticks,
        t1 = this._stop;
      if (t1 == null)
        t1 = H.intTypeCheck($.Primitives_timerTicks.call$0());
      t2 = this._core$_start;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      ticks = t1 - t2;
      if ($.Stopwatch__frequency === 1000000)
        return ticks;
      return ticks * 1000;
    },
    start$0: function(_) {
      var t1, t2, t3, _this = this;
      if (_this._stop != null) {
        t1 = _this._core$_start;
        t2 = H.intTypeCheck($.Primitives_timerTicks.call$0());
        t3 = _this._stop;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (typeof t1 !== "number")
          return t1.$add();
        _this._core$_start = t1 + (t2 - t3);
        _this._stop = null;
      }
    },
    stop$0: function(_) {
      if (this._stop == null)
        this._stop = H.intTypeCheck($.Primitives_timerTicks.call$0());
    },
    reset$0: function(_) {
      var t1 = this._stop;
      this._core$_start = t1 == null ? H.intTypeCheck($.Primitives_timerTicks.call$0()) : t1;
    }
  };
  P.String.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [P.String];
    },
    $isPattern: 1
  };
  P.StringBuffer.prototype = {
    get$length: function(_) {
      return this._contents.length;
    },
    toString$0: function(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    get$isEmpty: function(_) {
      return this._contents.length === 0;
    },
    $isStringSink: 1
  };
  P.Symbol0.prototype = {};
  P.Type.prototype = {};
  P.Uri__parseIPv4Address_error.prototype = {
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv4 address, " + msg, this.host, position));
    },
    $signature: 99
  };
  P.Uri_parseIPv6Address_error.prototype = {
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv6 address, " + msg, this.host, position));
    },
    call$1: function(msg) {
      return this.call$2(msg, null);
    },
    $signature: 69
  };
  P.Uri_parseIPv6Address_parseHex.prototype = {
    call$2: function(start, end) {
      var value;
      if (end - start > 4)
        this.error.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
      value = P.int_parse(C.JSString_methods.substring$2(this.host, start, end), null, 16);
      if (typeof value !== "number")
        return value.$lt();
      if (value < 0 || value > 65535)
        this.error.call$2("each part must be in the range of `0x0..0xFFFF`", start);
      return value;
    },
    $signature: 128
  };
  P._Uri.prototype = {
    get$userInfo: function() {
      return this._userInfo;
    },
    get$host: function(_) {
      var t1 = this._host;
      if (t1 == null)
        return "";
      if (C.JSString_methods.startsWith$1(t1, "["))
        return C.JSString_methods.substring$2(t1, 1, t1.length - 1);
      return t1;
    },
    get$port: function(_) {
      var t1 = this._port;
      if (t1 == null)
        return P._Uri__defaultPort(this.scheme);
      return t1;
    },
    get$query: function(_) {
      var t1 = this._query;
      return t1 == null ? "" : t1;
    },
    get$fragment: function() {
      var t1 = this._fragment;
      return t1 == null ? "" : t1;
    },
    get$hasScheme: function() {
      return this.scheme.length !== 0;
    },
    get$hasAuthority: function() {
      return this._host != null;
    },
    get$hasQuery: function() {
      return this._query != null;
    },
    get$hasFragment: function() {
      return this._fragment != null;
    },
    toString$0: function(_) {
      var t2, t3, t4, _this = this,
        t1 = _this._core$_text;
      if (t1 == null) {
        t1 = _this.scheme;
        t2 = t1.length !== 0 ? t1 + ":" : "";
        t3 = _this._host;
        t4 = t3 == null;
        if (!t4 || t1 === "file") {
          t1 = t2 + "//";
          t2 = _this._userInfo;
          if (t2.length !== 0)
            t1 = t1 + H.S(t2) + "@";
          if (!t4)
            t1 += t3;
          t2 = _this._port;
          if (t2 != null)
            t1 = t1 + ":" + H.S(t2);
        } else
          t1 = t2;
        t1 += _this.path;
        t2 = _this._query;
        if (t2 != null)
          t1 = t1 + "?" + t2;
        t2 = _this._fragment;
        if (t2 != null)
          t1 = t1 + "#" + t2;
        t1 = _this._core$_text = t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      return t1;
    },
    $eq: function(_, other) {
      var t1, t2, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!!J.getInterceptor$(other).$isUri)
        if (_this.scheme === other.get$scheme())
          if (_this._host != null === other.get$hasAuthority())
            if (_this._userInfo == other.get$userInfo())
              if (_this.get$host(_this) == other.get$host(other))
                if (_this.get$port(_this) == other.get$port(other))
                  if (_this.path === other.get$path(other)) {
                    t1 = _this._query;
                    t2 = t1 == null;
                    if (!t2 === other.get$hasQuery()) {
                      if (t2)
                        t1 = "";
                      if (t1 === other.get$query(other)) {
                        t1 = _this._fragment;
                        t2 = t1 == null;
                        if (!t2 === other.get$hasFragment()) {
                          if (t2)
                            t1 = "";
                          t1 = t1 === other.get$fragment();
                        } else
                          t1 = false;
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this._hashCodeCache;
      return t1 == null ? this._hashCodeCache = C.JSString_methods.get$hashCode(this.toString$0(0)) : t1;
    },
    $isUri: 1,
    get$scheme: function() {
      return this.scheme;
    },
    get$path: function(receiver) {
      return this.path;
    }
  };
  P._Uri__Uri$notSimple_closure.prototype = {
    call$1: function(_) {
      throw H.wrapException(P.FormatException$("Invalid port", this.uri, this.portStart + 1));
    },
    $signature: 62
  };
  P._Uri__makePath_closure.prototype = {
    call$1: function(s) {
      return P._Uri__uriEncode(C.List_qg40, s, C.C_Utf8Codec, false);
    },
    $signature: 8
  };
  P.UriData.prototype = {
    get$uri: function() {
      var t2, queryIndex, end, query, _this = this, _null = null,
        t1 = _this._uriCache;
      if (t1 != null)
        return t1;
      t1 = _this._separatorIndices;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t2 = _this._core$_text;
      t1 = t1[0] + 1;
      queryIndex = C.JSString_methods.indexOf$2(t2, "?", t1);
      end = t2.length;
      if (queryIndex >= 0) {
        query = P._Uri__normalizeOrSubstring(t2, queryIndex + 1, end, C.List_CVk, false);
        end = queryIndex;
      } else
        query = _null;
      return _this._uriCache = new P._DataUri("data", _null, _null, _null, P._Uri__normalizeOrSubstring(t2, t1, end, C.List_qg4, false), query, _null);
    },
    toString$0: function(_) {
      var t2,
        t1 = this._separatorIndices;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t2 = this._core$_text;
      return t1[0] === -1 ? "data:" + t2 : t2;
    }
  };
  P._createTables_closure.prototype = {
    call$1: function(_) {
      return new Uint8Array(96);
    },
    $signature: 65
  };
  P._createTables_build.prototype = {
    call$2: function(state, defaultTransition) {
      var t1 = this.tables;
      if (state >= t1.length)
        return H.ioore(t1, state);
      t1 = t1[state];
      J.fillRange$3$x(t1, 0, 96, defaultTransition);
      return t1;
    },
    $signature: 127
  };
  P._createTables_setChars.prototype = {
    call$3: function(target, chars, transition) {
      var t1, t2, i, t3;
      for (t1 = chars.length, t2 = target.length, i = 0; i < t1; ++i) {
        t3 = C.JSString_methods._codeUnitAt$1(chars, i) ^ 96;
        if (t3 >= t2)
          return H.ioore(target, t3);
        target[t3] = transition;
      }
    },
    $signature: 26
  };
  P._createTables_setRange.prototype = {
    call$3: function(target, range, transition) {
      var i, n, t1, t2;
      for (i = C.JSString_methods._codeUnitAt$1(range, 0), n = C.JSString_methods._codeUnitAt$1(range, 1), t1 = target.length; i <= n; ++i) {
        t2 = (i ^ 96) >>> 0;
        if (t2 >= t1)
          return H.ioore(target, t2);
        target[t2] = transition;
      }
    },
    $signature: 26
  };
  P._SimpleUri.prototype = {
    get$hasScheme: function() {
      return this._schemeEnd > 0;
    },
    get$hasAuthority: function() {
      return this._hostStart > 0;
    },
    get$hasQuery: function() {
      var t1 = this._queryStart;
      if (typeof t1 !== "number")
        return t1.$lt();
      return t1 < this._fragmentStart;
    },
    get$hasFragment: function() {
      return this._fragmentStart < this._uri.length;
    },
    get$_isHttp: function() {
      return this._schemeEnd === 4 && C.JSString_methods.startsWith$1(this._uri, "http");
    },
    get$_isHttps: function() {
      return this._schemeEnd === 5 && C.JSString_methods.startsWith$1(this._uri, "https");
    },
    get$scheme: function() {
      var t2, _this = this, _s4_ = "file",
        _s7_ = "package",
        t1 = _this._schemeEnd;
      if (t1 <= 0)
        return "";
      t2 = _this._schemeCache;
      if (t2 != null)
        return t2;
      if (_this.get$_isHttp())
        t1 = _this._schemeCache = "http";
      else if (_this.get$_isHttps()) {
        _this._schemeCache = "https";
        t1 = "https";
      } else if (t1 === 4 && C.JSString_methods.startsWith$1(_this._uri, _s4_)) {
        _this._schemeCache = _s4_;
        t1 = _s4_;
      } else if (t1 === 7 && C.JSString_methods.startsWith$1(_this._uri, _s7_)) {
        _this._schemeCache = _s7_;
        t1 = _s7_;
      } else {
        t1 = C.JSString_methods.substring$2(_this._uri, 0, t1);
        _this._schemeCache = t1;
      }
      return t1;
    },
    get$userInfo: function() {
      var t1 = this._hostStart,
        t2 = this._schemeEnd + 3;
      return t1 > t2 ? C.JSString_methods.substring$2(this._uri, t2, t1 - 1) : "";
    },
    get$host: function(_) {
      var t1 = this._hostStart;
      return t1 > 0 ? C.JSString_methods.substring$2(this._uri, t1, this._portStart) : "";
    },
    get$port: function(_) {
      var t1, t2, _this = this;
      if (_this._hostStart > 0) {
        t1 = _this._portStart;
        if (typeof t1 !== "number")
          return t1.$add();
        t2 = _this._pathStart;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = t1 + 1 < t2;
        t1 = t2;
      } else
        t1 = false;
      if (t1) {
        t1 = _this._portStart;
        if (typeof t1 !== "number")
          return t1.$add();
        return P.int_parse(C.JSString_methods.substring$2(_this._uri, t1 + 1, _this._pathStart), null, null);
      }
      if (_this.get$_isHttp())
        return 80;
      if (_this.get$_isHttps())
        return 443;
      return 0;
    },
    get$path: function(_) {
      return C.JSString_methods.substring$2(this._uri, this._pathStart, this._queryStart);
    },
    get$query: function(_) {
      var t1 = this._queryStart,
        t2 = this._fragmentStart;
      if (typeof t1 !== "number")
        return t1.$lt();
      return t1 < t2 ? C.JSString_methods.substring$2(this._uri, t1 + 1, t2) : "";
    },
    get$fragment: function() {
      var t1 = this._fragmentStart,
        t2 = this._uri;
      return t1 < t2.length ? C.JSString_methods.substring$1(t2, t1 + 1) : "";
    },
    get$hashCode: function(_) {
      var t1 = this._hashCodeCache;
      return t1 == null ? this._hashCodeCache = C.JSString_methods.get$hashCode(this._uri) : t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return !!J.getInterceptor$(other).$isUri && this._uri === other.toString$0(0);
    },
    toString$0: function(_) {
      return this._uri;
    },
    $isUri: 1
  };
  P._DataUri.prototype = {};
  P.ServiceExtensionResponse.prototype = {};
  P._SyncBlock.prototype = {};
  W.promiseToFuture_closure.prototype = {
    call$1: function(promiseValue) {
      return this.completer.complete$1(0, H.futureOrCheck(promiseValue, {futureOr: 1, type: this.T}));
    },
    $signature: 3
  };
  W.promiseToFuture_closure0.prototype = {
    call$1: function(promiseError) {
      return this.completer.completeError$1(promiseError);
    },
    $signature: 3
  };
  W.HtmlElement.prototype = {$isHtmlElement: 1};
  W.AccessibleNodeList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.AnchorElement.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isAnchorElement: 1
  };
  W.ApplicationCacheErrorEvent.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.AreaElement.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    }
  };
  W.BaseElement.prototype = {$isBaseElement: 1};
  W.Blob.prototype = {$isBlob: 1};
  W.BodyElement.prototype = {$isBodyElement: 1};
  W.CanvasElement.prototype = {$isCanvasElement: 1};
  W.CanvasRenderingContext2D.prototype = {
    fillText$3: function(receiver, text, x, y) {
      receiver.fillText(text, x, y);
    },
    $isCanvasRenderingContext2D: 1
  };
  W.CharacterData.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.CssNumericValue.prototype = {$isCssNumericValue: 1};
  W.CssPerspective.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.CssRule.prototype = {$isCssRule: 1};
  W.CssStyleDeclaration.prototype = {
    _browserPropertyName$1: function(receiver, propertyName) {
      var t1 = $.$get$CssStyleDeclaration__propertyCache(),
        $name = t1[propertyName];
      if (typeof $name === "string")
        return $name;
      $name = this._supportedBrowserPropertyName$1(receiver, propertyName);
      t1[propertyName] = $name;
      return $name;
    },
    _supportedBrowserPropertyName$1: function(receiver, propertyName) {
      var prefixed;
      if (propertyName.replace(/^-ms-/, "ms-").replace(/-([\da-z])/ig, function(_, letter) {
        return letter.toUpperCase();
      }) in receiver)
        return propertyName;
      prefixed = P.Device_cssPrefix() + propertyName;
      if (prefixed in receiver)
        return prefixed;
      return propertyName;
    },
    _setPropertyHelper$3: function(receiver, propertyName, value, priority) {
      if (priority == null)
        priority = "";
      receiver.setProperty(propertyName, value, priority);
    },
    set$height: function(receiver, value) {
      receiver.height = value;
    },
    set$left: function(receiver, value) {
      receiver.left = value;
    },
    set$overflow: function(receiver, value) {
      receiver.overflow = value;
    },
    set$position: function(receiver, value) {
      receiver.position = value;
    },
    set$top: function(receiver, value) {
      receiver.top = value;
    },
    set$visibility: function(receiver, value) {
      receiver.visibility = value;
    },
    set$width: function(receiver, value) {
      receiver.width = value;
    },
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.CssStyleDeclarationBase.prototype = {};
  W.CssStyleSheet.prototype = {$isCssStyleSheet: 1};
  W.CssStyleValue.prototype = {};
  W.CssTransformComponent.prototype = {};
  W.CssTransformValue.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.CssUnparsedValue.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.DataTransferItemList.prototype = {
    $index: function(receiver, index) {
      return receiver[H.intTypeCheck(index)];
    },
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.DeprecationReport.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.DivElement.prototype = {$isDivElement: 1};
  W.Document.prototype = {$isDocument: 1};
  W.DomError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.DomException.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.DomRectList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.assertSubtype(value, "$isRectangle", [P.num], "$asRectangle");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [[P.Rectangle, P.num]];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [[P.Rectangle, P.num]];
    },
    $asListMixin: function() {
      return [[P.Rectangle, P.num]];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [[P.Rectangle, P.num]];
    },
    $isList: 1,
    $asList: function() {
      return [[P.Rectangle, P.num]];
    },
    $asImmutableListMixin: function() {
      return [[P.Rectangle, P.num]];
    }
  };
  W.DomRectReadOnly.prototype = {
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(this.get$width(receiver)) + " x " + H.S(this.get$height(receiver));
    },
    $eq: function(receiver, other) {
      var t1;
      if (other == null)
        return false;
      t1 = J.getInterceptor$(other);
      if (!t1.$isRectangle)
        return false;
      return receiver.left === other.left && receiver.top === other.top && this.get$width(receiver) === t1.get$width(other) && this.get$height(receiver) === t1.get$height(other);
    },
    get$hashCode: function(receiver) {
      return W._JenkinsSmiHash_hash4(C.JSNumber_methods.get$hashCode(receiver.left), C.JSNumber_methods.get$hashCode(receiver.top), C.JSNumber_methods.get$hashCode(this.get$width(receiver)), C.JSNumber_methods.get$hashCode(this.get$height(receiver)));
    },
    get$height: function(receiver) {
      return receiver.height;
    },
    get$width: function(receiver) {
      return receiver.width;
    },
    $isRectangle: 1,
    $asRectangle: function() {
      return [P.num];
    }
  };
  W.DomStringList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.stringTypeCheck(value);
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.String];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [P.String];
    },
    $asListMixin: function() {
      return [P.String];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.String];
    },
    $isList: 1,
    $asList: function() {
      return [P.String];
    },
    $asImmutableListMixin: function() {
      return [P.String];
    }
  };
  W.DomTokenList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W._ChildrenElementList.prototype = {
    contains$1: function(_, element) {
      return J.contains$1$asx(this._childElements, element);
    },
    get$isEmpty: function(_) {
      return this._html$_element.firstElementChild == null;
    },
    get$length: function(_) {
      return this._childElements.length;
    },
    $index: function(_, index) {
      return H.interceptedTypeCheck(J.$index$asx(this._childElements, H.intTypeCheck(index)), "$isElement0");
    },
    $indexSet: function(_, index, value) {
      H.intTypeCheck(index);
      this._html$_element.replaceChild(H.interceptedTypeCheck(value, "$isElement0"), J.$index$asx(this._childElements, index));
    },
    get$iterator: function(_) {
      var t1 = this.toList$0(this);
      return new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    addAll$1: function(_, iterable) {
      var t1, t2;
      H.assertSubtype(iterable, "$isIterable", [W.Element0], "$asIterable");
      for (t1 = J.get$iterator$ax(iterable), t2 = this._html$_element; t1.moveNext$0();)
        t2.appendChild(t1.get$current(t1));
    },
    sort$1: function(_, compare) {
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [W.Element0, W.Element0]});
      throw H.wrapException(P.UnsupportedError$("Cannot sort element lists"));
    },
    $asEfficientLengthIterable: function() {
      return [W.Element0];
    },
    $asListMixin: function() {
      return [W.Element0];
    },
    $asIterable: function() {
      return [W.Element0];
    },
    $asList: function() {
      return [W.Element0];
    }
  };
  W._FrozenElementList.prototype = {
    get$length: function(_) {
      return this._nodeList.length;
    },
    $index: function(_, index) {
      return H.assertSubtypeOfRuntimeType(C.NodeList_methods.$index(this._nodeList, H.intTypeCheck(index)), H.getTypeArgumentByIndex(this, 0));
    },
    $indexSet: function(_, index, value) {
      H.intTypeCheck(index);
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
      throw H.wrapException(P.UnsupportedError$("Cannot modify list"));
    },
    sort$1: function(_, compare) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      throw H.wrapException(P.UnsupportedError$("Cannot sort list"));
    }
  };
  W.Element0.prototype = {
    get$attributes: function(receiver) {
      return new W._ElementAttributeMap(receiver);
    },
    get$children: function(receiver) {
      return new W._ChildrenElementList(receiver, receiver.children);
    },
    toString$0: function(receiver) {
      return receiver.localName;
    },
    createFragment$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var t1, t2, contextElement, fragment;
      if (treeSanitizer == null) {
        t1 = $.Element__defaultValidator;
        if (t1 == null) {
          t1 = H.setRuntimeTypeInfo([], [W.NodeValidator]);
          t2 = new W.NodeValidatorBuilder(t1);
          C.JSArray_methods.add$1(t1, W._Html5NodeValidator$(null));
          C.JSArray_methods.add$1(t1, W._TemplatingNodeValidator$());
          $.Element__defaultValidator = t2;
          validator = t2;
        } else
          validator = t1;
        t1 = $.Element__defaultSanitizer;
        if (t1 == null) {
          t1 = new W._ValidatingTreeSanitizer(validator);
          $.Element__defaultSanitizer = t1;
          treeSanitizer = t1;
        } else {
          t1.validator = validator;
          treeSanitizer = t1;
        }
      }
      if ($.Element__parseDocument == null) {
        t1 = document;
        t2 = t1.implementation.createHTMLDocument("");
        $.Element__parseDocument = t2;
        $.Element__parseRange = t2.createRange();
        t2 = $.Element__parseDocument.createElement("base");
        H.interceptedTypeCheck(t2, "$isBaseElement");
        t2.href = t1.baseURI;
        $.Element__parseDocument.head.appendChild(t2);
      }
      t1 = $.Element__parseDocument;
      if (t1.body == null) {
        t2 = t1.createElement("body");
        t1.body = H.interceptedTypeCheck(t2, "$isBodyElement");
      }
      t1 = $.Element__parseDocument;
      if (!!this.$isBodyElement)
        contextElement = t1.body;
      else {
        contextElement = t1.createElement(receiver.tagName);
        $.Element__parseDocument.body.appendChild(contextElement);
      }
      if ("createContextualFragment" in window.Range.prototype && !C.JSArray_methods.contains$1(C.List_ego, receiver.tagName)) {
        $.Element__parseRange.selectNodeContents(contextElement);
        fragment = $.Element__parseRange.createContextualFragment(html);
      } else {
        contextElement.innerHTML = html;
        fragment = $.Element__parseDocument.createDocumentFragment();
        for (; t1 = contextElement.firstChild, t1 != null;)
          fragment.appendChild(t1);
      }
      t1 = $.Element__parseDocument.body;
      if (contextElement == null ? t1 != null : contextElement !== t1)
        J.remove$0$ax(contextElement);
      treeSanitizer.sanitizeTree$1(fragment);
      document.adoptNode(fragment);
      return fragment;
    },
    createFragment$2$treeSanitizer: function($receiver, html, treeSanitizer) {
      return this.createFragment$3$treeSanitizer$validator($receiver, html, treeSanitizer, null);
    },
    setInnerHtml$1: function(receiver, html) {
      receiver.textContent = null;
      receiver.appendChild(this.createFragment$3$treeSanitizer$validator(receiver, html, null, null));
    },
    $isElement0: 1,
    get$tagName: function(receiver) {
      return receiver.tagName;
    }
  };
  W.Element_Element$html_closure.prototype = {
    call$1: function(e) {
      return !!J.getInterceptor$(H.interceptedTypeCheck(e, "$isNode")).$isElement0;
    },
    $signature: 27
  };
  W.ErrorEvent.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.Event.prototype = {
    get$target: function(receiver) {
      return W._convertNativeToDart_EventTarget(receiver.target);
    },
    $isEvent: 1
  };
  W.EventTarget.prototype = {
    addEventListener$3: function(receiver, type, listener, useCapture) {
      H.functionTypeCheck(listener, {func: 1, args: [W.Event]});
      if (listener != null)
        this._addEventListener$3(receiver, type, listener, useCapture);
    },
    addEventListener$2: function($receiver, type, listener) {
      return this.addEventListener$3($receiver, type, listener, null);
    },
    removeEventListener$3: function(receiver, type, listener, useCapture) {
      H.functionTypeCheck(listener, {func: 1, args: [W.Event]});
      if (listener != null)
        this._removeEventListener$3(receiver, type, listener, useCapture);
    },
    removeEventListener$2: function($receiver, type, listener) {
      return this.removeEventListener$3($receiver, type, listener, null);
    },
    _addEventListener$3: function(receiver, type, listener, options) {
      return receiver.addEventListener(type, H.convertDartClosureToJS(H.functionTypeCheck(listener, {func: 1, args: [W.Event]}), 1), options);
    },
    _removeEventListener$3: function(receiver, type, listener, options) {
      return receiver.removeEventListener(type, H.convertDartClosureToJS(H.functionTypeCheck(listener, {func: 1, args: [W.Event]}), 1), options);
    },
    $isEventTarget: 1
  };
  W.File.prototype = {$isFile: 1};
  W.FileList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isFile");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.File];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.File];
    },
    $asListMixin: function() {
      return [W.File];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.File];
    },
    $isList: 1,
    $asList: function() {
      return [W.File];
    },
    $isFileList: 1,
    $asImmutableListMixin: function() {
      return [W.File];
    }
  };
  W.FileWriter.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.FontFace.prototype = {$isFontFace: 1};
  W.FontFaceSet.prototype = {$isFontFaceSet: 1};
  W.FormElement.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.Gamepad.prototype = {$isGamepad: 1};
  W.History.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.HtmlCollection.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isNode");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Node];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Node];
    },
    $asListMixin: function() {
      return [W.Node];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    },
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $isHtmlCollection: 1,
    $asImmutableListMixin: function() {
      return [W.Node];
    }
  };
  W.HttpRequest.prototype = {
    open$3$async: function(receiver, method, url, async) {
      return receiver.open(method, url, true);
    },
    $isHttpRequest: 1
  };
  W.HttpRequest_request_closure.prototype = {
    call$1: function(e) {
      var t1, t2, accepted, unknownRedirect, t3;
      H.interceptedTypeCheck(e, "$isProgressEvent");
      t1 = this.xhr;
      t2 = t1.status;
      if (typeof t2 !== "number")
        return t2.$ge();
      accepted = t2 >= 200 && t2 < 300;
      unknownRedirect = t2 > 307 && t2 < 400;
      t2 = accepted || t2 === 0 || t2 === 304 || unknownRedirect;
      t3 = this.completer;
      if (t2)
        t3.complete$1(0, t1);
      else
        t3.completeError$1(e);
    },
    $signature: 124
  };
  W.HttpRequestEventTarget.prototype = {};
  W.ImageData.prototype = {$isImageData: 1};
  W.InputElement.prototype = {$isInputElement: 1};
  W.InterventionReport.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.KeyboardEvent.prototype = {$isKeyboardEvent: 1};
  W.LabelElement.prototype = {};
  W.Location.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isLocation: 1
  };
  W.MediaError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.MediaKeyMessageEvent.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.MediaList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.MessagePort.prototype = {
    addEventListener$3: function(receiver, type, listener, useCapture) {
      H.functionTypeCheck(listener, {func: 1, args: [W.Event]});
      if (type === "message")
        receiver.start();
      this.super$EventTarget$addEventListener(receiver, type, listener, false);
    },
    $isMessagePort: 1
  };
  W.MetaElement.prototype = {$isMetaElement: 1};
  W.MidiInputMap.prototype = {
    containsKey$1: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(key)) != null;
    },
    $index: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(H.stringTypeCheck(key)));
    },
    forEach$1: function(receiver, f) {
      var entries, entry;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
      entries = receiver.entries();
      for (; true;) {
        entry = entries.next();
        if (entry.done)
          return;
        f.call$2(entry.value[0], P.convertNativeToDart_Dictionary(entry.value[1]));
      }
    },
    get$keys: function(receiver) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this.forEach$1(receiver, new W.MidiInputMap_keys_closure(keys));
      return keys;
    },
    get$length: function(receiver) {
      return receiver.size;
    },
    get$isEmpty: function(receiver) {
      return receiver.size === 0;
    },
    $indexSet: function(receiver, key, value) {
      throw H.wrapException(P.UnsupportedError$("Not supported"));
    },
    $asMapMixin: function() {
      return [P.String, null];
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, null];
    }
  };
  W.MidiInputMap_keys_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.keys, k);
    },
    $signature: 9
  };
  W.MidiOutputMap.prototype = {
    containsKey$1: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(key)) != null;
    },
    $index: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(H.stringTypeCheck(key)));
    },
    forEach$1: function(receiver, f) {
      var entries, entry;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
      entries = receiver.entries();
      for (; true;) {
        entry = entries.next();
        if (entry.done)
          return;
        f.call$2(entry.value[0], P.convertNativeToDart_Dictionary(entry.value[1]));
      }
    },
    get$keys: function(receiver) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this.forEach$1(receiver, new W.MidiOutputMap_keys_closure(keys));
      return keys;
    },
    get$length: function(receiver) {
      return receiver.size;
    },
    get$isEmpty: function(receiver) {
      return receiver.size === 0;
    },
    $indexSet: function(receiver, key, value) {
      throw H.wrapException(P.UnsupportedError$("Not supported"));
    },
    $asMapMixin: function() {
      return [P.String, null];
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, null];
    }
  };
  W.MidiOutputMap_keys_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.keys, k);
    },
    $signature: 9
  };
  W.MimeType.prototype = {$isMimeType: 1};
  W.MimeTypeArray.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isMimeType");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.MimeType];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.MimeType];
    },
    $asListMixin: function() {
      return [W.MimeType];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.MimeType];
    },
    $isList: 1,
    $asList: function() {
      return [W.MimeType];
    },
    $asImmutableListMixin: function() {
      return [W.MimeType];
    }
  };
  W.MouseEvent.prototype = {
    get$offset: function(receiver) {
      var t1, target, t2, t3, t4, t5;
      if (!!receiver.offsetX)
        return new P.Point(receiver.offsetX, receiver.offsetY, [P.num]);
      else {
        t1 = receiver.target;
        if (!J.getInterceptor$(W._convertNativeToDart_EventTarget(t1)).$isElement0)
          throw H.wrapException(P.UnsupportedError$("offsetX is only supported on elements"));
        target = H.interceptedTypeCheck(W._convertNativeToDart_EventTarget(t1), "$isElement0");
        t1 = receiver.clientX;
        t2 = receiver.clientY;
        t3 = [P.num];
        t4 = target.getBoundingClientRect();
        t5 = t4.left;
        t4 = t4.top;
        H.assertSubtype(new P.Point(t5, t4, t3), "$isPoint", t3, "$asPoint");
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof t2 !== "number")
          return t2.$sub();
        return new P.Point(C.JSNumber_methods.toInt$0(t1 - t5), C.JSNumber_methods.toInt$0(t2 - t4), t3);
      }
    },
    $isMouseEvent: 1
  };
  W.NavigatorUserMediaError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W._ChildNodeListLazy.prototype = {
    get$single: function(_) {
      var t1 = this._this,
        l = t1.childNodes.length;
      if (l === 0)
        throw H.wrapException(P.StateError$("No elements"));
      if (l > 1)
        throw H.wrapException(P.StateError$("More than one element"));
      return t1.firstChild;
    },
    addAll$1: function(_, iterable) {
      var t1, t2, len, i;
      H.assertSubtype(iterable, "$isIterable", [W.Node], "$asIterable");
      t1 = J.getInterceptor$(iterable);
      if (!!t1.$is_ChildNodeListLazy) {
        t1 = iterable._this;
        t2 = this._this;
        if (t1 !== t2)
          for (len = t1.childNodes.length, i = 0; i < len; ++i)
            t2.appendChild(t1.firstChild);
        return;
      }
      for (t1 = t1.get$iterator(iterable), t2 = this._this; t1.moveNext$0();)
        t2.appendChild(t1.get$current(t1));
    },
    $indexSet: function(_, index, value) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._this;
      t1.replaceChild(H.interceptedTypeCheck(value, "$isNode"), C.NodeList_methods.$index(t1.childNodes, index));
    },
    get$iterator: function(_) {
      var t1 = this._this.childNodes;
      return new W.FixedSizeListIterator(t1, t1.length, [H.getRuntimeTypeArgumentIntercepted(C.NodeList_methods, t1, "ImmutableListMixin", 0)]);
    },
    sort$1: function(_, compare) {
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [W.Node, W.Node]});
      throw H.wrapException(P.UnsupportedError$("Cannot sort Node list"));
    },
    get$length: function(_) {
      return this._this.childNodes.length;
    },
    $index: function(_, index) {
      H.intTypeCheck(index);
      return C.NodeList_methods.$index(this._this.childNodes, index);
    },
    $asEfficientLengthIterable: function() {
      return [W.Node];
    },
    $asListMixin: function() {
      return [W.Node];
    },
    $asIterable: function() {
      return [W.Node];
    },
    $asList: function() {
      return [W.Node];
    }
  };
  W.Node.prototype = {
    remove$0: function(receiver) {
      var t1 = receiver.parentNode;
      if (t1 != null)
        t1.removeChild(receiver);
    },
    replaceWith$1: function(receiver, otherNode) {
      var $parent, exception;
      try {
        $parent = receiver.parentNode;
        J._replaceChild$2$x($parent, otherNode, receiver);
      } catch (exception) {
        H.unwrapException(exception);
      }
      return receiver;
    },
    toString$0: function(receiver) {
      var value = receiver.nodeValue;
      return value == null ? this.super$Interceptor$toString(receiver) : value;
    },
    append$1: function(receiver, node) {
      return receiver.appendChild(node);
    },
    _replaceChild$2: function(receiver, node, child) {
      return receiver.replaceChild(node, child);
    },
    $isNode: 1
  };
  W.NodeList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isNode");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Node];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Node];
    },
    $asListMixin: function() {
      return [W.Node];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    },
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $asImmutableListMixin: function() {
      return [W.Node];
    }
  };
  W.OverconstrainedError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.ParagraphElement.prototype = {};
  W.Plugin.prototype = {$isPlugin: 1,
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.PluginArray.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isPlugin");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Plugin];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Plugin];
    },
    $asListMixin: function() {
      return [W.Plugin];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Plugin];
    },
    $isList: 1,
    $asList: function() {
      return [W.Plugin];
    },
    $asImmutableListMixin: function() {
      return [W.Plugin];
    }
  };
  W.PointerEvent0.prototype = {$isPointerEvent0: 1};
  W.PopStateEvent.prototype = {$isPopStateEvent: 1};
  W.PositionError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.PresentationConnectionCloseEvent.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.ProgressEvent.prototype = {$isProgressEvent: 1};
  W.ReportBody.prototype = {};
  W.RtcStatsReport.prototype = {
    containsKey$1: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(key)) != null;
    },
    $index: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(H.stringTypeCheck(key)));
    },
    forEach$1: function(receiver, f) {
      var entries, entry;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
      entries = receiver.entries();
      for (; true;) {
        entry = entries.next();
        if (entry.done)
          return;
        f.call$2(entry.value[0], P.convertNativeToDart_Dictionary(entry.value[1]));
      }
    },
    get$keys: function(receiver) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this.forEach$1(receiver, new W.RtcStatsReport_keys_closure(keys));
      return keys;
    },
    get$length: function(receiver) {
      return receiver.size;
    },
    get$isEmpty: function(receiver) {
      return receiver.size === 0;
    },
    $indexSet: function(receiver, key, value) {
      throw H.wrapException(P.UnsupportedError$("Not supported"));
    },
    $asMapMixin: function() {
      return [P.String, null];
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, null];
    }
  };
  W.RtcStatsReport_keys_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.keys, k);
    },
    $signature: 9
  };
  W.ScriptElement.prototype = {$isScriptElement: 1};
  W.SelectElement.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.SourceBuffer.prototype = {$isSourceBuffer: 1};
  W.SourceBufferList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isSourceBuffer");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.SourceBuffer];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.SourceBuffer];
    },
    $asListMixin: function() {
      return [W.SourceBuffer];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.SourceBuffer];
    },
    $isList: 1,
    $asList: function() {
      return [W.SourceBuffer];
    },
    $asImmutableListMixin: function() {
      return [W.SourceBuffer];
    }
  };
  W.SpanElement.prototype = {$isSpanElement: 1};
  W.SpeechGrammar.prototype = {$isSpeechGrammar: 1};
  W.SpeechGrammarList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isSpeechGrammar");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.SpeechGrammar];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.SpeechGrammar];
    },
    $asListMixin: function() {
      return [W.SpeechGrammar];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.SpeechGrammar];
    },
    $isList: 1,
    $asList: function() {
      return [W.SpeechGrammar];
    },
    $asImmutableListMixin: function() {
      return [W.SpeechGrammar];
    }
  };
  W.SpeechRecognitionError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.SpeechRecognitionResult.prototype = {$isSpeechRecognitionResult: 1,
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.Storage.prototype = {
    containsKey$1: function(receiver, key) {
      return receiver.getItem(key) != null;
    },
    $index: function(receiver, key) {
      return receiver.getItem(H.stringTypeCheck(key));
    },
    $indexSet: function(receiver, key, value) {
      receiver.setItem(key, H.stringTypeCheck(value));
    },
    forEach$1: function(receiver, f) {
      var i, key;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String, P.String]});
      for (i = 0; true; ++i) {
        key = receiver.key(i);
        if (key == null)
          return;
        f.call$2(key, receiver.getItem(key));
      }
    },
    get$keys: function(receiver) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this.forEach$1(receiver, new W.Storage_keys_closure(keys));
      return keys;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    get$isEmpty: function(receiver) {
      return receiver.key(0) == null;
    },
    $asMapMixin: function() {
      return [P.String, P.String];
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, P.String];
    }
  };
  W.Storage_keys_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.keys, k);
    },
    $signature: 129
  };
  W.StyleElement.prototype = {$isStyleElement: 1};
  W.StyleSheet.prototype = {$isStyleSheet: 1};
  W.TableElement.prototype = {
    createFragment$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var table, fragment;
      if ("createContextualFragment" in window.Range.prototype)
        return this.super$Element$createFragment(receiver, html, treeSanitizer, validator);
      table = W.Element_Element$html("<table>" + html + "</table>", treeSanitizer, validator);
      fragment = document.createDocumentFragment();
      fragment.toString;
      table.toString;
      new W._ChildNodeListLazy(fragment).addAll$1(0, new W._ChildNodeListLazy(table));
      return fragment;
    }
  };
  W.TableRowElement.prototype = {
    createFragment$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var t1, fragment, section, row;
      if ("createContextualFragment" in window.Range.prototype)
        return this.super$Element$createFragment(receiver, html, treeSanitizer, validator);
      t1 = document;
      fragment = t1.createDocumentFragment();
      t1 = C.TableElement_methods.createFragment$3$treeSanitizer$validator(t1.createElement("table"), html, treeSanitizer, validator);
      t1.toString;
      t1 = new W._ChildNodeListLazy(t1);
      section = t1.get$single(t1);
      section.toString;
      t1 = new W._ChildNodeListLazy(section);
      row = t1.get$single(t1);
      fragment.toString;
      row.toString;
      new W._ChildNodeListLazy(fragment).addAll$1(0, new W._ChildNodeListLazy(row));
      return fragment;
    }
  };
  W.TableSectionElement.prototype = {
    createFragment$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var t1, fragment, section;
      if ("createContextualFragment" in window.Range.prototype)
        return this.super$Element$createFragment(receiver, html, treeSanitizer, validator);
      t1 = document;
      fragment = t1.createDocumentFragment();
      t1 = C.TableElement_methods.createFragment$3$treeSanitizer$validator(t1.createElement("table"), html, treeSanitizer, validator);
      t1.toString;
      t1 = new W._ChildNodeListLazy(t1);
      section = t1.get$single(t1);
      fragment.toString;
      section.toString;
      new W._ChildNodeListLazy(fragment).addAll$1(0, new W._ChildNodeListLazy(section));
      return fragment;
    }
  };
  W.TemplateElement.prototype = {$isTemplateElement: 1};
  W.TextAreaElement.prototype = {$isTextAreaElement: 1};
  W.TextTrack.prototype = {$isTextTrack: 1};
  W.TextTrackCue.prototype = {$isTextTrackCue: 1};
  W.TextTrackCueList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isTextTrackCue");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.TextTrackCue];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.TextTrackCue];
    },
    $asListMixin: function() {
      return [W.TextTrackCue];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.TextTrackCue];
    },
    $isList: 1,
    $asList: function() {
      return [W.TextTrackCue];
    },
    $asImmutableListMixin: function() {
      return [W.TextTrackCue];
    }
  };
  W.TextTrackList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isTextTrack");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.TextTrack];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.TextTrack];
    },
    $asListMixin: function() {
      return [W.TextTrack];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.TextTrack];
    },
    $isList: 1,
    $asList: function() {
      return [W.TextTrack];
    },
    $asImmutableListMixin: function() {
      return [W.TextTrack];
    }
  };
  W.TimeRanges.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.Touch.prototype = {$isTouch: 1};
  W.TouchEvent.prototype = {$isTouchEvent: 1};
  W.TouchList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isTouch");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Touch];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Touch];
    },
    $asListMixin: function() {
      return [W.Touch];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Touch];
    },
    $isList: 1,
    $asList: function() {
      return [W.Touch];
    },
    $asImmutableListMixin: function() {
      return [W.Touch];
    }
  };
  W.TrackDefaultList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.UIEvent.prototype = {};
  W.Url.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    }
  };
  W.VideoTrackList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.WheelEvent.prototype = {
    get$deltaY: function(receiver) {
      if (receiver.deltaY !== undefined)
        return receiver.deltaY;
      throw H.wrapException(P.UnsupportedError$("deltaY is not supported"));
    },
    get$deltaX: function(receiver) {
      if (receiver.deltaX !== undefined)
        return receiver.deltaX;
      throw H.wrapException(P.UnsupportedError$("deltaX is not supported"));
    },
    get$deltaMode: function(receiver) {
      if (!!receiver.deltaMode)
        return receiver.deltaMode;
      return 0;
    },
    $isWheelEvent: 1
  };
  W.Window0.prototype = {
    get$animationFrame: function(receiver) {
      var t1 = P.num,
        t2 = new P._Future($.Zone__current, [t1]);
      this.requestAnimationFrame$1(receiver, new W.Window_animationFrame_closure(new P._SyncCompleter(t2, [t1])));
      return t2;
    },
    requestAnimationFrame$1: function(receiver, callback) {
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.num]});
      this._ensureRequestAnimationFrame$0(receiver);
      return this._requestAnimationFrame$1(receiver, W._wrapZone(callback, P.num));
    },
    _requestAnimationFrame$1: function(receiver, callback) {
      return receiver.requestAnimationFrame(H.convertDartClosureToJS(H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.num]}), 1));
    },
    _ensureRequestAnimationFrame$0: function(receiver) {
      if (!!(receiver.requestAnimationFrame && receiver.cancelAnimationFrame))
        return;
      (function($this) {
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {
          $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];
          $this.cancelAnimationFrame = $this[vendors[i] + 'CancelAnimationFrame'] || $this[vendors[i] + 'CancelRequestAnimationFrame'];
        }
        if ($this.requestAnimationFrame && $this.cancelAnimationFrame)
          return;
        $this.requestAnimationFrame = function(callback) {
          return window.setTimeout(function() {
            callback(Date.now());
          }, 16);
        };
        $this.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      })(receiver);
    },
    $isWindowBase: 1
  };
  W.Window_animationFrame_closure.prototype = {
    call$1: function(time) {
      this.completer.complete$1(0, H.numTypeCheck(time));
    },
    $signature: 17
  };
  W._Attr.prototype = {$is_Attr: 1};
  W._CssRuleList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isCssRule");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.CssRule];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.CssRule];
    },
    $asListMixin: function() {
      return [W.CssRule];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.CssRule];
    },
    $isList: 1,
    $asList: function() {
      return [W.CssRule];
    },
    $asImmutableListMixin: function() {
      return [W.CssRule];
    }
  };
  W._DomRect.prototype = {
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(receiver.width) + " x " + H.S(receiver.height);
    },
    $eq: function(receiver, other) {
      var t1;
      if (other == null)
        return false;
      t1 = J.getInterceptor$(other);
      if (!t1.$isRectangle)
        return false;
      return receiver.left === other.left && receiver.top === other.top && receiver.width === t1.get$width(other) && receiver.height === t1.get$height(other);
    },
    get$hashCode: function(receiver) {
      return W._JenkinsSmiHash_hash4(C.JSNumber_methods.get$hashCode(receiver.left), C.JSNumber_methods.get$hashCode(receiver.top), C.JSNumber_methods.get$hashCode(receiver.width), C.JSNumber_methods.get$hashCode(receiver.height));
    },
    get$height: function(receiver) {
      return receiver.height;
    },
    get$width: function(receiver) {
      return receiver.width;
    }
  };
  W._GamepadList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isGamepad");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Gamepad];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Gamepad];
    },
    $asListMixin: function() {
      return [W.Gamepad];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Gamepad];
    },
    $isList: 1,
    $asList: function() {
      return [W.Gamepad];
    },
    $asImmutableListMixin: function() {
      return [W.Gamepad];
    }
  };
  W._NamedNodeMap.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isNode");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Node];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Node];
    },
    $asListMixin: function() {
      return [W.Node];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    },
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $asImmutableListMixin: function() {
      return [W.Node];
    }
  };
  W._SpeechRecognitionResultList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isSpeechRecognitionResult");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.SpeechRecognitionResult];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.SpeechRecognitionResult];
    },
    $asListMixin: function() {
      return [W.SpeechRecognitionResult];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.SpeechRecognitionResult];
    },
    $isList: 1,
    $asList: function() {
      return [W.SpeechRecognitionResult];
    },
    $asImmutableListMixin: function() {
      return [W.SpeechRecognitionResult];
    }
  };
  W._StyleSheetList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isStyleSheet");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.StyleSheet];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.StyleSheet];
    },
    $asListMixin: function() {
      return [W.StyleSheet];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.StyleSheet];
    },
    $isList: 1,
    $asList: function() {
      return [W.StyleSheet];
    },
    $asImmutableListMixin: function() {
      return [W.StyleSheet];
    }
  };
  W._AttributeMap.prototype = {
    forEach$1: function(_, f) {
      var t1, t2, t3, _i, key;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String, P.String]});
      for (t1 = this.get$keys(this), t2 = t1.length, t3 = this._html$_element, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        key = t1[_i];
        f.call$2(key, t3.getAttribute(key));
      }
    },
    get$keys: function(_) {
      var len, i, attr,
        attributes = this._html$_element.attributes,
        keys = H.setRuntimeTypeInfo([], [P.String]);
      for (len = attributes.length, i = 0; i < len; ++i) {
        if (i >= attributes.length)
          return H.ioore(attributes, i);
        attr = H.interceptedTypeCheck(attributes[i], "$is_Attr");
        if (attr.namespaceURI == null)
          C.JSArray_methods.add$1(keys, attr.name);
      }
      return keys;
    },
    get$isEmpty: function(_) {
      return this.get$keys(this).length === 0;
    },
    $asMapMixin: function() {
      return [P.String, P.String];
    },
    $asMap: function() {
      return [P.String, P.String];
    }
  };
  W._ElementAttributeMap.prototype = {
    containsKey$1: function(_, key) {
      return this._html$_element.hasAttribute(key);
    },
    $index: function(_, key) {
      return this._html$_element.getAttribute(H.stringTypeCheck(key));
    },
    $indexSet: function(_, key, value) {
      this._html$_element.setAttribute(key, H.stringTypeCheck(value));
    },
    get$length: function(_) {
      return this.get$keys(this).length;
    }
  };
  W._EventStream.prototype = {
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      return W._EventStreamSubscription$(this._html$_target, this._eventType, onData, false, t1);
    }
  };
  W._ElementEventStreamImpl.prototype = {};
  W._EventStreamSubscription.prototype = {
    cancel$0: function(_) {
      var _this = this;
      if (_this._html$_target == null)
        return;
      _this._unlisten$0();
      _this._html$_target = null;
      _this.set$_onData(null);
      return;
    },
    pause$0: function(_) {
      if (this._html$_target == null)
        return;
      ++this._pauseCount;
      this._unlisten$0();
    },
    resume$0: function(_) {
      var _this = this;
      if (_this._html$_target == null || _this._pauseCount <= 0)
        return;
      --_this._pauseCount;
      _this._tryResume$0();
    },
    _tryResume$0: function() {
      var _this = this,
        t1 = _this._onData;
      if (t1 != null && _this._pauseCount <= 0)
        J.addEventListener$3$x(_this._html$_target, _this._eventType, t1, false);
    },
    _unlisten$0: function() {
      var t1 = this._onData;
      if (t1 != null)
        J.removeEventListener$3$x(this._html$_target, this._eventType, t1, false);
    },
    set$_onData: function(_onData) {
      this._onData = H.functionTypeCheck(_onData, {func: 1, args: [W.Event]});
    }
  };
  W._EventStreamSubscription_closure.prototype = {
    call$1: function(e) {
      return this.onData.call$1(H.interceptedTypeCheck(e, "$isEvent"));
    },
    $signature: 52
  };
  W._Html5NodeValidator.prototype = {
    _Html5NodeValidator$1$uriPolicy: function(uriPolicy) {
      var _i;
      if ($._Html5NodeValidator__attributeValidators.get$isEmpty($._Html5NodeValidator__attributeValidators)) {
        for (_i = 0; _i < 262; ++_i)
          $._Html5NodeValidator__attributeValidators.$indexSet(0, C.List_2Zi[_i], W.html__Html5NodeValidator__standardAttributeValidator$closure());
        for (_i = 0; _i < 12; ++_i)
          $._Html5NodeValidator__attributeValidators.$indexSet(0, C.List_yrN[_i], W.html__Html5NodeValidator__uriAttributeValidator$closure());
      }
    },
    allowsElement$1: function(element) {
      return $.$get$_Html5NodeValidator__allowedElements().contains$1(0, W.Element__safeTagName(element));
    },
    allowsAttribute$3: function(element, attributeName, value) {
      var validator = $._Html5NodeValidator__attributeValidators.$index(0, H.S(W.Element__safeTagName(element)) + "::" + attributeName);
      if (validator == null)
        validator = $._Html5NodeValidator__attributeValidators.$index(0, "*::" + attributeName);
      if (validator == null)
        return false;
      return H.boolTypeCheck(validator.call$4(element, attributeName, value, this));
    },
    $isNodeValidator: 1
  };
  W.ImmutableListMixin.prototype = {
    get$iterator: function(receiver) {
      return new W.FixedSizeListIterator(receiver, this.get$length(receiver), [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0)]);
    },
    sort$1: function(receiver, compare) {
      var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      throw H.wrapException(P.UnsupportedError$("Cannot sort immutable List."));
    }
  };
  W.NodeValidatorBuilder.prototype = {
    allowsElement$1: function(element) {
      return C.JSArray_methods.any$1(this._validators, new W.NodeValidatorBuilder_allowsElement_closure(element));
    },
    allowsAttribute$3: function(element, attributeName, value) {
      return C.JSArray_methods.any$1(this._validators, new W.NodeValidatorBuilder_allowsAttribute_closure(element, attributeName, value));
    },
    $isNodeValidator: 1
  };
  W.NodeValidatorBuilder_allowsElement_closure.prototype = {
    call$1: function(v) {
      return H.interceptedTypeCheck(v, "$isNodeValidator").allowsElement$1(this.element);
    },
    $signature: 29
  };
  W.NodeValidatorBuilder_allowsAttribute_closure.prototype = {
    call$1: function(v) {
      return H.interceptedTypeCheck(v, "$isNodeValidator").allowsAttribute$3(this.element, this.attributeName, this.value);
    },
    $signature: 29
  };
  W._SimpleNodeValidator.prototype = {
    _SimpleNodeValidator$4$allowedAttributes$allowedElements$allowedUriAttributes: function(uriPolicy, allowedAttributes, allowedElements, allowedUriAttributes) {
      var legalAttributes, extraUriAttributes, t1;
      this.allowedElements.addAll$1(0, allowedElements);
      legalAttributes = allowedAttributes.where$1(0, new W._SimpleNodeValidator_closure());
      extraUriAttributes = allowedAttributes.where$1(0, new W._SimpleNodeValidator_closure0());
      this.allowedAttributes.addAll$1(0, legalAttributes);
      t1 = this.allowedUriAttributes;
      t1.addAll$1(0, C.List_empty3);
      t1.addAll$1(0, extraUriAttributes);
    },
    allowsElement$1: function(element) {
      return this.allowedElements.contains$1(0, W.Element__safeTagName(element));
    },
    allowsAttribute$3: function(element, attributeName, value) {
      var _this = this,
        tagName = W.Element__safeTagName(element),
        t1 = _this.allowedUriAttributes;
      if (t1.contains$1(0, H.S(tagName) + "::" + attributeName))
        return _this.uriPolicy.allowsUri$1(value);
      else if (t1.contains$1(0, "*::" + attributeName))
        return _this.uriPolicy.allowsUri$1(value);
      else {
        t1 = _this.allowedAttributes;
        if (t1.contains$1(0, H.S(tagName) + "::" + attributeName))
          return true;
        else if (t1.contains$1(0, "*::" + attributeName))
          return true;
        else if (t1.contains$1(0, H.S(tagName) + "::*"))
          return true;
        else if (t1.contains$1(0, "*::*"))
          return true;
      }
      return false;
    },
    $isNodeValidator: 1
  };
  W._SimpleNodeValidator_closure.prototype = {
    call$1: function(x) {
      return !C.JSArray_methods.contains$1(C.List_yrN, H.stringTypeCheck(x));
    },
    $signature: 30
  };
  W._SimpleNodeValidator_closure0.prototype = {
    call$1: function(x) {
      return C.JSArray_methods.contains$1(C.List_yrN, H.stringTypeCheck(x));
    },
    $signature: 30
  };
  W._TemplatingNodeValidator.prototype = {
    allowsAttribute$3: function(element, attributeName, value) {
      if (this.super$_SimpleNodeValidator$allowsAttribute(element, attributeName, value))
        return true;
      if (attributeName === "template" && value === "")
        return true;
      if (element.getAttribute("template") === "")
        return this._templateAttrs.contains$1(0, attributeName);
      return false;
    }
  };
  W._TemplatingNodeValidator_closure.prototype = {
    call$1: function(attr) {
      return "TEMPLATE::" + H.S(H.stringTypeCheck(attr));
    },
    $signature: 8
  };
  W._SvgNodeValidator.prototype = {
    allowsElement$1: function(element) {
      var t1 = J.getInterceptor$(element);
      if (!!t1.$isScriptElement0)
        return false;
      t1 = !!t1.$isSvgElement;
      if (t1 && W.Element__safeTagName(element) === "foreignObject")
        return false;
      if (t1)
        return true;
      return false;
    },
    allowsAttribute$3: function(element, attributeName, value) {
      if (attributeName === "is" || C.JSString_methods.startsWith$1(attributeName, "on"))
        return false;
      return this.allowsElement$1(element);
    },
    $isNodeValidator: 1
  };
  W.FixedSizeListIterator.prototype = {
    moveNext$0: function() {
      var _this = this,
        nextPosition = _this._html$_position + 1,
        t1 = _this._html$_length;
      if (nextPosition < t1) {
        _this.set$_html$_current(J.$index$asx(_this._array, nextPosition));
        _this._html$_position = nextPosition;
        return true;
      }
      _this.set$_html$_current(null);
      _this._html$_position = t1;
      return false;
    },
    get$current: function(_) {
      return this._html$_current;
    },
    set$_html$_current: function(_current) {
      this._html$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  W._DOMWindowCrossFrame.prototype = {$isEventTarget: 1, $isWindowBase: 1};
  W.NodeValidator.prototype = {};
  W._SameOriginUriPolicy.prototype = {$isUriPolicy: 1};
  W._ValidatingTreeSanitizer.prototype = {
    sanitizeTree$1: function(node) {
      new W._ValidatingTreeSanitizer_sanitizeTree_walk(this).call$2(node, null);
    },
    _removeNode$2: function(node, $parent) {
      if ($parent == null)
        J.remove$0$ax(node);
      else
        $parent.removeChild(node);
    },
    _sanitizeUntrustedElement$2: function(element, $parent) {
      var corruptedTest1, elementText, elementTagName, exception, t1,
        corrupted = true,
        attrs = null, isAttr = null;
      try {
        attrs = J.get$attributes$x(element);
        isAttr = attrs._html$_element.getAttribute("is");
        H.interceptedTypeCheck(element, "$isElement0");
        corruptedTest1 = function(element) {
          if (!(element.attributes instanceof NamedNodeMap))
            return true;
          var childNodes = element.childNodes;
          if (element.lastChild && element.lastChild !== childNodes[childNodes.length - 1])
            return true;
          if (element.children)
            if (!(element.children instanceof HTMLCollection || element.children instanceof NodeList))
              return true;
          var length = 0;
          if (element.children)
            length = element.children.length;
          for (var i = 0; i < length; i++) {
            var child = element.children[i];
            if (child.id == 'attributes' || child.name == 'attributes' || child.id == 'lastChild' || child.name == 'lastChild' || child.id == 'children' || child.name == 'children')
              return true;
          }
          return false;
        }(element);
        corrupted = H.boolConversionCheck(corruptedTest1) ? true : !(element.attributes instanceof NamedNodeMap);
      } catch (exception) {
        H.unwrapException(exception);
      }
      elementText = "element unprintable";
      try {
        elementText = J.toString$0$(element);
      } catch (exception) {
        H.unwrapException(exception);
      }
      try {
        elementTagName = W.Element__safeTagName(element);
        this._sanitizeElement$7(H.interceptedTypeCheck(element, "$isElement0"), $parent, corrupted, elementText, elementTagName, H.interceptedTypeCheck(attrs, "$isMap"), H.stringTypeCheck(isAttr));
      } catch (exception) {
        if (H.unwrapException(exception) instanceof P.ArgumentError)
          throw exception;
        else {
          this._removeNode$2(element, $parent);
          window;
          t1 = "Removing corrupted element " + H.S(elementText);
          if (typeof console != "undefined")
            window.console.warn(t1);
        }
      }
    },
    _sanitizeElement$7: function(element, $parent, corrupted, text, tag, attrs, isAttr) {
      var t1, keys, i, $name, t2, t3, _this = this;
      if (corrupted) {
        _this._removeNode$2(element, $parent);
        window;
        t1 = "Removing element due to corrupted attributes on <" + text + ">";
        if (typeof console != "undefined")
          window.console.warn(t1);
        return;
      }
      if (!_this.validator.allowsElement$1(element)) {
        _this._removeNode$2(element, $parent);
        window;
        t1 = "Removing disallowed element <" + H.S(tag) + "> from " + H.S($parent);
        if (typeof console != "undefined")
          window.console.warn(t1);
        return;
      }
      if (isAttr != null)
        if (!_this.validator.allowsAttribute$3(element, "is", isAttr)) {
          _this._removeNode$2(element, $parent);
          window;
          t1 = "Removing disallowed type extension <" + H.S(tag) + ' is="' + isAttr + '">';
          if (typeof console != "undefined")
            window.console.warn(t1);
          return;
        }
      t1 = attrs.get$keys(attrs);
      keys = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
      for (i = attrs.get$keys(attrs).length - 1, t1 = attrs._html$_element; i >= 0; --i) {
        if (i >= keys.length)
          return H.ioore(keys, i);
        $name = keys[i];
        t2 = _this.validator;
        t3 = J.toLowerCase$0$s($name);
        H.stringTypeCheck($name);
        if (!t2.allowsAttribute$3(element, t3, t1.getAttribute($name))) {
          window;
          t2 = "Removing disallowed attribute <" + H.S(tag) + " " + $name + '="' + H.S(t1.getAttribute($name)) + '">';
          if (typeof console != "undefined")
            window.console.warn(t2);
          t1.removeAttribute($name);
        }
      }
      if (!!J.getInterceptor$(element).$isTemplateElement)
        _this.sanitizeTree$1(element.content);
    },
    $isNodeTreeSanitizer: 1
  };
  W._ValidatingTreeSanitizer_sanitizeTree_walk.prototype = {
    call$2: function(node, $parent) {
      var child, nextChild, exception, t2, t3,
        t1 = this.$this;
      switch (node.nodeType) {
        case 1:
          t1._sanitizeUntrustedElement$2(node, $parent);
          break;
        case 8:
        case 11:
        case 3:
        case 4:
          break;
        default:
          t1._removeNode$2(node, $parent);
      }
      child = node.lastChild;
      for (t1 = node == null; null != child;) {
        nextChild = null;
        try {
          nextChild = child.previousSibling;
        } catch (exception) {
          H.unwrapException(exception);
          t2 = H.interceptedTypeCheck(child, "$isNode");
          if (t1) {
            t3 = t2.parentNode;
            if (t3 != null)
              t3.removeChild(t2);
          } else
            node.removeChild(t2);
          child = null;
          nextChild = node.lastChild;
        }
        if (child != null)
          this.call$2(child, node);
        child = H.interceptedTypeCheck(nextChild, "$isNode");
      }
    },
    $signature: 70
  };
  W._CssStyleDeclaration_Interceptor_CssStyleDeclarationBase.prototype = {};
  W._DomRectList_Interceptor_ListMixin.prototype = {};
  W._DomRectList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._DomStringList_Interceptor_ListMixin.prototype = {};
  W._DomStringList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._FileList_Interceptor_ListMixin.prototype = {};
  W._FileList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._HtmlCollection_Interceptor_ListMixin.prototype = {};
  W._HtmlCollection_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._MidiInputMap_Interceptor_MapMixin.prototype = {};
  W._MidiOutputMap_Interceptor_MapMixin.prototype = {};
  W._MimeTypeArray_Interceptor_ListMixin.prototype = {};
  W._MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._NodeList_Interceptor_ListMixin.prototype = {};
  W._NodeList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._PluginArray_Interceptor_ListMixin.prototype = {};
  W._PluginArray_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._RtcStatsReport_Interceptor_MapMixin.prototype = {};
  W._SourceBufferList_EventTarget_ListMixin.prototype = {};
  W._SourceBufferList_EventTarget_ListMixin_ImmutableListMixin.prototype = {};
  W._SpeechGrammarList_Interceptor_ListMixin.prototype = {};
  W._SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._Storage_Interceptor_MapMixin.prototype = {};
  W._TextTrackCueList_Interceptor_ListMixin.prototype = {};
  W._TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._TextTrackList_EventTarget_ListMixin.prototype = {};
  W._TextTrackList_EventTarget_ListMixin_ImmutableListMixin.prototype = {};
  W._TouchList_Interceptor_ListMixin.prototype = {};
  W._TouchList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W.__CssRuleList_Interceptor_ListMixin.prototype = {};
  W.__CssRuleList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W.__GamepadList_Interceptor_ListMixin.prototype = {};
  W.__GamepadList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W.__NamedNodeMap_Interceptor_ListMixin.prototype = {};
  W.__NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W.__SpeechRecognitionResultList_Interceptor_ListMixin.prototype = {};
  W.__SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W.__StyleSheetList_Interceptor_ListMixin.prototype = {};
  W.__StyleSheetList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  P._StructuredClone.prototype = {
    findSlot$1: function(value) {
      var i,
        t1 = this.values,
        $length = t1.length;
      for (i = 0; i < $length; ++i)
        if (t1[i] === value)
          return i;
      C.JSArray_methods.add$1(t1, value);
      C.JSArray_methods.add$1(this.copies, null);
      return $length;
    },
    walk$1: function(e) {
      var t2, slot, t3, copy, _this = this, t1 = {};
      if (e == null)
        return e;
      if (typeof e === "boolean")
        return e;
      if (typeof e === "number")
        return e;
      if (typeof e === "string")
        return e;
      t2 = J.getInterceptor$(e);
      if (!!t2.$isDateTime)
        return new Date(e._core$_value);
      if (!!t2.$isRegExp)
        throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
      if (!!t2.$isFile)
        return e;
      if (!!t2.$isBlob)
        return e;
      if (!!t2.$isFileList)
        return e;
      if (!!t2.$isImageData)
        return e;
      if (!!t2.$isNativeByteBuffer || !!t2.$isNativeTypedData || !!t2.$isMessagePort)
        return e;
      if (!!t2.$isMap) {
        slot = _this.findSlot$1(e);
        t3 = _this.copies;
        if (slot >= t3.length)
          return H.ioore(t3, slot);
        copy = t1.copy = t3[slot];
        if (copy != null)
          return copy;
        copy = {};
        t1.copy = copy;
        C.JSArray_methods.$indexSet(t3, slot, copy);
        t2.forEach$1(e, new P._StructuredClone_walk_closure(t1, _this));
        return t1.copy;
      }
      if (!!t2.$isList) {
        slot = _this.findSlot$1(e);
        t1 = _this.copies;
        if (slot >= t1.length)
          return H.ioore(t1, slot);
        copy = t1[slot];
        if (copy != null)
          return copy;
        return _this.copyList$2(e, slot);
      }
      throw H.wrapException(P.UnimplementedError$("structured clone of other type"));
    },
    copyList$2: function(e, slot) {
      var i,
        t1 = J.getInterceptor$asx(e),
        $length = t1.get$length(e),
        copy = new Array($length);
      C.JSArray_methods.$indexSet(this.copies, slot, copy);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i)
        C.JSArray_methods.$indexSet(copy, i, this.walk$1(t1.$index(e, i)));
      return copy;
    }
  };
  P._StructuredClone_walk_closure.prototype = {
    call$2: function(key, value) {
      this._box_0.copy[key] = this.$this.walk$1(value);
    },
    $signature: 5
  };
  P._AcceptStructuredClone.prototype = {
    findSlot$1: function(value) {
      var i,
        t1 = this.values,
        $length = t1.length;
      for (i = 0; i < $length; ++i)
        if (t1[i] === value)
          return i;
      C.JSArray_methods.add$1(t1, value);
      C.JSArray_methods.add$1(this.copies, null);
      return $length;
    },
    walk$1: function(e) {
      var millisSinceEpoch, t1, proto, slot, copy, l, t2, $length, i, _this = this, _box_0 = {};
      if (e == null)
        return e;
      if (typeof e === "boolean")
        return e;
      if (typeof e === "number")
        return e;
      if (typeof e === "string")
        return e;
      if (e instanceof Date) {
        millisSinceEpoch = e.getTime();
        t1 = new P.DateTime(millisSinceEpoch, true);
        t1.DateTime$_withValue$2$isUtc(millisSinceEpoch, true);
        return t1;
      }
      if (e instanceof RegExp)
        throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
      if (typeof Promise != "undefined" && e instanceof Promise)
        return P.convertNativePromiseToDartFuture(e);
      proto = Object.getPrototypeOf(e);
      if (proto === Object.prototype || proto === null) {
        slot = _this.findSlot$1(e);
        t1 = _this.copies;
        if (slot >= t1.length)
          return H.ioore(t1, slot);
        copy = _box_0.copy = t1[slot];
        if (copy != null)
          return copy;
        copy = P.LinkedHashMap__makeEmpty();
        _box_0.copy = copy;
        C.JSArray_methods.$indexSet(t1, slot, copy);
        _this.forEachJsField$2(e, new P._AcceptStructuredClone_walk_closure(_box_0, _this));
        return _box_0.copy;
      }
      if (e instanceof Array) {
        l = e;
        slot = _this.findSlot$1(l);
        t1 = _this.copies;
        if (slot >= t1.length)
          return H.ioore(t1, slot);
        copy = t1[slot];
        if (copy != null)
          return copy;
        t2 = J.getInterceptor$asx(l);
        $length = t2.get$length(l);
        copy = _this.mustCopy ? new Array($length) : l;
        C.JSArray_methods.$indexSet(t1, slot, copy);
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = J.getInterceptor$ax(copy);
        i = 0;
        for (; i < $length; ++i)
          t1.$indexSet(copy, i, _this.walk$1(t2.$index(l, i)));
        return copy;
      }
      return e;
    },
    convertNativeToDart_AcceptStructuredClone$2$mustCopy: function(object, mustCopy) {
      this.mustCopy = mustCopy;
      return this.walk$1(object);
    }
  };
  P._AcceptStructuredClone_walk_closure.prototype = {
    call$2: function(key, value) {
      var t1 = this._box_0.copy,
        t2 = this.$this.walk$1(value);
      J.$indexSet$ax(t1, key, t2);
      return t2;
    },
    $signature: 85
  };
  P.convertDartToNative_Dictionary_closure.prototype = {
    call$2: function(key, value) {
      this.object[key] = value;
    },
    $signature: 5
  };
  P._StructuredCloneDart2Js.prototype = {};
  P._AcceptStructuredCloneDart2Js.prototype = {
    forEachJsField$2: function(object, action) {
      var t1, t2, _i, key;
      H.functionTypeCheck(action, {func: 1, args: [,,]});
      for (t1 = Object.keys(object), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        key = t1[_i];
        action.call$2(key, object[key]);
      }
    }
  };
  P.convertNativePromiseToDartFuture_closure.prototype = {
    call$1: function(result) {
      return this.completer.complete$1(0, result);
    },
    $signature: 3
  };
  P.convertNativePromiseToDartFuture_closure0.prototype = {
    call$1: function(result) {
      return this.completer.completeError$1(result);
    },
    $signature: 3
  };
  P.FilteredElementList.prototype = {
    get$_html_common$_iterable: function() {
      var t1 = this._childNodes,
        t2 = H.getRuntimeTypeArgument(t1, "ListMixin", 0),
        t3 = W.Element0;
      return new H.MappedIterable(new H.WhereIterable(t1, H.functionTypeCheck(new P.FilteredElementList__iterable_closure(), {func: 1, ret: P.bool, args: [t2]}), [t2]), H.functionTypeCheck(new P.FilteredElementList__iterable_closure0(), {func: 1, ret: t3, args: [t2]}), [t2, t3]);
    },
    forEach$1: function(_, f) {
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [W.Element0]});
      C.JSArray_methods.forEach$1(P.List_List$from(this.get$_html_common$_iterable(), false, W.Element0), f);
    },
    $indexSet: function(_, index, value) {
      var t1;
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isElement0");
      t1 = this.get$_html_common$_iterable();
      J.replaceWith$1$x(t1._f.call$1(J.elementAt$1$ax(t1._iterable, index)), value);
    },
    contains$1: function(_, needle) {
      return false;
    },
    sort$1: function(_, compare) {
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [W.Element0, W.Element0]});
      throw H.wrapException(P.UnsupportedError$("Cannot sort filtered list"));
    },
    get$length: function(_) {
      return J.get$length$asx(this.get$_html_common$_iterable()._iterable);
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this.get$_html_common$_iterable();
      return t1._f.call$1(J.elementAt$1$ax(t1._iterable, index));
    },
    get$iterator: function(_) {
      var t1 = P.List_List$from(this.get$_html_common$_iterable(), false, W.Element0);
      return new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    $asEfficientLengthIterable: function() {
      return [W.Element0];
    },
    $asListMixin: function() {
      return [W.Element0];
    },
    $asIterable: function() {
      return [W.Element0];
    },
    $asList: function() {
      return [W.Element0];
    }
  };
  P.FilteredElementList__iterable_closure.prototype = {
    call$1: function(n) {
      return !!J.getInterceptor$(H.interceptedTypeCheck(n, "$isNode")).$isElement0;
    },
    $signature: 27
  };
  P.FilteredElementList__iterable_closure0.prototype = {
    call$1: function(n) {
      return H.interceptedTypeCast(H.interceptedTypeCheck(n, "$isNode"), "$isElement0");
    },
    $signature: 87
  };
  P.Point.prototype = {
    toString$0: function(_) {
      return "Point(" + H.S(this.x) + ", " + H.S(this.y) + ")";
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor$(other).$isPoint && this.x == other.x && this.y == other.y;
    },
    get$hashCode: function(_) {
      var hash,
        t1 = J.get$hashCode$(this.x),
        t2 = J.get$hashCode$(this.y);
      t2 = P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, t1), t2);
      hash = 536870911 & t2 + ((67108863 & t2) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    }
  };
  P._RectangleBase.prototype = {};
  P.Rectangle.prototype = {};
  P.Length.prototype = {$isLength: 1};
  P.LengthList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isLength");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.Length];
    },
    $asListMixin: function() {
      return [P.Length];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.Length];
    },
    $isList: 1,
    $asList: function() {
      return [P.Length];
    },
    $asImmutableListMixin: function() {
      return [P.Length];
    }
  };
  P.Number.prototype = {$isNumber: 1};
  P.NumberList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isNumber");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.Number];
    },
    $asListMixin: function() {
      return [P.Number];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.Number];
    },
    $isList: 1,
    $asList: function() {
      return [P.Number];
    },
    $asImmutableListMixin: function() {
      return [P.Number];
    }
  };
  P.PointList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  P.ScriptElement0.prototype = {$isScriptElement0: 1};
  P.StringList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.stringTypeCheck(value);
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.String];
    },
    $asListMixin: function() {
      return [P.String];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.String];
    },
    $isList: 1,
    $asList: function() {
      return [P.String];
    },
    $asImmutableListMixin: function() {
      return [P.String];
    }
  };
  P.SvgElement.prototype = {
    get$children: function(receiver) {
      return new P.FilteredElementList(receiver, new W._ChildNodeListLazy(receiver));
    },
    createFragment$3$treeSanitizer$validator: function(receiver, svg, treeSanitizer, validator) {
      var html, t2, fragment, svgFragment, root,
        t1 = H.setRuntimeTypeInfo([], [W.NodeValidator]);
      C.JSArray_methods.add$1(t1, W._Html5NodeValidator$(null));
      C.JSArray_methods.add$1(t1, W._TemplatingNodeValidator$());
      C.JSArray_methods.add$1(t1, new W._SvgNodeValidator());
      treeSanitizer = new W._ValidatingTreeSanitizer(new W.NodeValidatorBuilder(t1));
      html = '<svg version="1.1">' + svg + "</svg>";
      t1 = document;
      t2 = t1.body;
      fragment = (t2 && C.BodyElement_methods).createFragment$2$treeSanitizer(t2, html, treeSanitizer);
      svgFragment = t1.createDocumentFragment();
      fragment.toString;
      t1 = new W._ChildNodeListLazy(fragment);
      root = t1.get$single(t1);
      for (; t1 = root.firstChild, t1 != null;)
        svgFragment.appendChild(t1);
      return svgFragment;
    },
    $isSvgElement: 1
  };
  P.Transform.prototype = {$isTransform: 1};
  P.TransformList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isTransform");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.Transform];
    },
    $asListMixin: function() {
      return [P.Transform];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.Transform];
    },
    $isList: 1,
    $asList: function() {
      return [P.Transform];
    },
    $asImmutableListMixin: function() {
      return [P.Transform];
    }
  };
  P._LengthList_Interceptor_ListMixin.prototype = {};
  P._LengthList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  P._NumberList_Interceptor_ListMixin.prototype = {};
  P._NumberList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  P._StringList_Interceptor_ListMixin.prototype = {};
  P._StringList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  P._TransformList_Interceptor_ListMixin.prototype = {};
  P._TransformList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  P.ByteBuffer.prototype = {};
  P.Endian.prototype = {};
  P.ByteData.prototype = {};
  P.Int8List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  P.Uint8List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  P.Uint8ClampedList.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  P.Int16List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  P.Uint16List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  P.Int32List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  P.Uint32List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  P.Float32List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.double];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.double];
    },
    $isList: 1,
    $asList: function() {
      return [P.double];
    }
  };
  P.Float64List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.double];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.double];
    },
    $isList: 1,
    $asList: function() {
      return [P.double];
    }
  };
  P.AudioBuffer.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  P.AudioParamMap.prototype = {
    containsKey$1: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(key)) != null;
    },
    $index: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(H.stringTypeCheck(key)));
    },
    forEach$1: function(receiver, f) {
      var entries, entry;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
      entries = receiver.entries();
      for (; true;) {
        entry = entries.next();
        if (entry.done)
          return;
        f.call$2(entry.value[0], P.convertNativeToDart_Dictionary(entry.value[1]));
      }
    },
    get$keys: function(receiver) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this.forEach$1(receiver, new P.AudioParamMap_keys_closure(keys));
      return keys;
    },
    get$length: function(receiver) {
      return receiver.size;
    },
    get$isEmpty: function(receiver) {
      return receiver.size === 0;
    },
    $indexSet: function(receiver, key, value) {
      throw H.wrapException(P.UnsupportedError$("Not supported"));
    },
    $asMapMixin: function() {
      return [P.String, null];
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, null];
    }
  };
  P.AudioParamMap_keys_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.keys, k);
    },
    $signature: 9
  };
  P.AudioTrackList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  P.BaseAudioContext.prototype = {};
  P.OfflineAudioContext.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  P._AudioParamMap_Interceptor_MapMixin.prototype = {};
  P.SqlError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  P.SqlResultSetRowList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return P.convertNativeToDart_Dictionary(receiver.item(index));
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isMap");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [[P.Map,,,]];
    },
    $asListMixin: function() {
      return [[P.Map,,,]];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [[P.Map,,,]];
    },
    $isList: 1,
    $asList: function() {
      return [[P.Map,,,]];
    },
    $asImmutableListMixin: function() {
      return [[P.Map,,,]];
    }
  };
  P._SqlResultSetRowList_Interceptor_ListMixin.prototype = {};
  P._SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  Y.HeapPriorityQueue.prototype = {
    get$isEmpty: function(_) {
      return this._length === 0;
    },
    get$length: function(_) {
      return this._length;
    },
    toString$0: function(_) {
      var t1 = this._priority_queue$_queue;
      return P.IterableBase_iterableToShortString(H.SubListIterable$(t1, 0, this._length, H.getTypeArgumentByIndex(t1, 0)), "(", ")");
    },
    _bubbleDown$2: function(element, index) {
      var rightChildIndex, t1, t2, leftChildIndex, t3, leftChild, rightChild, comp, minChild, minChildIndex, child, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      rightChildIndex = index * 2 + 2;
      for (t1 = _this.comparison; t2 = _this._length, rightChildIndex < t2; index = minChildIndex) {
        leftChildIndex = rightChildIndex - 1;
        t2 = _this._priority_queue$_queue;
        t3 = t2.length;
        if (leftChildIndex < 0 || leftChildIndex >= t3)
          return H.ioore(t2, leftChildIndex);
        leftChild = t2[leftChildIndex];
        if (rightChildIndex < 0 || rightChildIndex >= t3)
          return H.ioore(t2, rightChildIndex);
        rightChild = t2[rightChildIndex];
        comp = t1.call$2(leftChild, rightChild);
        if (typeof comp !== "number")
          return comp.$lt();
        if (comp < 0) {
          minChild = leftChild;
          minChildIndex = leftChildIndex;
        } else {
          minChild = rightChild;
          minChildIndex = rightChildIndex;
        }
        comp = t1.call$2(element, minChild);
        if (typeof comp !== "number")
          return comp.$le();
        if (comp <= 0) {
          C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, element);
          return;
        }
        C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, minChild);
        rightChildIndex = minChildIndex * 2 + 2;
      }
      leftChildIndex = rightChildIndex - 1;
      if (leftChildIndex < t2) {
        t2 = _this._priority_queue$_queue;
        if (leftChildIndex < 0 || leftChildIndex >= t2.length)
          return H.ioore(t2, leftChildIndex);
        child = t2[leftChildIndex];
        comp = t1.call$2(element, child);
        if (typeof comp !== "number")
          return comp.$gt();
        if (comp > 0) {
          C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, child);
          index = leftChildIndex;
        }
      }
      C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, element);
    },
    $isPriorityQueue: 1
  };
  Z.Curve.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    }
  };
  Z.Cubic.prototype = {
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(" + C.JSDouble_methods.toStringAsFixed$1(_this.a, 2) + ", " + C.JSDouble_methods.toStringAsFixed$1(_this.b, 2) + ", " + C.JSDouble_methods.toStringAsFixed$1(_this.c, 2) + ", " + C.JSInt_methods.toStringAsFixed$1(_this.d, 2) + ")";
    }
  };
  U._ErrorDiagnostic.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      this._maybeCacheValue$0();
      return J.join$1$ax(this._value, "");
    },
    $asDiagnosticsProperty: function() {
      return [[P.List, P.Object]];
    }
  };
  U.ErrorDescription.prototype = {};
  U.ErrorSummary.prototype = {};
  U.ErrorHint.prototype = {};
  U.FlutterErrorDetails.prototype = {
    exceptionAsString$0: function() {
      var message, fullMessage, t2, position, body, splitPoint,
        longMessage = this.exception,
        t1 = J.getInterceptor$(longMessage);
      if (!!t1.$isAssertionError) {
        message = longMessage.get$message(longMessage);
        fullMessage = longMessage.toString$0(0);
        if (typeof message === "string" && message !== fullMessage) {
          t1 = fullMessage.length;
          t2 = J.getInterceptor$asx(message);
          if (t1 > t2.get$length(message)) {
            position = J.getInterceptor$s(fullMessage).lastIndexOf$1(fullMessage, message);
            if (position === t1 - t2.get$length(message) && position > 2 && C.JSString_methods.substring$2(fullMessage, position - 2, position) === ": ") {
              body = C.JSString_methods.substring$2(fullMessage, 0, position - 2);
              splitPoint = C.JSString_methods.indexOf$1(body, " Failed assertion:");
              if (splitPoint >= 0)
                body = C.JSString_methods.substring$2(body, 0, splitPoint) + "\n" + C.JSString_methods.substring$1(body, splitPoint + 1);
              longMessage = t2.trimRight$0(message) + "\n" + body;
            } else
              longMessage = null;
          } else
            longMessage = null;
        } else
          longMessage = null;
        if (longMessage == null)
          longMessage = fullMessage;
      } else if (!(typeof longMessage === "string"))
        longMessage = !!t1.$isError || !!t1.$isException ? t1.toString$0(longMessage) : "  " + H.S(t1.toString$0(longMessage));
      longMessage = J.trimRight$0$s(longMessage);
      return longMessage.length === 0 ? "  <no message available>" : longMessage;
    },
    _exceptionToDiagnosticable$0: function() {
      var t1 = this.exception,
        t2 = J.getInterceptor$(t1);
      if (!!t2.$isFlutterError)
        return t1;
      if (!!t2.$isAssertionError && t1.get$message(t1) instanceof U.FlutterError)
        return H.interceptedTypeCheck(t2.get$message(t1), "$isDiagnosticable");
      return;
    },
    get$summary: function() {
      var t1, summary, _null = null;
      if (this._exceptionToDiagnosticable$0() != null) {
        t1 = H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
        this.debugFillProperties$1(new Y.DiagnosticPropertiesBuilder(t1, C.DiagnosticsTreeStyle_0));
        summary = C.JSArray_methods.firstWhere$2$orElse(t1, new U.FlutterErrorDetails_summary_closure(), new U.FlutterErrorDetails_summary_closure0());
      } else
        summary = _null;
      if (summary == null) {
        t1 = this.exceptionAsString$0().split("\n");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = H.setRuntimeTypeInfo([J.trimLeft$0$s(t1[0])], [P.Object]);
        t1 = new U.ErrorSummary(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_6, _null, false, false, _null, C.DiagnosticsTreeStyle_6);
      } else
        t1 = summary;
      return t1;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, verb, diagnosticable, t3, t4, errorName, t5, prefix, message, stackLines, stackList, throwPattern, assertPattern, assertMatch, ourLibraryPattern, ourFault, _this = this, _null = null;
      _this.super$DiagnosticableMixin$debugFillProperties(properties);
      t1 = _this.context;
      if (t1 != null) {
        t1 = H.setRuntimeTypeInfo([" " + t1.toString$0(0)], [P.Object]);
        t1 = new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6);
      } else
        t1 = "";
      t2 = [P.Object];
      t1 = H.setRuntimeTypeInfo(["thrown" + H.S(t1)], t2);
      verb = new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6);
      diagnosticable = _this._exceptionToDiagnosticable$0();
      t1 = _this.exception;
      t3 = J.getInterceptor$(t1);
      if (!!t3.$isNullThrownError) {
        t1 = H.setRuntimeTypeInfo(["The null value was " + verb.toString$0(0) + "."], t2);
        t4 = properties.properties;
        C.JSArray_methods.add$1(t4, new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6));
        t1 = t4;
      } else if (typeof t1 === "number") {
        t1 = H.setRuntimeTypeInfo(["The number " + H.S(t1) + " was " + verb.toString$0(0) + "."], t2);
        t4 = properties.properties;
        C.JSArray_methods.add$1(t4, new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6));
        t1 = t4;
      } else {
        if (!!t3.$isAssertionError) {
          t4 = H.setRuntimeTypeInfo(["assertion"], t2);
          errorName = new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t4, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6);
        } else if (typeof t1 === "string") {
          t4 = H.setRuntimeTypeInfo(["message"], t2);
          errorName = new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t4, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6);
        } else if (!!t3.$isError || !!t3.$isException) {
          t4 = H.setRuntimeTypeInfo([t3.get$runtimeType(t1).toString$0(0)], t2);
          errorName = new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t4, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6);
        } else {
          t4 = H.setRuntimeTypeInfo([t3.get$runtimeType(t1).toString$0(0) + " object"], t2);
          errorName = new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t4, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6);
        }
        t4 = H.setRuntimeTypeInfo(["The following " + errorName.toString$0(0) + " was " + verb.toString$0(0) + ":"], t2);
        t5 = properties.properties;
        C.JSArray_methods.add$1(t5, new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t4, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6));
        if (diagnosticable != null)
          diagnosticable.debugFillProperties$1(properties);
        else {
          prefix = t3.get$runtimeType(t1).toString$0(0) + ": ";
          message = _this.exceptionAsString$0();
          t1 = H.setRuntimeTypeInfo([C.JSString_methods.startsWith$1(message, prefix) ? C.JSString_methods.substring$1(message, prefix.length) : message], t2);
          C.JSArray_methods.add$1(t5, new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6));
        }
        t1 = t5;
      }
      t4 = _this.stack;
      t5 = t4 != null;
      stackLines = t5 ? H.setRuntimeTypeInfo(C.JSString_methods.trimRight$0(t4.toString$0(0)).split("\n"), [P.String]) : _null;
      if (!!t3.$isAssertionError && diagnosticable == null) {
        if (stackLines != null) {
          stackList = H.SubListIterable$(stackLines, 0, 2, H.getTypeArgumentByIndex(stackLines, 0)).toList$0(0);
          if (stackList.length >= 2) {
            throwPattern = P.RegExp_RegExp("^#0 +_AssertionError._throwNew \\(dart:.+\\)$");
            assertPattern = P.RegExp_RegExp("^#1 +[^(]+ \\((.+?):([0-9]+)(?::[0-9]+)?\\)$");
            if (0 >= stackList.length)
              return H.ioore(stackList, 0);
            t3 = H.stringTypeCheck(stackList[0]);
            if (typeof t3 !== "string")
              H.throwExpression(H.argumentErrorValue(t3));
            if (throwPattern._nativeRegExp.test(t3)) {
              if (1 >= stackList.length)
                return H.ioore(stackList, 1);
              assertMatch = assertPattern.firstMatch$1(stackList[1]);
              if (assertMatch != null) {
                ourLibraryPattern = P.RegExp_RegExp("^package:flutter/");
                t3 = assertMatch._match;
                if (1 >= t3.length)
                  return H.ioore(t3, 1);
                t3 = t3[1];
                if (typeof t3 !== "string")
                  H.throwExpression(H.argumentErrorValue(t3));
                ourFault = ourLibraryPattern._nativeRegExp.test(t3);
              } else
                ourFault = true;
            } else
              ourFault = true;
          } else
            ourFault = true;
        } else
          ourFault = true;
        if (ourFault) {
          C.JSArray_methods.add$1(t1, Y.DiagnosticsNode_DiagnosticsNode$message("", true));
          t2 = H.setRuntimeTypeInfo(["Either the assertion indicates an error in the framework itself, or we should provide substantially more information in this error message to help you determine and fix the underlying cause.\nIn either case, please report this assertion by filing a bug on GitHub:\n  https://github.com/flutter/flutter/issues/new?template=BUG.md"], t2);
          C.JSArray_methods.add$1(t1, new U.ErrorHint(_null, false, true, _null, _null, _null, false, t2, _null, C.DiagnosticLevel_5, _null, false, false, _null, C.DiagnosticsTreeStyle_6));
        }
      }
      if (t5) {
        C.JSArray_methods.add$1(t1, Y.DiagnosticsNode_DiagnosticsNode$message("", true));
        C.JSArray_methods.add$1(t1, U.DiagnosticsStackTrace$("When the exception was thrown, this was the stack", t4, _null));
      }
      t2 = _this.informationCollector;
      if (t2 != null) {
        C.JSArray_methods.add$1(t1, Y.DiagnosticsNode_DiagnosticsNode$message("", true));
        J.forEach$1$ax(t2.call$0(), properties.get$add(properties));
      }
    },
    toStringShort$0: function() {
      var t1 = "Exception Caught By " + this.library;
      return t1;
    },
    toString$0: function(_) {
      return new Y.DiagnosticableNode(this, null, true, true, null, C.DiagnosticsTreeStyle_4, [Y.Diagnosticable]).toStringDeep$1$minLevel(C.DiagnosticLevel_2);
    }
  };
  U.FlutterErrorDetails_summary_closure.prototype = {
    call$1: function(node) {
      H.interceptedTypeCheck(node, "$isDiagnosticsNode");
      return node.get$level(node) === C.DiagnosticLevel_6;
    },
    $signature: 18
  };
  U.FlutterErrorDetails_summary_closure0.prototype = {
    call$0: function() {
      return;
    },
    $signature: 0
  };
  U.FlutterError.prototype = {
    get$message: function(_) {
      return this.toString$0(0);
    },
    debugFillProperties$1: function(properties) {
      C.JSArray_methods.forEach$1(this.diagnostics, properties.get$add(properties));
    },
    toStringShort$0: function() {
      return "FlutterError";
    },
    toString$0: function(_) {
      var t1 = this.diagnostics,
        t2 = P.String,
        t3 = H.getTypeArgumentByIndex(t1, 0);
      return new H.MappedListIterable(t1, H.functionTypeCheck(new U.FlutterError_toString_closure(new Y.TextTreeRenderer(4000000000, 65, C.DiagnosticLevel_2, -1)), {func: 1, ret: t2, args: [t3]}), [t3, t2]).join$1(0, "\n");
    },
    $isAssertionError: 1,
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1
  };
  U.FlutterError_FlutterError_closure.prototype = {
    call$1: function(line) {
      var _null = null,
        t1 = H.setRuntimeTypeInfo([H.stringTypeCheck(line)], [P.Object]);
      return new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6);
    },
    $signature: 106
  };
  U.FlutterError_toString_closure.prototype = {
    call$1: function(node) {
      return C.JSString_methods.trimRight$0(this.renderer.render$1(H.interceptedTypeCheck(node, "$isDiagnosticsNode")));
    },
    $signature: 108
  };
  U.DiagnosticsStackTrace.prototype = {};
  U._FlutterError_Error_DiagnosticableTreeMixin.prototype = {};
  N.BindingBase.prototype = {
    BindingBase$0: function() {
      var t1, t2, _this = this;
      P.Timeline_startSync("Framework initialization", null, null);
      _this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding$initInstances();
      $.WidgetsBinding__instance = _this;
      _this.WidgetsBinding__buildOwner.set$onBuildScheduled(_this.get$_handleBuildScheduled());
      t1 = $.$get$window();
      t1.toString;
      t2 = {func: 1, ret: -1};
      t1.set$_onLocaleChanged(H.functionTypeCheck(_this.get$handleLocaleChanged(), t2));
      t1.set$_onAccessibilityFeaturesChanged(H.functionTypeCheck(_this.get$handleAccessibilityFeaturesChanged(), t2));
      C.MethodChannel_89P.setMethodCallHandler$1(_this.get$_handleNavigationInvocation());
      C.BasicMessageChannel_Qma.setMessageHandler$1(_this.get$_handleSystemMessage());
      _this.initServiceExtensions$0();
      t2 = P.String;
      P.postEvent("Flutter.FrameworkInitialization", P.LinkedHashMap_LinkedHashMap$_empty(t2, t2));
      P.Timeline_finishSync();
    },
    initInstances$0: function() {
    },
    initServiceExtensions$0: function() {
    },
    lockEvents$1: function(callback) {
      var future;
      H.functionTypeCheck(callback, {func: 1, ret: [P.Future, -1]});
      P.Timeline_startSync("Lock events", null, null);
      ++this._lockCount;
      future = callback.call$0();
      future.whenComplete$1(new N.BindingBase_lockEvents_closure(this));
      return future;
    },
    unlocked$0: function() {
    },
    registerSignalServiceExtension$2$callback$name: function(callback, $name) {
      this.registerServiceExtension$2$callback$name(new N.BindingBase_registerSignalServiceExtension_closure(H.functionTypeCheck(callback, {func: 1, ret: [P.Future, -1]})), $name);
    },
    registerNumericServiceExtension$3$getter$name$setter: function(getter, $name, setter) {
      H.functionTypeCheck(getter, {func: 1, ret: [P.Future, P.double]});
      this.registerServiceExtension$2$callback$name(new N.BindingBase_registerNumericServiceExtension_closure(this, $name, H.functionTypeCheck(setter, {func: 1, ret: [P.Future, -1], args: [P.double]}), getter), $name);
    },
    _postExtensionStateChangedEvent$2: function($name, value) {
      var t1 = P.String;
      P.postEvent("Flutter.ServiceExtensionStateChanged", H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["extension", "ext.flutter." + $name, "value", value], t1, null), "$isMap", [t1, null], "$asMap"));
    },
    registerServiceExtension$2$callback$name: function(callback, $name) {
      var methodName;
      H.functionTypeCheck(callback, {func: 1, ret: [P.Future, [P.Map, P.String,,]], args: [[P.Map, P.String, P.String]]});
      methodName = "ext.flutter." + $name;
      P.registerExtension(methodName, new N.BindingBase_registerServiceExtension_closure(methodName, callback));
    },
    toString$0: function(_) {
      return "<" + new H.TypeImpl(H.getRti(this)).toString$0(0) + ">";
    }
  };
  N.BindingBase_lockEvents_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (--t1._lockCount <= 0) {
        P.Timeline_finishSync();
        t1.super$_WidgetsFlutterBinding_BindingBase_GestureBinding$unlocked();
        if (t1.SchedulerBinding__taskQueue._length !== 0)
          t1._ensureEventLoopCallback$0();
      }
    },
    $signature: 0
  };
  N.BindingBase_registerSignalServiceExtension_closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$BindingBase_registerSignalServiceExtension_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$BindingBase_registerSignalServiceExtension_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]),
        $async$returnValue, $async$self = this;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.callback.call$0(), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 19
  };
  N.BindingBase_registerNumericServiceExtension_closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$BindingBase_registerNumericServiceExtension_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$BindingBase_registerNumericServiceExtension_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]),
        $async$returnValue, $async$self = this, t1, t2, $async$temp1, $async$temp2, $async$temp3;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.name;
              t2 = J.getInterceptor$x(parameters);
              $async$goto = H.boolConversionCheck(t2.containsKey$1(parameters, t1)) ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return P._asyncAwait($async$self.setter.call$1(P.double_parse(t2.$index(parameters, t1))), $async$call$1);
            case 5:
              // returning from await.
              $async$temp1 = $async$self.$this;
              $async$temp2 = t1;
              $async$temp3 = J;
              $async$goto = 6;
              return P._asyncAwait($async$self.getter.call$0(), $async$call$1);
            case 6:
              // returning from await.
              $async$temp1._postExtensionStateChangedEvent$2($async$temp2, $async$temp3.toString$0$($async$result));
            case 4:
              // join
              $async$temp1 = P;
              $async$temp2 = t1;
              $async$temp3 = J;
              $async$goto = 7;
              return P._asyncAwait($async$self.getter.call$0(), $async$call$1);
            case 7:
              // returning from await.
              $async$returnValue = $async$temp1.LinkedHashMap_LinkedHashMap$_literal([$async$temp2, $async$temp3.toString$0$($async$result)], P.String, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 19
  };
  N.BindingBase_registerServiceExtension_closure.prototype = {
    call$2: function(method, parameters) {
      var t1;
      H.stringTypeCheck(method);
      t1 = P.String;
      H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap");
      return this.$call$body$BindingBase_registerServiceExtension_closure(method, parameters);
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $call$body$BindingBase_registerServiceExtension_closure: function(method, parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.ServiceExtensionResponse),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, caughtException, caughtStack, result, exception, stack, exception0, t1, t2, t3, $async$exception0;
      var $async$call$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(E.debugInstrumentAction("Wait for outer event loop", new N.BindingBase_registerServiceExtension__closure(), -1), $async$call$2);
            case 3:
              // returning from await.
              caughtException = null;
              caughtStack = null;
              result = null;
              $async$handler = 5;
              $async$goto = 8;
              return P._asyncAwait($async$self.callback.call$1(parameters), $async$call$2);
            case 8:
              // returning from await.
              result = $async$result;
              $async$handler = 2;
              // goto after finally
              $async$goto = 7;
              break;
            case 5:
              // catch
              $async$handler = 4;
              $async$exception0 = $async$currentError;
              exception = H.unwrapException($async$exception0);
              stack = H.getTraceFromException($async$exception0);
              caughtException = exception;
              caughtStack = stack;
              // goto after finally
              $async$goto = 7;
              break;
            case 4:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 7:
              // after finally
              if (caughtException == null) {
                J.$indexSet$ax(result, "type", "_extensionType");
                J.$indexSet$ax(result, "method", method);
                t1 = C.C_JsonCodec.encode$1(result);
                $async$returnValue = new P.ServiceExtensionResponse(t1, null, null);
                // goto return
                $async$goto = 1;
                break;
              } else {
                t1 = caughtException;
                t2 = caughtStack;
                t3 = H.setRuntimeTypeInfo(['during a service extension callback for "' + H.S(method) + '"'], [P.Object]);
                U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(U.FlutterErrorDetails$(new U.ErrorDescription(null, false, true, null, null, null, false, t3, null, C.DiagnosticLevel_3, null, false, false, null, C.DiagnosticsTreeStyle_6), t1, null, "Flutter framework", false, t2));
                t1 = P.String;
                t1 = C.C_JsonCodec.encode$1(P.LinkedHashMap_LinkedHashMap$_literal(["exception", J.toString$0$(caughtException), "stack", J.toString$0$(caughtStack), "method", method], t1, t1));
                P.ServiceExtensionResponse__validateErrorCode(-32000);
                $async$returnValue = new P.ServiceExtensionResponse(null, -32000, t1);
                // goto return
                $async$goto = 1;
                break;
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$2, $async$completer);
    },
    $signature: 32
  };
  N.BindingBase_registerServiceExtension__closure.prototype = {
    call$0: function() {
      return P.Future_Future$delayed(C.Duration_0, -1);
    },
    $signature: 6
  };
  B.ChangeNotifier.prototype = {
    dispose$0: function() {
      this.set$_change_notifier$_listeners(null);
    },
    notifyListeners$0: function() {
      var listener, exception, stack, localListeners, t2, _i, exception0, t3, _this = this, _null = null,
        t1 = _this.ChangeNotifier__listeners;
      if (t1 != null) {
        localListeners = P.List_List$from(t1, true, {func: 1, ret: -1});
        for (t1 = localListeners.length, t2 = [P.Object], _i = 0; _i < localListeners.length; localListeners.length === t1 || (0, H.throwConcurrentModificationError)(localListeners), ++_i) {
          listener = localListeners[_i];
          try {
            if (_this.ChangeNotifier__listeners.contains$1(0, listener))
              listener.call$0();
          } catch (exception0) {
            exception = H.unwrapException(exception0);
            stack = H.getTraceFromException(exception0);
            t3 = H.setRuntimeTypeInfo(["while dispatching notifications for " + new H.TypeImpl(H.getRti(_this)).toString$0(0)], t2);
            U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(new U.FlutterErrorDetails(exception, stack, "foundation library", new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t3, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), new B.ChangeNotifier_notifyListeners_closure(_this), false));
          }
        }
      }
    },
    set$_change_notifier$_listeners: function(_listeners) {
      this.ChangeNotifier__listeners = H.assertSubtype(_listeners, "$isObserverList", [{func: 1, ret: -1}], "$asObserverList");
    }
  };
  B.ChangeNotifier_notifyListeners_closure.prototype = {
    call$0: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1;
        return function $async$call$0($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                $async$goto = 2;
                return Y.DiagnosticsProperty$("The " + new H.TypeImpl(H.getRti(t1)).toString$0(0) + " sending notification was", t1, true, C.C__NoDefaultValue, null, false, null, null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_8, null, B.ChangeNotifier);
              case 2:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, [Y.DiagnosticsProperty, B.ChangeNotifier]);
    },
    $signature: 47
  };
  Y.DiagnosticLevel.prototype = {
    toString$0: function(_) {
      return this._diagnostics$_name;
    }
  };
  Y.DiagnosticsTreeStyle.prototype = {
    toString$0: function(_) {
      return this._diagnostics$_name;
    }
  };
  Y.TextTreeConfiguration.prototype = {};
  Y._WordWrapParseMode.prototype = {
    toString$0: function(_) {
      return this._diagnostics$_name;
    }
  };
  Y._PrefixedStringBuilder.prototype = {
    get$prefixOtherLines: function() {
      var t1 = this._nextPrefixOtherLines;
      return t1 == null ? this._prefixOtherLines : t1;
    },
    incrementPrefixOtherLines$2$updateCurrentLine: function(suffix, updateCurrentLine) {
      var _this = this;
      if (_this._currentLine._contents.length === 0 || updateCurrentLine) {
        _this._prefixOtherLines = J.$add$ansx(_this.get$prefixOtherLines(), suffix);
        _this._nextPrefixOtherLines = null;
      } else
        _this._nextPrefixOtherLines = J.$add$ansx(_this.get$prefixOtherLines(), suffix);
    },
    get$requiresMultipleLines: function() {
      var t2, _this = this,
        t1 = _this._numLines;
      if (t1 <= 1)
        if (!(t1 === 1 && _this._currentLine._contents.length !== 0)) {
          t1 = _this._currentLine._contents;
          if (_this._buffer._contents.length === 0)
            t2 = _this.prefixLineOne;
          else
            t2 = _this._prefixOtherLines;
          t2 = t1.length + t2.length > _this.wrapWidth;
          t1 = t2;
        } else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    _finalizeLine$1: function(addTrailingLineBreak) {
      var t3, lines, $length, i, t4, _this = this,
        firstLine = _this._buffer._contents.length === 0,
        t1 = _this._currentLine,
        t2 = t1._contents,
        text = t2.charCodeAt(0) == 0 ? t2 : t2;
      t1._contents = "";
      t1 = _this._wrappableRanges;
      if (t1.length === 0) {
        _this._writeLine$3$firstLine$includeLineBreak(text, firstLine, addTrailingLineBreak);
        return;
      }
      t2 = firstLine ? _this.prefixLineOne.length : _this._prefixOtherLines.length;
      t3 = _this._prefixOtherLines;
      t3 = firstLine ? t3.length : t3.length;
      lines = Y._PrefixedStringBuilder__wordWrapLine(text, t1, _this.wrapWidth, t3, t2);
      $length = lines.get$length(lines);
      for (t2 = new P._SyncStarIterator(lines._outerHelper(), [H.getTypeArgumentByIndex(lines, 0)]), t3 = !addTrailingLineBreak, i = 0; t2.moveNext$0();) {
        t4 = t2.get$current(t2);
        ++i;
        _this._writeLine$3$firstLine$includeLineBreak(t4, firstLine, !t3 || i < $length);
      }
      C.JSArray_methods.set$length(t1, 0);
    },
    write$2$allowWrap: function(_, s, allowWrap) {
      var lines, t1, t2, i, t3, line, wrapStart, wrapEnd, _this = this;
      if (s.length === 0)
        return;
      lines = s.split("\n");
      for (t1 = _this._currentLine, t2 = _this._wrappableRanges, i = 0; i < lines.length; ++i) {
        if (i > 0) {
          _this._finalizeLine$1(true);
          t3 = _this._nextPrefixOtherLines;
          if (t3 != null) {
            _this._prefixOtherLines = t3;
            _this._nextPrefixOtherLines = null;
          }
        }
        line = lines[i];
        t3 = line.length;
        if (t3 !== 0) {
          if (allowWrap && true) {
            wrapStart = t1._contents.length;
            wrapEnd = wrapStart + t3;
            if (t2.length !== 0 && C.JSArray_methods.get$last(t2) === wrapStart)
              C.JSArray_methods.set$last(t2, wrapEnd);
            else {
              C.JSArray_methods.add$1(t2, wrapStart);
              C.JSArray_methods.add$1(t2, wrapEnd);
            }
          }
          t1._contents += H.S(line);
        }
      }
    },
    write$1: function($receiver, s) {
      return this.write$2$allowWrap($receiver, s, false);
    },
    _updatePrefix$0: function() {
      var t1 = this._nextPrefixOtherLines;
      if (t1 != null) {
        this._prefixOtherLines = t1;
        this._nextPrefixOtherLines = null;
      }
    },
    _writeLine$3$firstLine$includeLineBreak: function(line, firstLine, includeLineBreak) {
      var t2, _this = this,
        t1 = _this._buffer;
      if (t1._contents.length === 0)
        t2 = _this.prefixLineOne;
      else
        t2 = _this._prefixOtherLines;
      t2 = t1._contents += C.JSString_methods.trimRight$0(H.S(t2) + H.S(line));
      if (includeLineBreak)
        t1._contents = t2 + "\n";
      ++_this._numLines;
    },
    writeRawLines$1: function(lines) {
      var t1, t2, _this = this;
      if (lines.length === 0)
        return;
      if (_this._currentLine._contents.length !== 0)
        _this._finalizeLine$1(true);
      t1 = _this._buffer;
      t2 = t1._contents += lines;
      if (!C.JSString_methods.endsWith$1(lines, "\n"))
        t1._contents = t2 + "\n";
      ++_this._numLines;
      _this._updatePrefix$0();
    },
    writeStretched$2: function(text, targetLineLength) {
      var t1, t2, t3, targetLength, _this = this;
      _this.write$1(0, text);
      t1 = _this._currentLine;
      t2 = t1._contents;
      if (_this._buffer._contents.length === 0)
        t3 = _this.prefixLineOne;
      else
        t3 = _this._prefixOtherLines;
      targetLength = targetLineLength - (t2.length + t3.length);
      if (targetLength > 0) {
        t2 = text.length;
        t3 = t2 - 1;
        if (t3 < 0)
          return H.ioore(text, t3);
        t1._contents += C.JSString_methods.$mul(text[t3], targetLength);
      }
      C.JSArray_methods.set$length(_this._wrappableRanges, 0);
    },
    build$0: function() {
      if (this._currentLine._contents.length !== 0)
        this._finalizeLine$1(false);
      var t1 = this._buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  Y._PrefixedStringBuilder__wordWrapLine_noWrap.prototype = {
    call$1: function(index) {
      var t1, t2, t3, t4, t5;
      for (t1 = this._box_0, t2 = this.wrapRanges; true;) {
        t3 = t1.currentChunk;
        t4 = t2.length;
        if (t3 >= t4)
          return true;
        t5 = t3 + 1;
        if (t5 >= t4)
          return H.ioore(t2, t5);
        if (index < t2[t5])
          break;
        t1.currentChunk = t3 + 2;
      }
      t1 = t1.currentChunk;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      return index < t2[t1];
    },
    $signature: 20
  };
  Y._NoDefaultValue.prototype = {};
  Y.TextTreeRenderer.prototype = {
    render$4$parentConfiguration$prefixLineOne$prefixOtherLines: function(node, parentConfiguration, prefixLineOne, prefixOtherLines) {
      var isSingleLine, t1, config, descendants, t2, t3, t4, builder, children, description, wrapName, wrapDescription, uppercaseTitle, $name, includeName, propertiesIterable, properties, i, property, propertyStyle, propertyRender, propertyLines, t5, prefixChildrenRaw, child, childStyle, childConfig, lastChildPrefixLineOne, childPrefixOtherLines, nextChildStyle, childPrefixLineOne, _this = this, _null = null, _s1_ = "\n", _box_0 = {};
      _box_0.prefixOtherLines = prefixOtherLines;
      if (node.get$style(node) === C.DiagnosticsTreeStyle_7)
        isSingleLine = (parentConfiguration == null ? _null : parentConfiguration.lineBreakProperties) !== true;
      else
        isSingleLine = false;
      if (prefixOtherLines == null) {
        _box_0.prefixOtherLines = prefixLineOne;
        t1 = prefixLineOne;
      } else
        t1 = prefixOtherLines;
      config = node.get$textTreeConfiguration();
      if (t1.length === 0)
        t1 = _box_0.prefixOtherLines = t1 + config.prefixOtherLinesRootNode;
      if (node.get$style(node) === C.DiagnosticsTreeStyle_10) {
        descendants = H.setRuntimeTypeInfo([], [P.String]);
        _box_0.lines = _box_0.depth = 0;
        new Y.TextTreeRenderer_render_visitor(_box_0, 25, descendants, 5).call$1(node);
        if (_box_0.lines > 1)
          t1 = prefixLineOne + ("This " + H.S(node.name) + " had the following descendants (showing up to depth 5):\n");
        else {
          t1 = descendants.length;
          t2 = node.name;
          t1 = t1 === 1 ? prefixLineOne + ("This " + H.S(t2) + " had the following child:\n") : prefixLineOne + ("This " + H.S(t2) + " has no descendants.\n");
        }
        t1 = P.StringBuffer__writeAll(t1, descendants, _s1_);
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      t2 = _this._wrapWidthProperties;
      t3 = Math.max(_this._wrapWidth, t1.length + t2);
      t4 = new P.StringBuffer("");
      builder = new Y._PrefixedStringBuilder(prefixLineOne, t1, t3, new P.StringBuffer(""), t4, H.setRuntimeTypeInfo([], [P.int]));
      children = node.getChildren$0();
      description = node.toDescription$1$parentConfiguration(parentConfiguration);
      t1 = config.beforeName;
      if (t1.length !== 0)
        builder.write$1(0, t1);
      t1 = !isSingleLine;
      wrapName = t1 && node.get$allowNameWrap();
      wrapDescription = t1 && node.get$allowWrap();
      uppercaseTitle = node.get$style(node) === C.DiagnosticsTreeStyle_4;
      $name = node.name;
      if (uppercaseTitle)
        $name = $name == null ? _null : $name.toUpperCase();
      if (description == null || description.length === 0) {
        if (node.get$showName() && $name != null)
          builder.write$2$allowWrap(0, $name, wrapName);
      } else {
        if ($name != null && $name.length !== 0 && node.get$showName()) {
          builder.write$2$allowWrap(0, $name, wrapName);
          if (node.showSeparator)
            builder.write$2$allowWrap(0, config.afterName, wrapName);
          builder.write$2$allowWrap(0, config.isNameOnOwnLine || J.contains$1$asx(description, _s1_) ? _s1_ : " ", wrapName);
          includeName = true;
        } else
          includeName = false;
        if (t1 && builder.get$requiresMultipleLines() && t4._contents.length !== 0)
          builder.write$1(0, _s1_);
        if (includeName)
          builder.incrementPrefixOtherLines$2$updateCurrentLine(children.length === 0 ? config.propertyPrefixNoChildren : config.propertyPrefixIfChildren, true);
        if (uppercaseTitle)
          description = description.toUpperCase();
        builder.write$2$allowWrap(0, J.trimRight$0$s(description), wrapDescription);
        if (!includeName)
          builder.incrementPrefixOtherLines$2$updateCurrentLine(children.length === 0 ? config.propertyPrefixNoChildren : config.propertyPrefixIfChildren, false);
      }
      t1 = config.suffixLineOne;
      if (t1.length !== 0)
        builder.writeStretched$2(t1, t3);
      t1 = node.getProperties$0(0);
      t3 = H.getTypeArgumentByIndex(t1, 0);
      propertiesIterable = new H.WhereIterable(t1, H.functionTypeCheck(new Y.TextTreeRenderer_render_closure(_this), {func: 1, ret: P.bool, args: [t3]}), [t3]);
      t1 = _this._maxDescendentsTruncatableNode;
      if (t1 >= 0 && node.get$allowTruncate()) {
        if (propertiesIterable.get$length(propertiesIterable) < t1) {
          t3 = H.TakeIterable_TakeIterable(propertiesIterable, t1, t3);
          properties = P.List_List$from(t3, true, H.getRuntimeTypeArgument(t3, "Iterable", 0));
          C.JSArray_methods.add$1(properties, Y.DiagnosticsNode_DiagnosticsNode$message("...", true));
        } else
          properties = P.List_List$from(propertiesIterable, true, t3);
        if (t1 < children.length) {
          children = H.SubListIterable$(children, 0, t1, H.getTypeArgumentByIndex(children, 0)).toList$0(0);
          C.JSArray_methods.add$1(children, Y.DiagnosticsNode_DiagnosticsNode$message("...", true));
        }
      } else
        properties = P.List_List$from(propertiesIterable, true, t3);
      if (properties.length === 0)
        if (children.length === 0) {
          node.get$emptyBodyDescription();
          t1 = false;
        } else
          t1 = true;
      else
        t1 = true;
      if (t1)
        if (!node.showSeparator)
          t1 = (description == null ? _null : description.length !== 0) === true;
        else
          t1 = true;
      else
        t1 = false;
      if (t1)
        builder.write$1(0, config.afterDescriptionIfBody);
      t1 = config.lineBreakProperties;
      if (t1)
        builder.write$1(0, config.lineBreak);
      if (properties.length !== 0)
        builder.write$1(0, config.beforeProperties);
      t3 = config.bodyIndent;
      builder.incrementPrefixOtherLines$2$updateCurrentLine(t3, false);
      node.get$emptyBodyDescription();
      for (t1 = !t1, i = 0; t4 = properties.length, i < t4; ++i) {
        property = properties[i];
        if (i > 0)
          builder.write$1(0, config.propertySeparator);
        propertyStyle = property.get$textTreeConfiguration();
        if (property.get$style(property) === C.DiagnosticsTreeStyle_7) {
          propertyRender = _this.render$4$parentConfiguration$prefixLineOne$prefixOtherLines(property, config, propertyStyle.prefixLineOne, propertyStyle.childLinkSpace + propertyStyle.prefixOtherLines);
          propertyLines = propertyRender.split(_s1_);
          if (propertyLines.length === 1 && t1)
            builder.write$1(0, C.JSArray_methods.get$first(propertyLines));
          else {
            builder.write$2$allowWrap(0, propertyRender, false);
            if (!C.JSString_methods.endsWith$1(propertyRender, _s1_))
              builder.write$1(0, _s1_);
          }
        } else {
          t4 = builder._nextPrefixOtherLines;
          t4 = H.S(t4 == null ? builder._prefixOtherLines : t4) + propertyStyle.prefixLineOne;
          t5 = builder._nextPrefixOtherLines;
          builder.writeRawLines$1(_this.render$4$parentConfiguration$prefixLineOne$prefixOtherLines(property, config, t4, H.S(t5 == null ? builder._prefixOtherLines : t5) + propertyStyle.childLinkSpace + propertyStyle.prefixOtherLines));
        }
      }
      if (t4 !== 0)
        builder.write$1(0, config.afterProperties);
      config.toString;
      builder.write$1(0, "");
      if (t1)
        builder.write$1(0, config.lineBreak);
      prefixChildrenRaw = H.S(_box_0.prefixOtherLines) + t3;
      if (children.length === 0 && config.addBlankLineIfNoChildren && builder.get$requiresMultipleLines() && J.trimRight$0$s(builder.get$prefixOtherLines()).length !== 0)
        builder.write$1(0, config.lineBreak);
      if (children.length !== 0 && config.showChildren) {
        if (config.isBlankLineBetweenPropertiesAndChildren && properties.length !== 0 && C.JSArray_methods.get$first(children).get$textTreeConfiguration().isBlankLineBetweenPropertiesAndChildren)
          builder.write$1(0, config.lineBreak);
        builder._prefixOtherLines = _box_0.prefixOtherLines;
        builder._nextPrefixOtherLines = null;
        for (t1 = builder.wrapWidth, i = 0; i < children.length; ++i) {
          child = children[i];
          childStyle = child == null ? _null : child.get$style(child);
          childConfig = childStyle === C.DiagnosticsTreeStyle_7 || childStyle === C.DiagnosticsTreeStyle_8 ? config : child.get$textTreeConfiguration();
          t3 = children.length;
          if (i === t3 - 1) {
            lastChildPrefixLineOne = prefixChildrenRaw + childConfig.prefixLastChildLineOne;
            t3 = childConfig.childLinkSpace;
            childPrefixOtherLines = prefixChildrenRaw + t3 + childConfig.prefixOtherLines;
            builder.writeRawLines$1(_this.render$4$parentConfiguration$prefixLineOne$prefixOtherLines(child, config, lastChildPrefixLineOne, childPrefixOtherLines));
            t4 = childConfig.footer;
            if (t4.length !== 0) {
              builder._prefixOtherLines = prefixChildrenRaw;
              builder._nextPrefixOtherLines = null;
              builder.write$1(0, t3 + t4);
              t3 = childConfig.manditoryFooter;
              if (t3.length !== 0)
                builder.writeStretched$2(t3, Math.max(t1, t2 + childPrefixOtherLines.length));
              builder.write$1(0, config.lineBreak);
            }
          } else {
            t4 = i + 1;
            if (t4 >= t3)
              return H.ioore(children, t4);
            t4 = H.interceptedTypeCheck(children[t4], "$isDiagnosticsNode");
            childStyle = t4 == null ? _null : t4.get$style(t4);
            nextChildStyle = childStyle === C.DiagnosticsTreeStyle_7 || childStyle === C.DiagnosticsTreeStyle_8 ? config : t4.get$textTreeConfiguration();
            childPrefixLineOne = prefixChildrenRaw + childConfig.prefixLineOne;
            childPrefixOtherLines = prefixChildrenRaw + nextChildStyle.linkCharacter + childConfig.prefixOtherLines;
            builder.writeRawLines$1(_this.render$4$parentConfiguration$prefixLineOne$prefixOtherLines(child, config, childPrefixLineOne, childPrefixOtherLines));
            t3 = childConfig.footer;
            if (t3.length !== 0) {
              builder._prefixOtherLines = prefixChildrenRaw;
              builder._nextPrefixOtherLines = null;
              builder.write$1(0, childConfig.linkCharacter + t3);
              t3 = childConfig.manditoryFooter;
              if (t3.length !== 0)
                builder.writeStretched$2(t3, Math.max(t1, t2 + childPrefixOtherLines.length));
              builder.write$1(0, config.lineBreak);
            }
          }
        }
      }
      if (parentConfiguration == null && config.manditoryFooter.length !== 0) {
        builder.writeStretched$2(config.manditoryFooter, builder.wrapWidth);
        builder.write$1(0, config.lineBreak);
      }
      if (builder._currentLine._contents.length !== 0)
        builder._finalizeLine$1(false);
      t1 = builder._buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    render$1: function(node) {
      return this.render$4$parentConfiguration$prefixLineOne$prefixOtherLines(node, null, "", null);
    }
  };
  Y.TextTreeRenderer_render_visitor.prototype = {
    call$1: function(node) {
      var t1, t2, t3, t4, t5, t6, _i, child, t7, _this = this;
      for (t1 = node.getChildren$0(), t2 = t1.length, t3 = _this._box_0, t4 = _this.maxLines, t5 = _this.descendants, t6 = _this.maxDepth, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        t7 = t3.lines;
        if (t7 < t4) {
          ++t3.depth;
          C.JSArray_methods.add$1(t5, H.S(t3.prefixOtherLines) + C.JSString_methods.$mul("  ", t3.depth) + H.S(child));
          if (t3.depth < t6)
            _this.call$1(child);
          --t3.depth;
        } else if (t7 === t4)
          C.JSArray_methods.add$1(t5, H.S(t3.prefixOtherLines) + "  ...(descendants list truncated after " + t3.lines + " lines)");
        ++t3.lines;
      }
    },
    $signature: 34
  };
  Y.TextTreeRenderer_render_closure.prototype = {
    call$1: function(n) {
      H.interceptedTypeCheck(n, "$isDiagnosticsNode");
      return n.get$level(n).index >= this.$this._minLevel.index;
    },
    $signature: 18
  };
  Y.DiagnosticsNode.prototype = {
    get$level: function(_) {
      return C.DiagnosticLevel_3;
    },
    get$emptyBodyDescription: function() {
      return;
    },
    get$allowWrap: function() {
      return false;
    },
    get$allowNameWrap: function() {
      return false;
    },
    get$allowTruncate: function() {
      return false;
    },
    toString$1$minLevel: function(_, minLevel) {
      var description, t1, _this = this;
      if (_this.get$style(_this) === C.DiagnosticsTreeStyle_7)
        return _this.toStringDeep$2$minLevel$parentConfiguration(minLevel, null);
      description = _this.toDescription$1$parentConfiguration(null);
      t1 = _this.name;
      if (t1 == null || t1.length === 0 || !_this.get$showName())
        return description;
      if (J.contains$1$asx(description, "\n")) {
        t1 = H.S(t1);
        t1 = t1 + (_this.showSeparator ? ":" : "") + "\n" + description;
      } else {
        t1 = H.S(t1);
        t1 = t1 + (_this.showSeparator ? ":" : "") + " " + description;
      }
      return t1;
    },
    toString$0: function($receiver) {
      return this.toString$1$minLevel($receiver, C.DiagnosticLevel_3);
    },
    get$textTreeConfiguration: function() {
      switch (this.get$style(this)) {
        case C.DiagnosticsTreeStyle_2:
          return $.$get$denseTextConfiguration();
        case C.DiagnosticsTreeStyle_0:
          return $.$get$sparseTextConfiguration();
        case C.DiagnosticsTreeStyle_1:
          return $.$get$dashedTextConfiguration();
        case C.DiagnosticsTreeStyle_5:
          return $.$get$whitespaceTextConfiguration();
        case C.DiagnosticsTreeStyle_3:
          return $.$get$transitionTextConfiguration();
        case C.DiagnosticsTreeStyle_7:
          return $.$get$singleLineTextConfiguration();
        case C.DiagnosticsTreeStyle_8:
          return $.$get$errorPropertyTextConfiguration();
        case C.DiagnosticsTreeStyle_9:
          return $.$get$shallowTextConfiguration();
        case C.DiagnosticsTreeStyle_4:
          return $.$get$errorTextConfiguration();
        case C.DiagnosticsTreeStyle_10:
          return $.$get$whitespaceTextConfiguration();
        case C.DiagnosticsTreeStyle_6:
          return $.$get$flatTextConfiguration();
      }
      return;
    },
    toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines: function(minLevel, parentConfiguration, prefixLineOne, prefixOtherLines) {
      return new Y.TextTreeRenderer(65, 65, minLevel, -1).render$4$parentConfiguration$prefixLineOne$prefixOtherLines(this, parentConfiguration, prefixLineOne, prefixOtherLines);
    },
    toStringDeep$2$minLevel$parentConfiguration: function(minLevel, parentConfiguration) {
      return this.toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines(minLevel, parentConfiguration, "", null);
    },
    toStringDeep$1$minLevel: function(minLevel) {
      return this.toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines(minLevel, null, "", null);
    },
    toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines: function(minLevel, prefixLineOne, prefixOtherLines) {
      return this.toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines(minLevel, null, prefixLineOne, prefixOtherLines);
    },
    get$showName: function() {
      return this.showName;
    },
    get$style: function(receiver) {
      return this.style;
    }
  };
  Y.StringProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, _this = this,
        text = _this._description;
      if (text == null) {
        _this._maybeCacheValue$0();
        text = _this._value;
      }
      if (parentConfiguration != null && !parentConfiguration.lineBreakProperties && text != null)
        text = H.stringReplaceAllUnchecked(text, "\n", "\\n");
      if (_this.quoted && text != null) {
        t1 = _this.ifEmpty;
        if (t1 != null && text.length === 0)
          return t1;
        return '"' + text + '"';
      }
      return J.toString$0$(text);
    },
    $asDiagnosticsProperty: function() {
      return [P.String];
    }
  };
  Y._NumProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (_this._value == null) {
        _this._maybeCacheValue$0();
        return J.toString$0$(_this._value);
      }
      t1 = _this.unit;
      return t1 != null ? H.S(_this.numberToString$0()) + t1 : _this.numberToString$0();
    }
  };
  Y.DoubleProperty.prototype = {
    numberToString$0: function() {
      this._maybeCacheValue$0();
      var t1 = this._value;
      return t1 == null ? null : J.toStringAsFixed$1$n(t1, 1);
    },
    $as_NumProperty: function() {
      return [P.double];
    },
    $asDiagnosticsProperty: function() {
      return [P.double];
    }
  };
  Y.IntProperty.prototype = {
    numberToString$0: function() {
      this._maybeCacheValue$0();
      return J.toString$0$(this._value);
    },
    $as_NumProperty: function() {
      return [P.int];
    },
    $asDiagnosticsProperty: function() {
      return [P.int];
    }
  };
  Y.FlagProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (J.$eq$(_this._value, true))
        return _this.ifTrue;
      else {
        _this._maybeCacheValue$0();
        if (J.$eq$(_this._value, false)) {
          t1 = _this.ifFalse;
          if (t1 != null)
            return t1;
        }
      }
      return _this.super$DiagnosticsProperty$valueToString(parentConfiguration);
    },
    get$showName: function() {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (_this._value != null) {
        _this._maybeCacheValue$0();
        J.$eq$(_this._value, true);
        _this._maybeCacheValue$0();
        t1 = J.$eq$(_this._value, false) && _this.ifFalse == null;
      } else
        t1 = true;
      if (t1)
        return true;
      return _this.showName;
    },
    get$level: function(_) {
      var _this = this;
      _this._maybeCacheValue$0();
      J.$eq$(_this._value, true);
      _this._maybeCacheValue$0();
      if (J.$eq$(_this._value, false))
        if (_this.ifFalse == null)
          return C.DiagnosticLevel_0;
      return Y.DiagnosticsProperty.prototype.get$level.call(_this, _this);
    },
    $asDiagnosticsProperty: function() {
      return [P.bool];
    }
  };
  Y.IterableProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, t2, item, isSingleLine, _this = this;
      _this._maybeCacheValue$0();
      if (_this._value == null) {
        _this._maybeCacheValue$0();
        return J.toString$0$(_this._value);
      }
      _this._maybeCacheValue$0();
      if (J.get$isEmpty$asx(_this._value)) {
        t1 = _this.ifEmpty;
        return t1 == null ? "[]" : t1;
      }
      _this._maybeCacheValue$0();
      if (J.get$length$asx(_this._value) === 5)
        P.print("");
      if (new H.TypeImpl(H.getTypeArgumentByIndex(_this, 0)).$eq(0, C.Type_double_K1J))
        if (parentConfiguration != null && !parentConfiguration.lineBreakProperties) {
          for (_this._maybeCacheValue$0(), t1 = J.get$iterator$ax(_this._value), t2 = ""; t1.moveNext$0();) {
            item = t1.get$current(t1);
            if (t2.length !== 0)
              t2 += ", ";
            t2 += Y.debugPrintDouble(H.doubleTypeCast(item));
          }
          return "[" + (t2.charCodeAt(0) == 0 ? t2 : t2) + "]";
        } else {
          isSingleLine = _this.style === C.DiagnosticsTreeStyle_7;
          for (_this._maybeCacheValue$0(), t1 = J.get$iterator$ax(_this._value), t2 = ""; t1.moveNext$0();) {
            item = t1.get$current(t1);
            if (t2.length !== 0)
              t2 += isSingleLine ? ", " : "\n";
            t2 += Y.debugPrintDouble(H.doubleTypeCast(item));
          }
          return t2.charCodeAt(0) == 0 ? t2 : t2;
        }
      if (parentConfiguration != null && !parentConfiguration.lineBreakProperties) {
        _this._maybeCacheValue$0();
        return "[" + J.join$1$ax(_this._value, ", ") + "]";
      }
      _this._maybeCacheValue$0();
      t1 = _this._value;
      return J.join$1$ax(t1, _this.style === C.DiagnosticsTreeStyle_7 ? ", " : "\n");
    },
    get$level: function(_) {
      var t1, _this = this;
      if (_this.ifEmpty == null) {
        _this._maybeCacheValue$0();
        if (_this._value != null) {
          _this._maybeCacheValue$0();
          t1 = J.get$isEmpty$asx(_this._value) && Y.DiagnosticsProperty.prototype.get$level.call(_this, _this) !== C.DiagnosticLevel_0;
        } else
          t1 = false;
      } else
        t1 = false;
      if (t1)
        return C.DiagnosticLevel_1;
      return Y.DiagnosticsProperty.prototype.get$level.call(_this, _this);
    },
    $asDiagnosticsProperty: function($T) {
      return [[P.Iterable, $T]];
    }
  };
  Y.EnumProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var _this = this;
      _this._maybeCacheValue$0();
      if (_this._value == null) {
        _this._maybeCacheValue$0();
        return J.toString$0$(_this._value);
      }
      _this._maybeCacheValue$0();
      return Y.describeEnum(_this._value);
    }
  };
  Y.ObjectFlagProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (!(_this._value != null)) {
        t1 = _this.ifNull;
        if (t1 != null)
          return t1;
      }
      return _this.super$DiagnosticsProperty$valueToString(parentConfiguration);
    },
    get$showName: function() {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (!(_this._value != null && true)) {
        _this._maybeCacheValue$0();
        t1 = _this._value == null && _this.ifNull == null;
      } else
        t1 = true;
      if (t1)
        return true;
      return _this.showName;
    },
    get$level: function(_) {
      var _this = this;
      _this._maybeCacheValue$0();
      if (_this._value != null)
        return C.DiagnosticLevel_0;
      else if (_this.ifNull == null)
        return C.DiagnosticLevel_0;
      return Y.DiagnosticsProperty.prototype.get$level.call(_this, _this);
    }
  };
  Y.DiagnosticsProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var v, t1, desc;
      this._maybeCacheValue$0();
      v = this._value;
      t1 = J.getInterceptor$(v);
      if (!!t1.$isFunction) {
        desc = t1.toString$0(v);
        return C.JSString_methods.contains$1(desc, "Closure:") && C.JSString_methods.contains$1(desc, "from:") ? C.JSString_methods.substring$2(desc, 0, C.JSString_methods.indexOf$1(desc, "from: ") - 1) : desc;
      } else if (typeof v === "number")
        return Y.debugPrintDouble(v);
      t1 = J.getInterceptor$(v);
      t1 = !!t1.$isDiagnosticableTree ? v.toStringShort$0() : t1.toString$0(v);
      return t1 == null ? "" : t1;
    },
    toDescription$1$parentConfiguration: function(parentConfiguration) {
      var t2, result, _this = this,
        t1 = _this._description;
      if (t1 != null)
        return _this._addTooltip$1(t1);
      _this._maybeCacheValue$0();
      if (_this._exception != null) {
        _this._maybeCacheValue$0();
        return "EXCEPTION (" + J.get$runtimeType$(_this._exception).toString$0(0) + ")";
      }
      t1 = _this.ifNull;
      if (t1 != null) {
        _this._maybeCacheValue$0();
        t2 = _this._value == null;
      } else
        t2 = false;
      if (t2)
        return _this._addTooltip$1(t1);
      result = _this.valueToString$1$parentConfiguration(parentConfiguration);
      return _this._addTooltip$1(result.length === 0 && _this.ifEmpty != null ? _this.ifEmpty : result);
    },
    _addTooltip$1: function(text) {
      var t1 = this.tooltip;
      return t1 == null ? text : H.S(text) + " (" + t1 + ")";
    },
    _maybeCacheValue$0: function() {
      return;
    },
    get$level: function(_) {
      var t2, _this = this,
        t1 = _this._defaultLevel;
      if (t1 === C.DiagnosticLevel_0)
        return t1;
      _this._maybeCacheValue$0();
      if (_this._exception != null)
        return C.DiagnosticLevel_7;
      _this._maybeCacheValue$0();
      if (_this._value == null && _this.missingIfNull)
        return C.DiagnosticLevel_4;
      t2 = _this.defaultValue;
      if (!J.$eq$(t2, C.C__NoDefaultValue)) {
        _this._maybeCacheValue$0();
        t2 = J.$eq$(_this._value, t2);
      } else
        t2 = false;
      if (t2)
        return C.DiagnosticLevel_1;
      return t1;
    },
    getProperties$0: function(_) {
      return C.List_empty;
    },
    getChildren$0: function() {
      return C.List_empty;
    },
    get$allowWrap: function() {
      return this.allowWrap;
    },
    get$allowNameWrap: function() {
      return true;
    }
  };
  Y.DiagnosticableNode.prototype = {
    get$_builder: function() {
      var t1, _this = this;
      if (_this._cachedBuilder == null) {
        t1 = new Y.DiagnosticPropertiesBuilder(H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]), C.DiagnosticsTreeStyle_0);
        _this._cachedBuilder = t1;
        _this.value.debugFillProperties$1(t1);
      }
      return _this._cachedBuilder;
    },
    get$style: function(_) {
      var t1 = this.style;
      return t1 == null ? this.get$_builder().defaultDiagnosticsTreeStyle : t1;
    },
    get$emptyBodyDescription: function() {
      this.get$_builder().toString;
      return;
    },
    getProperties$0: function(_) {
      return this.get$_builder().properties;
    },
    getChildren$0: function() {
      return C.List_empty;
    },
    toDescription$1$parentConfiguration: function(parentConfiguration) {
      return this.value.toStringShort$0();
    }
  };
  Y._DiagnosticableTreeNode.prototype = {
    getChildren$0: function() {
      var t1 = this.value.debugDescribeChildren$0();
      return t1;
    },
    $asDiagnosticableNode: function() {
      return [Y.DiagnosticableTree];
    }
  };
  Y.DiagnosticPropertiesBuilder.prototype = {
    add$1: function(_, property) {
      C.JSArray_methods.add$1(this.properties, H.interceptedTypeCheck(property, "$isDiagnosticsNode"));
    }
  };
  Y.Diagnosticable.prototype = {};
  Y.DiagnosticableMixin.prototype = {
    toStringShort$0: function() {
      return this.get$runtimeType(this).toString$0(0) + "#" + Y.shortHash(this);
    },
    toString$0: function(_) {
      var t1 = this.toStringShort$0();
      return t1;
    },
    debugFillProperties$1: function(properties) {
    }
  };
  Y.DiagnosticableTree.prototype = {
    toStringShort$0: function() {
      return this.get$runtimeType(this).toString$0(0) + "#" + Y.shortHash(this);
    },
    debugDescribeChildren$0: function() {
      return C.List_empty;
    }
  };
  Y.DiagnosticableTreeMixin.prototype = {
    toString$0: function(_) {
      return this.toDiagnosticsNode$1$style(C.DiagnosticsTreeStyle_7).toString$1$minLevel(0, C.DiagnosticLevel_2);
    },
    toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines: function(minLevel, prefixLineOne, prefixOtherLines) {
      return this.toDiagnosticsNode$0().toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines(minLevel, prefixLineOne, prefixOtherLines);
    },
    toStringShort$0: function() {
      return this.get$runtimeType(this).toString$0(0) + "#" + Y.shortHash(this);
    },
    toDiagnosticsNode$2$name$style: function($name, style) {
      return new Y._DiagnosticableTreeNode(this, $name, true, true, null, style);
    },
    toDiagnosticsNode$1$style: function(style) {
      return this.toDiagnosticsNode$2$name$style(null, style);
    },
    toDiagnosticsNode$0: function() {
      return this.toDiagnosticsNode$2$name$style(null, null);
    },
    debugDescribeChildren$0: function() {
      return C.List_empty;
    },
    debugFillProperties$1: function(properties) {
    }
  };
  Y.DiagnosticsBlock.prototype = {
    getChildren$0: function() {
      return this._diagnostics$_children;
    },
    getProperties$0: function(_) {
      return this._properties;
    },
    toDescription$1$parentConfiguration: function(parentConfiguration) {
      return;
    },
    get$level: function() {
      return C.DiagnosticLevel_3;
    },
    get$allowTruncate: function() {
      return this.allowTruncate;
    }
  };
  Y._Diagnosticable_Object_DiagnosticableMixin.prototype = {};
  D.Key.prototype = {};
  D.LocalKey.prototype = {};
  F.LicenseEntry.prototype = {};
  F.LicenseEntryWithLineBreaks.prototype = {};
  B.AbstractNode.prototype = {
    redepthChild$1: function(child) {
      var t1, t2;
      H.interceptedTypeCheck(child, "$isAbstractNode");
      t1 = child._node$_depth;
      t2 = this._node$_depth;
      if (t1 <= t2) {
        child._node$_depth = t2 + 1;
        child.redepthChildren$0();
      }
    },
    redepthChildren$0: function() {
    },
    get$owner: function() {
      return this._node$_owner;
    },
    attach$1: function(owner) {
      this._node$_owner = owner;
    },
    detach$0: function(_) {
      this._node$_owner = null;
    },
    get$parent: function(_) {
      return this._node$_parent;
    },
    adoptChild$1: function(child) {
      var t1;
      child._node$_parent = this;
      t1 = this._node$_owner;
      if (t1 != null)
        child.attach$1(t1);
      this.redepthChild$1(child);
    },
    dropChild$1: function(child) {
      child._node$_parent = null;
      if (this._node$_owner != null)
        child.detach$0(0);
    }
  };
  R.ObserverList.prototype = {
    contains$1: function(_, element) {
      var t2, _this = this,
        t1 = _this._list;
      if (t1.length < 15)
        return C.JSArray_methods.contains$1(t1, element);
      if (_this._isDirty) {
        t2 = _this._set;
        if (t2 == null)
          _this.set$_set(P.HashSet_HashSet$from(t1, H.getTypeArgumentByIndex(_this, 0)));
        else {
          t2.clear$0(0);
          _this._set.addAll$1(0, t1);
        }
        _this._isDirty = false;
      }
      return _this._set.contains$1(0, element);
    },
    get$iterator: function(_) {
      var t1 = this._list;
      return new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    get$isEmpty: function(_) {
      return this._list.length === 0;
    },
    set$_set: function(_set) {
      this._set = H.assertSubtype(_set, "$isHashSet", this.$ti, "$asHashSet");
    }
  };
  T.TargetPlatform.prototype = {
    toString$0: function(_) {
      return this._platform$_name;
    }
  };
  D.GestureArenaMember.prototype = {};
  D._GestureArena.prototype = {};
  D.GestureArenaManager.prototype = {
    close$1: function(_, pointer) {
      this._arenas.$index(0, pointer);
      return;
    },
    sweep$1: function(pointer) {
      this._arenas.$index(0, pointer);
      return;
    }
  };
  N.GestureBinding.prototype = {
    _handlePointerDataPacket$1: function(packet) {
      this.GestureBinding__pendingPointerEvents.addAll$1(0, G.PointerEventConverter_expand(packet.data, $.$get$window()._devicePixelRatio));
      if (this._lockCount <= 0)
        this._flushPointerEventQueue$0();
    },
    _flushPointerEventQueue$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, hitTestResult, t8, t9, t10, _this = this;
      for (t1 = _this.GestureBinding__pendingPointerEvents, t2 = _this.GestureBinding__hitTests, t3 = [O.HitTestEntry]; !t1.get$isEmpty(t1);) {
        t4 = H.interceptedTypeCheck(t1.removeFirst$0(), "$isPointerEvent");
        t5 = J.getInterceptor$(t4);
        t6 = !!t5.$isPointerDownEvent;
        if (t6 || !!t5.$isPointerSignalEvent) {
          t7 = H.setRuntimeTypeInfo([], t3);
          hitTestResult = new O.HitTestResult(t7);
          t8 = t4.position;
          t9 = _this.RendererBinding__pipelineOwner._rootNode;
          t10 = t9.RenderObjectWithChildMixin__child;
          if (t10 != null)
            t10.hitTest$2$position(new S.BoxHitTestResult(t7), t8);
          C.JSArray_methods.add$1(t7, new O.HitTestEntry(t9));
          _this.super$GestureBinding$hitTest(hitTestResult, t8);
          if (t6)
            t2.$indexSet(0, t4.pointer, hitTestResult);
        } else if (!!t5.$isPointerUpEvent || !!t5.$isPointerCancelEvent)
          hitTestResult = t2.remove$1(0, t4.pointer);
        else
          hitTestResult = t4.down ? t2.$index(0, t4.pointer) : null;
        if (hitTestResult != null || !!t5.$isPointerHoverEvent || !!t5.$isPointerAddedEvent || !!t5.$isPointerRemovedEvent)
          _this.dispatchEvent$2(0, t4, hitTestResult);
      }
    },
    hitTest$2: function(result, position) {
      C.JSArray_methods.add$1(result._path, new O.HitTestEntry(this));
    },
    dispatchEvent$2: function(_, $event, hitTestResult) {
      var exception, stack, entry, exception0, stack0, t1, t2, t3, _i, t4, _null = null,
        _s15_ = "gesture library";
      if (hitTestResult == null) {
        try {
          this.GestureBinding_pointerRouter.route$1($event);
        } catch (exception0) {
          exception = H.unwrapException(exception0);
          stack = H.getTraceFromException(exception0);
          t1 = H.setRuntimeTypeInfo(["while dispatching a non-hit-tested pointer event"], [P.Object]);
          U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(N.FlutterErrorDetailsForPointerEventDispatcher$(new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), $event, exception, _null, new N.GestureBinding_dispatchEvent_closure($event), _s15_, stack));
        }
        return;
      }
      for (t1 = hitTestResult._path, t2 = t1.length, t3 = [P.Object], _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        entry = t1[_i];
        try {
          J.get$target$x(entry).handleEvent$2($event, entry);
        } catch (exception) {
          exception0 = H.unwrapException(exception);
          stack0 = H.getTraceFromException(exception);
          t4 = H.setRuntimeTypeInfo(["while dispatching a pointer event"], t3);
          U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(new N.FlutterErrorDetailsForPointerEventDispatcher(exception0, stack0, _s15_, new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t4, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), new N.GestureBinding_dispatchEvent_closure0($event, entry), false));
        }
      }
    },
    handleEvent$2: function($event, entry) {
      var _this = this;
      _this.GestureBinding_pointerRouter.route$1($event);
      if (!!$event.$isPointerDownEvent)
        _this.GestureBinding_gestureArena.close$1(0, $event.pointer);
      else if (!!$event.$isPointerUpEvent)
        _this.GestureBinding_gestureArena.sweep$1($event.pointer);
      else if (!!$event.$isPointerSignalEvent)
        _this.GestureBinding_pointerSignalResolver.resolve$1($event);
    }
  };
  N.GestureBinding_dispatchEvent_closure.prototype = {
    call$0: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError;
        return function $async$call$0($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return Y.DiagnosticsProperty$("Event", $async$self.event, true, C.C__NoDefaultValue, null, false, null, null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_8, null, F.PointerEvent);
              case 2:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, [Y.DiagnosticsProperty, F.PointerEvent]);
    },
    $signature: 35
  };
  N.GestureBinding_dispatchEvent_closure0.prototype = {
    call$0: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1;
        return function $async$call$0($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return Y.DiagnosticsProperty$("Event", $async$self.event, true, C.C__NoDefaultValue, null, false, null, null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_8, null, F.PointerEvent);
              case 2:
                // after yield
                t1 = $async$self.entry;
                $async$goto = 3;
                return Y.DiagnosticsProperty$("Target", t1.get$target(t1), true, C.C__NoDefaultValue, null, false, null, null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_8, null, O.HitTestTarget);
              case 3:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, [Y.DiagnosticsProperty, P.Object]);
    },
    $signature: 53
  };
  N.FlutterErrorDetailsForPointerEventDispatcher.prototype = {};
  G._PointerState.prototype = {
    toString$0: function(_) {
      return "_PointerState(pointer: " + H.S(this._pointer) + ", down: " + this._down + ", lastPosition: " + this.lastPosition.toString$0(0) + ")";
    }
  };
  G.PointerEventConverter__ensureStateForPointer_closure.prototype = {
    call$0: function() {
      return new G._PointerState(this.position);
    },
    $signature: 54
  };
  F.PointerEvent.prototype = {
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null,
        _s8_ = "obscured",
        _s11_ = "synthesized";
      _this.super$DiagnosticableMixin$debugFillProperties(properties);
      t1 = Q.Offset;
      t2 = Y.DiagnosticsProperty$("position", _this.position, true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("delta", _this.delta, true, C.Offset_0_0, _null, false, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_7, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("timeStamp", _this.timeStamp, true, C.Duration_0, _null, false, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_7, _null, P.Duration));
      C.JSArray_methods.add$1(t3, Y.IntProperty$("pointer", _this.pointer, C.C__NoDefaultValue, _null, C.DiagnosticLevel_2));
      C.JSArray_methods.add$1(t3, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, _this.kind, C.C__NoDefaultValue, C.DiagnosticLevel_2, "kind", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.PointerDeviceKind]));
      C.JSArray_methods.add$1(t3, Y.IntProperty$("device", _this.device, 0, _null, C.DiagnosticLevel_2));
      C.JSArray_methods.add$1(t3, Y.IntProperty$("buttons", _this.buttons, 0, _null, C.DiagnosticLevel_2));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("down", _this.down, true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_7, _null, P.bool));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("pressure", _this.pressure, 1, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("pressureMin", _this.pressureMin, 1, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("pressureMax", _this.pressureMax, 1, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("distance", _this.distance, 0, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("distanceMin", 0, 0, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("distanceMax", _this.distanceMax, 0, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("size", _this.size, 0, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("radiusMajor", _this.radiusMajor, 0, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("radiusMinor", _this.radiusMinor, 0, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("radiusMin", _this.radiusMin, 0, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("radiusMax", _this.radiusMax, 0, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("orientation", _this.orientation, 0, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("tilt", _this.tilt, 0, C.DiagnosticLevel_2, _null, _null));
      C.JSArray_methods.add$1(t3, Y.IntProperty$("platformData", _this.platformData, 0, _null, C.DiagnosticLevel_2));
      C.JSArray_methods.add$1(t3, new Y.FlagProperty(_s8_, _null, _null, false, true, _null, _null, _null, false, _this.obscured, _null, C.DiagnosticLevel_2, _s8_, true, false, _null, C.DiagnosticsTreeStyle_7));
      C.JSArray_methods.add$1(t3, new Y.FlagProperty(_s11_, _null, _null, false, true, _null, _null, _null, false, _this.synthesized, _null, C.DiagnosticLevel_2, _s11_, true, false, _null, C.DiagnosticsTreeStyle_7));
    }
  };
  F.PointerAddedEvent.prototype = {};
  F.PointerRemovedEvent.prototype = {};
  F.PointerHoverEvent.prototype = {};
  F.PointerDownEvent.prototype = {};
  F.PointerMoveEvent.prototype = {};
  F.PointerUpEvent.prototype = {};
  F.PointerSignalEvent.prototype = {};
  F.PointerScrollEvent.prototype = {
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$PointerEvent$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("scrollDelta", this.scrollDelta, true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, Q.Offset);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  F.PointerCancelEvent.prototype = {};
  O.HitTestTarget.prototype = {};
  O.HitTestEntry.prototype = {
    toString$0: function(_) {
      return this.get$target(this).toString$0(0);
    },
    get$target: function(receiver) {
      return this.target;
    }
  };
  O.HitTestResult.prototype = {
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  Y.MouseTrackerAnnotation.prototype = {};
  Y._TrackedAnnotation.prototype = {};
  Y.MouseTracker.prototype = {
    _scheduleMousePositionCheck$0: function() {
      var t2, _this = this,
        t1 = _this._trackedAnnotations;
      if (t1.get$isNotEmpty(t1) && !_this._postFrameCheckScheduled) {
        _this._postFrameCheckScheduled = true;
        t1 = $.SchedulerBinding__instance;
        t1.toString;
        t2 = H.functionTypeCheck(new Y.MouseTracker__scheduleMousePositionCheck_closure(_this), {func: 1, ret: -1, args: [P.Duration]});
        C.JSArray_methods.add$1(t1.SchedulerBinding__postFrameCallbacks, t2);
        $.SchedulerBinding__instance.scheduleFrame$0();
      }
    },
    _handleEvent$1: function($event) {
      var deviceId, t1, wasConnected, _this = this;
      H.interceptedTypeCheck($event, "$isPointerEvent");
      if ($event.kind !== C.PointerDeviceKind_1)
        return;
      deviceId = $event.device;
      t1 = J.getInterceptor$($event);
      if (!!t1.$isPointerAddedEvent) {
        _this._addMouseEvent$2(deviceId, $event);
        return;
      }
      if (!!t1.$isPointerRemovedEvent) {
        t1 = _this._lastMouseEvent;
        wasConnected = t1.get$isNotEmpty(t1);
        t1.remove$1(0, deviceId);
        if (t1.get$isNotEmpty(t1) !== wasConnected)
          _this.notifyListeners$0();
        _this._scheduleMousePositionCheck$0();
      } else if (!!t1.$isPointerMoveEvent || !!t1.$isPointerHoverEvent || !!t1.$isPointerDownEvent) {
        t1 = _this._lastMouseEvent;
        if (!t1.containsKey$1(0, deviceId) || !J.$eq$(t1.$index(0, deviceId).position, $event.position))
          _this._scheduleMousePositionCheck$0();
        _this._addMouseEvent$2(deviceId, $event);
      }
    },
    collectMousePositions$0: function() {
      var t2, t3, t4, t5, t6, hits, t7, hitAnnotations, t8, t9, t10, _this = this,
        exitAnnotation = new Y.MouseTracker_collectMousePositions_exitAnnotation(_this),
        t1 = _this._lastMouseEvent;
      if (!t1.get$isNotEmpty(t1)) {
        t1 = _this._trackedAnnotations;
        t1.get$values(t1).forEach$1(0, new Y.MouseTracker_collectMousePositions_exitAllDevices(exitAnnotation));
        return;
      }
      for (t2 = t1.get$keys(t1), t2 = t2.get$iterator(t2), t3 = _this._trackedAnnotations, t4 = Y._TrackedAnnotation, t5 = _this.annotationFinder; t2.moveNext$0();) {
        t6 = t2.get$current(t2);
        hits = t5.call$1(t1.$index(0, t6).position);
        t7 = J.getInterceptor$asx(hits);
        if (t7.get$isEmpty(hits)) {
          for (t7 = t3.get$values(t3), t7 = t7.get$iterator(t7); t7.moveNext$0();)
            exitAnnotation.call$2(t7.get$current(t7), t6);
          continue;
        }
        hitAnnotations = t7.map$1$1(hits, new Y.MouseTracker_collectMousePositions_closure(_this), t4).toSet$0(0);
        for (t7 = new P._LinkedHashSetIterator(hitAnnotations, hitAnnotations._collection$_modifications, [H.getTypeArgumentByIndex(hitAnnotations, 0)]), t7._collection$_cell = hitAnnotations._collection$_first; t7.moveNext$0();) {
          t8 = t7._collection$_current;
          if (!t8.get$activeDevices().contains$1(0, t6)) {
            t8.get$activeDevices().add$1(0, t6);
            t9 = t8.get$annotation();
            t9.get$onEnter(t9);
          }
          t8.get$annotation().get$onHover();
          for (t8 = t3.get$values(t3), t8 = t8.get$iterator(t8); t8.moveNext$0();) {
            t9 = t8.get$current(t8);
            if (hitAnnotations.contains$1(0, t9))
              continue;
            if (t9.get$activeDevices().contains$1(0, t6)) {
              t10 = t9.get$annotation();
              t10.get$onExit(t10);
              t9.get$activeDevices().remove$1(0, t6);
            }
          }
        }
      }
    },
    _addMouseEvent$2: function(deviceId, $event) {
      var t1 = this._lastMouseEvent,
        wasConnected = t1.get$isNotEmpty(t1);
      t1.$indexSet(0, deviceId, $event);
      if (t1.get$isNotEmpty(t1) !== wasConnected)
        this.notifyListeners$0();
    }
  };
  Y.MouseTracker__scheduleMousePositionCheck_closure.prototype = {
    call$1: function(_) {
      var t1;
      H.interceptedTypeCheck(_, "$isDuration");
      t1 = this.$this;
      t1._postFrameCheckScheduled = false;
      t1.collectMousePositions$0();
    },
    $signature: 36
  };
  Y.MouseTracker_collectMousePositions_exitAnnotation.prototype = {
    call$2: function(trackedAnnotation, deviceId) {
      var t1 = trackedAnnotation.get$annotation();
      t1.get$onExit(t1);
    },
    $signature: 57
  };
  Y.MouseTracker_collectMousePositions_exitAllDevices.prototype = {
    call$1: function(trackedAnnotation) {
      var t1, deviceIds, t2;
      H.interceptedTypeCheck(trackedAnnotation, "$is_TrackedAnnotation");
      t1 = trackedAnnotation.get$activeDevices();
      if (t1.get$isNotEmpty(t1)) {
        deviceIds = trackedAnnotation.get$activeDevices().toSet$0(0);
        for (t1 = deviceIds.get$iterator(deviceIds), t2 = this.exitAnnotation; t1.moveNext$0();)
          t2.call$2(trackedAnnotation, t1.get$current(t1));
      }
    },
    $signature: 58
  };
  Y.MouseTracker_collectMousePositions_closure.prototype = {
    call$1: function(hit) {
      return this.$this._trackedAnnotations.$index(0, H.interceptedTypeCheck(hit, "$isMouseTrackerAnnotation"));
    },
    $signature: 59
  };
  O.PointerRouter.prototype = {
    _dispatch$2: function($event, route) {
      var exception, stack, exception0, t1, _null = null;
      H.functionTypeCheck(route, {func: 1, ret: -1, args: [F.PointerEvent]});
      try {
        route.call$1($event);
      } catch (exception0) {
        exception = H.unwrapException(exception0);
        stack = H.getTraceFromException(exception0);
        t1 = H.setRuntimeTypeInfo(["while routing a pointer event"], [P.Object]);
        U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(new O.FlutterErrorDetailsForPointerRouter(exception, stack, "gesture library", new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), new O.PointerRouter__dispatch_closure($event), false));
      }
    },
    route$1: function($event) {
      var t1, globalRoutes, t2, _i, route;
      this._routeMap.$index(0, $event.pointer);
      t1 = this._globalRoutes;
      globalRoutes = P.List_List$from(t1, true, {func: 1, ret: -1, args: [F.PointerEvent]});
      for (t2 = globalRoutes.length, _i = 0; _i < globalRoutes.length; globalRoutes.length === t2 || (0, H.throwConcurrentModificationError)(globalRoutes), ++_i) {
        route = globalRoutes[_i];
        if (t1.contains$1(0, route))
          this._dispatch$2($event, route);
      }
    }
  };
  O.PointerRouter__dispatch_closure.prototype = {
    call$0: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError;
        return function $async$call$0($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return Y.DiagnosticsProperty$("Event", $async$self.event, true, C.C__NoDefaultValue, null, false, null, null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_8, null, F.PointerEvent);
              case 2:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, [Y.DiagnosticsProperty, F.PointerEvent]);
    },
    $signature: 35
  };
  O.FlutterErrorDetailsForPointerRouter.prototype = {};
  G.PointerSignalResolver.prototype = {
    resolve$1: function($event) {
      return;
    }
  };
  S.GestureRecognizer.prototype = {$isDiagnosticable: 1, $isDiagnosticableTree: 1};
  S._GestureRecognizer_GestureArenaMember_DiagnosticableTreeMixin.prototype = {};
  G.RenderComparison.prototype = {
    toString$0: function(_) {
      return this._basic_types$_name;
    }
  };
  N.PaintingBinding.prototype = {};
  Z.ClipContext.prototype = {};
  E.ImageCache.prototype = {};
  E._CachedImage.prototype = {};
  L.ImageStreamCompleter.prototype = {};
  T.TransformProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, t2, t3, rows, _this = this;
      if (parentConfiguration != null && !parentConfiguration.lineBreakProperties) {
        _this._maybeCacheValue$0();
        t1 = _this._value.getRow$1(0);
        _this._maybeCacheValue$0();
        t2 = _this._value.getRow$1(1);
        _this._maybeCacheValue$0();
        t3 = _this._value.getRow$1(2);
        _this._maybeCacheValue$0();
        rows = H.setRuntimeTypeInfo([t1, t2, t3, _this._value.getRow$1(3)], [E.Vector4]);
        t3 = P.String;
        t2 = H.getTypeArgumentByIndex(rows, 0);
        return "[" + new H.MappedListIterable(rows, H.functionTypeCheck(new T.TransformProperty_valueToString_closure(), {func: 1, ret: t3, args: [t2]}), [t2, t3]).join$1(0, "; ") + "]";
      }
      _this._maybeCacheValue$0();
      return C.JSArray_methods.join$1(T.debugDescribeTransform(_this._value), "\n");
    },
    $asDiagnosticsProperty: function() {
      return [E.Matrix4];
    }
  };
  T.TransformProperty_valueToString_closure.prototype = {
    call$1: function(v) {
      var t1 = H.interceptedTypeCheck(v, "$isVector4")._v4storage,
        t2 = P.String,
        t3 = H.getRuntimeTypeArgumentIntercepted(C.NativeFloat64List_methods, t1, "ListMixin", 0);
      return new H.MappedListIterable(t1, H.functionTypeCheck(new T.TransformProperty_valueToString__closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]).join$1(0, ",");
    },
    $signature: 60
  };
  T.TransformProperty_valueToString__closure.prototype = {
    call$1: function(c) {
      return J.toStringAsFixed$1$n(H.doubleTypeCheck(c), 1);
    },
    $signature: 61
  };
  U.TextWidthBasis.prototype = {
    toString$0: function(_) {
      return this._text_painter$_name;
    }
  };
  U.TextPainter.prototype = {
    set$text: function(_, value) {
      var t1, _this = this;
      if (_this._text.$eq(0, value))
        return;
      t1 = _this._text;
      J.$eq$(t1.style, value.style);
      _this._text = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    set$textAlign: function(_, value) {
      var _this = this;
      if (_this._text_painter$_textAlign === value)
        return;
      _this._text_painter$_textAlign = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    set$textDirection: function(value) {
      var _this = this;
      if (_this._text_painter$_textDirection == value)
        return;
      _this._text_painter$_textDirection = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    set$textScaleFactor: function(value) {
      var _this = this;
      if (_this._textScaleFactor === value)
        return;
      _this._textScaleFactor = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    set$ellipsis: function(value) {
      var _this = this;
      if (_this._text_painter$_ellipsis == value)
        return;
      _this._text_painter$_ellipsis = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    set$textWidthBasis: function(value) {
      var _this = this;
      if (_this._textWidthBasis === value)
        return;
      _this._textWidthBasis = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    layout$2$maxWidth$minWidth: function(maxWidth, minWidth) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, builder, newWidth, _this = this, _null = null;
      if (!_this._text_painter$_needsLayout && minWidth == _this._lastMinWidth && maxWidth == _this._lastMaxWidth)
        return;
      _this._text_painter$_needsLayout = false;
      t1 = _this._text_painter$_paragraph;
      if (t1 == null) {
        t1 = _this._text.style;
        if (t1 == null)
          t1 = _null;
        else {
          t2 = _this._text_painter$_textAlign;
          t3 = _this._text_painter$_textDirection;
          if (t3 == null)
            t3 = _null;
          t4 = _this._textScaleFactor;
          t5 = _this._text_painter$_maxLines;
          t6 = _this._text_painter$_ellipsis;
          t7 = _this._text_painter$_locale;
          t8 = t1.fontWeight;
          t9 = t1.fontStyle;
          t10 = t1.fontFamily;
          t1 = t1.height;
          t1 = Q.ParagraphStyle$(t6, t10, 14 * t4, t9, t8, t1, t7, t5, _null, t2, t3);
        }
        if (t1 == null) {
          t1 = _this._text_painter$_textAlign;
          t2 = _this._text_painter$_textDirection;
          if (t2 == null)
            t2 = _null;
          t3 = _this._text_painter$_maxLines;
          t2 = Q.ParagraphStyle$(_this._text_painter$_ellipsis, _null, _null, _null, _null, _null, _this._text_painter$_locale, t3, _null, t1, t2);
          t1 = t2;
        }
        builder = Q.ParagraphBuilder$(t1);
        _this._text.build$2$textScaleFactor(builder, _this._textScaleFactor);
        t1 = _this._text_painter$_paragraph = builder.build$0();
      }
      _this._lastMinWidth = minWidth;
      _this._lastMaxWidth = maxWidth;
      t1.layout$1(new Q.ParagraphConstraints(maxWidth));
      if (minWidth != maxWidth) {
        newWidth = C.JSNumber_methods.clamp$2(Math.ceil(_this._text_painter$_paragraph.get$maxIntrinsicWidth()), minWidth, maxWidth);
        t1 = _this._text_painter$_paragraph;
        if (newWidth !== Math.ceil(t1.get$width(t1)))
          _this._text_painter$_paragraph.layout$1(new Q.ParagraphConstraints(newWidth));
      }
    },
    layout$0: function() {
      return this.layout$2$maxWidth$minWidth(1 / 0, 0);
    }
  };
  Q.TextSpan.prototype = {
    build$2$textScaleFactor: function(builder, textScaleFactor) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, _i,
        t1 = this.style,
        hasStyle = t1 != null;
      if (hasStyle) {
        t2 = t1.color;
        t3 = t1.decoration;
        t4 = t1.decorationColor;
        t5 = t1.decorationStyle;
        t6 = t1.decorationThickness;
        t7 = t1.fontWeight;
        t8 = t1.fontStyle;
        t9 = t1.textBaseline;
        t10 = t1.fontFamily;
        t11 = t1.get$fontFamilyFallback();
        t12 = t1.letterSpacing;
        t13 = t1.wordSpacing;
        t14 = t1.height;
        t15 = t1.locale;
        t16 = t1.foreground;
        C.JSArray_methods.add$1(builder._ops, Q.TextStyle$(null, t2, t3, t4, t5, t6, t10, t11, null, t8, t7, t16, t14, t12, t15, t1.shadows, t9, t13));
      }
      t1 = builder._ops;
      C.JSArray_methods.add$1(t1, this.text);
      t2 = this.children;
      if (t2 != null)
        for (_i = 0; _i < 1; ++_i)
          t2[_i].build$2$textScaleFactor(builder, textScaleFactor);
      if (hasStyle)
        C.JSArray_methods.add$1(t1, $.$get$ParagraphBuilder__paragraphBuilderPop());
    },
    visitTextSpan$1: function(visitor) {
      var t1, _i;
      H.functionTypeCheck(visitor, {func: 1, ret: P.bool, args: [Q.TextSpan]});
      if (!H.boolConversionCheck(visitor.call$1(this)))
        return false;
      t1 = this.children;
      if (t1 != null)
        for (_i = 0; _i < 1; ++_i)
          if (!t1[_i].visitTextSpan$1(visitor))
            return false;
      return true;
    },
    getSpanForPosition$1: function(position) {
      var t1 = {};
      t1.offset = 0;
      t1.result = null;
      this.visitTextSpan$1(new Q.TextSpan_getSpanForPosition_closure(t1, position.offset, position.affinity));
      return t1.result;
    },
    toPlainText$0: function() {
      var t1,
        buffer = new P.StringBuffer("");
      this.visitTextSpan$1(new Q.TextSpan_toPlainText_closure(true, buffer));
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    compareTo$1: function(_, other) {
      var t1, candidate, result, t2, index, _this = this;
      if (_this === other)
        return C.RenderComparison_0;
      if (other.text === _this.text) {
        t1 = _this.children == null ? null : 1;
        t1 = t1 != (other.children == null ? null : 1) || _this.style == null !== (other.style == null);
      } else
        t1 = true;
      if (t1)
        return C.RenderComparison_3;
      t1 = _this.style;
      if (t1 != null) {
        candidate = t1.compareTo$1(0, other.style);
        result = candidate.index > 0 ? candidate : C.RenderComparison_0;
        if (result === C.RenderComparison_3)
          return result;
      } else
        result = C.RenderComparison_0;
      t1 = _this.children;
      if (t1 != null)
        for (t2 = other.children, index = 0; index < 1; ++index) {
          candidate = C.JSNull_methods.compareTo$1(t1[index], t2[index]);
          if (candidate.get$index(candidate).$gt(0, result.index))
            result = candidate;
          if (result === C.RenderComparison_3)
            return result;
        }
      return result;
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isTextSpan");
      if (other.text === _this.text)
        if (J.$eq$(other.style, _this.style))
          t1 = S.listEquals(other.children, _this.children, Q.TextSpan);
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return Q.hashValues(this.style, this.text, null, null, Q.hashList(this.children), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toStringShort$0: function() {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _null = null;
      this.super$DiagnosticableMixin$debugFillProperties(properties);
      properties.defaultDiagnosticsTreeStyle = C.DiagnosticsTreeStyle_5;
      t1 = this.style;
      t2 = t1 == null;
      if (!t2)
        t1.debugFillProperties$1(properties);
      t1 = Y.DiagnosticsProperty$("recognizer", _null, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, S.GestureRecognizer);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t1);
      C.JSArray_methods.add$1(t3, Y.StringProperty$("text", this.text, _null, true, false));
      t2;
    },
    debugDescribeChildren$0: function() {
      var t2, t3,
        t1 = this.children;
      if (t1 == null)
        return C.List_empty;
      t2 = Y.DiagnosticsNode;
      t3 = H.getTypeArgumentByIndex(t1, 0);
      return new H.MappedListIterable(t1, H.functionTypeCheck(new Q.TextSpan_debugDescribeChildren_closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]).toList$0(0);
    }
  };
  Q.TextSpan_getSpanForPosition_closure.prototype = {
    call$1: function(span) {
      var _this = this,
        t1 = _this._box_0,
        t2 = t1.offset,
        endOffset = t2 + span.text.length,
        t3 = _this.targetOffset;
      if (!(t3 === t2 && _this.affinity === C.TextAffinity_1))
        if (!(t3 > t2 && t3 < endOffset))
          t2 = t3 === endOffset && _this.affinity === C.TextAffinity_0;
        else
          t2 = true;
      else
        t2 = true;
      if (t2) {
        t1.result = span;
        return false;
      }
      t1.offset = endOffset;
      return true;
    },
    $signature: 21
  };
  Q.TextSpan_toPlainText_closure.prototype = {
    call$1: function(span) {
      this.buffer._contents += span.text;
      return true;
    },
    $signature: 21
  };
  Q.TextSpan_debugDescribeChildren_closure.prototype = {
    call$1: function(child) {
      H.interceptedTypeCheck(child, "$isTextSpan");
      if (child != null)
        return new Y._DiagnosticableTreeNode(child, null, true, true, null, null);
      else
        return Y.DiagnosticsNode_DiagnosticsNode$message("<null child>", true);
    },
    $signature: 63
  };
  A.TextStyle0.prototype = {
    get$fontFamilyFallback: function() {
      return this._text_style$_fontFamilyFallback;
    },
    merge$1: function(other) {
      var t1, t2, t3, t4, t5, _this = this;
      if (other == null)
        return _this;
      t1 = other.fontFamily;
      other.get$fontFamilyFallback();
      t2 = other.fontWeight;
      t3 = _this.color;
      t4 = _this.backgroundColor;
      if (t1 == null)
        t1 = _this.fontFamily;
      t5 = _this.get$fontFamilyFallback();
      if (t2 == null)
        t2 = _this.fontWeight;
      return A.TextStyle$0(_this.background, t4, t3, null, _this.decoration, _this.decorationColor, _this.decorationStyle, _this.decorationThickness, t1, t5, _this.fontSize, _this.fontStyle, t2, _this.foreground, _this.height, true, _this.letterSpacing, _this.locale, _this.shadows, _this.textBaseline, _this.wordSpacing);
    },
    compareTo$1: function(_, other) {
      var t1, _this = this;
      if (_this === other)
        return C.RenderComparison_0;
      if (_this.fontFamily == other.fontFamily)
        if (_this.fontWeight == other.fontWeight)
          t1 = !S.listEquals(_this.shadows, other.shadows, Q.Shadow) || !S.listEquals(_this.get$fontFamilyFallback(), other.get$fontFamilyFallback(), P.String);
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return C.RenderComparison_3;
      other.decorationThickness;
      return C.RenderComparison_0;
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isTextStyle0");
      if (_this.fontFamily == other.fontFamily)
        if (_this.fontWeight == other.fontWeight)
          t1 = S.listEquals(_this.shadows, other.shadows, Q.Shadow) && S.listEquals(_this.get$fontFamilyFallback(), other.get$fontFamilyFallback(), P.String);
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var _this = this;
      return Q.hashValues(true, _this.color, _this.backgroundColor, _this.fontFamily, _this.get$fontFamilyFallback(), _this.fontSize, _this.fontWeight, _this.fontStyle, _this.letterSpacing, _this.wordSpacing, _this.textBaseline, _this.height, _this.locale, _this.foreground, _this.background, _this.decoration, _this.decorationColor, _this.decorationStyle, _this.shadows, C.C__HashEnd);
    },
    toStringShort$0: function() {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    },
    debugFillProperties$1: function(properties) {
      var styles, t1, weightDescription, t2, t3, _this = this, _null = null;
      _this.super$DiagnosticableMixin$debugFillProperties(properties);
      styles = H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
      t1 = Q.Color;
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$("color", _this.color, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, t1));
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$("backgroundColor", _this.backgroundColor, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, t1));
      C.JSArray_methods.add$1(styles, Y.StringProperty$("family", _this.fontFamily, _null, false, true));
      C.JSArray_methods.add$1(styles, Y.IterableProperty$("familyFallback", _this.get$fontFamilyFallback(), _null, "[]", P.String));
      C.JSArray_methods.add$1(styles, Y.DoubleProperty$("size", _this.fontSize, _null, C.DiagnosticLevel_3, _null, _null));
      t1 = _this.fontWeight;
      weightDescription = t1 != null ? "" + (t1.index + 1) + "00" : _null;
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$("weight", t1, true, _null, weightDescription, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, Q.FontWeight));
      C.JSArray_methods.add$1(styles, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, _this.fontStyle, _null, C.DiagnosticLevel_3, "style", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.FontStyle]));
      C.JSArray_methods.add$1(styles, Y.DoubleProperty$("letterSpacing", _this.letterSpacing, _null, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(styles, Y.DoubleProperty$("wordSpacing", _this.wordSpacing, _null, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(styles, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, _this.textBaseline, _null, C.DiagnosticLevel_3, "baseline", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextBaseline]));
      C.JSArray_methods.add$1(styles, Y.DoubleProperty$("height", _this.height, _null, C.DiagnosticLevel_3, _null, "x"));
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$("locale", _this.locale, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, Q.Locale));
      t1 = Q.Paint;
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$("foreground", _this.foreground, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, t1));
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$("background", _this.background, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, t1));
      t1 = !C.JSArray_methods.any$1(styles, new A.TextStyle_debugFillProperties_closure());
      t2 = t1 && true ? C.DiagnosticLevel_1 : C.DiagnosticLevel_3;
      t2 = Y.DiagnosticsProperty$("inherit", true, true, C.C__NoDefaultValue, _null, false, _null, _null, t2, false, true, true, C.DiagnosticsTreeStyle_7, _null, P.bool);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.forEach$1(styles, properties.get$add(properties));
      if (t1)
        C.JSArray_methods.add$1(t3, new Y.FlagProperty("<all styles inherited>", "<no style specified>", _null, false, true, _null, _null, _null, false, true, _null, C.DiagnosticLevel_3, "inherit", true, false, _null, C.DiagnosticsTreeStyle_7));
    }
  };
  A.TextStyle_debugFillProperties_closure.prototype = {
    call$1: function(n) {
      H.interceptedTypeCheck(n, "$isDiagnosticsNode");
      return n.get$level(n).index >= 3;
    },
    $signature: 18
  };
  N.RendererBinding.prototype = {
    handleMetricsChanged$0: function() {
      this.RendererBinding__pipelineOwner._rootNode.set$configuration(this.createViewConfiguration$0());
      this.scheduleForcedFrame$0();
    },
    handleTextScaleFactorChanged$0: function() {
    },
    handlePlatformBrightnessChanged$0: function() {
    },
    createViewConfiguration$0: function() {
      var t2,
        t1 = $.$get$window(),
        devicePixelRatio = t1._devicePixelRatio;
      t1 = t1.get$physicalSize();
      t2 = t1._dx;
      if (typeof t2 !== "number")
        return t2.$div();
      t1 = t1._dy;
      if (typeof t1 !== "number")
        return t1.$div();
      return new A.ViewConfiguration(new Q.Size(t2 / devicePixelRatio, t1 / devicePixelRatio), devicePixelRatio);
    },
    _createMouseTracker$0: function() {
      var t1 = {func: 1, ret: -1};
      t1 = new Y.MouseTracker(new N.RendererBinding__createMouseTracker_closure(this), P.LinkedHashMap_LinkedHashMap$_empty(Y.MouseTrackerAnnotation, Y._TrackedAnnotation), P.LinkedHashMap_LinkedHashMap$_empty(P.int, F.PointerEvent), new R.ObserverList(H.setRuntimeTypeInfo([], [t1]), [t1]));
      this.GestureBinding_pointerRouter._globalRoutes.add$1(0, H.functionTypeCheck(t1.get$_handleEvent(), {func: 1, ret: -1, args: [F.PointerEvent]}));
      return t1;
    },
    _handleSemanticsEnabledChanged$0: function() {
      $.$get$window().toString;
      this.setSemanticsEnabled$1(T.EngineSemanticsOwner_instance()._semanticsEnabled);
    },
    setSemanticsEnabled$1: function(enabled) {
      var t1, t2, t3, t4, _this = this;
      if (enabled) {
        if (_this.RendererBinding__semanticsHandle == null) {
          t1 = _this.RendererBinding__pipelineOwner;
          if (++t1._outstandingSemanticsHandles === 1) {
            t2 = A.SemanticsNode;
            t3 = P.int;
            t4 = {func: 1, ret: -1};
            t1._semanticsOwner = new A.SemanticsOwner(P.LinkedHashSet_LinkedHashSet(t2), P.LinkedHashMap_LinkedHashMap$_empty(t3, t2), P.LinkedHashSet_LinkedHashSet(t2), P.LinkedHashMap_LinkedHashMap$_empty(t3, A.CustomSemanticsAction), new R.ObserverList(H.setRuntimeTypeInfo([], [t4]), [t4]));
            t1.onSemanticsOwnerCreated.call$0();
          }
          _this.RendererBinding__semanticsHandle = new K.SemanticsHandle(t1, null);
        }
      } else {
        t1 = _this.RendererBinding__semanticsHandle;
        if (t1 != null) {
          t2 = t1._object$_owner;
          if (t2 != null) {
            if (--t2._outstandingSemanticsHandles === 0) {
              t3 = t2._semanticsOwner;
              t3._semantics$_dirtyNodes.clear$0(0);
              t3._nodes.clear$0(0);
              t3._detachedNodes.clear$0(0);
              t3.super$ChangeNotifier$dispose();
              t2._semanticsOwner = null;
              t2.onSemanticsOwnerDisposed.call$0();
            }
            t1._object$_owner = null;
          }
        }
        _this.RendererBinding__semanticsHandle = null;
      }
    },
    _handleSemanticsAction$3: function(id, action, args) {
      var t1 = this.RendererBinding__pipelineOwner._semanticsOwner;
      if (t1 != null)
        t1.performAction$3(id, action, null);
    },
    _handleSemanticsOwnerCreated$0: function() {
      var t1 = this.RendererBinding__pipelineOwner._rootNode;
      H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner")._nodesNeedingSemantics.add$1(0, t1);
      H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner").onNeedVisualUpdate.call$0();
    },
    _handleSemanticsOwnerDisposed$0: function() {
      this.RendererBinding__pipelineOwner._rootNode.clearSemantics$0();
    },
    _handlePersistentFrameCallback$1: function(timeStamp) {
      H.interceptedTypeCheck(timeStamp, "$isDuration");
      this.drawFrame$0();
    },
    drawFrame$0: function() {
      var _this = this;
      _this.RendererBinding__pipelineOwner.flushLayout$0();
      _this.RendererBinding__pipelineOwner.flushCompositingBits$0();
      _this.RendererBinding__pipelineOwner.flushPaint$0();
      _this.RendererBinding__pipelineOwner._rootNode.compositeFrame$0();
      _this.RendererBinding__pipelineOwner.flushSemantics$0();
    }
  };
  N.RendererBinding__createMouseTracker_closure.prototype = {
    call$1: function(offset) {
      var t4,
        t1 = this.$this.RendererBinding__pipelineOwner._rootNode._layer,
        t2 = $.$get$window()._devicePixelRatio,
        t3 = offset._dx;
      if (typeof t3 !== "number")
        return t3.$mul();
      t4 = offset._dy;
      if (typeof t4 !== "number")
        return t4.$mul();
      return t1.findAll$1$1(new Q.Offset(t3 * t2, t4 * t2), Y.MouseTrackerAnnotation);
    },
    $signature: 66
  };
  S.BoxConstraints.prototype = {
    constrain$1: function(size) {
      var _this = this;
      return new Q.Size(J.clamp$2$n(size._dx, _this.minWidth, _this.maxWidth), J.clamp$2$n(size._dy, _this.minHeight, _this.maxHeight));
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isBoxConstraints");
      return _this.minWidth == other.minWidth && _this.maxWidth == other.maxWidth && _this.minHeight == other.minHeight && _this.maxHeight == other.maxHeight;
    },
    get$hashCode: function(_) {
      var _this = this;
      return Q.hashValues(_this.minWidth, _this.maxWidth, _this.minHeight, _this.maxHeight, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return this.super$Object$toString(0);
    }
  };
  S.BoxHitTestResult.prototype = {};
  S.BoxHitTestEntry.prototype = {
    get$target: function(_) {
      return H.interceptedTypeCheck(this.target, "$isRenderBox");
    },
    toString$0: function(_) {
      var t1 = this.super$HitTestEntry$toString(0);
      return t1;
    }
  };
  S.BoxParentData.prototype = {
    toString$0: function(_) {
      var t1 = this.super$ParentData$toString(0);
      return t1;
    }
  };
  S._IntrinsicDimensionsCacheEntry.prototype = {};
  S.RenderBox.prototype = {
    setupParentData$1: function(child) {
      if (!(child.parentData instanceof S.BoxParentData))
        child.parentData = new S.BoxParentData();
    },
    get$semanticBounds: function() {
      var t1 = this._size,
        t2 = t1._dx;
      t1 = t1._dy;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return new Q.Rect(0, 0, 0 + t2, 0 + t1);
    },
    get$constraints: function() {
      return K.RenderObject.prototype.get$constraints.call(this);
    },
    markNeedsLayout$0: function() {
      var _this = this,
        t1 = _this._cachedBaselines;
      if (!(t1 != null && t1.get$isNotEmpty(t1))) {
        t1 = _this._cachedIntrinsicDimensions;
        t1 = t1 != null && t1.get$isNotEmpty(t1);
      } else
        t1 = true;
      if (t1) {
        t1 = _this._cachedBaselines;
        if (t1 != null)
          t1.clear$0(0);
        t1 = _this._cachedIntrinsicDimensions;
        if (t1 != null)
          t1.clear$0(0);
        if (_this._node$_parent instanceof K.RenderObject) {
          _this.markParentNeedsLayout$0();
          return;
        }
      }
      _this.super$RenderObject$markNeedsLayout();
    },
    performResize$0: function() {
      var t1 = K.RenderObject.prototype.get$constraints.call(this);
      this._size = new Q.Size(C.JSInt_methods.clamp$2(0, t1.minWidth, t1.maxWidth), C.JSInt_methods.clamp$2(0, t1.minHeight, t1.maxHeight));
    },
    performLayout$0: function() {
    },
    hitTest$2$position: function(result, position) {
      var t2, t3, _this = this,
        t1 = _this._size;
      t1.toString;
      t2 = position._dx;
      if (typeof t2 !== "number")
        return t2.$ge();
      if (t2 >= 0) {
        t3 = t1._dx;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (t2 < t3) {
          t2 = position._dy;
          if (typeof t2 !== "number")
            return t2.$ge();
          if (t2 >= 0) {
            t1 = t1._dy;
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = t2 < t1;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      if (t1)
        if (_this.hitTestChildren$2$position(result, position) || _this.hitTestSelf$1(position)) {
          C.JSArray_methods.add$1(result._path, new S.BoxHitTestEntry(position, _this));
          return true;
        }
      return false;
    },
    hitTestSelf$1: function(position) {
      return false;
    },
    hitTestChildren$2$position: function(result, position) {
      return false;
    },
    applyPaintTransform$2: function(child, transform) {
      var tx, ty, tz, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17;
      H.interceptedTypeCheck(child.parentData, "$isBoxParentData").toString;
      transform.toString;
      if (typeof 0 === "number") {
        tx = 0;
        ty = 0;
        tz = 0;
      } else {
        tx = null;
        ty = null;
        tz = null;
      }
      t1 = transform._m4storage;
      t2 = t1[0];
      if (typeof tx !== "number")
        return H.iae(tx);
      t3 = t1[4];
      if (typeof ty !== "number")
        return H.iae(ty);
      t4 = t1[8];
      if (typeof tz !== "number")
        return H.iae(tz);
      t5 = t1[12];
      t6 = t1[1];
      t7 = t1[5];
      t8 = t1[9];
      t9 = t1[13];
      t10 = t1[2];
      t11 = t1[6];
      t12 = t1[10];
      t13 = t1[14];
      t14 = t1[3];
      t15 = t1[7];
      t16 = t1[11];
      t17 = t1[15];
      t1[12] = t2 * tx + t3 * ty + t4 * tz + t5;
      t1[13] = t6 * tx + t7 * ty + t8 * tz + t9;
      t1[14] = t10 * tx + t11 * ty + t12 * tz + t13;
      t1[15] = t14 * tx + t15 * ty + t16 * tz + t17;
    },
    get$paintBounds: function() {
      var t1 = this._size,
        t2 = t1._dx;
      t1 = t1._dy;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return new Q.Rect(0, 0, 0 + t2, 0 + t1);
    },
    handleEvent$2: function($event, entry) {
      this.super$RenderObject$handleEvent($event, H.interceptedTypeCheck(entry, "$isBoxHitTestEntry"));
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$RenderObject$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("size", this._size, true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, true, true, true, C.DiagnosticsTreeStyle_7, _null, Q.Size);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  V.RenderErrorBox.prototype = {
    RenderErrorBox$1: function(message) {
      var builder, t1, t2, exception,
        _s24_ = "\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n";
      try {
        t1 = this.message;
        if (t1 !== "") {
          builder = Q.ParagraphBuilder$($.$get$RenderErrorBox_paragraphStyle());
          t2 = $.$get$RenderErrorBox_textStyle();
          C.JSArray_methods.add$1(builder._ops, t2);
          t1 = H.S(t1) + _s24_ + H.S(t1) + _s24_ + H.S(t1) + _s24_ + H.S(t1) + _s24_ + H.S(t1) + _s24_ + H.S(t1) + _s24_ + H.S(t1) + _s24_ + H.S(t1) + _s24_ + H.S(t1) + _s24_ + H.S(t1) + _s24_ + H.S(t1) + _s24_ + H.S(t1);
          C.JSArray_methods.add$1(builder._ops, t1);
          this._paragraph = H.interceptedTypeCheck(builder.build$0(), "$isParagraph");
        }
      } catch (exception) {
        H.unwrapException(exception);
      }
    },
    get$sizedByParent: function() {
      return true;
    },
    hitTestSelf$1: function(position) {
      return true;
    },
    performResize$0: function() {
      this._size = K.RenderObject.prototype.get$constraints.call(this).constrain$1(C.Size_100000_100000);
    },
    paint$2: function(context, offset) {
      var width, parentBox, t1, t2, t3, t4, t5, t6, exception, _this = this;
      try {
        t1 = context.get$canvas(context);
        t2 = _this._size;
        t3 = offset._dx;
        t4 = offset._dy;
        t5 = t2._dx;
        t2 = t2._dy;
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (typeof t4 !== "number")
          return t4.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t6 = new Q.Paint(new Q.PaintData());
        t6.set$color(0, C.Color_4035969024);
        t1.drawRect$2(new Q.Rect(t3, t4, t3 + t5, t4 + t2), t6);
        width = null;
        t1 = _this._paragraph;
        if (t1 != null) {
          t2 = _this._node$_parent;
          if (t2 instanceof S.RenderBox) {
            parentBox = t2;
            width = parentBox._size._dx;
          } else
            width = _this._size._dx;
          t1.layout$1(new Q.ParagraphConstraints(width));
          context.get$canvas(context).drawParagraph$2(_this._paragraph, offset);
        }
      } catch (exception) {
        H.unwrapException(exception);
      }
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  T.Layer.prototype = {
    updateSubtreeNeedsAddToScene$0: function() {
      this._subtreeNeedsAddToScene = this._needsAddToScene || false;
    },
    remove$0: function(_) {
      var t2, t3, _this = this,
        t1 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(_this, _this), "$isContainerLayer");
      if (t1 != null) {
        t2 = _this._previousSibling;
        t3 = _this._nextSibling;
        if (t2 == null)
          t1._firstChild = t3;
        else
          t2._nextSibling = t3;
        t3 = _this._nextSibling;
        if (t3 == null)
          t1._lastChild = t2;
        else
          t3._previousSibling = t2;
        _this._nextSibling = _this._previousSibling = null;
        t1._needsAddToScene = true;
        t1.super$AbstractNode$dropChild(_this);
      }
    },
    _addToSceneWithRetainedRendering$1: function(builder) {
      var _this = this;
      if (!H.boolConversionCheck(_this._subtreeNeedsAddToScene) && _this._engineLayer != null) {
        builder.addRetained$1(_this._engineLayer);
        return;
      }
      _this.addToScene$1(builder);
      _this._needsAddToScene = false;
    },
    toStringShort$0: function() {
      var t1 = this.super$DiagnosticableTreeMixin$toStringShort();
      return t1 + (this._node$_owner == null ? " DETACHED" : "");
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$DiagnosticableTreeMixin$debugFillProperties(properties);
      t1 = _this._node$_owner;
      t2 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(_this, _this), "$isContainerLayer") != null ? C.DiagnosticLevel_0 : C.DiagnosticLevel_3;
      t2 = Y.DiagnosticsProperty$("owner", t1, true, _null, _null, false, _null, _null, t2, false, true, true, C.DiagnosticsTreeStyle_7, _null, P.Object);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, t2);
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("creator", _this.debugCreator, true, _null, _null, false, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_7, _null, _null));
    },
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1
  };
  T.PictureLayer.prototype = {
    addToScene$2: function(builder, layerOffset) {
      builder.addPicture$4$isComplexHint$willChangeHint(layerOffset, this._picture, false, false);
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Layer$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("paint bounds", this.canvasBounds, true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, Q.Rect);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    find$1$1: function(_, regionOffset) {
      return;
    },
    find$1: function($receiver, regionOffset) {
      return this.find$1$1($receiver, regionOffset, null);
    },
    findAll$1$1: function(regionOffset, $S) {
      return H.setRuntimeTypeInfo([], [$S]);
    }
  };
  T.ContainerLayer.prototype = {
    buildScene$1: function(builder) {
      this.updateSubtreeNeedsAddToScene$0();
      this.addToScene$1(builder);
      return builder.build$0();
    },
    updateSubtreeNeedsAddToScene$0: function() {
      var child, _this = this;
      _this.super$Layer$updateSubtreeNeedsAddToScene();
      child = _this._firstChild;
      for (; child != null;) {
        child.updateSubtreeNeedsAddToScene$0();
        _this._subtreeNeedsAddToScene = H.boolConversionCheck(_this._subtreeNeedsAddToScene) || H.boolConversionCheck(child._subtreeNeedsAddToScene);
        child = child._nextSibling;
      }
    },
    find$1$1: function(_, regionOffset) {
      var current = this._lastChild;
      for (; current != null;) {
        current.find$1(0, regionOffset);
        current = current._previousSibling;
      }
      return;
    },
    findAll$1$1: function(regionOffset, $S) {
      return this.findAll$body$ContainerLayer(regionOffset, $S, $S);
    },
    findAll$body$ContainerLayer: function($async$regionOffset, $async$$S, $async$type) {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var regionOffset = $async$regionOffset,
          $S = $async$$S;
        var $async$goto = 0, $async$handler = 2, $async$currentError, child;
        return function $async$findAll$1$1($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self._firstChild == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                child = $async$self._lastChild;
              case 3:
                // for condition
                // trivial condition
                $async$goto = 5;
                return P._IterationMarker_yieldStar(child.findAll$1$1(regionOffset, $S));
              case 5:
                // after yield
                if (child === $async$self._firstChild) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                child = child._previousSibling;
                // goto for condition
                $async$goto = 3;
                break;
              case 4:
                // after for
              case 1:
                // return
                return P._IterationMarker_endOfIteration();
              case 2:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, $async$type);
    },
    attach$1: function(owner) {
      var child;
      this.super$AbstractNode$attach(owner);
      child = this._firstChild;
      for (; child != null;) {
        child.attach$1(owner);
        child = child._nextSibling;
      }
    },
    detach$0: function(_) {
      var child;
      this.super$AbstractNode$detach(0);
      child = this._firstChild;
      for (; child != null;) {
        child.detach$0(0);
        child = child._nextSibling;
      }
    },
    append$1: function(_, child) {
      var t1, _this = this;
      _this._needsAddToScene = true;
      _this.super$AbstractNode$adoptChild(child);
      t1 = child._previousSibling = _this._lastChild;
      if (t1 != null)
        t1._nextSibling = child;
      _this._lastChild = child;
      if (_this._firstChild == null)
        _this._firstChild = child;
    },
    removeAllChildren$0: function() {
      var next, _this = this,
        child = _this._firstChild;
      for (; child != null; child = next) {
        next = child._nextSibling;
        child._nextSibling = child._previousSibling = null;
        _this._needsAddToScene = true;
        _this.super$AbstractNode$dropChild(child);
      }
      _this._lastChild = _this._firstChild = null;
    },
    addToScene$2: function(builder, layerOffset) {
      this.addChildrenToScene$2(builder, layerOffset);
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    addChildrenToScene$2: function(builder, childOffset) {
      var child = this._firstChild;
      for (; child != null;) {
        if (childOffset.$eq(0, C.Offset_0_0))
          child._addToSceneWithRetainedRendering$1(builder);
        else
          child.addToScene$2(builder, childOffset);
        child = child._nextSibling;
      }
    },
    addChildrenToScene$1: function(builder) {
      return this.addChildrenToScene$2(builder, C.Offset_0_0);
    },
    debugDescribeChildren$0: function() {
      var count, t1,
        children = H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]),
        child = this._firstChild;
      if (child == null)
        return children;
      for (count = 1; true;) {
        t1 = "child " + count;
        child.toString;
        C.JSArray_methods.add$1(children, new Y._DiagnosticableTreeNode(child, t1, true, true, null, null));
        if (child == this._lastChild)
          break;
        ++count;
        child = child._nextSibling;
      }
      return children;
    }
  };
  T.OffsetLayer.prototype = {
    set$offset: function(_, value) {
      if (!value.$eq(0, this._layer$_offset))
        this._needsAddToScene = true;
      this._layer$_offset = value;
    },
    find$1$1: function(_, regionOffset) {
      return this.super$ContainerLayer$find(0, regionOffset.$sub(0, this._layer$_offset));
    },
    find$1: function($receiver, regionOffset) {
      return this.find$1$1($receiver, regionOffset, null);
    },
    findAll$1$1: function(regionOffset, $S) {
      return this.super$ContainerLayer$findAll(regionOffset.$sub(0, this._layer$_offset), $S);
    },
    addToScene$2: function(builder, layerOffset) {
      var t4, _this = this,
        t1 = layerOffset._dx,
        t2 = _this._layer$_offset,
        t3 = t2._dx;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = layerOffset._dy;
      t2 = t2._dy;
      if (typeof t4 !== "number")
        return t4.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      _this._engineLayer = builder.pushOffset$3$oldLayer(t1 + t3, t4 + t2, _this._engineLayer);
      _this.addChildrenToScene$1(builder);
      builder.pop$0();
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Layer$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("offset", this._layer$_offset, true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, Q.Offset);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  T.TransformLayer.prototype = {
    addToScene$2: function(builder, layerOffset) {
      var t1, t2, t3, _this = this;
      _this._lastEffectiveTransform = _this._layer$_transform;
      t1 = _this._layer$_offset;
      t2 = t1._dx;
      t3 = layerOffset._dx;
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = t2 + t3;
      t1 = t1._dy;
      t2 = layerOffset._dy;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = t1 + t2;
      if (!new Q.Offset(t3, t2).$eq(0, C.Offset_0_0)) {
        t1 = E.Matrix4_Matrix4$translationValues0(t3, t2, 0);
        t1.multiply$1(0, _this._lastEffectiveTransform);
        _this._lastEffectiveTransform = t1;
      }
      _this._engineLayer = builder.pushTransform$2$oldLayer(_this._lastEffectiveTransform._m4storage, _this._engineLayer);
      _this.addChildrenToScene$1(builder);
      builder.pop$0();
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    _transformOffset$1: function(regionOffset) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, _this = this;
      if (_this._inverseDirty) {
        _this._invertedTransform = E.Matrix4_tryInvert(_this._layer$_transform);
        _this._inverseDirty = false;
      }
      if (_this._invertedTransform == null)
        return;
      t1 = new Float64Array(4);
      t1[3] = 1;
      t1[2] = 0;
      C.NativeFloat64List_methods.$indexSet(t1, 1, regionOffset._dy);
      C.NativeFloat64List_methods.$indexSet(t1, 0, regionOffset._dx);
      t2 = _this._invertedTransform._m4storage;
      t3 = t2[0];
      t4 = t1[0];
      t5 = t2[4];
      t6 = t1[1];
      t7 = t2[8];
      t8 = t1[2];
      t9 = t2[12];
      t10 = t1[3];
      t11 = t2[1];
      t12 = t2[5];
      t13 = t2[9];
      t14 = t2[13];
      t15 = t2[2];
      t16 = t2[6];
      t17 = t2[10];
      t18 = t2[14];
      t19 = t2[3];
      t20 = t2[7];
      t21 = t2[11];
      t2 = t2[15];
      t1[0] = t3 * t4 + t5 * t6 + t7 * t8 + t9 * t10;
      t1[1] = t11 * t4 + t12 * t6 + t13 * t8 + t14 * t10;
      t1[2] = t15 * t4 + t16 * t6 + t17 * t8 + t18 * t10;
      t1[3] = t19 * t4 + t20 * t6 + t21 * t8 + t2 * t10;
      return new Q.Offset(t1[0], t1[1]);
    },
    find$1$1: function(_, regionOffset) {
      var transformedOffset = this._transformOffset$1(regionOffset);
      return transformedOffset == null ? null : this.super$OffsetLayer$find(0, transformedOffset);
    },
    find$1: function($receiver, regionOffset) {
      return this.find$1$1($receiver, regionOffset, null);
    },
    findAll$1$1: function(regionOffset, $S) {
      return this.findAll$body$TransformLayer(regionOffset, $S, $S);
    },
    findAll$body$TransformLayer: function($async$regionOffset, $async$$S, $async$type) {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var regionOffset = $async$regionOffset,
          $S = $async$$S;
        var $async$goto = 0, $async$handler = 2, $async$currentError, transformedOffset;
        return function $async$findAll$1$1($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                transformedOffset = $async$self._transformOffset$1(regionOffset);
                if (transformedOffset == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 3;
                return P._IterationMarker_yieldStar($async$self.super$OffsetLayer$findAll(transformedOffset, $S));
              case 3:
                // after yield
              case 1:
                // return
                return P._IterationMarker_endOfIteration();
              case 2:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, $async$type);
    },
    debugFillProperties$1: function(properties) {
      var _null = null;
      this.super$OffsetLayer$debugFillProperties(properties);
      C.JSArray_methods.add$1(properties.properties, new T.TransformProperty(_null, false, true, _null, _null, _null, false, this._layer$_transform, C.C__NoDefaultValue, C.DiagnosticLevel_3, "transform", true, true, _null, C.DiagnosticsTreeStyle_7));
    }
  };
  T._Layer_AbstractNode_DiagnosticableTreeMixin.prototype = {};
  K.ParentData.prototype = {
    detach$0: function(_) {
    },
    toString$0: function(_) {
      return "<none>";
    }
  };
  K.PaintingContext.prototype = {
    paintChild$2: function(child, offset) {
      if (child.get$isRepaintBoundary()) {
        this.stopRecordingIfNeeded$0();
        if (child._needsPaint)
          K.PaintingContext__repaintCompositedChild(child, null, true);
        child._layer.set$offset(0, offset);
        this.appendLayer$1(child._layer);
      } else
        child._paintWithContext$2(this, offset);
    },
    appendLayer$1: function(layer) {
      layer.remove$0(0);
      this._containerLayer.append$1(0, layer);
    },
    get$canvas: function(_) {
      var t1, _this = this;
      if (_this._canvas == null) {
        _this._currentLayer = new T.PictureLayer(_this.estimatedBounds);
        t1 = Q.PictureRecorder_PictureRecorder();
        _this._recorder = t1;
        _this._canvas = Q.Canvas$(t1);
        _this._containerLayer.append$1(0, _this._currentLayer);
      }
      return _this._canvas;
    },
    stopRecordingIfNeeded$0: function() {
      var t1, t2, _this = this;
      if (_this._canvas == null)
        return;
      t1 = _this._currentLayer;
      t2 = _this._recorder.endRecording$0();
      t1._needsAddToScene = true;
      t1._picture = t2;
      _this._canvas = _this._recorder = _this._currentLayer = null;
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "#" + H.Primitives_objectHashCode(_this) + "(layer: " + H.S(_this._containerLayer) + ", canvas bounds: " + _this.estimatedBounds.toString$0(0) + ")";
    }
  };
  K.Constraints.prototype = {};
  K.SemanticsHandle.prototype = {
    dispose$0: function() {
      var t2,
        t1 = this._object$_owner;
      if (t1 != null) {
        if (--t1._outstandingSemanticsHandles === 0) {
          t2 = t1._semanticsOwner;
          t2._semantics$_dirtyNodes.clear$0(0);
          t2._nodes.clear$0(0);
          t2._detachedNodes.clear$0(0);
          t2.super$ChangeNotifier$dispose();
          t1._semanticsOwner = null;
          t1.onSemanticsOwnerDisposed.call$0();
        }
        this._object$_owner = null;
      }
    }
  };
  K.PipelineOwner.prototype = {
    set$rootNode: function(value) {
      var t1 = this._rootNode;
      if (t1 === value)
        return;
      if (t1 != null)
        t1.detach$0(0);
      this._rootNode = value;
      value.attach$1(this);
    },
    flushLayout$0: function() {
      var dirtyNodes, node, t1, t2, t3, t4, t5, _i;
      P.Timeline_startSync("Layout", C.Map_9aZ6I, null);
      try {
        for (t1 = [K.RenderObject]; t2 = this._nodesNeedingLayout, t2.length !== 0;) {
          dirtyNodes = t2;
          this.set$_nodesNeedingLayout(H.setRuntimeTypeInfo([], t1));
          t2 = dirtyNodes;
          t3 = H.getTypeArgumentByIndex(t2, 0);
          t4 = H.functionTypeCheck(new K.PipelineOwner_flushLayout_closure(), {func: 1, ret: P.int, args: [t3, t3]});
          if (typeof t2 !== "object" || t2 === null || !!t2.immutable$list)
            H.throwExpression(P.UnsupportedError$("sort"));
          t5 = J.get$length$asx(t2);
          if (typeof t5 !== "number")
            return t5.$sub();
          --t5;
          if (t5 - 0 <= 32)
            H.Sort__insertionSort(t2, 0, t5, t4, t3);
          else
            H.Sort__dualPivotQuicksort(t2, 0, t5, t4, t3);
          t3 = t2.length;
          _i = 0;
          for (; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
            node = t2[_i];
            if (node._needsLayout) {
              t4 = node;
              t4 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t4), "$isPipelineOwner") === this;
            } else
              t4 = false;
            if (t4)
              node._layoutWithoutResize$0();
          }
        }
      } finally {
        P.Timeline_finishSync();
      }
    },
    flushCompositingBits$0: function() {
      var t1, t2, _i, node;
      P.Timeline_startSync("Compositing bits", null, null);
      t1 = this._nodesNeedingCompositingBitsUpdate;
      C.JSArray_methods.sort$1(t1, new K.PipelineOwner_flushCompositingBits_closure());
      for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        node = t1[_i];
        if (node._needsCompositingBitsUpdate && H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(node), "$isPipelineOwner") === this)
          node._updateCompositingBits$0();
      }
      C.JSArray_methods.set$length(t1, 0);
      P.Timeline_finishSync();
    },
    flushPaint$0: function() {
      var dirtyNodes, node, t1, t2, _i, t3;
      P.Timeline_startSync("Paint", C.Map_9aZ6I, null);
      try {
        dirtyNodes = this._nodesNeedingPaint;
        this.set$_nodesNeedingPaint(H.setRuntimeTypeInfo([], [K.RenderObject]));
        for (t1 = dirtyNodes, J.sort$1$ax(t1, new K.PipelineOwner_flushPaint_closure()), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          node = t1[_i];
          if (node._needsPaint) {
            t3 = node;
            t3 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t3), "$isPipelineOwner") === this;
          } else
            t3 = false;
          if (t3)
            if (node._layer._node$_owner != null)
              K.PaintingContext__repaintCompositedChild(node, null, false);
            else
              node._skippedPaintingOnLayer$0();
        }
      } finally {
        P.Timeline_finishSync();
      }
    },
    flushSemantics$0: function() {
      var nodesToProcess, node, t1, nodesToProcess0, t2, _i, t3, _this = this;
      if (_this._semanticsOwner == null)
        return;
      P.Timeline_startSync("Semantics", null, null);
      try {
        t1 = _this._nodesNeedingSemantics;
        nodesToProcess0 = t1.toList$0(0);
        C.JSArray_methods.sort$1(nodesToProcess0, new K.PipelineOwner_flushSemantics_closure());
        nodesToProcess = nodesToProcess0;
        t1.clear$0(0);
        for (t1 = nodesToProcess, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          node = t1[_i];
          if (node._needsSemanticsUpdate) {
            t3 = node;
            t3 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t3), "$isPipelineOwner") === _this;
          } else
            t3 = false;
          if (t3)
            node._updateSemantics$0();
        }
        _this._semanticsOwner.sendSemanticsUpdate$0();
      } finally {
        P.Timeline_finishSync();
      }
    },
    set$_nodesNeedingLayout: function(_nodesNeedingLayout) {
      this._nodesNeedingLayout = H.assertSubtype(_nodesNeedingLayout, "$isList", [K.RenderObject], "$asList");
    },
    set$_nodesNeedingPaint: function(_nodesNeedingPaint) {
      this._nodesNeedingPaint = H.assertSubtype(_nodesNeedingPaint, "$isList", [K.RenderObject], "$asList");
    }
  };
  K.PipelineOwner_flushLayout_closure.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isRenderObject");
      H.interceptedTypeCheck(b, "$isRenderObject");
      return a._node$_depth - b._node$_depth;
    },
    $signature: 10
  };
  K.PipelineOwner_flushCompositingBits_closure.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isRenderObject");
      H.interceptedTypeCheck(b, "$isRenderObject");
      return a._node$_depth - b._node$_depth;
    },
    $signature: 10
  };
  K.PipelineOwner_flushPaint_closure.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isRenderObject");
      H.interceptedTypeCheck(b, "$isRenderObject");
      return b._node$_depth - a._node$_depth;
    },
    $signature: 10
  };
  K.PipelineOwner_flushSemantics_closure.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isRenderObject");
      H.interceptedTypeCheck(b, "$isRenderObject");
      return a._node$_depth - b._node$_depth;
    },
    $signature: 10
  };
  K.RenderObject.prototype = {
    setupParentData$1: function(child) {
      if (!(child.parentData instanceof K.ParentData))
        child.parentData = new K.ParentData();
    },
    adoptChild$1: function(child) {
      var _this = this;
      _this.setupParentData$1(child);
      _this.markNeedsLayout$0();
      _this.markNeedsCompositingBitsUpdate$0();
      _this.markNeedsSemanticsUpdate$0();
      _this.super$AbstractNode$adoptChild(child);
    },
    dropChild$1: function(child) {
      var _this = this;
      child._cleanRelayoutBoundary$0();
      child.parentData.toString;
      child.parentData = null;
      _this.super$AbstractNode$dropChild(child);
      _this.markNeedsLayout$0();
      _this.markNeedsCompositingBitsUpdate$0();
      _this.markNeedsSemanticsUpdate$0();
    },
    visitChildren$1: function(visitor) {
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
    },
    _debugReportException$3: function(method, exception, stack) {
      var t1, _null = null;
      H.interceptedTypeCheck(stack, "$isStackTrace");
      t1 = H.setRuntimeTypeInfo(["during " + method + "()"], [P.Object]);
      U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(new K.FlutterErrorDetailsForRendering(exception, stack, "rendering library", new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), new K.RenderObject__debugReportException_closure(this), false));
    },
    attach$1: function(owner) {
      var _this = this;
      _this.super$AbstractNode$attach(H.interceptedTypeCheck(owner, "$isPipelineOwner"));
      if (_this._needsLayout && _this._relayoutBoundary != null) {
        _this._needsLayout = false;
        _this.markNeedsLayout$0();
      }
      if (_this._needsCompositingBitsUpdate) {
        _this._needsCompositingBitsUpdate = false;
        _this.markNeedsCompositingBitsUpdate$0();
      }
      if (_this._needsPaint && _this._layer != null) {
        _this._needsPaint = false;
        _this.markNeedsPaint$0();
      }
      if (_this._needsSemanticsUpdate && _this.get$_semanticsConfiguration()._isSemanticBoundary) {
        _this._needsSemanticsUpdate = false;
        _this.markNeedsSemanticsUpdate$0();
      }
    },
    get$constraints: function() {
      return this._constraints;
    },
    markNeedsLayout$0: function() {
      var _this = this;
      if (_this._needsLayout)
        return;
      if (_this._relayoutBoundary !== _this)
        _this.markParentNeedsLayout$0();
      else {
        _this._needsLayout = true;
        if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner") != null) {
          C.JSArray_methods.add$1(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._nodesNeedingLayout, _this);
          H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner").onNeedVisualUpdate.call$0();
        }
      }
    },
    markParentNeedsLayout$0: function() {
      this._needsLayout = true;
      H.interceptedTypeCheck(this._node$_parent, "$isRenderObject").markNeedsLayout$0();
    },
    _cleanRelayoutBoundary$0: function() {
      var _this = this;
      if (_this._relayoutBoundary !== _this) {
        _this._relayoutBoundary = null;
        _this._needsLayout = true;
        _this.visitChildren$1(new K.RenderObject__cleanRelayoutBoundary_closure());
      }
    },
    _layoutWithoutResize$0: function() {
      var e, stack, exception, _this = this;
      try {
        _this.performLayout$0();
        _this.markNeedsSemanticsUpdate$0();
      } catch (exception) {
        e = H.unwrapException(exception);
        stack = H.getTraceFromException(exception);
        _this._debugReportException$3("performLayout", e, stack);
      }
      _this._needsLayout = false;
      _this.markNeedsPaint$0();
    },
    layout$2$parentUsesSize: function(constraints, parentUsesSize) {
      var e, stack, e0, stack0, t1, t2, relayoutBoundary, exception, _this = this;
      if (parentUsesSize)
        if (!_this.get$sizedByParent()) {
          t1 = constraints.minWidth;
          t2 = constraints.maxWidth;
          if (typeof t1 !== "number")
            return t1.$ge();
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (t1 >= t2) {
            t1 = constraints.minHeight;
            t2 = constraints.maxHeight;
            if (typeof t1 !== "number")
              return t1.$ge();
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 >= t2;
            t1 = t2;
          } else
            t1 = false;
          t1 = t1 || !(_this._node$_parent instanceof K.RenderObject);
        } else
          t1 = true;
      else
        t1 = true;
      relayoutBoundary = t1 ? _this : H.interceptedTypeCheck(_this._node$_parent, "$isRenderObject")._relayoutBoundary;
      if (!_this._needsLayout && J.$eq$(constraints, _this._constraints) && relayoutBoundary == _this._relayoutBoundary)
        return;
      _this._constraints = constraints;
      _this._relayoutBoundary = relayoutBoundary;
      if (_this.get$sizedByParent())
        try {
          _this.performResize$0();
        } catch (exception) {
          e = H.unwrapException(exception);
          stack = H.getTraceFromException(exception);
          _this._debugReportException$3("performResize", e, stack);
        }
      try {
        _this.performLayout$0();
        _this.markNeedsSemanticsUpdate$0();
      } catch (exception) {
        e0 = H.unwrapException(exception);
        stack0 = H.getTraceFromException(exception);
        _this._debugReportException$3("performLayout", e0, stack0);
      }
      _this._needsLayout = false;
      _this.markNeedsPaint$0();
    },
    layout$1: function(constraints) {
      return this.layout$2$parentUsesSize(constraints, false);
    },
    get$sizedByParent: function() {
      return false;
    },
    get$isRepaintBoundary: function() {
      return false;
    },
    markNeedsCompositingBitsUpdate$0: function() {
      var t1, _this = this;
      if (_this._needsCompositingBitsUpdate)
        return;
      _this._needsCompositingBitsUpdate = true;
      t1 = _this._node$_parent;
      if (t1 instanceof K.RenderObject) {
        if (t1._needsCompositingBitsUpdate)
          return;
        if (!_this.get$isRepaintBoundary() && !t1.get$isRepaintBoundary()) {
          t1.markNeedsCompositingBitsUpdate$0();
          return;
        }
      }
      if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner") != null)
        C.JSArray_methods.add$1(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._nodesNeedingCompositingBitsUpdate, _this);
    },
    _updateCompositingBits$0: function() {
      var oldNeedsCompositing, _this = this;
      if (!_this._needsCompositingBitsUpdate)
        return;
      oldNeedsCompositing = _this._needsCompositing;
      _this._needsCompositing = false;
      _this.visitChildren$1(new K.RenderObject__updateCompositingBits_closure(_this));
      if (_this.get$isRepaintBoundary() || false)
        _this._needsCompositing = true;
      if (oldNeedsCompositing != _this._needsCompositing)
        _this.markNeedsPaint$0();
      _this._needsCompositingBitsUpdate = false;
    },
    markNeedsPaint$0: function() {
      var t1, _this = this;
      if (_this._needsPaint)
        return;
      _this._needsPaint = true;
      if (_this.get$isRepaintBoundary()) {
        if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner") != null) {
          C.JSArray_methods.add$1(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._nodesNeedingPaint, _this);
          H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner").onNeedVisualUpdate.call$0();
        }
      } else {
        t1 = _this._node$_parent;
        if (t1 instanceof K.RenderObject)
          t1.markNeedsPaint$0();
        else if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner") != null)
          H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner").onNeedVisualUpdate.call$0();
      }
    },
    _skippedPaintingOnLayer$0: function() {
      var t1,
        ancestor = this._node$_parent;
      for (; ancestor instanceof K.RenderObject;) {
        if (ancestor.get$isRepaintBoundary()) {
          t1 = ancestor._layer;
          if (t1 == null)
            break;
          if (t1._node$_owner != null)
            break;
          ancestor._needsPaint = true;
        }
        ancestor = ancestor._node$_parent;
      }
    },
    _paintWithContext$2: function(context, offset) {
      var e, stack, exception, _this = this;
      if (_this._needsLayout)
        return;
      _this._needsPaint = false;
      try {
        _this.paint$2(context, offset);
      } catch (exception) {
        e = H.unwrapException(exception);
        stack = H.getTraceFromException(exception);
        _this._debugReportException$3("paint", e, stack);
      }
    },
    paint$2: function(context, offset) {
    },
    applyPaintTransform$2: function(child, transform) {
    },
    describeSemanticsConfiguration$1: function(config) {
    },
    get$_semanticsConfiguration: function() {
      var t1, _this = this;
      if (_this._cachedSemanticsConfiguration == null) {
        t1 = new A.SemanticsConfiguration(P.LinkedHashMap_LinkedHashMap$_empty(Q.SemanticsAction, {func: 1, ret: -1, args: [,]}), P.LinkedHashMap_LinkedHashMap$_empty(A.CustomSemanticsAction, {func: 1, ret: -1}));
        _this._cachedSemanticsConfiguration = t1;
        _this.describeSemanticsConfiguration$1(t1);
      }
      return _this._cachedSemanticsConfiguration;
    },
    clearSemantics$0: function() {
      this._needsSemanticsUpdate = true;
      this._semantics = null;
      this.visitChildren$1(new K.RenderObject_clearSemantics_closure());
    },
    markNeedsSemanticsUpdate$0: function() {
      var t1, wasSemanticsBoundary, isEffectiveSemanticsBoundary, t2, t3, t4, node, t5, _this = this;
      if (_this._node$_owner == null || H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._semanticsOwner == null)
        return _this._cachedSemanticsConfiguration = null;
      if (_this._semantics != null) {
        t1 = _this._cachedSemanticsConfiguration;
        wasSemanticsBoundary = (t1 == null ? null : t1._isSemanticBoundary) === true;
      } else
        wasSemanticsBoundary = false;
      _this._cachedSemanticsConfiguration = null;
      isEffectiveSemanticsBoundary = _this.get$_semanticsConfiguration()._isSemanticBoundary && wasSemanticsBoundary;
      t1 = Q.SemanticsAction;
      t2 = {func: 1, ret: -1, args: [,]};
      t3 = A.CustomSemanticsAction;
      t4 = {func: 1, ret: -1};
      node = _this;
      while (true) {
        if (!(!isEffectiveSemanticsBoundary && node._node$_parent instanceof K.RenderObject))
          break;
        if (node !== _this && node._needsSemanticsUpdate)
          break;
        node._needsSemanticsUpdate = true;
        node = H.interceptedTypeCheck(node._node$_parent, "$isRenderObject");
        if (node._cachedSemanticsConfiguration == null) {
          t5 = new A.SemanticsConfiguration(P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), P.LinkedHashMap_LinkedHashMap$_empty(t3, t4));
          node._cachedSemanticsConfiguration = t5;
          node.describeSemanticsConfiguration$1(t5);
        }
        isEffectiveSemanticsBoundary = node._cachedSemanticsConfiguration._isSemanticBoundary;
        if (isEffectiveSemanticsBoundary && node._semantics == null)
          return;
      }
      if (node !== _this && _this._semantics != null && _this._needsSemanticsUpdate)
        H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._nodesNeedingSemantics.remove$1(0, _this);
      if (!node._needsSemanticsUpdate) {
        node._needsSemanticsUpdate = true;
        if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner") != null) {
          H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._nodesNeedingSemantics.add$1(0, node);
          H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner").onNeedVisualUpdate.call$0();
        }
      }
    },
    _updateSemantics$0: function() {
      var t1, interestingFragment, t2, t3, t4, _this = this, _null = null;
      if (_this._needsLayout)
        return;
      t1 = _this._semantics;
      t1 = t1 == null ? _null : H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t1, t1), "$isSemanticsNode");
      if (t1 == null)
        t1 = _null;
      else
        t1 = t1._isMergedIntoParent;
      interestingFragment = H.interceptedTypeCheck(_this._getSemanticsForParent$1$mergeIntoParent(t1 === true), "$is_InterestingSemanticsFragment");
      t1 = _this._semantics;
      t2 = t1 == null;
      t3 = t2 ? _null : t1.parentSemanticsClipRect;
      t4 = t2 ? _null : t1.parentPaintClipRect;
      t1 = t2 ? _null : t1.elevationAdjustment;
      t1 = interestingFragment.compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect(t1 == null ? 0 : t1, t4, t3);
      t1.get$single(t1);
    },
    _getSemanticsForParent$1$mergeIntoParent: function(mergeIntoParent) {
      var producesForkingFragment, t1, t2, fragments, toBeMarkedExplicit, childrenMergeIntoParent, result, _this = this, _box_0 = {},
        config = _this.get$_semanticsConfiguration();
      config.isBlockingSemanticsOfPreviouslyPaintedNodes;
      _box_0.dropSemanticsOfPreviousSiblings = false;
      producesForkingFragment = !config._hasBeenAnnotated && !config._isSemanticBoundary;
      t1 = K._InterestingSemanticsFragment;
      t2 = [t1];
      fragments = H.setRuntimeTypeInfo([], t2);
      toBeMarkedExplicit = P.LinkedHashSet_LinkedHashSet$_empty(t1);
      if (!mergeIntoParent) {
        config._isMergingSemanticsOfDescendants;
        childrenMergeIntoParent = false;
      } else
        childrenMergeIntoParent = true;
      _box_0.abortWalk = false;
      _this.visitChildrenForSemantics$1(new K.RenderObject__getSemanticsForParent_closure(_box_0, _this, childrenMergeIntoParent, fragments, toBeMarkedExplicit, config, producesForkingFragment));
      if (_box_0.abortWalk)
        return new K._AbortingSemanticsFragment(H.setRuntimeTypeInfo([_this], [K.RenderObject]), false);
      for (t1 = P._LinkedHashSetIterator$(toBeMarkedExplicit, toBeMarkedExplicit._collection$_modifications, H.getTypeArgumentByIndex(toBeMarkedExplicit, 0)); t1.moveNext$0();)
        t1._collection$_current.markAsExplicit$0();
      _this._needsSemanticsUpdate = false;
      if (!(_this._node$_parent instanceof K.RenderObject)) {
        t1 = _box_0.dropSemanticsOfPreviousSiblings;
        result = new K._RootSemanticsFragment(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([_this], [K.RenderObject]), t1);
      } else {
        t1 = _box_0.dropSemanticsOfPreviousSiblings;
        if (producesForkingFragment)
          result = new K._ContainerSemanticsFragment(H.setRuntimeTypeInfo([], t2), t1);
        else {
          result = new K._SwitchableSemanticsFragment(mergeIntoParent, config, H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([_this], [K.RenderObject]), t1);
          if (config._isSemanticBoundary)
            result._isExplicit = true;
        }
      }
      result.addAll$1(0, fragments);
      return result;
    },
    visitChildrenForSemantics$1: function(visitor) {
      this.visitChildren$1(H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]}));
    },
    assembleSemanticsNode$3: function(node, config, children) {
      var t1 = A.SemanticsNode;
      node.updateWith$2$childrenInInversePaintOrder$config(0, H.assertSubtype(H.assertSubtype(children, "$isIterable", [t1], "$asIterable"), "$isList", [t1], "$asList"), config);
    },
    handleEvent$2: function($event, entry) {
    },
    toStringShort$0: function() {
      var target, count, _this = this,
        header = _this.get$runtimeType(_this).toString$0(0) + "#" + Y.shortHash(_this),
        t1 = _this._relayoutBoundary;
      if (t1 != null && t1 !== _this) {
        target = H.interceptedTypeCheck(_this._node$_parent, "$isRenderObject");
        count = 1;
        while (true) {
          if (!(target != null && target !== t1))
            break;
          target = H.interceptedTypeCheck(target._node$_parent, "$isRenderObject");
          ++count;
        }
        header += " relayoutBoundary=up" + count;
      }
      if (_this._needsLayout)
        header += " NEEDS-LAYOUT";
      if (_this._needsPaint)
        header += " NEEDS-PAINT";
      if (_this._needsCompositingBitsUpdate)
        header += " NEEDS-COMPOSITING-BITS-UPDATE";
      return _this._node$_owner == null ? header + " DETACHED" : header;
    },
    toString$0: function(_) {
      return this.toStringShort$0();
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$DiagnosticableTreeMixin$debugFillProperties(properties);
      t1 = _this._needsCompositing;
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, new Y.FlagProperty("needs compositing", _null, _null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, "needsCompositing", true, false, _null, C.DiagnosticsTreeStyle_7));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("creator", _this.debugCreator, true, _null, _null, false, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_7, _null, _null));
      t1 = _this.parentData;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("parentData", t1, true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, true, true, true, C.DiagnosticsTreeStyle_7, _null, K.ParentData));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("constraints", _this.get$constraints(), true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, true, true, true, C.DiagnosticsTreeStyle_7, _null, K.Constraints));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("layer", _this._layer, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, T.ContainerLayer));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("semantics node", _this._semantics, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, A.SemanticsNode));
      _this.get$_semanticsConfiguration().isBlockingSemanticsOfPreviouslyPaintedNodes;
      C.JSArray_methods.add$1(t2, new Y.FlagProperty("blocks semantics of earlier render objects below the common boundary", _null, _null, false, true, _null, _null, _null, false, false, _null, C.DiagnosticLevel_3, "isBlockingSemanticsOfPreviouslyPaintedNodes", true, false, _null, C.DiagnosticsTreeStyle_7));
      t1 = _this.get$_semanticsConfiguration()._isSemanticBoundary;
      C.JSArray_methods.add$1(t2, new Y.FlagProperty("semantic boundary", _null, _null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, "isSemanticBoundary", true, false, _null, C.DiagnosticsTreeStyle_7));
    },
    debugDescribeChildren$0: function() {
      return H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
    },
    showOnScreen$4$curve$descendant$duration$rect: function(curve, descendant, duration, rect) {
      var t1 = this._node$_parent;
      if (t1 instanceof K.RenderObject)
        t1.showOnScreen$4$curve$descendant$duration$rect(curve, descendant == null ? this : descendant, duration, rect);
    },
    showOnScreen$0: function() {
      return this.showOnScreen$4$curve$descendant$duration$rect(C.Cubic_JUR, null, C.Duration_0, null);
    },
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1,
    $isHitTestTarget: 1
  };
  K.RenderObject__debugReportException_closure.prototype = {
    call$0: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1;
        return function $async$call$0($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                $async$goto = 2;
                return new Y._DiagnosticableTreeNode(t1, "The following RenderObject was being processed when the exception was fired", true, true, null, C.DiagnosticsTreeStyle_9);
              case 2:
                // after yield
                $async$goto = 3;
                return new Y._DiagnosticableTreeNode(t1, "This RenderObject", true, true, null, C.DiagnosticsTreeStyle_10);
              case 3:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, Y.DiagnosticsNode);
    },
    $signature: 24
  };
  K.RenderObject__cleanRelayoutBoundary_closure.prototype = {
    call$1: function(child) {
      child._cleanRelayoutBoundary$0();
    },
    $signature: 11
  };
  K.RenderObject__updateCompositingBits_closure.prototype = {
    call$1: function(child) {
      child._updateCompositingBits$0();
      if (H.boolConversionCheck(child._needsCompositing))
        this.$this._needsCompositing = true;
    },
    $signature: 11
  };
  K.RenderObject_clearSemantics_closure.prototype = {
    call$1: function(child) {
      child.clearSemantics$0();
    },
    $signature: 11
  };
  K.RenderObject__getSemanticsForParent_closure.prototype = {
    call$1: function(renderChild) {
      var parentFragment, t2, t3, t4, t5, t6, t7, t8, t9, _i, siblingFragment, _this = this,
        t1 = _this._box_0;
      if (t1.abortWalk || _this.$this._needsLayout) {
        t1.abortWalk = true;
        return;
      }
      parentFragment = renderChild._getSemanticsForParent$1$mergeIntoParent(_this.childrenMergeIntoParent);
      if (parentFragment.get$abortsWalk()) {
        t1.abortWalk = true;
        return;
      }
      if (parentFragment.dropsSemanticsOfPreviousSiblings) {
        C.JSArray_methods.set$length(_this.fragments, 0);
        _this.toBeMarkedExplicit.clear$0(0);
        if (!_this.config._isSemanticBoundary)
          t1.dropSemanticsOfPreviousSiblings = true;
      }
      for (t1 = J.get$iterator$ax(parentFragment.get$interestingFragments()), t2 = _this.fragments, t3 = _this.toBeMarkedExplicit, t4 = _this.config, t5 = _this.$this, t6 = _this.producesForkingFragment; t1.moveNext$0();) {
        t7 = t1.get$current(t1);
        C.JSArray_methods.add$1(t2, t7);
        C.JSArray_methods.add$1(t7._ancestorChain, t5);
        t7.addTags$1(t4._tagsForChildren);
        if (t4.explicitChildNodes || !(t5._node$_parent instanceof K.RenderObject)) {
          t7.markAsExplicit$0();
          continue;
        }
        if (t7.get$config() == null || t6)
          continue;
        if (!t4.isCompatibleWith$1(t7.get$config()))
          t3.add$1(0, t7);
        for (t8 = C.JSArray_methods.sublist$2(t2, 0, t2.length - 1), t9 = t8.length, _i = 0; _i < t8.length; t8.length === t9 || (0, H.throwConcurrentModificationError)(t8), ++_i) {
          siblingFragment = t8[_i];
          if (!t7.get$config().isCompatibleWith$1(siblingFragment.get$config())) {
            t3.add$1(0, t7);
            t3.add$1(0, siblingFragment);
          }
        }
      }
    },
    $signature: 11
  };
  K.RenderObjectWithChildMixin.prototype = {
    set$child: function(value) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(_this, "RenderObjectWithChildMixin", 0));
      t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        _this.dropChild$1(t1);
      _this.set$_object$_child(value);
      t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        _this.adoptChild$1(t1);
    },
    redepthChildren$0: function() {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        this.redepthChild$1(t1);
    },
    visitChildren$1: function(visitor) {
      var t1;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        visitor.call$1(t1);
    },
    debugDescribeChildren$0: function() {
      var t1 = this.RenderObjectWithChildMixin__child,
        t2 = [Y.DiagnosticsNode];
      return t1 != null ? H.setRuntimeTypeInfo([new Y._DiagnosticableTreeNode(t1, "child", true, true, null, null)], t2) : H.setRuntimeTypeInfo([], t2);
    },
    set$_object$_child: function(_child) {
      this.RenderObjectWithChildMixin__child = H.assertSubtypeOfRuntimeType(_child, H.getRuntimeTypeArgument(this, "RenderObjectWithChildMixin", 0));
    }
  };
  K.FlutterErrorDetailsForRendering.prototype = {};
  K._SemanticsFragment.prototype = {
    get$abortsWalk: function() {
      return false;
    }
  };
  K._ContainerSemanticsFragment.prototype = {
    addAll$1: function(_, fragments) {
      C.JSArray_methods.addAll$1(this.interestingFragments, H.assertSubtype(fragments, "$isIterable", [K._InterestingSemanticsFragment], "$asIterable"));
    },
    get$interestingFragments: function() {
      return this.interestingFragments;
    }
  };
  K._InterestingSemanticsFragment.prototype = {
    get$interestingFragments: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError;
        return function $async$get$interestingFragments($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return $async$self;
              case 2:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, K._InterestingSemanticsFragment);
    },
    addTags$1: function(tags) {
      return;
    }
  };
  K._RootSemanticsFragment.prototype = {
    compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect: function($async$elevationAdjustment, $async$parentPaintClipRect, $async$parentSemanticsClipRect) {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var elevationAdjustment = $async$elevationAdjustment,
          parentPaintClipRect = $async$parentPaintClipRect,
          parentSemanticsClipRect = $async$parentSemanticsClipRect;
        var $async$goto = 0, $async$handler = 1, $async$currentError, t3, t4, t5, node, children, _i, t1, t2;
        return function $async$compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._ancestorChain;
                t2 = C.JSArray_methods.get$first(t1);
                if (t2._semantics == null) {
                  t3 = C.JSArray_methods.get$first(t1).get$showOnScreen();
                  t4 = C.JSArray_methods.get$first(t1);
                  t4 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t4), "$isPipelineOwner")._semanticsOwner;
                  t5 = $.$get$SemanticsNode__kEmptyConfig();
                  t5 = new A.SemanticsNode(0, t3, C.Rect_0_0_0_0, false, t5._actions, t5._customSemanticsActions, t5._actionsAsBits, t5._flags, t5._label, t5._semantics$_value, t5._decreasedValue, t5._increasedValue, t5._hint, t5._elevation, t5._thickness, t5._textDirection);
                  t5.attach$1(t4);
                  t2._semantics = t5;
                }
                node = C.JSArray_methods.get$first(t1)._semantics;
                node.set$rect(0, C.JSArray_methods.get$first(t1).get$semanticBounds());
                children = H.setRuntimeTypeInfo([], [A.SemanticsNode]);
                for (t1 = $async$self._object$_children, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
                  C.JSArray_methods.addAll$1(children, t1[_i].compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect(0, parentPaintClipRect, parentSemanticsClipRect));
                node.updateWith$2$childrenInInversePaintOrder$config(0, children, null);
                $async$goto = 2;
                return node;
              case 2:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, A.SemanticsNode);
    },
    get$config: function() {
      return;
    },
    markAsExplicit$0: function() {
    },
    addAll$1: function(_, fragments) {
      C.JSArray_methods.addAll$1(this._object$_children, H.assertSubtype(fragments, "$isIterable", [K._InterestingSemanticsFragment], "$asIterable"));
    }
  };
  K._SwitchableSemanticsFragment.prototype = {
    compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect: function($async$elevationAdjustment, $async$parentPaintClipRect, $async$parentSemanticsClipRect) {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var elevationAdjustment = $async$elevationAdjustment,
          parentPaintClipRect = $async$parentPaintClipRect,
          parentSemanticsClipRect = $async$parentSemanticsClipRect;
        var $async$goto = 0, $async$handler = 2, $async$currentError, t1, t2, t3, _i, fragment, geometry, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, node, children;
        return function $async$compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = !$async$self._isExplicit ? 3 : 4;
                break;
              case 3:
                // then
                t1 = $async$self._ancestorChain;
                C.JSArray_methods.get$first(t1)._semantics = null;
                t2 = $async$self._object$_children, t3 = t2.length, _i = 0;
              case 5:
                // for condition
                if (!(_i < t2.length)) {
                  // goto after for
                  $async$goto = 7;
                  break;
                }
                fragment = t2[_i];
                C.JSArray_methods.addAll$1(fragment._ancestorChain, C.JSArray_methods.sublist$1(t1, 1));
                $async$goto = 8;
                return P._IterationMarker_yieldStar(fragment.compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect(elevationAdjustment + $async$self._config._elevation, parentPaintClipRect, parentSemanticsClipRect));
              case 8:
                // after yield
              case 6:
                // for update
                t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i;
                // goto for condition
                $async$goto = 5;
                break;
              case 7:
                // after for
                // goto return
                $async$goto = 1;
                break;
              case 4:
                // join
                t1 = $async$self._ancestorChain;
                if (t1.length > 1) {
                  geometry = new K._SemanticsGeometry();
                  geometry._computeValues$3(parentSemanticsClipRect, parentPaintClipRect, t1);
                } else
                  geometry = null;
                t2 = $async$self._mergeIntoParent;
                t3 = !t2;
                if (t3) {
                  if (geometry == null)
                    t4 = null;
                  else {
                    t4 = geometry._rect;
                    t4 = t4.get$isEmpty(t4);
                  }
                  t4 = t4 === true;
                } else
                  t4 = false;
                if (t4) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t4 = C.JSArray_methods.get$first(t1);
                if (t4._semantics == null) {
                  t5 = C.JSArray_methods.get$first(t1).get$showOnScreen();
                  t6 = $.$get$SemanticsNode__kEmptyConfig();
                  t7 = t6._actions;
                  t8 = t6._customSemanticsActions;
                  t9 = t6._actionsAsBits;
                  t10 = t6._flags;
                  t11 = t6._label;
                  t12 = t6._semantics$_value;
                  t13 = t6._decreasedValue;
                  t14 = t6._increasedValue;
                  t15 = t6._hint;
                  t16 = t6._elevation;
                  t17 = t6._thickness;
                  t6 = t6._textDirection;
                  t18 = ($.SemanticsNode__lastIdentifier + 1) % 65535;
                  $.SemanticsNode__lastIdentifier = t18;
                  t4._semantics = new A.SemanticsNode(t18, t5, C.Rect_0_0_0_0, false, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t6);
                }
                node = C.JSArray_methods.get$first(t1)._semantics;
                node.set$isMergedIntoParent(t2);
                node.set$tags($async$self._object$_tagsForChildren);
                node.elevationAdjustment = elevationAdjustment;
                if (elevationAdjustment !== 0) {
                  $async$self._ensureConfigIsWritable$0();
                  t2 = $async$self._config;
                  t2.set$elevation(0, t2._elevation + elevationAdjustment);
                }
                if (geometry != null) {
                  node.set$rect(0, geometry._rect);
                  t2 = geometry._transform;
                  if (!T.MatrixUtils_matrixEquals(node._semantics$_transform, t2)) {
                    node._semantics$_transform = T.MatrixUtils_isIdentity(t2) ? null : t2;
                    node._markDirty$0();
                  }
                  node.parentSemanticsClipRect = geometry._semanticsClipRect;
                  node.parentPaintClipRect = geometry._paintClipRect;
                  if (t3 && geometry._markAsHidden) {
                    $async$self._ensureConfigIsWritable$0();
                    $async$self._config._setFlag$2(C.SemanticsFlag_8192, true);
                  }
                }
                children = H.setRuntimeTypeInfo([], [A.SemanticsNode]);
                for (t2 = $async$self._object$_children, t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
                  fragment = t2[_i];
                  t4 = node.parentSemanticsClipRect;
                  C.JSArray_methods.addAll$1(children, fragment.compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect(0, node.parentPaintClipRect, t4));
                }
                t2 = $async$self._config;
                if (t2._isSemanticBoundary)
                  C.JSArray_methods.get$first(t1).assembleSemanticsNode$3(node, $async$self._config, children);
                else
                  node.updateWith$2$childrenInInversePaintOrder$config(0, children, t2);
                $async$goto = 9;
                return node;
              case 9:
                // after yield
              case 1:
                // return
                return P._IterationMarker_endOfIteration();
              case 2:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, A.SemanticsNode);
    },
    get$config: function() {
      return this._isExplicit ? null : this._config;
    },
    addAll$1: function(_, fragments) {
      var t1, t2, _i, fragment, _this = this;
      H.assertSubtype(fragments, "$isIterable", [K._InterestingSemanticsFragment], "$asIterable");
      for (t1 = fragments.length, t2 = _this._object$_children, _i = 0; _i < fragments.length; fragments.length === t1 || (0, H.throwConcurrentModificationError)(fragments), ++_i) {
        fragment = fragments[_i];
        C.JSArray_methods.add$1(t2, fragment);
        if (fragment.get$config() == null)
          continue;
        if (!_this._isConfigWritable) {
          _this._config = _this._config.copy$0();
          _this._isConfigWritable = true;
        }
        _this._config.absorb$1(fragment.get$config());
      }
    },
    _ensureConfigIsWritable$0: function() {
      var _this = this;
      if (!_this._isConfigWritable) {
        _this._config = _this._config.copy$0();
        _this._isConfigWritable = true;
      }
    },
    markAsExplicit$0: function() {
      this._isExplicit = true;
    }
  };
  K._AbortingSemanticsFragment.prototype = {
    get$abortsWalk: function() {
      return true;
    },
    get$config: function() {
      return;
    },
    compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect: function($async$elevationAdjustment, $async$parentPaintClipRect, $async$parentSemanticsClipRect) {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var elevationAdjustment = $async$elevationAdjustment,
          parentPaintClipRect = $async$parentPaintClipRect,
          parentSemanticsClipRect = $async$parentSemanticsClipRect;
        var $async$goto = 0, $async$handler = 1, $async$currentError;
        return function $async$compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return C.JSArray_methods.get$first($async$self._ancestorChain)._semantics;
              case 2:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, A.SemanticsNode);
    },
    markAsExplicit$0: function() {
    }
  };
  K._SemanticsGeometry.prototype = {
    _computeValues$3: function(parentSemanticsClipRect, parentPaintClipRect, ancestors) {
      var t1, index, $parent, child, owner, t2, paintRect, _this = this;
      H.assertSubtype(ancestors, "$isList", [K.RenderObject], "$asList");
      t1 = new E.Matrix4(new Float64Array(16));
      t1.setIdentity$0();
      _this._transform = t1;
      _this._semanticsClipRect = parentSemanticsClipRect;
      _this._paintClipRect = parentPaintClipRect;
      for (index = ancestors.length - 1; index > 0;) {
        t1 = ancestors.length;
        if (index >= t1)
          return H.ioore(ancestors, index);
        $parent = ancestors[index];
        --index;
        if (index >= t1)
          return H.ioore(ancestors, index);
        child = ancestors[index];
        $parent.toString;
        t1 = K._SemanticsGeometry__intersectRects(_this._semanticsClipRect, null);
        _this._semanticsClipRect = t1;
        _this._semanticsClipRect = K._SemanticsGeometry__transformRect(t1, $parent, child);
        _this._paintClipRect = K._SemanticsGeometry__transformRect(_this._paintClipRect, $parent, child);
        $parent.applyPaintTransform$2(child, _this._transform);
      }
      owner = C.JSArray_methods.get$first(ancestors);
      t1 = _this._semanticsClipRect;
      t1 = t1 == null ? owner.get$semanticBounds() : t1.intersect$1(owner.get$semanticBounds());
      _this._rect = t1;
      t2 = _this._paintClipRect;
      if (t2 != null) {
        paintRect = t2.intersect$1(t1);
        if (paintRect.get$isEmpty(paintRect)) {
          t1 = _this._rect;
          t1 = !t1.get$isEmpty(t1);
        } else
          t1 = false;
        _this._markAsHidden = t1;
        if (!t1)
          _this._rect = paintRect;
      }
    }
  };
  K._RenderObject_AbstractNode_DiagnosticableTreeMixin.prototype = {};
  Q.TextOverflow.prototype = {
    toString$0: function(_) {
      return this._paragraph$_name;
    }
  };
  Q.RenderParagraph.prototype = {
    set$text: function(_, value) {
      var _this = this,
        t1 = _this._textPainter;
      switch (t1._text.compareTo$1(0, value)) {
        case C.RenderComparison_0:
        case C.RenderComparison_1:
          return;
        case C.RenderComparison_2:
          t1.set$text(0, value);
          _this.markNeedsPaint$0();
          _this.markNeedsSemanticsUpdate$0();
          break;
        case C.RenderComparison_3:
          t1.set$text(0, value);
          _this._overflowShader = null;
          _this.markNeedsLayout$0();
          break;
      }
    },
    set$textAlign: function(_, value) {
      var t1 = this._textPainter;
      if (t1._text_painter$_textAlign === value)
        return;
      t1.set$textAlign(0, value);
      this.markNeedsPaint$0();
    },
    set$textDirection: function(value) {
      var t1 = this._textPainter;
      if (t1._text_painter$_textDirection == value)
        return;
      t1.set$textDirection(value);
      this.markNeedsLayout$0();
    },
    set$softWrap: function(value) {
      return;
    },
    set$overflow: function(_, value) {
      var t1, _this = this;
      if (_this._overflow === value)
        return;
      _this._overflow = value;
      t1 = value === C.TextOverflow_2 ? "\u2026" : null;
      _this._textPainter.set$ellipsis(t1);
      _this.markNeedsLayout$0();
    },
    set$textScaleFactor: function(value) {
      var t1 = this._textPainter;
      if (t1._textScaleFactor === value)
        return;
      t1.set$textScaleFactor(value);
      this._overflowShader = null;
      this.markNeedsLayout$0();
    },
    set$maxLines: function(value) {
      return;
    },
    set$locale: function(_, value) {
      return;
    },
    set$strutStyle: function(value) {
      return;
    },
    set$textWidthBasis: function(value) {
      var t1 = this._textPainter;
      if (t1._textWidthBasis === value)
        return;
      t1.set$textWidthBasis(value);
      this._overflowShader = null;
      this.markNeedsLayout$0();
    },
    _layoutText$2$maxWidth$minWidth: function(maxWidth, minWidth) {
      this._textPainter.layout$2$maxWidth$minWidth(maxWidth, minWidth);
    },
    hitTestSelf$1: function(position) {
      return true;
    },
    handleEvent$2: function($event, entry) {
      var t1, t2, position;
      H.interceptedTypeCheck(entry, "$isBoxHitTestEntry");
      if (!$event.$isPointerDownEvent)
        return;
      t1 = K.RenderObject.prototype.get$constraints.call(this);
      t2 = t1.minWidth;
      this._layoutText$2$maxWidth$minWidth(t1.maxWidth, t2);
      t2 = this._textPainter;
      position = t2._text_painter$_paragraph.getPositionForOffset$1(entry.localPosition);
      t2._text.getSpanForPosition$1(position);
    },
    performLayout$0: function() {
      var t3, textDidExceedMaxLines, t4, t5, didOverflowHeight, didOverflowWidth, fadeSizePainter, fadeStart, fadeEnd, _this = this, _null = null,
        t1 = K.RenderObject.prototype.get$constraints.call(_this),
        t2 = t1.minWidth;
      _this._layoutText$2$maxWidth$minWidth(t1.maxWidth, t2);
      t2 = _this._textPainter;
      t1 = t2._text_painter$_paragraph;
      t1 = Math.ceil(t1.get$width(t1));
      t3 = t2._text_painter$_paragraph;
      t3 = Math.ceil(t3.get$height(t3));
      textDidExceedMaxLines = t2._text_painter$_paragraph._didExceedMaxLines;
      t4 = _this._size = K.RenderObject.prototype.get$constraints.call(_this).constrain$1(new Q.Size(t1, t3));
      t5 = t4._dy;
      if (typeof t5 !== "number")
        return t5.$lt();
      didOverflowHeight = t5 < t3 || textDidExceedMaxLines;
      t3 = t4._dx;
      if (typeof t3 !== "number")
        return t3.$lt();
      didOverflowWidth = t3 < t1;
      if (didOverflowWidth || didOverflowHeight)
        switch (_this._overflow) {
          case C.TextOverflow_3:
            _this._needsClipping = false;
            _this._overflowShader = null;
            break;
          case C.TextOverflow_0:
          case C.TextOverflow_2:
            _this._needsClipping = true;
            _this._overflowShader = null;
            break;
          case C.TextOverflow_1:
            _this._needsClipping = true;
            t1 = Q.TextSpan$(_null, t2._text.style, "\u2026");
            t3 = t2._text_painter$_textDirection;
            t4 = t2._textScaleFactor;
            fadeSizePainter = U.TextPainter$(_null, t2._text_painter$_locale, _null, _null, t1, C.TextAlign_4, t3, t4, C.TextWidthBasis_0);
            fadeSizePainter.layout$0();
            if (didOverflowWidth) {
              switch (t2._text_painter$_textDirection) {
                case C.TextDirection_0:
                  t1 = fadeSizePainter._text_painter$_paragraph;
                  fadeStart = Math.ceil(t1.get$width(t1));
                  fadeEnd = 0;
                  break;
                case C.TextDirection_1:
                  fadeEnd = _this._size._dx;
                  t1 = fadeSizePainter._text_painter$_paragraph;
                  t1 = Math.ceil(t1.get$width(t1));
                  if (typeof fadeEnd !== "number")
                    return fadeEnd.$sub();
                  fadeStart = fadeEnd - t1;
                  break;
                default:
                  fadeStart = _null;
                  fadeEnd = fadeStart;
              }
              _this._overflowShader = Q.Gradient_Gradient$linear(new Q.Offset(fadeStart, 0), new Q.Offset(fadeEnd, 0), H.setRuntimeTypeInfo([C.Color_4294967295, C.Color_16777215], [Q.Color]));
            } else {
              fadeEnd = _this._size._dy;
              t1 = fadeSizePainter._text_painter$_paragraph;
              t1 = Math.ceil(t1.get$height(t1));
              if (typeof fadeEnd !== "number")
                return fadeEnd.$sub();
              _this._overflowShader = Q.Gradient_Gradient$linear(new Q.Offset(0, fadeEnd - t1 / 2), new Q.Offset(0, fadeEnd), H.setRuntimeTypeInfo([C.Color_4294967295, C.Color_16777215], [Q.Color]));
            }
            break;
        }
      else {
        _this._needsClipping = false;
        _this._overflowShader = null;
      }
    },
    paint$2: function(context, offset) {
      var canvas, t3, t4, bounds, _this = this,
        t1 = K.RenderObject.prototype.get$constraints.call(_this),
        t2 = t1.minWidth;
      _this._layoutText$2$maxWidth$minWidth(t1.maxWidth, t2);
      canvas = context.get$canvas(context);
      if (_this._needsClipping) {
        t1 = _this._size;
        t2 = offset._dx;
        t3 = offset._dy;
        t4 = t1._dx;
        t1 = t1._dy;
        if (typeof t2 !== "number")
          return t2.$add();
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t1 !== "number")
          return H.iae(t1);
        bounds = new Q.Rect(t2, t3, t2 + t4, t3 + t1);
        if (_this._overflowShader != null)
          canvas.saveLayer$2(bounds, new Q.Paint(new Q.PaintData()));
        else
          canvas.save$0(0);
        canvas.clipRect$1(bounds);
      }
      canvas.drawParagraph$2(_this._textPainter._text_painter$_paragraph, offset);
      if (_this._needsClipping) {
        if (_this._overflowShader != null) {
          canvas.translate$2(0, offset._dx, offset._dy);
          t1 = new Q.PaintData();
          t1.blendMode = C.BlendMode_13;
          t2 = _this._overflowShader;
          t1.shader = t2;
          t2 = _this._size;
          t3 = t2._dx;
          t2 = t2._dy;
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (typeof t2 !== "number")
            return H.iae(t2);
          canvas.drawRect$2(new Q.Rect(0, 0, 0 + t3, 0 + t2), new Q.Paint(t1));
        }
        canvas.restore$0(0);
      }
    },
    describeSemanticsConfiguration$1: function(config) {
      var t2, t3, _this = this, t1 = {};
      _this.super$RenderObject$describeSemanticsConfiguration(config);
      t2 = _this._recognizerOffsets;
      C.JSArray_methods.set$length(t2, 0);
      C.JSArray_methods.set$length(_this._recognizers, 0);
      t1.offset = 0;
      t3 = _this._textPainter;
      t3._text.visitTextSpan$1(new Q.RenderParagraph_describeSemanticsConfiguration_closure(t1, _this));
      if (t2.length !== 0)
        config._isSemanticBoundary = config.explicitChildNodes = true;
      else {
        config._label = t3._text.toPlainText$0();
        config._hasBeenAnnotated = true;
        config._textDirection = t3._text_painter$_textDirection;
      }
    },
    assembleSemanticsNode$3: function(node, config, children) {
      var newChildren, rawLabel, buildSemanticsConfig, t2, current, i, j, t3, start, t4, end, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, node0, configuration, _this = this, _box_0 = {},
        t1 = A.SemanticsNode;
      H.assertSubtype(children, "$isIterable", [t1], "$asIterable");
      newChildren = H.setRuntimeTypeInfo([], [t1]);
      t1 = _this._textPainter;
      rawLabel = t1._text.toPlainText$0();
      _box_0.order = -1;
      _box_0.currentDirection = t1._text_painter$_textDirection;
      _box_0.currentRect = null;
      buildSemanticsConfig = new Q.RenderParagraph_assembleSemanticsNode_buildSemanticsConfig(_box_0, _this, rawLabel);
      for (t1 = _this._recognizerOffsets, t2 = _this._recognizers, current = 0, i = 0, j = 0; t3 = t1.length, i < t3; i += 2, ++j, current = end) {
        start = t1[i];
        t4 = i + 1;
        if (t4 >= t3)
          return H.ioore(t1, t4);
        end = t1[t4];
        if (current !== start) {
          t3 = $.$get$SemanticsNode__kEmptyConfig();
          t4 = t3._actions;
          t5 = t3._customSemanticsActions;
          t6 = t3._actionsAsBits;
          t7 = t3._flags;
          t8 = t3._label;
          t9 = t3._semantics$_value;
          t10 = t3._decreasedValue;
          t11 = t3._increasedValue;
          t12 = t3._hint;
          t13 = t3._elevation;
          t14 = t3._thickness;
          t3 = t3._textDirection;
          t15 = ($.SemanticsNode__lastIdentifier + 1) % 65535;
          $.SemanticsNode__lastIdentifier = t15;
          node0 = new A.SemanticsNode(t15, null, C.Rect_0_0_0_0, false, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t3);
          node0.updateWith$1$config(0, buildSemanticsConfig.call$2(current, start));
          t3 = _box_0.currentRect;
          if (!J.$eq$(node0._semantics$_rect, t3)) {
            node0._semantics$_rect = t3;
            node0._markDirty$0();
          }
          C.JSArray_methods.add$1(newChildren, node0);
        }
        t3 = $.$get$SemanticsNode__kEmptyConfig();
        t4 = t3._actions;
        t5 = t3._customSemanticsActions;
        t6 = t3._actionsAsBits;
        t7 = t3._flags;
        t8 = t3._label;
        t9 = t3._semantics$_value;
        t10 = t3._decreasedValue;
        t11 = t3._increasedValue;
        t12 = t3._hint;
        t13 = t3._elevation;
        t14 = t3._thickness;
        t3 = t3._textDirection;
        t15 = ($.SemanticsNode__lastIdentifier + 1) % 65535;
        $.SemanticsNode__lastIdentifier = t15;
        node0 = new A.SemanticsNode(t15, null, C.Rect_0_0_0_0, false, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t3);
        configuration = buildSemanticsConfig.call$2(start, end);
        if (j >= t2.length)
          return H.ioore(t2, j);
        node0.updateWith$1$config(0, configuration);
        t3 = _box_0.currentRect;
        if (!J.$eq$(node0._semantics$_rect, t3)) {
          node0._semantics$_rect = t3;
          node0._markDirty$0();
        }
        C.JSArray_methods.add$1(newChildren, node0);
      }
      t1 = rawLabel.length;
      if (current < t1) {
        t2 = $.$get$SemanticsNode__kEmptyConfig();
        t3 = t2._actions;
        t4 = t2._customSemanticsActions;
        t5 = t2._actionsAsBits;
        t6 = t2._flags;
        t7 = t2._label;
        t8 = t2._semantics$_value;
        t9 = t2._decreasedValue;
        t10 = t2._increasedValue;
        t11 = t2._hint;
        t12 = t2._elevation;
        t13 = t2._thickness;
        t2 = t2._textDirection;
        t14 = ($.SemanticsNode__lastIdentifier + 1) % 65535;
        $.SemanticsNode__lastIdentifier = t14;
        node0 = new A.SemanticsNode(t14, null, C.Rect_0_0_0_0, false, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t2);
        node0.updateWith$1$config(0, buildSemanticsConfig.call$2(current, t1));
        node0.set$rect(0, _box_0.currentRect);
        C.JSArray_methods.add$1(newChildren, node0);
      }
      node.updateWith$2$childrenInInversePaintOrder$config(0, newChildren, config);
    },
    debugDescribeChildren$0: function() {
      return H.setRuntimeTypeInfo([new Y._DiagnosticableTreeNode(this._textPainter._text, "text", true, true, null, C.DiagnosticsTreeStyle_3)], [Y.DiagnosticsNode]);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = this._textPainter;
      t2 = t1._text_painter$_textAlign;
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, t2, C.C__NoDefaultValue, C.DiagnosticLevel_3, "textAlign", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextAlign]));
      t2 = t1._text_painter$_textDirection;
      C.JSArray_methods.add$1(t3, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, t2, C.C__NoDefaultValue, C.DiagnosticLevel_3, "textDirection", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextDirection]));
      C.JSArray_methods.add$1(t3, new Y.FlagProperty("wrapping at box width", "no wrapping except at line break characters", _null, false, true, _null, _null, _null, false, true, _null, C.DiagnosticLevel_3, "softWrap", true, true, _null, C.DiagnosticsTreeStyle_7));
      t2 = this._overflow;
      C.JSArray_methods.add$1(t3, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, t2, C.C__NoDefaultValue, C.DiagnosticLevel_3, "overflow", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextOverflow]));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("textScaleFactor", t1._textScaleFactor, 1, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("locale", t1._text_painter$_locale, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, Q.Locale));
      C.JSArray_methods.add$1(t3, Y.IntProperty$("maxLines", t1._text_painter$_maxLines, C.C__NoDefaultValue, "unlimited", C.DiagnosticLevel_3));
    }
  };
  Q.RenderParagraph_describeSemanticsConfiguration_closure.prototype = {
    call$1: function(span) {
      var t1 = this._box_0;
      t1.offset = t1.offset + span.text.length;
      return true;
    },
    $signature: 21
  };
  Q.RenderParagraph_assembleSemanticsNode_buildSemanticsConfig.prototype = {
    call$2: function(start, end) {
      var rects, rect, _i, textBox,
        t1 = this._box_0,
        initialDirection = t1.currentDirection,
        selection = X.TextSelection$(start, end),
        t2 = this.$this,
        t3 = K.RenderObject.prototype.get$constraints.call(t2),
        t4 = t3.minWidth;
      t2._layoutText$2$maxWidth$minWidth(t3.maxWidth, t4);
      rects = t2._textPainter._text_painter$_paragraph._getBoxesForRange$4(selection.start, selection.end, 0, 0);
      for (t2 = rects.length, rect = null, _i = 0; _i < rects.length; rects.length === t2 || (0, H.throwConcurrentModificationError)(rects), ++_i) {
        textBox = rects[_i];
        if (rect == null)
          rect = new Q.Rect(textBox.left, textBox.top, textBox.right, textBox.bottom);
        rect = rect.expandToInclude$1(new Q.Rect(textBox.left, textBox.top, textBox.right, textBox.bottom));
        t1.currentDirection = textBox.direction;
      }
      t2 = rect.left;
      t2.toString;
      t2 = Math.floor(t2);
      t3 = rect.top;
      t3.toString;
      t1.currentRect = new Q.Rect(t2 - 4, Math.floor(t3) - 4, Math.ceil(rect.right) + 4, Math.ceil(rect.bottom) + 4);
      t3 = new A.SemanticsConfiguration(P.LinkedHashMap_LinkedHashMap$_empty(Q.SemanticsAction, {func: 1, ret: -1, args: [,]}), P.LinkedHashMap_LinkedHashMap$_empty(A.CustomSemanticsAction, {func: 1, ret: -1}));
      t3._sortKey = new A.OrdinalSortKey(++t1.order, null);
      t3._hasBeenAnnotated = true;
      t3._textDirection = initialDirection;
      t3._label = C.JSString_methods.substring$2(this.rawLabel, start, end);
      return t3;
    },
    $signature: 71
  };
  A.ViewConfiguration.prototype = {
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  A.RenderView.prototype = {
    set$configuration: function(value) {
      var t1, _this = this;
      if (_this._view$_configuration === value)
        return;
      _this._view$_configuration = value;
      t1 = _this._updateMatricesAndCreateNewRootLayer$0();
      _this._layer.detach$0(0);
      _this._layer = t1;
      _this.markNeedsPaint$0();
      _this.markNeedsLayout$0();
    },
    _updateMatricesAndCreateNewRootLayer$0: function() {
      var rootLayer,
        t1 = this._view$_configuration.devicePixelRatio,
        t2 = new Float64Array(16),
        t3 = new E.Matrix4(t2);
      t2[15] = 1;
      t2[10] = 1;
      t2[5] = t1;
      t2[0] = t1;
      this._rootTransform = t3;
      rootLayer = new T.TransformLayer(t3, C.Offset_0_0);
      rootLayer.attach$1(this);
      return rootLayer;
    },
    performResize$0: function() {
    },
    performLayout$0: function() {
      var t3,
        t1 = this._view$_size = this._view$_configuration.size,
        t2 = this.RenderObjectWithChildMixin__child;
      if (t2 != null) {
        t3 = t1._dx;
        t1 = t1._dy;
        t2.layout$1(new S.BoxConstraints(t3, t3, t1, t1));
      }
    },
    hitTest$2$position: function(result, position) {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.hitTest$2$position(new S.BoxHitTestResult(result._path), position);
      C.JSArray_methods.add$1(result._path, new O.HitTestEntry(this));
      return true;
    },
    get$isRepaintBoundary: function() {
      return true;
    },
    paint$2: function(context, offset) {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        context.paintChild$2(t1, offset);
    },
    applyPaintTransform$2: function(child, transform) {
      H.interceptedTypeCheck(child, "$isRenderBox");
      transform.multiply$1(0, this._rootTransform);
      this.super$RenderObject$applyPaintTransform(child, transform);
    },
    compositeFrame$0: function() {
      var builder, scene, bounds, t1, t2, t3, t4, t5, _this = this;
      P.Timeline_startSync("Compositing", C.Map_9aZ6I, null);
      try {
        builder = Q.SceneBuilder_SceneBuilder();
        scene = _this._layer.buildScene$1(builder);
        bounds = _this.get$paintBounds();
        t1 = bounds.get$center();
        t2 = _this._window;
        t3 = t2._devicePixelRatio;
        t4 = bounds.get$center();
        t5 = bounds.get$center()._dy;
        t2 = t2._devicePixelRatio;
        if (typeof t5 !== "number")
          return t5.$sub();
        _this._layer.find$1(0, new Q.Offset(t1._dx, 0 / t3));
        switch (T.defaultTargetPlatform()) {
          case C.TargetPlatform_0:
            _this._layer.find$1(0, new Q.Offset(t4._dx, t5 - 0 / t2));
            break;
          case C.TargetPlatform_2:
          case C.TargetPlatform_1:
            break;
        }
        t1 = H.interceptedTypeCheck(scene, "$isScene");
        $.$get$domRenderer().renderScene$1(t1.get$webOnlyRootElement());
        scene.dispose$0();
      } finally {
        P.Timeline_finishSync();
      }
    },
    get$paintBounds: function() {
      var t1 = this._view$_size,
        t2 = this._view$_configuration.devicePixelRatio,
        t3 = t1._dx;
      if (typeof t3 !== "number")
        return t3.$mul();
      t1 = t1._dy;
      if (typeof t1 !== "number")
        return t1.$mul();
      return new Q.Rect(0, 0, 0 + t3 * t2, 0 + t1 * t2);
    },
    get$semanticBounds: function() {
      var t1 = this._rootTransform,
        t2 = this._view$_size,
        t3 = t2._dx;
      t2 = t2._dy;
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return T.MatrixUtils_transformRect(t1, new Q.Rect(0, 0, 0 + t3, 0 + t2));
    },
    debugFillProperties$1: function(properties) {
      var _null = null,
        t1 = this._window,
        t2 = Y.DiagnosticsProperty$("window size", t1.get$physicalSize(), true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, "in physical pixels", Q.Size),
        t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("device pixel ratio", t1._devicePixelRatio, C.C__NoDefaultValue, C.DiagnosticLevel_3, "physical pixels per logical pixel", _null));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("configuration", this._view$_configuration, true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, "in logical pixels", A.ViewConfiguration));
      if (T.EngineSemanticsOwner_instance()._semanticsEnabled)
        C.JSArray_methods.add$1(t3, Y.DiagnosticsNode_DiagnosticsNode$message("semantics enabled", true));
    },
    $asRenderObjectWithChildMixin: function() {
      return [S.RenderBox];
    }
  };
  A._RenderView_RenderObject_RenderObjectWithChildMixin.prototype = {
    attach$1: function(owner) {
      var t1;
      H.interceptedTypeCheck(owner, "$isPipelineOwner");
      this.super$RenderObject$attach(owner);
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.attach$1(owner);
    },
    detach$0: function(_) {
      var t1;
      this.super$AbstractNode$detach(0);
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.detach$0(0);
    },
    set$_object$_child: function(_child) {
      this.RenderObjectWithChildMixin__child = H.assertSubtypeOfRuntimeType(_child, H.getRuntimeTypeArgument(this, "RenderObjectWithChildMixin", 0));
    }
  };
  N._TaskEntry.prototype = {};
  N._FrameCallbackEntry.prototype = {};
  N.SchedulerPhase.prototype = {
    toString$0: function(_) {
      return this._binding$_name;
    }
  };
  N.SchedulerBinding.prototype = {
    handleAppLifecycleStateChanged$1: function(state) {
      this.SchedulerBinding__lifecycleState = state;
      switch (state) {
        case C.AppLifecycleState_0:
        case C.AppLifecycleState_1:
          this._setFramesEnabledState$1(true);
          break;
        case C.AppLifecycleState_2:
        case C.AppLifecycleState_3:
          this._setFramesEnabledState$1(false);
          break;
      }
    },
    _handleLifecycleMessage$1: function(message) {
      return this._handleLifecycleMessage$body$SchedulerBinding(H.stringTypeCheck(message));
    },
    _handleLifecycleMessage$body$SchedulerBinding: function(message) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this;
      var $async$_handleLifecycleMessage$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.handleAppLifecycleStateChanged$1(N.SchedulerBinding__parseAppLifecycleMessage(message));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleLifecycleMessage$1, $async$completer);
    },
    _ensureEventLoopCallback$0: function() {
      if (this.SchedulerBinding__hasRequestedAnEventLoopCallback)
        return;
      this.SchedulerBinding__hasRequestedAnEventLoopCallback = true;
      P.Timer_Timer(C.Duration_0, this.get$_runTasks());
    },
    _runTasks$0: function() {
      this.SchedulerBinding__hasRequestedAnEventLoopCallback = false;
      if (this.handleEventLoopCallback$0())
        this._ensureEventLoopCallback$0();
    },
    handleEventLoopCallback$0: function() {
      var entry, exception, exceptionStack, t3, t4, newLength, last, exception0, _this = this, _null = null,
        _s15_ = "No such element",
        t1 = _this.SchedulerBinding__taskQueue,
        t2 = t1._length === 0;
      if (t2 || _this._lockCount > 0)
        return false;
      if (t2)
        H.throwExpression(P.StateError$(_s15_));
      t2 = t1._priority_queue$_queue;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      entry = t2[0];
      t2 = entry.priority;
      if (H.boolConversionCheck(_this.SchedulerBinding_schedulingStrategy.call$2$priority$scheduler(t2, _this))) {
        try {
          t2 = t1._length;
          if (t2 === 0)
            H.throwExpression(P.StateError$(_s15_));
          t3 = t1._priority_queue$_queue;
          t4 = t3.length;
          if (0 >= t4)
            return H.ioore(t3, 0);
          newLength = t2 - 1;
          if (newLength < 0 || newLength >= t4)
            return H.ioore(t3, newLength);
          last = t3[newLength];
          C.JSArray_methods.$indexSet(t3, newLength, _null);
          t1._length = newLength;
          if (newLength > 0)
            t1._bubbleDown$2(last, 0);
          entry.run$0();
        } catch (exception0) {
          exception = H.unwrapException(exception0);
          exceptionStack = H.getTraceFromException(exception0);
          t2 = H.setRuntimeTypeInfo(["during a task callback"], [P.Object]);
          U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(U.FlutterErrorDetails$(new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t2, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), exception, _null, "scheduler library", false, exceptionStack));
        }
        return t1._length !== 0;
      }
      return false;
    },
    get$endOfFrame: function() {
      var t1, _this = this;
      if (_this.SchedulerBinding__nextFrameCompleter == null) {
        if (_this.SchedulerBinding__schedulerPhase === C.SchedulerPhase_0)
          _this.scheduleFrame$0();
        t1 = -1;
        _this.set$_nextFrameCompleter(new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]));
        C.JSArray_methods.add$1(_this.SchedulerBinding__postFrameCallbacks, H.functionTypeCheck(new N.SchedulerBinding_endOfFrame_closure(_this), {func: 1, ret: -1, args: [P.Duration]}));
      }
      return _this.SchedulerBinding__nextFrameCompleter.future;
    },
    _setFramesEnabledState$1: function(enabled) {
      if (this.SchedulerBinding__framesEnabled === enabled)
        return;
      this.SchedulerBinding__framesEnabled = enabled;
      if (enabled)
        this.scheduleFrame$0();
    },
    ensureVisualUpdate$0: function() {
      switch (this.SchedulerBinding__schedulerPhase) {
        case C.SchedulerPhase_0:
        case C.SchedulerPhase_4:
          this.scheduleFrame$0();
          return;
        case C.SchedulerPhase_1:
        case C.SchedulerPhase_2:
        case C.SchedulerPhase_3:
          return;
      }
    },
    scheduleFrame$0: function() {
      if (this.SchedulerBinding__hasScheduledFrame || !this.SchedulerBinding__framesEnabled)
        return;
      $.$get$window().scheduleFrame$0();
      this.SchedulerBinding__hasScheduledFrame = true;
    },
    scheduleForcedFrame$0: function() {
      if (this.SchedulerBinding__hasScheduledFrame)
        return;
      $.$get$window().scheduleFrame$0();
      this.SchedulerBinding__hasScheduledFrame = true;
    },
    scheduleWarmUpFrame$0: function() {
      var hadScheduledFrame, _this = this;
      if (_this.SchedulerBinding__warmUpFrame || _this.SchedulerBinding__schedulerPhase !== C.SchedulerPhase_0)
        return;
      _this.SchedulerBinding__warmUpFrame = true;
      P.Timeline_startSync("Warm-up frame", null, null);
      hadScheduledFrame = _this.SchedulerBinding__hasScheduledFrame;
      P.Timer_Timer(C.Duration_0, new N.SchedulerBinding_scheduleWarmUpFrame_closure(_this));
      P.Timer_Timer(C.Duration_0, new N.SchedulerBinding_scheduleWarmUpFrame_closure0(_this, hadScheduledFrame));
      _this.lockEvents$1(new N.SchedulerBinding_scheduleWarmUpFrame_closure1(_this));
    },
    resetEpoch$0: function() {
      var _this = this;
      _this.SchedulerBinding__epochStart = _this._adjustForEpoch$1(_this.SchedulerBinding__lastRawTimeStamp);
      _this.SchedulerBinding__firstRawTimeStampInEpoch = null;
    },
    _adjustForEpoch$1: function(rawTimeStamp) {
      var t1 = this.SchedulerBinding__firstRawTimeStampInEpoch,
        rawDurationSinceEpoch = t1 == null ? C.Duration_0 : new P.Duration(rawTimeStamp._duration - t1._duration);
      t1 = $._timeDilation;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return P.Duration$(C.JSDouble_methods.round$0(rawDurationSinceEpoch._duration / t1) + this.SchedulerBinding__epochStart._duration, 0, 0);
    },
    _handleBeginFrame$1: function(rawTimeStamp) {
      if (this.SchedulerBinding__warmUpFrame) {
        this.SchedulerBinding__ignoreNextEngineDrawFrame = true;
        return;
      }
      this.handleBeginFrame$1(rawTimeStamp);
    },
    _handleDrawFrame$0: function() {
      if (this.SchedulerBinding__ignoreNextEngineDrawFrame) {
        this.SchedulerBinding__ignoreNextEngineDrawFrame = false;
        return;
      }
      this.handleDrawFrame$0();
    },
    handleBeginFrame$1: function(rawTimeStamp) {
      var callbacks, t1, _this = this;
      P.Timeline_startSync("Frame", C.Map_9aZ6I, null);
      if (_this.SchedulerBinding__firstRawTimeStampInEpoch == null)
        _this.SchedulerBinding__firstRawTimeStampInEpoch = rawTimeStamp;
      t1 = rawTimeStamp == null;
      _this.SchedulerBinding__currentFrameTimeStamp = _this._adjustForEpoch$1(t1 ? _this.SchedulerBinding__lastRawTimeStamp : rawTimeStamp);
      if (!t1)
        _this.SchedulerBinding__lastRawTimeStamp = rawTimeStamp;
      ++_this.SchedulerBinding__profileFrameNumber;
      t1 = _this.SchedulerBinding__profileFrameStopwatch;
      t1.reset$0(0);
      t1.start$0(0);
      _this.SchedulerBinding__hasScheduledFrame = false;
      try {
        P.Timeline_startSync("Animate", C.Map_9aZ6I, null);
        _this.SchedulerBinding__schedulerPhase = C.SchedulerPhase_1;
        callbacks = _this.SchedulerBinding__transientCallbacks;
        _this.set$_transientCallbacks(P.LinkedHashMap_LinkedHashMap$_empty(P.int, N._FrameCallbackEntry));
        J.forEach$1$ax(callbacks, new N.SchedulerBinding_handleBeginFrame_closure(_this));
        _this.SchedulerBinding__removedIds.clear$0(0);
      } finally {
        _this.SchedulerBinding__schedulerPhase = C.SchedulerPhase_2;
      }
    },
    handleDrawFrame$0: function() {
      var callback, localPostFrameCallbacks, callback0, t1, t2, _i, _this = this;
      P.Timeline_finishSync();
      try {
        _this.SchedulerBinding__schedulerPhase = C.SchedulerPhase_3;
        for (t1 = _this.SchedulerBinding__persistentCallbacks, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          callback = t1[_i];
          _this._invokeFrameCallback$2(callback, _this.SchedulerBinding__currentFrameTimeStamp);
        }
        _this.SchedulerBinding__schedulerPhase = C.SchedulerPhase_4;
        t1 = _this.SchedulerBinding__postFrameCallbacks;
        localPostFrameCallbacks = P.List_List$from(t1, true, {func: 1, ret: -1, args: [P.Duration]});
        C.JSArray_methods.set$length(t1, 0);
        for (t1 = localPostFrameCallbacks, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          callback0 = t1[_i];
          _this._invokeFrameCallback$2(callback0, _this.SchedulerBinding__currentFrameTimeStamp);
        }
      } finally {
        _this.SchedulerBinding__schedulerPhase = C.SchedulerPhase_0;
        P.Timeline_finishSync();
        t1 = _this.SchedulerBinding__profileFrameStopwatch;
        t1.stop$0(0);
        P.postEvent("Flutter.Frame", P.LinkedHashMap_LinkedHashMap$_literal(["number", _this.SchedulerBinding__profileFrameNumber, "startTime", _this.SchedulerBinding__currentFrameTimeStamp._duration, "elapsed", t1.get$elapsedMicroseconds()], P.String, null));
        _this.SchedulerBinding__currentFrameTimeStamp = null;
      }
    },
    _invokeFrameCallback$3: function(callback, timeStamp, callbackStack) {
      var exception, exceptionStack, exception0, t1, _null = null;
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.Duration]});
      try {
        callback.call$1(timeStamp);
      } catch (exception0) {
        exception = H.unwrapException(exception0);
        exceptionStack = H.getTraceFromException(exception0);
        t1 = H.setRuntimeTypeInfo(["during a scheduler callback"], [P.Object]);
        U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(U.FlutterErrorDetails$(new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), exception, _null, "scheduler library", false, exceptionStack));
      }
    },
    _invokeFrameCallback$2: function(callback, timeStamp) {
      return this._invokeFrameCallback$3(callback, timeStamp, null);
    },
    set$_transientCallbacks: function(_transientCallbacks) {
      this.SchedulerBinding__transientCallbacks = H.assertSubtype(_transientCallbacks, "$isMap", [P.int, N._FrameCallbackEntry], "$asMap");
    },
    set$_nextFrameCompleter: function(_nextFrameCompleter) {
      this.SchedulerBinding__nextFrameCompleter = H.assertSubtype(_nextFrameCompleter, "$isCompleter", [-1], "$asCompleter");
    }
  };
  N.SchedulerBinding_endOfFrame_closure.prototype = {
    call$1: function(timeStamp) {
      var t1;
      H.interceptedTypeCheck(timeStamp, "$isDuration");
      t1 = this.$this;
      t1.SchedulerBinding__nextFrameCompleter.complete$0(0);
      t1.set$_nextFrameCompleter(null);
    },
    $signature: 36
  };
  N.SchedulerBinding_scheduleWarmUpFrame_closure.prototype = {
    call$0: function() {
      this.$this.handleBeginFrame$1(null);
    },
    $signature: 0
  };
  N.SchedulerBinding_scheduleWarmUpFrame_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.handleDrawFrame$0();
      t1.resetEpoch$0();
      t1.SchedulerBinding__warmUpFrame = false;
      if (this.hadScheduledFrame)
        t1.scheduleFrame$0();
    },
    $signature: 0
  };
  N.SchedulerBinding_scheduleWarmUpFrame_closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait($async$self.$this.get$endOfFrame(), $async$call$0);
            case 2:
              // returning from await.
              P.Timeline_finishSync();
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 22
  };
  N.SchedulerBinding_handleBeginFrame_closure.prototype = {
    call$2: function(id, callbackEntry) {
      var t1;
      H.intTypeCheck(id);
      H.interceptedTypeCheck(callbackEntry, "$is_FrameCallbackEntry");
      t1 = this.$this;
      if (!t1.SchedulerBinding__removedIds.contains$1(0, id))
        t1._invokeFrameCallback$3(callbackEntry.get$callback(), t1.SchedulerBinding__currentFrameTimeStamp, callbackEntry.get$debugStack());
    },
    $signature: 74
  };
  N.SemanticsBinding.prototype = {
    handleAccessibilityFeaturesChanged$0: function() {
      this.SemanticsBinding__accessibilityFeatures = $.$get$window()._accessibilityFeatures;
    }
  };
  A.SemanticsTag.prototype = {};
  A.CustomSemanticsAction.prototype = {};
  A.SemanticsData.prototype = {
    toStringShort$0: function() {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, actionSummary, t4, t5, t6, description, customSemanticsActionSummary, flagSummary, _this = this, _null = null;
      _this.super$DiagnosticableMixin$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("rect", _this.rect, true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_7, _null, Q.Rect);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, new T.TransformProperty(_null, false, true, _null, _null, _null, false, _this.transform, _null, C.DiagnosticLevel_3, "transform", true, false, _null, C.DiagnosticsTreeStyle_7));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("elevation", _this.elevation, 0, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("thickness", _this.thickness, 0, C.DiagnosticLevel_3, _null, _null));
      t1 = P.String;
      t3 = [t1];
      actionSummary = H.setRuntimeTypeInfo([], t3);
      for (t4 = C.Map_EC0yd.get$values(C.Map_EC0yd), t4 = t4.get$iterator(t4), t5 = _this.actions; t4.moveNext$0();) {
        t6 = t4.get$current(t4);
        if ((t5 & t6.index) !== 0) {
          description = J.toString$0$(t6);
          C.JSArray_methods.add$1(actionSummary, C.JSString_methods.substring$1(description, J.getInterceptor$s(description).indexOf$1(description, ".") + 1));
        }
      }
      t4 = _this.customSemanticsActionIds;
      t5 = H.getTypeArgumentByIndex(t4, 0);
      customSemanticsActionSummary = new H.MappedListIterable(t4, H.functionTypeCheck(new A.SemanticsData_debugFillProperties_closure(), {func: 1, ret: t1, args: [t5]}), [t5, t1]).toList$0(0);
      C.JSArray_methods.add$1(t2, Y.IterableProperty$("actions", actionSummary, C.C__NoDefaultValue, _null, t1));
      C.JSArray_methods.add$1(t2, Y.IterableProperty$("customActions", customSemanticsActionSummary, C.C__NoDefaultValue, _null, t1));
      flagSummary = H.setRuntimeTypeInfo([], t3);
      for (t3 = C.Map_ek6Ds.get$values(C.Map_ek6Ds), t3 = t3.get$iterator(t3), t4 = _this.flags; t3.moveNext$0();) {
        t5 = t3.get$current(t3);
        if ((t4 & t5.index) !== 0) {
          description = J.toString$0$(t5);
          C.JSArray_methods.add$1(flagSummary, C.JSString_methods.substring$1(description, J.getInterceptor$s(description).indexOf$1(description, ".") + 1));
        }
      }
      C.JSArray_methods.add$1(t2, Y.IterableProperty$("flags", flagSummary, C.C__NoDefaultValue, _null, t1));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("label", _this.label, "", true, true));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("value", _this.value, "", true, true));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("increasedValue", _this.increasedValue, "", true, true));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("decreasedValue", _this.decreasedValue, "", true, true));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("hint", _this.hint, "", true, true));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, _this.textDirection, _null, C.DiagnosticLevel_3, "textDirection", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextDirection]));
      C.JSArray_methods.add$1(t2, Y.IntProperty$("platformViewId", _this.platformViewId, _null, _null, C.DiagnosticLevel_3));
      C.JSArray_methods.add$1(t2, Y.IntProperty$("scrollChildren", _this.scrollChildCount, _null, _null, C.DiagnosticLevel_3));
      C.JSArray_methods.add$1(t2, Y.IntProperty$("scrollIndex", _this.scrollIndex, _null, _null, C.DiagnosticLevel_3));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("scrollExtentMin", _this.scrollExtentMin, _null, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("scrollPosition", _this.scrollPosition, _null, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("scrollExtentMax", _this.scrollExtentMax, _null, C.DiagnosticLevel_3, _null, _null));
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (!(other instanceof A.SemanticsData))
        return false;
      if (other.flags === _this.flags)
        if (other.actions === _this.actions)
          if (other.label == _this.label)
            if (other.value == _this.value)
              if (other.increasedValue == _this.increasedValue)
                if (other.decreasedValue == _this.decreasedValue)
                  if (other.hint == _this.hint)
                    if (other.textDirection == _this.textDirection)
                      if (J.$eq$(other.rect, _this.rect))
                        if (S.setEquals(other.tags, _this.tags, A.SemanticsTag))
                          t1 = J.$eq$(other.transform, _this.transform) && other.elevation === _this.elevation && other.thickness === _this.thickness && A.SemanticsData__sortedListsEqual(other.customSemanticsActionIds, _this.customSemanticsActionIds);
                        else
                          t1 = false;
                      else
                        t1 = false;
                    else
                      t1 = false;
                  else
                    t1 = false;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var _this = this;
      return Q.hashValues(Q.hashValues(_this.flags, _this.actions, _this.label, _this.value, _this.increasedValue, _this.decreasedValue, _this.hint, _this.textDirection, _this.rect, _this.tags, _this.textSelection, _this.scrollChildCount, _this.scrollIndex, _this.scrollPosition, _this.scrollExtentMax, _this.scrollExtentMin, _this.platformViewId, _this.transform, _this.elevation, _this.thickness), Q.hashList(_this.customSemanticsActionIds), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    }
  };
  A.SemanticsData_debugFillProperties_closure.prototype = {
    call$1: function(actionId) {
      $.CustomSemanticsAction__actions.$index(0, H.intTypeCheck(actionId)).toString;
      return;
    },
    $signature: 16
  };
  A._SemanticsDiagnosticableNode.prototype = {
    getChildren$0: function() {
      var t1 = this.value.debugDescribeChildren$1$childOrder(this.childOrder);
      return t1;
    },
    $asDiagnosticableNode: function() {
      return [A.SemanticsNode];
    }
  };
  A.SemanticsNode.prototype = {
    set$rect: function(_, value) {
      if (!J.$eq$(this._semantics$_rect, value)) {
        this._semantics$_rect = value;
        this._markDirty$0();
      }
    },
    set$isMergedIntoParent: function(value) {
      if (this._isMergedIntoParent === value)
        return;
      this._isMergedIntoParent = value;
      this._markDirty$0();
    },
    _replaceChildren$1: function(newChildren) {
      var t1, t2, _i, sawChange, child, t3, i, t4, _this = this;
      H.assertSubtype(newChildren, "$isList", [A.SemanticsNode], "$asList");
      t1 = _this._semantics$_children;
      if (t1 != null)
        for (t2 = t1.length, _i = 0; _i < t2; ++_i)
          t1[_i]._dead = true;
      for (t1 = newChildren.length, _i = 0; _i < t1; ++_i)
        newChildren[_i]._dead = false;
      t1 = _this._semantics$_children;
      if (t1 != null)
        for (t2 = t1.length, sawChange = false, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          child = t1[_i];
          if (child._dead) {
            t3 = J.getInterceptor$x(child);
            if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t3, child), "$isSemanticsNode") === _this) {
              H.interceptedTypeCheck(child, "$isAbstractNode");
              child._node$_parent = null;
              if (_this._node$_owner != null)
                child.detach$0(0);
            }
            sawChange = true;
          }
        }
      else
        sawChange = false;
      for (t1 = newChildren.length, _i = 0; _i < newChildren.length; newChildren.length === t1 || (0, H.throwConcurrentModificationError)(newChildren), ++_i) {
        child = newChildren[_i];
        t2 = J.getInterceptor$x(child);
        if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t2, child), "$isSemanticsNode") !== _this) {
          if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t2, child), "$isSemanticsNode") != null) {
            t2 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t2, child), "$isSemanticsNode");
            if (t2 != null) {
              H.interceptedTypeCheck(child, "$isAbstractNode");
              child._node$_parent = null;
              if (t2._node$_owner != null)
                child.detach$0(0);
            }
          }
          H.interceptedTypeCheck(child, "$isAbstractNode");
          child._node$_parent = _this;
          t2 = _this._node$_owner;
          if (t2 != null)
            child.attach$1(t2);
          t2 = child._node$_depth;
          t3 = _this._node$_depth;
          if (t2 <= t3) {
            child._node$_depth = t3 + 1;
            child.redepthChildren$0();
          }
          sawChange = true;
        }
      }
      if (!sawChange && _this._semantics$_children != null)
        for (t1 = _this._semantics$_children, t2 = t1.length, t3 = newChildren.length, i = 0; i < t2; ++i) {
          t4 = t1[i].id;
          if (i >= t3)
            return H.ioore(newChildren, i);
          if (t4 !== newChildren[i].id) {
            sawChange = true;
            break;
          }
        }
      _this.set$_semantics$_children(0, newChildren);
      if (sawChange)
        _this._markDirty$0();
    },
    _visitDescendants$1: function(visitor) {
      var t1, t2, _i, child;
      H.functionTypeCheck(visitor, {func: 1, ret: P.bool, args: [A.SemanticsNode]});
      t1 = this._semantics$_children;
      if (t1 != null)
        for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          child = t1[_i];
          if (!H.boolConversionCheck(visitor.call$1(child)) || !child._visitDescendants$1(visitor))
            return false;
        }
      return true;
    },
    redepthChildren$0: function() {
      var t1 = this._semantics$_children;
      if (t1 != null)
        C.JSArray_methods.forEach$1(t1, this.get$redepthChild());
    },
    attach$1: function(owner) {
      var t1, t2, _i, _this = this;
      H.interceptedTypeCheck(owner, "$isSemanticsOwner");
      _this.super$AbstractNode$attach(owner);
      owner._nodes.$indexSet(0, _this.id, _this);
      owner._detachedNodes.remove$1(0, _this);
      if (_this._semantics$_dirty) {
        _this._semantics$_dirty = false;
        _this._markDirty$0();
      }
      t1 = _this._semantics$_children;
      if (t1 != null)
        for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          t1[_i].attach$1(owner);
    },
    detach$0: function(_) {
      var t1, t2, _i, child, t3, _this = this;
      H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner")._nodes.remove$1(0, _this.id);
      H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner")._detachedNodes.add$1(0, _this);
      _this.super$AbstractNode$detach(0);
      t1 = _this._semantics$_children;
      if (t1 != null)
        for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          child = t1[_i];
          t3 = J.getInterceptor$x(child);
          if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t3, child), "$isSemanticsNode") === _this)
            t3.detach$0(child);
        }
      _this._markDirty$0();
    },
    _markDirty$0: function() {
      var _this = this;
      if (_this._semantics$_dirty)
        return;
      _this._semantics$_dirty = true;
      if (_this._node$_owner != null)
        H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner")._semantics$_dirtyNodes.add$1(0, _this);
    },
    updateWith$2$childrenInInversePaintOrder$config: function(_, childrenInInversePaintOrder, config) {
      var t1, _this = this;
      H.assertSubtype(childrenInInversePaintOrder, "$isList", [A.SemanticsNode], "$asList");
      if (config == null)
        config = $.$get$SemanticsNode__kEmptyConfig();
      if (_this._label == config._label)
        if (_this._hint == config._hint)
          if (_this._elevation === config._elevation)
            if (_this._thickness === config._thickness)
              if (_this._decreasedValue == config._decreasedValue)
                if (_this._semantics$_value == config._semantics$_value)
                  if (_this._increasedValue == config._increasedValue)
                    if (_this._flags === config._flags)
                      if (_this._textDirection == config._textDirection)
                        if (_this._sortKey == config._sortKey)
                          if (_this._actionsAsBits === config._actionsAsBits) {
                            config._isMergingSemanticsOfDescendants;
                            t1 = false;
                          } else
                            t1 = true;
                        else
                          t1 = true;
                      else
                        t1 = true;
                    else
                      t1 = true;
                  else
                    t1 = true;
                else
                  t1 = true;
              else
                t1 = true;
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        _this._markDirty$0();
      _this._label = config._label;
      _this._decreasedValue = config._decreasedValue;
      _this._semantics$_value = config._semantics$_value;
      _this._increasedValue = config._increasedValue;
      _this._hint = config._hint;
      _this._hintOverrides = config._hintOverrides;
      _this._elevation = config._elevation;
      _this._thickness = config._thickness;
      _this._flags = config._flags;
      _this._textDirection = config._textDirection;
      _this._sortKey = config._sortKey;
      _this.set$_actions(P.LinkedHashMap_LinkedHashMap$from(config._actions, Q.SemanticsAction, {func: 1, ret: -1, args: [,]}));
      _this.set$_customSemanticsActions(P.LinkedHashMap_LinkedHashMap$from(config._customSemanticsActions, A.CustomSemanticsAction, {func: 1, ret: -1}));
      _this._actionsAsBits = config._actionsAsBits;
      _this._textSelection = config._textSelection;
      _this._scrollPosition = config._scrollPosition;
      _this._scrollExtentMax = config._scrollExtentMax;
      _this._scrollExtentMin = config._scrollExtentMin;
      config._isMergingSemanticsOfDescendants;
      _this._mergeAllDescendantsIntoThisNode = false;
      _this._scrollChildCount = config._scrollChildCount;
      _this._scrollIndex = config._scrollIndex;
      _this.indexInParent = config._indexInParent;
      _this._platformViewId = config._platformViewId;
      _this._isMultiline = (config._flags & 524288) !== 0;
      _this._replaceChildren$1(childrenInInversePaintOrder == null ? C.List_empty1 : childrenInInversePaintOrder);
    },
    updateWith$1$config: function($receiver, config) {
      return this.updateWith$2$childrenInInversePaintOrder$config($receiver, null, config);
    },
    getSemanticsData$0: function() {
      var t1, elevation, customSemanticsActionIds, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, _this = this, _box_0 = {};
      _box_0.flags = _this._flags;
      _box_0.actions = _this._actionsAsBits;
      _box_0.label = _this._label;
      _box_0.hint = _this._hint;
      _box_0.value = _this._semantics$_value;
      _box_0.increasedValue = _this._increasedValue;
      _box_0.decreasedValue = _this._decreasedValue;
      _box_0.textDirection = _this._textDirection;
      t1 = _this.tags;
      _box_0.mergedTags = t1 == null ? null : P.LinkedHashSet_LinkedHashSet$from(t1, A.SemanticsTag);
      _box_0.textSelection = _this._textSelection;
      _box_0.scrollChildCount = _this._scrollChildCount;
      _box_0.scrollIndex = _this._scrollIndex;
      _box_0.scrollPosition = _this._scrollPosition;
      _box_0.scrollExtentMax = _this._scrollExtentMax;
      _box_0.scrollExtentMin = _this._scrollExtentMin;
      _box_0.platformViewId = _this._platformViewId;
      elevation = _this._elevation;
      _box_0.thickness = _this._thickness;
      customSemanticsActionIds = P.LinkedHashSet_LinkedHashSet(P.int);
      for (t1 = _this._customSemanticsActions, t1 = t1.get$keys(t1), t1 = t1.get$iterator(t1); t1.moveNext$0();)
        customSemanticsActionIds.add$1(0, A.CustomSemanticsAction_getIdentifier(t1.get$current(t1)));
      _this._hintOverrides != null;
      t1 = _box_0.flags;
      t2 = _box_0.actions;
      t3 = _box_0.label;
      t4 = _box_0.value;
      t5 = _box_0.increasedValue;
      t6 = _box_0.decreasedValue;
      t7 = _box_0.hint;
      t8 = _box_0.textDirection;
      t9 = _this._semantics$_rect;
      t10 = _this._semantics$_transform;
      t11 = _box_0.thickness;
      t12 = _box_0.mergedTags;
      t13 = _box_0.textSelection;
      t14 = _box_0.scrollChildCount;
      t15 = _box_0.scrollIndex;
      t16 = _box_0.scrollPosition;
      t17 = _box_0.scrollExtentMax;
      t18 = _box_0.scrollExtentMin;
      t19 = _box_0.platformViewId;
      t20 = customSemanticsActionIds.toList$0(0);
      C.JSArray_methods.sort$0(t20);
      return new A.SemanticsData(t1, t2, t3, t4, t5, t6, t7, t8, t13, t14, t15, t16, t17, t18, t19, t9, t12, t10, elevation, t11, t20);
    },
    _addToUpdate$2: function(builder, customSemanticsActionIdsUpdate) {
      var data, t1, t2, childrenInTraversalOrder, childrenInHitTestOrder, childCount, sortedChildren, i, t3, customSemanticsActionIds, _this = this;
      H.assertSubtype(customSemanticsActionIdsUpdate, "$isSet", [P.int], "$asSet");
      data = _this.getSemanticsData$0();
      t1 = _this._semantics$_children;
      t2 = t1 == null ? null : t1.length !== 0;
      if (t2 !== true || false) {
        childrenInTraversalOrder = $.$get$SemanticsNode__kEmptyChildList();
        childrenInHitTestOrder = childrenInTraversalOrder;
      } else {
        childCount = t1.length;
        sortedChildren = _this._childrenInTraversalOrder$0();
        childrenInTraversalOrder = new Int32Array(childCount);
        for (t1 = sortedChildren.length, t2 = childrenInTraversalOrder.length, i = 0; i < childCount; ++i) {
          if (i >= t1)
            return H.ioore(sortedChildren, i);
          t3 = sortedChildren[i].id;
          if (i >= t2)
            return H.ioore(childrenInTraversalOrder, i);
          childrenInTraversalOrder[i] = t3;
        }
        childrenInHitTestOrder = new Int32Array(childCount);
        for (i = childCount - 1, t1 = _this._semantics$_children, t2 = childrenInHitTestOrder.length; i >= 0; --i) {
          t3 = childCount - i - 1;
          if (t3 < 0 || t3 >= t1.length)
            return H.ioore(t1, t3);
          t3 = t1[t3].id;
          if (i >= t2)
            return H.ioore(childrenInHitTestOrder, i);
          childrenInHitTestOrder[i] = t3;
        }
      }
      t1 = data.customSemanticsActionIds;
      t2 = t1.length;
      if (t2 !== 0) {
        customSemanticsActionIds = new Int32Array(t2);
        for (i = 0; i < t1.length; ++i) {
          C.NativeInt32List_methods.$indexSet(customSemanticsActionIds, i, t1[i]);
          if (i >= t1.length)
            return H.ioore(t1, i);
          customSemanticsActionIdsUpdate.add$1(0, t1[i]);
        }
      } else
        customSemanticsActionIds = null;
      t1 = data.transform;
      t1 = t1 == null ? null : t1._m4storage;
      if (t1 == null)
        t1 = $.$get$SemanticsNode__kIdentityTransform();
      t2 = customSemanticsActionIds == null ? $.$get$SemanticsNode__kEmptyCustomSemanticsActionsList() : customSemanticsActionIds;
      t1.length;
      C.JSArray_methods.add$1(builder._nodeUpdates, new T.SemanticsNodeUpdate(_this.id, data.flags, data.actions, -1, -1, 0, 0, 0 / 0, 0 / 0, 0 / 0, data.rect, data.label, data.hint, data.value, data.increasedValue, data.decreasedValue, data.textDirection, t1, childrenInTraversalOrder, childrenInHitTestOrder, t2));
      _this._semantics$_dirty = false;
    },
    _childrenInTraversalOrder$0: function() {
      var t1, childrenInDefaultOrder, everythingSorted, sortNodes, lastSortKey, position, child, sortKey, isCompatibleWithPreviousSortKey, t2, _this = this,
        inheritedTextDirection = _this._textDirection,
        ancestor = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(_this, _this), "$isSemanticsNode");
      while (true) {
        t1 = inheritedTextDirection == null;
        if (!(t1 && ancestor != null))
          break;
        inheritedTextDirection = ancestor._textDirection;
        ancestor = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(ancestor, ancestor), "$isSemanticsNode");
      }
      childrenInDefaultOrder = _this._semantics$_children;
      if (!t1)
        childrenInDefaultOrder = A._childrenInDefaultOrder(childrenInDefaultOrder, inheritedTextDirection);
      t1 = [A._TraversalSortNode];
      everythingSorted = H.setRuntimeTypeInfo([], t1);
      sortNodes = H.setRuntimeTypeInfo([], t1);
      for (t1 = H.getTypeArgumentByIndex(sortNodes, 0), lastSortKey = null, position = 0; position < childrenInDefaultOrder.length; ++position) {
        child = childrenInDefaultOrder[position];
        sortKey = child._sortKey;
        lastSortKey = position > 0 ? childrenInDefaultOrder[position - 1]._sortKey : null;
        if (position !== 0)
          if (J.get$runtimeType$(sortKey).$eq(0, J.get$runtimeType$(lastSortKey))) {
            if (sortKey != null)
              lastSortKey.name;
            isCompatibleWithPreviousSortKey = true;
          } else
            isCompatibleWithPreviousSortKey = false;
        else
          isCompatibleWithPreviousSortKey = true;
        if (!isCompatibleWithPreviousSortKey && sortNodes.length !== 0) {
          if (lastSortKey != null) {
            t2 = sortNodes.length - 1;
            if (t2 - 0 <= 32)
              H.Sort__insertionSort(sortNodes, 0, t2, J._interceptors_JSArray__compareAny$closure(), t1);
            else
              H.Sort__dualPivotQuicksort(sortNodes, 0, t2, J._interceptors_JSArray__compareAny$closure(), t1);
          }
          C.JSArray_methods.addAll$1(everythingSorted, sortNodes);
          C.JSArray_methods.set$length(sortNodes, 0);
        }
        C.JSArray_methods.add$1(sortNodes, new A._TraversalSortNode(child, sortKey, position));
      }
      if (lastSortKey != null)
        C.JSArray_methods.sort$0(sortNodes);
      C.JSArray_methods.addAll$1(everythingSorted, sortNodes);
      t1 = A.SemanticsNode;
      t2 = H.getTypeArgumentByIndex(everythingSorted, 0);
      return new H.MappedListIterable(everythingSorted, H.functionTypeCheck(new A.SemanticsNode__childrenInTraversalOrder_closure(), {func: 1, ret: t1, args: [t2]}), [t2, t1]).toList$0(0);
    },
    toStringShort$0: function() {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "#" + this.id;
    },
    debugFillProperties$1: function(properties) {
      var inDirtyNodes, hideOwner, t1, t2, offset, scale, description, t3, t4, matrix, actions, customSemanticsActions, _this = this, _null = null;
      _this.super$DiagnosticableTreeMixin$debugFillProperties(properties);
      if (_this._semantics$_dirty) {
        inDirtyNodes = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner") != null && H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner")._semantics$_dirtyNodes.contains$1(0, _this);
        C.JSArray_methods.add$1(properties.properties, new Y.FlagProperty("dirty", "STALE", _null, false, true, _null, _null, _null, false, inDirtyNodes, _null, C.DiagnosticLevel_3, "inDirtyNodes", true, false, _null, C.DiagnosticsTreeStyle_7));
        hideOwner = inDirtyNodes;
      } else
        hideOwner = true;
      t1 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner");
      t2 = hideOwner ? C.DiagnosticLevel_0 : C.DiagnosticLevel_3;
      t2 = Y.DiagnosticsProperty$("owner", t1, true, C.C__NoDefaultValue, _null, false, _null, _null, t2, false, true, true, C.DiagnosticsTreeStyle_7, _null, A.SemanticsOwner);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, t2);
      t2 = _this._isMergedIntoParent;
      C.JSArray_methods.add$1(t1, new Y.FlagProperty("merged up \u2b06\ufe0f", _null, _null, false, true, _null, _null, _null, false, t2, _null, C.DiagnosticLevel_3, "isMergedIntoParent", true, false, _null, C.DiagnosticsTreeStyle_7));
      C.JSArray_methods.add$1(t1, new Y.FlagProperty("merge boundary \u26d4\ufe0f", _null, _null, false, true, _null, _null, _null, false, false, _null, C.DiagnosticLevel_3, "mergeAllDescendantsIntoThisNode", true, false, _null, C.DiagnosticsTreeStyle_7));
      t2 = _this._semantics$_transform;
      offset = t2 != null ? T.MatrixUtils_getAsTranslation(t2) : _null;
      if (offset != null)
        C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("rect", _this._semantics$_rect.shift$1(offset), true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_7, _null, Q.Rect));
      else {
        t2 = _this._semantics$_transform;
        scale = t2 != null ? T.MatrixUtils_getAsScale(t2) : _null;
        if (scale != null)
          description = H.S(_this._semantics$_rect) + " scaled by " + C.JSNumber_methods.toStringAsFixed$1(scale, 1) + "x";
        else {
          t2 = _this._semantics$_transform;
          if (t2 != null && !T.MatrixUtils_isIdentity(t2)) {
            t2 = P.String;
            t3 = H.setRuntimeTypeInfo(J.toString$0$(_this._semantics$_transform).split("\n"), [t2]);
            t3 = H.SubListIterable$(t3, 0, 4, H.getTypeArgumentByIndex(t3, 0));
            t4 = H.getTypeArgumentByIndex(t3, 0);
            matrix = new H.MappedListIterable(t3, H.functionTypeCheck(new A.SemanticsNode_debugFillProperties_closure(), {func: 1, ret: t2, args: [t4]}), [t4, t2]).join$1(0, "; ");
            description = H.S(_this._semantics$_rect) + " with transform [" + matrix + "]";
          } else
            description = _null;
        }
        C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("rect", _this._semantics$_rect, true, C.C__NoDefaultValue, description, false, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_7, _null, Q.Rect));
      }
      t2 = _this._actions;
      t2 = t2.get$keys(t2);
      t3 = P.String;
      t4 = H.getRuntimeTypeArgument(t2, "Iterable", 0);
      t4 = H.MappedIterable_MappedIterable(t2, H.functionTypeCheck(new A.SemanticsNode_debugFillProperties_closure0(), {func: 1, ret: t3, args: [t4]}), t4, t3);
      actions = P.List_List$from(t4, true, H.getRuntimeTypeArgument(t4, "Iterable", 0));
      C.JSArray_methods.sort$0(actions);
      t4 = _this._customSemanticsActions;
      t4 = t4.get$keys(t4);
      t2 = H.getRuntimeTypeArgument(t4, "Iterable", 0);
      t2 = H.MappedIterable_MappedIterable(t4, H.functionTypeCheck(new A.SemanticsNode_debugFillProperties_closure1(), {func: 1, ret: t3, args: [t2]}), t2, t3);
      customSemanticsActions = P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "Iterable", 0));
      C.JSArray_methods.add$1(t1, Y.IterableProperty$("actions", actions, C.C__NoDefaultValue, _null, t3));
      C.JSArray_methods.add$1(t1, Y.IterableProperty$("customActions", customSemanticsActions, C.C__NoDefaultValue, _null, t3));
      t2 = C.Map_ek6Ds.get$values(C.Map_ek6Ds);
      t4 = H.getRuntimeTypeArgument(t2, "Iterable", 0);
      C.JSArray_methods.add$1(t1, Y.IterableProperty$("flags", P.List_List$from(new H.MappedIterable(new H.WhereIterable(t2, H.functionTypeCheck(new A.SemanticsNode_debugFillProperties_closure2(_this), {func: 1, ret: P.bool, args: [t4]}), [t4]), H.functionTypeCheck(new A.SemanticsNode_debugFillProperties_closure3(), {func: 1, ret: t3, args: [t4]}), [t4, t3]), true, t3), C.C__NoDefaultValue, _null, t3));
      if (!_this._isMergedIntoParent) {
        t2 = _this._semantics$_rect;
        t2 = t2.get$isEmpty(t2);
      } else
        t2 = false;
      C.JSArray_methods.add$1(t1, new Y.FlagProperty("invisible", _null, _null, false, true, _null, _null, _null, false, t2, _null, C.DiagnosticLevel_3, "isInvisible", true, false, _null, C.DiagnosticsTreeStyle_7));
      t2 = _this._flags;
      C.JSArray_methods.add$1(t1, new Y.FlagProperty("HIDDEN", _null, _null, false, true, _null, _null, _null, false, (t2 & 8192) !== 0, _null, C.DiagnosticLevel_3, "isHidden", true, false, _null, C.DiagnosticsTreeStyle_7));
      t2 = _this._flags;
      C.JSArray_methods.add$1(t1, new Y.FlagProperty("MULTI-LINE", _null, _null, false, true, _null, _null, _null, false, (t2 & 524288) !== 0, _null, C.DiagnosticLevel_3, "isMultiline", true, false, _null, C.DiagnosticsTreeStyle_7));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("label", _this._label, "", true, true));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("value", _this._semantics$_value, "", true, true));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("increasedValue", _this._increasedValue, "", true, true));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("decreasedValue", _this._decreasedValue, "", true, true));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("hint", _this._hint, "", true, true));
      t2 = _this._textDirection;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, t2, _null, C.DiagnosticLevel_3, "textDirection", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextDirection]));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("sortKey", _this._sortKey, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, A.SemanticsSortKey));
      C.JSArray_methods.add$1(t1, Y.IntProperty$("platformViewId", _this._platformViewId, _null, _null, C.DiagnosticLevel_3));
      C.JSArray_methods.add$1(t1, Y.IntProperty$("scrollChildren", _this._scrollChildCount, _null, _null, C.DiagnosticLevel_3));
      C.JSArray_methods.add$1(t1, Y.IntProperty$("scrollIndex", _this._scrollIndex, _null, _null, C.DiagnosticLevel_3));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("scrollExtentMin", _this._scrollExtentMin, _null, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("scrollPosition", _this._scrollPosition, _null, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("scrollExtentMax", _this._scrollExtentMax, _null, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("elevation", _this._elevation, 0, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("thicknes", _this._thickness, 0, C.DiagnosticLevel_3, _null, _null));
    },
    toDiagnosticsNode$3$childOrder$name$style: function(childOrder, $name, style) {
      return new A._SemanticsDiagnosticableNode(childOrder, this, $name, true, true, null, style);
    },
    toDiagnosticsNode$1$style: function(style) {
      return this.toDiagnosticsNode$3$childOrder$name$style(C.DebugSemanticsDumpOrder_1, null, style);
    },
    toDiagnosticsNode$0: function() {
      return this.toDiagnosticsNode$3$childOrder$name$style(C.DebugSemanticsDumpOrder_1, null, C.DiagnosticsTreeStyle_0);
    },
    debugDescribeChildren$1$childOrder: function(childOrder) {
      var t3,
        t1 = this.debugListChildrenInOrder$1(childOrder),
        t2 = Y.DiagnosticsNode;
      t1.toString;
      t3 = H.getTypeArgumentByIndex(t1, 0);
      return new H.MappedListIterable(t1, H.functionTypeCheck(new A.SemanticsNode_debugDescribeChildren_closure(childOrder), {func: 1, ret: t2, args: [t3]}), [t3, t2]).toList$0(0);
    },
    debugDescribeChildren$0: function() {
      return this.debugDescribeChildren$1$childOrder(C.DebugSemanticsDumpOrder_0);
    },
    debugListChildrenInOrder$1: function(childOrder) {
      var t1 = this._semantics$_children;
      if (t1 == null)
        return C.List_empty1;
      switch (childOrder) {
        case C.DebugSemanticsDumpOrder_0:
          return t1;
        case C.DebugSemanticsDumpOrder_1:
          return this._childrenInTraversalOrder$0();
      }
      return;
    },
    set$_semantics$_children: function(_, _children) {
      this._semantics$_children = H.assertSubtype(_children, "$isList", [A.SemanticsNode], "$asList");
    },
    set$_actions: function(_actions) {
      this._actions = H.assertSubtype(_actions, "$isMap", [Q.SemanticsAction, {func: 1, ret: -1, args: [,]}], "$asMap");
    },
    set$_customSemanticsActions: function(_customSemanticsActions) {
      this._customSemanticsActions = H.assertSubtype(_customSemanticsActions, "$isMap", [A.CustomSemanticsAction, {func: 1, ret: -1}], "$asMap");
    },
    set$tags: function(tags) {
      this.tags = H.assertSubtype(tags, "$isSet", [A.SemanticsTag], "$asSet");
    },
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1
  };
  A.SemanticsNode__childrenInTraversalOrder_closure.prototype = {
    call$1: function(sortNode) {
      return H.interceptedTypeCheck(sortNode, "$is_TraversalSortNode").node;
    },
    $signature: 75
  };
  A.SemanticsNode_debugFillProperties_closure.prototype = {
    call$1: function(line) {
      return J.substring$1$s(H.stringTypeCheck(line), 4);
    },
    $signature: 8
  };
  A.SemanticsNode_debugFillProperties_closure0.prototype = {
    call$1: function(action) {
      return Y.describeEnum(H.interceptedTypeCheck(action, "$isSemanticsAction"));
    },
    $signature: 76
  };
  A.SemanticsNode_debugFillProperties_closure1.prototype = {
    call$1: function(action) {
      H.interceptedTypeCheck(action, "$isCustomSemanticsAction").toString;
      return;
    },
    $signature: 77
  };
  A.SemanticsNode_debugFillProperties_closure2.prototype = {
    call$1: function(flag) {
      H.interceptedTypeCheck(flag, "$isSemanticsFlag");
      return (this.$this._flags & flag.index) !== 0;
    },
    $signature: 78
  };
  A.SemanticsNode_debugFillProperties_closure3.prototype = {
    call$1: function(flag) {
      return J.substring$1$s(J.toString$0$(H.interceptedTypeCheck(flag, "$isSemanticsFlag")), 14);
    },
    $signature: 79
  };
  A.SemanticsNode_debugDescribeChildren_closure.prototype = {
    call$1: function(node) {
      H.interceptedTypeCheck(node, "$isSemanticsNode");
      node.toString;
      return new A._SemanticsDiagnosticableNode(this.childOrder, node, null, true, true, null, C.DiagnosticsTreeStyle_0);
    },
    $signature: 80
  };
  A._BoxEdge.prototype = {
    compareTo$1: function(_, other) {
      var t1 = this.offset,
        t2 = H.interceptedTypeCheck(other, "$is_BoxEdge").offset;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return C.JSNumber_methods.toInt$0(J.get$sign$in(t1 - t2));
    },
    $isComparable: 1,
    $asComparable: function() {
      return [A._BoxEdge];
    }
  };
  A._SemanticsSortGroup.prototype = {
    compareTo$1: function(_, other) {
      var t1 = this.startOffset,
        t2 = H.interceptedTypeCheck(other, "$is_SemanticsSortGroup").startOffset;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return C.JSNumber_methods.toInt$0(J.get$sign$in(t1 - t2));
    },
    sortedWithinVerticalGroup$0: function() {
      var t1, t2, _i, child, t3, t4, t5, t6, horizontalGroups, group, depth, edge, result,
        edges = H.setRuntimeTypeInfo([], [A._BoxEdge]);
      for (t1 = this.nodes, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        t3 = child._semantics$_rect;
        t4 = t3.left;
        if (typeof t4 !== "number")
          return t4.$sub();
        t5 = t3.top;
        if (typeof t5 !== "number")
          return t5.$sub();
        t6 = t3.right;
        t3 = t3.bottom;
        C.JSArray_methods.add$1(edges, new A._BoxEdge(true, A._pointInParentCoordinates(child, new Q.Offset(t4 - -0.1, t5 - -0.1))._dx, child));
        C.JSArray_methods.add$1(edges, new A._BoxEdge(false, A._pointInParentCoordinates(child, new Q.Offset(t6 + -0.1, t3 + -0.1))._dx, child));
      }
      C.JSArray_methods.sort$0(edges);
      horizontalGroups = H.setRuntimeTypeInfo([], [A._SemanticsSortGroup]);
      for (t1 = edges.length, t2 = this.textDirection, t3 = [A.SemanticsNode], group = null, depth = 0, _i = 0; _i < edges.length; edges.length === t1 || (0, H.throwConcurrentModificationError)(edges), ++_i) {
        edge = edges[_i];
        if (edge.isLeadingEdge) {
          ++depth;
          if (group == null)
            group = new A._SemanticsSortGroup(edge.offset, t2, H.setRuntimeTypeInfo([], t3));
          C.JSArray_methods.add$1(group.nodes, edge.node);
        } else
          --depth;
        if (depth === 0) {
          C.JSArray_methods.add$1(horizontalGroups, group);
          group = null;
        }
      }
      C.JSArray_methods.sort$0(horizontalGroups);
      if (t2 === C.TextDirection_0)
        horizontalGroups = new H.ReversedListIterable(horizontalGroups, [H.getTypeArgumentByIndex(horizontalGroups, 0)]).toList$0(0);
      result = H.setRuntimeTypeInfo([], t3);
      for (t1 = horizontalGroups.length, _i = 0; _i < horizontalGroups.length; horizontalGroups.length === t1 || (0, H.throwConcurrentModificationError)(horizontalGroups), ++_i)
        C.JSArray_methods.addAll$1(result, horizontalGroups[_i].sortedWithinKnot$0());
      return result;
    },
    sortedWithinKnot$0: function() {
      var t3, t4, nodeMap, edges, t5, t6, t7, _i, node, t8, t9, t10, t11, center, _i0, nextNode, t12, t13, t14, nextCenter, direction, isLtrAndForward, isRtlAndForward, sortedIds, visitedIds, startNodes,
        t1 = this.nodes,
        t2 = t1.length;
      if (t2 <= 1)
        return t1;
      t3 = P.int;
      t4 = A.SemanticsNode;
      nodeMap = P.LinkedHashMap_LinkedHashMap$_empty(t3, t4);
      edges = P.LinkedHashMap_LinkedHashMap$_empty(t3, t3);
      for (t5 = this.textDirection, t6 = t5 === C.TextDirection_0, t5 = t5 === C.TextDirection_1, t7 = t2, _i = 0; _i < t7; t11 === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i, t7 = t11) {
        if (_i >= t7)
          return H.ioore(t1, _i);
        node = t1[_i];
        t7 = node.id;
        nodeMap.$indexSet(0, t7, node);
        t8 = node._semantics$_rect;
        t9 = t8.left;
        t10 = t8.right;
        if (typeof t9 !== "number")
          return H.iae(t9);
        t11 = t8.top;
        t8 = t8.bottom;
        if (typeof t11 !== "number")
          return H.iae(t11);
        center = A._pointInParentCoordinates(node, new Q.Offset(t9 + (t10 - t9) / 2, t11 + (t8 - t11) / 2));
        for (t8 = t1.length, t9 = center._dx, t10 = center._dy, _i0 = 0; t11 = t1.length, _i0 < t11; t1.length === t8 || (0, H.throwConcurrentModificationError)(t1), ++_i0) {
          nextNode = t1[_i0];
          if (node === nextNode || edges.$index(0, nextNode.id) === t7)
            continue;
          t11 = nextNode._semantics$_rect;
          t12 = t11.left;
          t13 = t11.right;
          if (typeof t12 !== "number")
            return H.iae(t12);
          t14 = t11.top;
          t11 = t11.bottom;
          if (typeof t14 !== "number")
            return H.iae(t14);
          nextCenter = A._pointInParentCoordinates(nextNode, new Q.Offset(t12 + (t13 - t12) / 2, t14 + (t11 - t14) / 2));
          t14 = nextCenter._dx;
          if (typeof t14 !== "number")
            return t14.$sub();
          if (typeof t9 !== "number")
            return H.iae(t9);
          t11 = nextCenter._dy;
          if (typeof t11 !== "number")
            return t11.$sub();
          if (typeof t10 !== "number")
            return H.iae(t10);
          direction = Math.atan2(t11 - t10, t14 - t9);
          isLtrAndForward = t5 && -0.7853981633974483 < direction && direction < 2.356194490192345;
          if (t6)
            isRtlAndForward = direction < -2.356194490192345 || direction > 2.356194490192345;
          else
            isRtlAndForward = false;
          if (isLtrAndForward || isRtlAndForward)
            edges.$indexSet(0, t7, nextNode.id);
        }
      }
      sortedIds = H.setRuntimeTypeInfo([], [t3]);
      visitedIds = P.LinkedHashSet_LinkedHashSet(t3);
      startNodes = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
      C.JSArray_methods.sort$1(startNodes, new A._SemanticsSortGroup_sortedWithinKnot_closure());
      t1 = H.getTypeArgumentByIndex(startNodes, 0);
      new H.MappedListIterable(startNodes, H.functionTypeCheck(new A._SemanticsSortGroup_sortedWithinKnot_closure0(), {func: 1, ret: t3, args: [t1]}), [t1, t3]).forEach$1(0, new A._SemanticsSortGroup_sortedWithinKnot_search(visitedIds, edges, sortedIds));
      t3 = H.getTypeArgumentByIndex(sortedIds, 0);
      t4 = new H.MappedListIterable(sortedIds, H.functionTypeCheck(new A._SemanticsSortGroup_sortedWithinKnot_closure1(nodeMap), {func: 1, ret: t4, args: [t3]}), [t3, t4]).toList$0(0);
      return new H.ReversedListIterable(t4, [H.getTypeArgumentByIndex(t4, 0)]).toList$0(0);
    },
    $asComparable: function() {
      return [A._SemanticsSortGroup];
    }
  };
  A._SemanticsSortGroup_sortedWithinKnot_closure.prototype = {
    call$2: function(a, b) {
      var t1, aTopLeft, bTopLeft, verticalDiff;
      H.interceptedTypeCheck(a, "$isSemanticsNode");
      H.interceptedTypeCheck(b, "$isSemanticsNode");
      t1 = a._semantics$_rect;
      aTopLeft = A._pointInParentCoordinates(a, new Q.Offset(t1.left, t1.top));
      t1 = b._semantics$_rect;
      bTopLeft = A._pointInParentCoordinates(b, new Q.Offset(t1.left, t1.top));
      verticalDiff = J.compareTo$1$ns(aTopLeft._dy, bTopLeft._dy);
      if (verticalDiff !== 0)
        return -verticalDiff;
      return -J.compareTo$1$ns(aTopLeft._dx, bTopLeft._dx);
    },
    $signature: 23
  };
  A._SemanticsSortGroup_sortedWithinKnot_search.prototype = {
    call$1: function(id) {
      var t1, _this = this;
      H.intTypeCheck(id);
      t1 = _this.visitedIds;
      if (t1.contains$1(0, id))
        return;
      t1.add$1(0, id);
      t1 = _this.edges;
      if (t1.containsKey$1(0, id))
        _this.call$1(t1.$index(0, id));
      C.JSArray_methods.add$1(_this.sortedIds, id);
    },
    $signature: 82
  };
  A._SemanticsSortGroup_sortedWithinKnot_closure0.prototype = {
    call$1: function(node) {
      return H.interceptedTypeCheck(node, "$isSemanticsNode").id;
    },
    $signature: 83
  };
  A._SemanticsSortGroup_sortedWithinKnot_closure1.prototype = {
    call$1: function(id) {
      return this.nodeMap.$index(0, H.intTypeCheck(id));
    },
    $signature: 84
  };
  A._TraversalSortNode.prototype = {
    compareTo$1: function(_, other) {
      var t1, t2;
      H.interceptedTypeCheck(other, "$is_TraversalSortNode");
      t1 = this.sortKey;
      if (t1 != null)
        t2 = (other == null ? null : other.sortKey) == null;
      else
        t2 = true;
      if (t2)
        return this.position - other.position;
      return t1.doCompare$1(other.sortKey);
    },
    $isComparable: 1,
    $asComparable: function() {
      return [A._TraversalSortNode];
    }
  };
  A.SemanticsOwner.prototype = {
    dispose$0: function() {
      var _this = this;
      _this._semantics$_dirtyNodes.clear$0(0);
      _this._nodes.clear$0(0);
      _this._detachedNodes.clear$0(0);
      _this.super$ChangeNotifier$dispose();
    },
    sendSemanticsUpdate$0: function() {
      var customSemanticsActionIds, visitedNodes, t2, t3, t4, t5, localDirtyNodes, t6, t7, t8, _i, node, builder, _this = this,
        t1 = _this._semantics$_dirtyNodes;
      if (t1._collection$_length === 0)
        return;
      customSemanticsActionIds = P.LinkedHashSet_LinkedHashSet(P.int);
      visitedNodes = H.setRuntimeTypeInfo([], [A.SemanticsNode]);
      for (t2 = H.getTypeArgumentByIndex(t1, 0), t3 = {func: 1, ret: P.bool, args: [t2]}, t4 = [t2], t5 = _this._detachedNodes; t1._collection$_length !== 0;) {
        localDirtyNodes = P.List_List$from(new H.WhereIterable(t1, H.functionTypeCheck(new A.SemanticsOwner_sendSemanticsUpdate_closure(_this), t3), t4), true, t2);
        t1.clear$0(0);
        t5.clear$0(0);
        t6 = H.getTypeArgumentByIndex(localDirtyNodes, 0);
        t7 = H.functionTypeCheck(new A.SemanticsOwner_sendSemanticsUpdate_closure0(), {func: 1, ret: P.int, args: [t6, t6]});
        t8 = localDirtyNodes.length - 1;
        if (t8 - 0 <= 32)
          H.Sort__insertionSort(localDirtyNodes, 0, t8, t7, t6);
        else
          H.Sort__dualPivotQuicksort(localDirtyNodes, 0, t8, t7, t6);
        C.JSArray_methods.addAll$1(visitedNodes, localDirtyNodes);
        for (t6 = localDirtyNodes.length, _i = 0; _i < localDirtyNodes.length; localDirtyNodes.length === t6 || (0, H.throwConcurrentModificationError)(localDirtyNodes), ++_i) {
          node = localDirtyNodes[_i];
          t7 = node._isMergedIntoParent;
          if (t7) {
            t7 = J.getInterceptor$x(node);
            if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t7, node), "$isSemanticsNode") != null)
              t8 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t7, node), "$isSemanticsNode")._isMergedIntoParent;
            else
              t8 = false;
            if (t8)
              H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t7, node), "$isSemanticsNode")._markDirty$0();
          }
        }
      }
      C.JSArray_methods.sort$1(visitedNodes, new A.SemanticsOwner_sendSemanticsUpdate_closure1());
      builder = new Q.SemanticsUpdateBuilder(H.setRuntimeTypeInfo([], [T.SemanticsNodeUpdate]));
      for (t2 = visitedNodes.length, _i = 0; _i < visitedNodes.length; visitedNodes.length === t2 || (0, H.throwConcurrentModificationError)(visitedNodes), ++_i) {
        node = visitedNodes[_i];
        if (node._semantics$_dirty && node._node$_owner != null)
          node._addToUpdate$2(builder, customSemanticsActionIds);
      }
      t1.clear$0(0);
      for (t1 = P._LinkedHashSetIterator$(customSemanticsActionIds, customSemanticsActionIds._collection$_modifications, H.getTypeArgumentByIndex(customSemanticsActionIds, 0)); t1.moveNext$0();)
        $.CustomSemanticsAction__actions.$index(0, t1._collection$_current).action;
      $.$get$window().toString;
      T.EngineSemanticsOwner_instance().updateSemantics$1(new T.SemanticsUpdate(builder._nodeUpdates));
      _this.notifyListeners$0();
    },
    _getSemanticsActionHandlerForId$2: function(id, action) {
      var t2, t1 = {},
        result = t1.result = this._nodes.$index(0, id);
      if (result != null) {
        t2 = result._isMergedIntoParent;
        t2 = t2 && !result._actions.containsKey$1(0, action);
      } else
        t2 = false;
      if (t2)
        result._visitDescendants$1(new A.SemanticsOwner__getSemanticsActionHandlerForId_closure(t1, action));
      t2 = t1.result;
      if (t2 == null || !t2._actions.containsKey$1(0, action))
        return;
      return t1.result._actions.$index(0, action);
    },
    performAction$3: function(id, action, args) {
      var handler = this._getSemanticsActionHandlerForId$2(id, action);
      if (handler != null) {
        handler.call$1(args);
        return;
      }
      if (action === C.SemanticsAction_256 && this._nodes.$index(0, id)._showOnScreen != null)
        this._nodes.$index(0, id)._showOnScreen.call$0();
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  A.SemanticsOwner_sendSemanticsUpdate_closure.prototype = {
    call$1: function(node) {
      return !this.$this._detachedNodes.contains$1(0, H.interceptedTypeCheck(node, "$isSemanticsNode"));
    },
    $signature: 39
  };
  A.SemanticsOwner_sendSemanticsUpdate_closure0.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isSemanticsNode");
      H.interceptedTypeCheck(b, "$isSemanticsNode");
      return a._node$_depth - b._node$_depth;
    },
    $signature: 23
  };
  A.SemanticsOwner_sendSemanticsUpdate_closure1.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isSemanticsNode");
      H.interceptedTypeCheck(b, "$isSemanticsNode");
      return a._node$_depth - b._node$_depth;
    },
    $signature: 23
  };
  A.SemanticsOwner__getSemanticsActionHandlerForId_closure.prototype = {
    call$1: function(node) {
      if (node._actions.containsKey$1(0, this.action)) {
        this._box_0.result = node;
        return false;
      }
      return true;
    },
    $signature: 39
  };
  A.SemanticsConfiguration.prototype = {
    set$elevation: function(_, value) {
      if (value === this._elevation)
        return;
      this._elevation = value;
      this._hasBeenAnnotated = true;
    },
    _setFlag$2: function(flag, value) {
      var t1, t2, _this = this;
      H.boolConversionCheck(value);
      t1 = _this._flags;
      t2 = flag.index;
      if (value)
        _this._flags = t1 | t2;
      else
        _this._flags = t1 & ~t2;
      _this._hasBeenAnnotated = true;
    },
    isCompatibleWith$1: function(other) {
      var t1, _this = this;
      if (other == null || !other._hasBeenAnnotated || !_this._hasBeenAnnotated)
        return true;
      if ((_this._actionsAsBits & other._actionsAsBits) !== 0)
        return false;
      if ((_this._flags & other._flags) !== 0)
        return false;
      t1 = _this._semantics$_value;
      if (t1 != null)
        if (t1.length !== 0) {
          t1 = other._semantics$_value;
          t1 = t1 != null && t1.length !== 0;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        return false;
      return true;
    },
    absorb$1: function(child) {
      var t1, t2, _this = this;
      if (!child._hasBeenAnnotated)
        return;
      _this._actions.addAll$1(0, child._actions);
      _this._customSemanticsActions.addAll$1(0, child._customSemanticsActions);
      _this._actionsAsBits = _this._actionsAsBits | child._actionsAsBits;
      _this._flags = _this._flags | child._flags;
      _this._textSelection = child._textSelection;
      _this._scrollPosition = child._scrollPosition;
      _this._scrollExtentMax = child._scrollExtentMax;
      _this._scrollExtentMin = child._scrollExtentMin;
      if (_this._hintOverrides == null)
        _this._hintOverrides = child._hintOverrides;
      _this._indexInParent = child._indexInParent;
      _this._scrollIndex = child._scrollIndex;
      _this._scrollChildCount = child._scrollChildCount;
      _this._platformViewId = child._platformViewId;
      t1 = _this._textDirection;
      if (t1 == null) {
        t1 = _this._textDirection = child._textDirection;
        _this._hasBeenAnnotated = true;
      }
      if (_this._sortKey == null)
        _this._sortKey = child._sortKey;
      t2 = _this._label;
      _this._label = A._concatStrings(child._label, child._textDirection, t2, t1);
      t1 = _this._decreasedValue;
      if (t1 === "" || t1 == null)
        _this._decreasedValue = child._decreasedValue;
      t1 = _this._semantics$_value;
      if (t1 === "" || t1 == null)
        _this._semantics$_value = child._semantics$_value;
      t1 = _this._increasedValue;
      if (t1 === "" || t1 == null)
        _this._increasedValue = child._increasedValue;
      t1 = _this._hint;
      t2 = _this._textDirection;
      _this._hint = A._concatStrings(child._hint, child._textDirection, t1, t2);
      _this._thickness = Math.max(_this._thickness, child._thickness + child._elevation);
      _this._hasBeenAnnotated = _this._hasBeenAnnotated || child._hasBeenAnnotated;
    },
    copy$0: function() {
      var _this = this,
        t1 = P.LinkedHashMap_LinkedHashMap$_empty(Q.SemanticsAction, {func: 1, ret: -1, args: [,]}),
        t2 = new A.SemanticsConfiguration(t1, P.LinkedHashMap_LinkedHashMap$_empty(A.CustomSemanticsAction, {func: 1, ret: -1}));
      t2._isSemanticBoundary = _this._isSemanticBoundary;
      t2.explicitChildNodes = _this.explicitChildNodes;
      t2._hasBeenAnnotated = _this._hasBeenAnnotated;
      t2._textDirection = _this._textDirection;
      t2._sortKey = _this._sortKey;
      t2._label = _this._label;
      t2._increasedValue = _this._increasedValue;
      t2._semantics$_value = _this._semantics$_value;
      t2._decreasedValue = _this._decreasedValue;
      t2._hint = _this._hint;
      t2._hintOverrides = _this._hintOverrides;
      t2._elevation = _this._elevation;
      t2._thickness = _this._thickness;
      t2._flags = _this._flags;
      t2.set$_tagsForChildren(_this._tagsForChildren);
      t2._textSelection = _this._textSelection;
      t2._scrollPosition = _this._scrollPosition;
      t2._scrollExtentMax = _this._scrollExtentMax;
      t2._scrollExtentMin = _this._scrollExtentMin;
      t2._actionsAsBits = _this._actionsAsBits;
      t2._indexInParent = _this._indexInParent;
      t2._scrollIndex = _this._scrollIndex;
      t2._scrollChildCount = _this._scrollChildCount;
      t2._platformViewId = _this._platformViewId;
      t1.addAll$1(0, _this._actions);
      t2._customSemanticsActions.addAll$1(0, _this._customSemanticsActions);
      return t2;
    },
    set$_tagsForChildren: function(_tagsForChildren) {
      this._tagsForChildren = H.assertSubtype(_tagsForChildren, "$isSet", [A.SemanticsTag], "$asSet");
    }
  };
  A.DebugSemanticsDumpOrder.prototype = {
    toString$0: function(_) {
      return this._semantics$_name;
    }
  };
  A.SemanticsSortKey.prototype = {
    compareTo$1: function(_, other) {
      return this.doCompare$1(H.interceptedTypeCheck(other, "$isSemanticsSortKey"));
    },
    debugFillProperties$1: function(properties) {
      var t1;
      this.super$DiagnosticableMixin$debugFillProperties(properties);
      t1 = Y.StringProperty$("name", this.name, null, true, true);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    $isComparable: 1,
    $asComparable: function() {
      return [A.SemanticsSortKey];
    }
  };
  A.OrdinalSortKey.prototype = {
    doCompare$1: function(other) {
      var t1 = other.order === this.order;
      if (t1)
        return 0;
      return C.JSInt_methods.compareTo$1(this.order, other.order);
    },
    debugFillProperties$1: function(properties) {
      var t1;
      this.super$SemanticsSortKey$debugFillProperties(properties);
      t1 = Y.DoubleProperty$("order", this.order, null, C.DiagnosticLevel_3, null, null);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  A._SemanticsNode_AbstractNode_DiagnosticableTreeMixin.prototype = {};
  Q.AssetBundle.prototype = {
    loadString$2$cache: function(key, cache) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, t1, data;
      var $async$loadString$2$cache = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.load$1(0, key), $async$loadString$2$cache);
            case 3:
              // returning from await.
              data = $async$result;
              if (data == null)
                throw H.wrapException(U.FlutterError_FlutterError("Unable to load asset: " + key));
              t1 = data.byteLength;
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$lt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 < 20480) {
                t1 = data.buffer;
                t1.toString;
                $async$returnValue = C.C_Utf8Codec.decode$1(0, H.NativeUint8List_NativeUint8List$view(t1, 0, null));
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = data.buffer;
              t1.toString;
              $async$returnValue = C.C_Utf8Codec.decode$1(0, H.NativeUint8List_NativeUint8List$view(t1, 0, null));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$loadString$2$cache, $async$completer);
    },
    toString$0: function(_) {
      return this.get$runtimeType(this).toString$0(0) + "#" + Y.shortHash(this) + "()";
    }
  };
  Q.CachingAssetBundle.prototype = {
    loadString$2$cache: function(key, cache) {
      return this.super$AssetBundle$loadString(key, true);
    }
  };
  Q.PlatformAssetBundle.prototype = {
    load$1: function(_, key) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.ByteData),
        $async$returnValue, port, isFile, t2, hasAuthority, path, asset, t1, scheme, userInfo, host;
      var $async$load$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P._Uri__uriEncode(C.List_gnE, key, C.C_Utf8Codec, false);
              scheme = P._Uri__makeScheme(null, 0, 0);
              userInfo = P._Uri__makeUserInfo(null, 0, 0);
              host = P._Uri__makeHost(null, 0, 0, false);
              P._Uri__makeQuery(null, 0, 0, null);
              P._Uri__makeFragment(null, 0, 0);
              port = P._Uri__makePort(null, scheme);
              isFile = scheme === "file";
              if (host == null)
                t2 = userInfo.length !== 0 || port != null || isFile;
              else
                t2 = false;
              if (t2)
                host = "";
              t2 = host == null;
              hasAuthority = !t2;
              path = P._Uri__makePath(t1, 0, t1.length, null, scheme, hasAuthority);
              t1 = scheme.length === 0;
              if (t1 && t2 && !C.JSString_methods.startsWith$1(path, "/"))
                path = P._Uri__normalizeRelativePath(path, !t1 || hasAuthority);
              else
                path = P._Uri__removeDotSegments(path);
              t2 && C.JSString_methods.startsWith$1(path, "//") ? "" : host;
              t1 = C.C_Utf8Encoder.convert$1(path).buffer;
              t1.toString;
              $async$goto = 3;
              return P._asyncAwait(B.BinaryMessages_send("flutter/assets", H.NativeByteData_NativeByteData$view(t1, 0, null)), $async$load$1);
            case 3:
              // returning from await.
              asset = $async$result;
              if (asset == null)
                throw H.wrapException(U.FlutterError_FlutterError("Unable to load asset: " + key));
              $async$returnValue = asset;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$load$1, $async$completer);
    }
  };
  N.ServicesBinding.prototype = {
    _addLicenses$0: function() {
      var $async$_addLicenses$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.String;
              t2 = new P._Future($.Zone__current, [t1]);
              rawLicenses = new P._AsyncCompleter(t2, [t1]);
              P.Timer_Timer(C.Duration_0, new N.ServicesBinding__addLicenses_closure(rawLicenses));
              $async$goto = 3;
              return P._asyncStarHelper(t2, $async$_addLicenses$0, $async$controller);
            case 3:
              // returning from await.
              t2 = [P.List, F.LicenseEntry];
              t1 = new P._Future($.Zone__current, [t2]);
              P.Timer_Timer(C.Duration_0, new N.ServicesBinding__addLicenses_closure0(new P._AsyncCompleter(t1, [t2]), rawLicenses));
              $async$goto = 4;
              return P._asyncStarHelper(t1, $async$_addLicenses$0, $async$controller);
            case 4:
              // returning from await.
              $async$temp1 = P;
              $async$goto = 6;
              return P._asyncStarHelper(t1, $async$_addLicenses$0, $async$controller);
            case 6:
              // returning from await.
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return P._asyncStarHelper(P._IterationMarker_yieldStar($async$temp1.Stream_Stream$fromIterable($async$result, F.LicenseEntry)), $async$_addLicenses$0, $async$controller);
            case 5:
              // after yield
            case 1:
              // return
              return P._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return P._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = P._makeAsyncStarStreamController($async$_addLicenses$0, F.LicenseEntry),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], t1, t2, rawLicenses, $async$temp1;
      return P._streamOfController($async$controller);
    }
  };
  N.ServicesBinding__addLicenses_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.rawLicenses.complete$1(0, $.$get$rootBundle().loadString$2$cache("LICENSE", false));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 22
  };
  N.ServicesBinding__addLicenses_closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, $async$temp1, $async$temp2, $async$temp3;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = $async$self.parsedLicenses;
              $async$temp2 = F;
              $async$temp3 = N.binding0_ServicesBinding__parseLicenses$closure();
              $async$goto = 2;
              return P._asyncAwait($async$self.rawLicenses.future, $async$call$0);
            case 2:
              // returning from await.
              $async$temp1.complete$1(0, $async$temp2.compute($async$temp3, $async$result, "parseLicenses", P.String, [P.List, F.LicenseEntry]));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 22
  };
  G.LogicalKeyboardKey.prototype = {
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this.keyId);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      return this.keyId === H.interceptedTypeCheck(other, "$isLogicalKeyboardKey").keyId;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this;
      _this.super$DiagnosticableMixin$debugFillProperties(properties);
      t1 = Y.StringProperty$("keyId", "0x" + C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(_this.keyId, 16), 8, "0"), C.C__NoDefaultValue, true, true);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.StringProperty$("keyLabel", _this.keyLabel, C.C__NoDefaultValue, true, true));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("debugName", _this.debugName, null, true, true));
    }
  };
  F.MethodCall0.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + this.method + ", " + H.S(this.$arguments) + ")";
    }
  };
  F.PlatformException.prototype = {
    toString$0: function(_) {
      return "PlatformException(" + H.S(this.code) + ", " + H.S(this.message) + ", " + H.S(this.details) + ")";
    },
    $isException: 1,
    get$message: function(receiver) {
      return this.message;
    }
  };
  F.MissingPluginException.prototype = {
    toString$0: function(_) {
      return "MissingPluginException(" + this.message + ")";
    },
    $isException: 1,
    get$message: function(receiver) {
      return this.message;
    }
  };
  U.StringCodec.prototype = {
    decodeMessage$1: function(message) {
      var t1, t2, t3;
      if (message == null)
        return;
      t1 = message.buffer;
      t2 = message.byteOffset;
      t3 = message.byteLength;
      t1.toString;
      return new P.Utf8Decoder(false).convert$1(H.NativeUint8List_NativeUint8List$view(t1, t2, t3));
    },
    encodeMessage$1: function(message) {
      var t1;
      H.stringTypeCheck(message);
      if (message == null)
        return;
      t1 = C.C_Utf8Encoder.convert$1(message).buffer;
      t1.toString;
      return H.NativeByteData_NativeByteData$view(t1, 0, null);
    },
    $isMessageCodec: 1,
    $asMessageCodec: function() {
      return [P.String];
    }
  };
  U.JSONMessageCodec.prototype = {
    encodeMessage$1: function(message) {
      if (message == null)
        return;
      return C.C_StringCodec.encodeMessage$1(C.C_JsonCodec.encode$1(message));
    },
    decodeMessage$1: function(message) {
      if (message == null)
        return message;
      return C.C_JsonCodec.decode$1(0, C.C_StringCodec.decodeMessage$1(message));
    },
    $isMessageCodec: 1,
    $asMessageCodec: function() {
    }
  };
  U.JSONMethodCodec.prototype = {
    decodeMethodCall$1: function(methodCall) {
      var method, $arguments, _null = null,
        decoded = C.C_JSONMessageCodec.decodeMessage$1(methodCall),
        t1 = J.getInterceptor$(decoded);
      if (!t1.$isMap)
        throw H.wrapException(P.FormatException$("Expected method call Map, got " + H.S(decoded), _null, _null));
      method = t1.$index(decoded, "method");
      $arguments = t1.$index(decoded, "args");
      if (typeof method === "string")
        return new F.MethodCall0(method, $arguments);
      throw H.wrapException(P.FormatException$("Invalid method call: " + H.S(decoded), _null, _null));
    },
    decodeEnvelope$1: function(envelope) {
      var t2, t3, _null = null,
        decoded = C.C_JSONMessageCodec.decodeMessage$1(envelope),
        t1 = J.getInterceptor$(decoded);
      if (!t1.$isList)
        throw H.wrapException(P.FormatException$("Expected envelope List, got " + H.S(decoded), _null, _null));
      if (t1.get$length(decoded) === 1)
        return t1.$index(decoded, 0);
      if (t1.get$length(decoded) === 3) {
        t2 = t1.$index(decoded, 0);
        if (typeof t2 === "string")
          if (t1.$index(decoded, 1) != null) {
            t2 = t1.$index(decoded, 1);
            t2 = typeof t2 === "string";
          } else
            t2 = true;
        else
          t2 = false;
      } else
        t2 = false;
      if (t2) {
        t2 = H.stringTypeCheck(t1.$index(decoded, 0));
        t3 = H.stringTypeCheck(t1.$index(decoded, 1));
        throw H.wrapException(F.PlatformException$(t2, t1.$index(decoded, 2), t3));
      }
      throw H.wrapException(P.FormatException$("Invalid envelope: " + H.S(decoded), _null, _null));
    },
    $isMethodCodec: 1
  };
  A.BasicMessageChannel.prototype = {
    setMessageHandler$1: function(handler) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      B.BinaryMessages_setMessageHandler(this.name, new A.BasicMessageChannel_setMessageHandler_closure(this, H.functionTypeCheck(handler, {func: 1, ret: [P.Future, t1], args: [t1]})));
    }
  };
  A.BasicMessageChannel_setMessageHandler_closure.prototype = {
    call$1: function(message) {
      return this.$call$body$BasicMessageChannel_setMessageHandler_closure(H.interceptedTypeCheck(message, "$isByteData"));
    },
    $call$body$BasicMessageChannel_setMessageHandler_closure: function(message) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.ByteData),
        $async$returnValue, $async$self = this, t1, $async$temp1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this.codec;
              $async$temp1 = t1;
              $async$goto = 3;
              return P._asyncAwait($async$self.handler.call$1(t1.decodeMessage$1(message)), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.encodeMessage$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 40
  };
  A.MethodChannel.prototype = {
    invokeMethod$1$2: function(method, $arguments, $T) {
      return this.invokeMethod$body$MethodChannel(method, $arguments, $T, $T);
    },
    invokeMethod$body$MethodChannel: function(method, $arguments, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, t1, result;
      var $async$invokeMethod$1$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.name;
              $async$goto = 3;
              return P._asyncAwait(B.BinaryMessages_send(t1, C.C_JSONMessageCodec.encodeMessage$1(P.LinkedHashMap_LinkedHashMap$_literal(["method", method, "args", $arguments], P.String, null))), $async$invokeMethod$1$2);
            case 3:
              // returning from await.
              result = $async$result;
              if (result == null)
                throw H.wrapException(new F.MissingPluginException("No implementation found for method " + method + " on channel " + t1));
              $async$returnValue = H.assertSubtypeOfRuntimeType($async$self.codec.decodeEnvelope$1(result), $T);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$invokeMethod$1$2, $async$completer);
    },
    setMethodCallHandler$1: function(handler) {
      H.functionTypeCheck(handler, {func: 1, ret: [P.Future,,], args: [F.MethodCall0]});
      B.BinaryMessages_setMessageHandler(this.name, new A.MethodChannel_setMethodCallHandler_closure(this, handler));
    },
    _handleAsMethodCall$2: function(message, handler) {
      H.functionTypeCheck(handler, {func: 1, ret: [P.Future,,], args: [F.MethodCall0]});
      return this._handleAsMethodCall$body$MethodChannel(message, handler);
    },
    _handleAsMethodCall$body$MethodChannel: function(message, handler) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.ByteData),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, e, e0, t1, exception, t2, $call, $async$exception, $async$temp1;
      var $async$_handleAsMethodCall$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $call = $async$self.codec.decodeMethodCall$1(message);
              $async$handler = 4;
              $async$temp1 = C.C_JSONMessageCodec;
              $async$goto = 7;
              return P._asyncAwait(handler.call$1($call), $async$_handleAsMethodCall$2);
            case 7:
              // returning from await.
              t1 = $async$temp1.encodeMessage$1([$async$result]);
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = H.unwrapException($async$exception);
              t2 = J.getInterceptor$(t1);
              if (!!t2.$isPlatformException) {
                e = t1;
                $async$returnValue = C.C_JSONMessageCodec.encodeMessage$1([e.code, e.message, e.details]);
                // goto return
                $async$goto = 1;
                break;
              } else if (!!t2.$isMissingPluginException) {
                // goto return
                $async$goto = 1;
                break;
              } else {
                e0 = t1;
                t1 = C.C_JSONMessageCodec.encodeMessage$1(["error", J.toString$0$(e0), null]);
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
              }
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleAsMethodCall$2, $async$completer);
    }
  };
  A.MethodChannel_setMethodCallHandler_closure.prototype = {
    call$1: function(message) {
      return this.$this._handleAsMethodCall$2(H.interceptedTypeCheck(message, "$isByteData"), this.handler);
    },
    $signature: 40
  };
  A.OptionalMethodChannel.prototype = {
    invokeMethod$1$2: function(method, $arguments, $T) {
      return this.invokeMethod$body$OptionalMethodChannel(method, $arguments, $T, $T);
    },
    invokeMethod$1$1: function(method, $T) {
      return this.invokeMethod$1$2(method, null, $T);
    },
    invokeMethod$body$OptionalMethodChannel: function(method, $arguments, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, result, exception, $async$exception;
      var $async$invokeMethod$1$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait($async$self.super$MethodChannel$invokeMethod(method, $arguments, $T), $async$invokeMethod$1$2);
            case 7:
              // returning from await.
              result = $async$result;
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              if (H.unwrapException($async$exception) instanceof F.MissingPluginException) {
                // goto return
                $async$goto = 1;
                break;
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$invokeMethod$1$2, $async$completer);
    }
  };
  B.BinaryMessages__sendPlatformMessage_closure.prototype = {
    call$1: function(reply) {
      var exception, stack, exception0, t1, _null = null;
      try {
        this.completer.complete$1(0, reply);
      } catch (exception0) {
        exception = H.unwrapException(exception0);
        stack = H.getTraceFromException(exception0);
        t1 = H.setRuntimeTypeInfo(["during a platform message response callback"], [P.Object]);
        U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(U.FlutterErrorDetails$(new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), exception, _null, "services library", false, stack));
      }
    },
    $signature: 12
  };
  B.KeyboardSide.prototype = {
    toString$0: function(_) {
      return this._raw_keyboard$_name;
    }
  };
  B.ModifierKey.prototype = {
    toString$0: function(_) {
      return this._raw_keyboard$_name;
    }
  };
  B.RawKeyEventData.prototype = {
    get$modifiersPressed: function() {
      var _i, key,
        result = P.LinkedHashMap_LinkedHashMap$_empty(B.ModifierKey, B.KeyboardSide);
      for (_i = 0; _i < 9; ++_i) {
        key = C.List_0[_i];
        if (this.isModifierPressed$1(key))
          result.$indexSet(0, key, this.getModifierSide$1(key));
      }
      return result;
    }
  };
  B.RawKeyEvent.prototype = {};
  B.RawKeyDownEvent.prototype = {};
  B.RawKeyUpEvent.prototype = {};
  B.RawKeyboard.prototype = {
    _handleKeyEvent$1: function(message) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, $async$self = this, t1, t2, t3, _i, listener, $event;
      var $async$_handleKeyEvent$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $event = B.RawKeyEvent_RawKeyEvent$fromMessage(H.assertSubtype(message, "$isMap", [P.String, null], "$asMap"));
              if (!!$event.$isRawKeyDownEvent)
                $async$self._keysPressed.add$1(0, $event.data.get$logicalKey());
              if (!!$event.$isRawKeyUpEvent)
                $async$self._keysPressed.remove$1(0, $event.data.get$logicalKey());
              t1 = $async$self._listeners;
              if (t1.length === 0) {
                // goto return
                $async$goto = 1;
                break;
              }
              for (t2 = P.List_List$from(t1, true, {func: 1, ret: -1, args: [B.RawKeyEvent]}), t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
                listener = t2[_i];
                if (C.JSArray_methods.contains$1(t1, listener))
                  listener.call$1($event);
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleKeyEvent$1, $async$completer);
    }
  };
  Q.RawKeyEventDataAndroid.prototype = {
    get$keyLabel: function() {
      var t1 = this.plainCodePoint;
      return t1 === 0 ? null : H.Primitives_stringFromCharCode(t1 & 2147483647);
    },
    get$logicalKey: function() {
      var keyId, t2, newKey, _this = this,
        t1 = _this.keyCode,
        numPadKey = C.Map_uS2jN.$index(0, t1);
      if (numPadKey != null)
        return numPadKey;
      if (_this.get$keyLabel() != null && _this.get$keyLabel().length !== 0 && !G.LogicalKeyboardKey_isControlCharacter(_this.get$keyLabel())) {
        keyId = 0 | _this.plainCodePoint & 2147483647 & 4294967295;
        t1 = C.Map_yHIsn.$index(0, keyId);
        if (t1 == null) {
          t1 = _this.get$keyLabel();
          t2 = "Key " + _this.get$keyLabel().toUpperCase();
          t1 = new G.LogicalKeyboardKey(keyId, t2, t1);
        }
        return t1;
      }
      newKey = C.Map_0rYGk.$index(0, t1);
      if (newKey != null)
        return newKey;
      t2 = "Unknown Android key code " + t1;
      newKey = new G.LogicalKeyboardKey((8589934592 | t1 | 1099511627776) >>> 0, t2, null);
      return newKey;
    },
    _isLeftRightModifierPressed$4: function(side, anyMask, leftMask, rightMask) {
      var t1 = this.metaState;
      if ((t1 & anyMask) === 0)
        return false;
      switch (side) {
        case C.KeyboardSide_0:
          return true;
        case C.KeyboardSide_3:
          return (t1 & leftMask) !== 0 && (t1 & rightMask) !== 0;
        case C.KeyboardSide_1:
          return (t1 & leftMask) !== 0;
        case C.KeyboardSide_2:
          return (t1 & rightMask) !== 0;
      }
      return false;
    },
    isModifierPressed$1: function(key) {
      var _this = this;
      switch (key) {
        case C.ModifierKey_0:
          return _this._isLeftRightModifierPressed$4(C.KeyboardSide_0, 4096, 8192, 16384);
        case C.ModifierKey_1:
          return _this._isLeftRightModifierPressed$4(C.KeyboardSide_0, 1, 64, 128);
        case C.ModifierKey_2:
          return _this._isLeftRightModifierPressed$4(C.KeyboardSide_0, 2, 16, 32);
        case C.ModifierKey_3:
          return _this._isLeftRightModifierPressed$4(C.KeyboardSide_0, 65536, 131072, 262144);
        case C.ModifierKey_4:
          return (_this.metaState & 1048576) !== 0;
        case C.ModifierKey_5:
          return (_this.metaState & 2097152) !== 0;
        case C.ModifierKey_6:
          return (_this.metaState & 4194304) !== 0;
        case C.ModifierKey_7:
          return (_this.metaState & 8) !== 0;
        case C.ModifierKey_8:
          return (_this.metaState & 4) !== 0;
      }
      return false;
    },
    getModifierSide$1: function(key) {
      var t1 = new Q.RawKeyEventDataAndroid_getModifierSide_findSide(this);
      switch (key) {
        case C.ModifierKey_0:
          return t1.call$2(8192, 16384);
        case C.ModifierKey_1:
          return t1.call$2(64, 128);
        case C.ModifierKey_2:
          return t1.call$2(16, 32);
        case C.ModifierKey_3:
          return t1.call$2(131072, 262144);
        case C.ModifierKey_4:
        case C.ModifierKey_5:
        case C.ModifierKey_6:
        case C.ModifierKey_7:
        case C.ModifierKey_8:
          return C.KeyboardSide_3;
      }
      return;
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(keyLabel: " + H.S(_this.get$keyLabel()) + " flags: " + _this.flags + ", codePoint: " + _this.codePoint + ", keyCode: " + _this.keyCode + ", scanCode: " + _this.scanCode + ", metaState: " + _this.metaState + ", modifiers down: " + _this.get$modifiersPressed().toString$0(0) + ")";
    }
  };
  Q.RawKeyEventDataAndroid_getModifierSide_findSide.prototype = {
    call$2: function(leftMask, rightMask) {
      var combinedMask = leftMask | rightMask,
        combined = this.$this.metaState & combinedMask;
      if (combined === leftMask)
        return C.KeyboardSide_1;
      else if (combined === rightMask)
        return C.KeyboardSide_2;
      else if (combined === combinedMask)
        return C.KeyboardSide_3;
      return;
    },
    $signature: 90
  };
  Q.RawKeyEventDataFuchsia.prototype = {
    get$logicalKey: function() {
      var t2, t3, newKey,
        t1 = this.codePoint;
      if (t1 !== 0) {
        t2 = H.Primitives_stringFromCharCode(t1);
        t3 = H.Primitives_stringFromCharCode(t1);
        t3 = "Key " + t3;
        return new G.LogicalKeyboardKey((0 | t1 & 4294967295) >>> 0, t3, t2);
      }
      t1 = this.hidUsage;
      newKey = C.Map_yHIsn.$index(0, (t1 | 4294967296) >>> 0);
      if (newKey != null)
        return newKey;
      t2 = "Ephemeral Fuchsia key code " + t1;
      newKey = new G.LogicalKeyboardKey((12884901888 | t1 | 1099511627776) >>> 0, t2, null);
      return newKey;
    },
    _raw_keyboard_fuchsia$_isLeftRightModifierPressed$4: function(side, anyMask, leftMask, rightMask) {
      var t1 = this.modifiers;
      if ((t1 & anyMask) === 0)
        return false;
      switch (side) {
        case C.KeyboardSide_0:
          return true;
        case C.KeyboardSide_3:
          return (t1 & leftMask) !== 0 && (t1 & rightMask) !== 0;
        case C.KeyboardSide_1:
          return (t1 & leftMask) !== 0;
        case C.KeyboardSide_2:
          return (t1 & rightMask) !== 0;
      }
      return false;
    },
    isModifierPressed$1: function(key) {
      var _this = this;
      switch (key) {
        case C.ModifierKey_0:
          return _this._raw_keyboard_fuchsia$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 24, 8, 16);
        case C.ModifierKey_1:
          return _this._raw_keyboard_fuchsia$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 6, 2, 4);
        case C.ModifierKey_2:
          return _this._raw_keyboard_fuchsia$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 96, 32, 64);
        case C.ModifierKey_3:
          return _this._raw_keyboard_fuchsia$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 384, 128, 256);
        case C.ModifierKey_4:
          return (_this.modifiers & 1) !== 0;
        case C.ModifierKey_5:
        case C.ModifierKey_6:
        case C.ModifierKey_7:
        case C.ModifierKey_8:
          return false;
      }
      return false;
    },
    getModifierSide$1: function(key) {
      var t1 = new Q.RawKeyEventDataFuchsia_getModifierSide_findSide(this);
      switch (key) {
        case C.ModifierKey_0:
          return t1.call$3(8, 16, 24);
        case C.ModifierKey_1:
          return t1.call$3(2, 4, 6);
        case C.ModifierKey_2:
          return t1.call$3(32, 64, 96);
        case C.ModifierKey_3:
          return t1.call$3(128, 256, 384);
        case C.ModifierKey_4:
          return (this.modifiers & 1) === 0 ? null : C.KeyboardSide_3;
        case C.ModifierKey_5:
        case C.ModifierKey_6:
        case C.ModifierKey_7:
        case C.ModifierKey_8:
          return;
      }
      return;
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(hidUsage: " + _this.hidUsage + ", codePoint: " + _this.codePoint + ", modifiers: " + _this.modifiers + ", modifiers down: " + _this.get$modifiersPressed().toString$0(0) + ")";
    }
  };
  Q.RawKeyEventDataFuchsia_getModifierSide_findSide.prototype = {
    call$3: function(leftMask, rightMask, combinedMask) {
      var combined = this.$this.modifiers & combinedMask;
      if (combined === leftMask)
        return C.KeyboardSide_1;
      else if (combined === rightMask)
        return C.KeyboardSide_2;
      else if (combined === combinedMask)
        return C.KeyboardSide_3;
      return;
    },
    $signature: 91
  };
  X.TextRange.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof X.TextRange))
        return false;
      return other.start == this.start && other.end == this.end;
    },
    get$hashCode: function(_) {
      return Q.hashValues(J.get$hashCode$(this.start), J.get$hashCode$(this.end), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return "TextRange(start: " + H.S(this.start) + ", end: " + H.S(this.end) + ")";
    }
  };
  X.TextSelection.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(baseOffset: " + H.S(this.baseOffset) + ", extentOffset: " + H.S(this.extentOffset) + ", affinity: " + C.TextAffinity_1.toString$0(0) + ", isDirectional: false)";
    },
    $eq: function(_, other) {
      var t1;
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof X.TextSelection))
        return false;
      if (other.baseOffset == this.baseOffset)
        if (other.extentOffset == this.extentOffset)
          t1 = true;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return Q.hashValues(J.get$hashCode$(this.baseOffset), J.get$hashCode$(this.extentOffset), H.Primitives_objectHashCode(C.TextAffinity_1), C.JSBool_methods.get$hashCode(false), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    }
  };
  T.RichText.prototype = {
    createRenderObject$1: function(context) {
      var _this = this,
        t1 = _this.overflow,
        t2 = L.Localizations_localeOf(context, true),
        t3 = H.setRuntimeTypeInfo([], [P.int]),
        t4 = H.setRuntimeTypeInfo([], [S.GestureRecognizer]),
        t5 = t1 === C.TextOverflow_2 ? "\u2026" : null;
      t4 = new Q.RenderParagraph(U.TextPainter$(t5, t2, _this.maxLines, null, _this.text, _this.textAlign, _this.textDirection, _this.textScaleFactor, C.TextWidthBasis_0), true, t1, t3, t4);
      t4.get$isRepaintBoundary();
      t4._needsCompositing = false;
      return t4;
    },
    updateRenderObject$2: function(context, renderObject) {
      var t1, _this = this;
      H.interceptedTypeCheck(renderObject, "$isRenderParagraph");
      renderObject.set$text(0, _this.text);
      renderObject.set$textAlign(0, _this.textAlign);
      renderObject.set$textDirection(_this.textDirection);
      renderObject.set$softWrap(true);
      renderObject.set$overflow(0, _this.overflow);
      renderObject.set$textScaleFactor(_this.textScaleFactor);
      renderObject.set$maxLines(_this.maxLines);
      renderObject.set$strutStyle(null);
      renderObject.set$textWidthBasis(C.TextWidthBasis_0);
      t1 = L.Localizations_localeOf(context, true);
      renderObject.set$locale(0, t1);
    },
    debugFillProperties$1: function(properties) {
      var t1, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, _this.textAlign, C.TextAlign_4, C.DiagnosticLevel_3, "textAlign", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextAlign]));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, _this.textDirection, _null, C.DiagnosticLevel_3, "textDirection", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextDirection]));
      C.JSArray_methods.add$1(t1, new Y.FlagProperty("wrapping at box width", "no wrapping except at line break characters", _null, false, true, _null, _null, _null, false, true, _null, C.DiagnosticLevel_3, "softWrap", true, true, _null, C.DiagnosticsTreeStyle_7));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, _this.overflow, C.TextOverflow_0, C.DiagnosticLevel_3, "overflow", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextOverflow]));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("textScaleFactor", _this.textScaleFactor, 1, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(t1, Y.IntProperty$("maxLines", _this.maxLines, C.C__NoDefaultValue, "unlimited", C.DiagnosticLevel_3));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, C.TextWidthBasis_0, C.TextWidthBasis_0, C.DiagnosticLevel_3, "textWidthBasis", true, true, _null, C.DiagnosticsTreeStyle_7, [U.TextWidthBasis]));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("text", _this.text.toPlainText$0(), C.C__NoDefaultValue, true, true));
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure.prototype = {
    call$0: function() {
      var t1 = $.RendererBinding__instance;
      t1 = t1 == null ? null : t1.RendererBinding__pipelineOwner._rootNode;
      t1 = t1 == null ? null : t1.super$DiagnosticableTreeMixin$toStringDeep(C.DiagnosticLevel_2, "", "");
      D.print__debugPrintThrottled$closure().call$1(t1 == null ? "Render tree unavailable." : t1);
      return D.debugPrintDone();
    },
    $signature: 6
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure0.prototype = {
    call$0: function() {
      N.debugDumpSemanticsTree(C.DebugSemanticsDumpOrder_1);
      return D.debugPrintDone();
    },
    $signature: 6
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure1.prototype = {
    call$0: function() {
      N.debugDumpSemanticsTree(C.DebugSemanticsDumpOrder_0);
      return D.debugPrintDone();
    },
    $signature: 6
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.double),
        $async$returnValue;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $._timeDilation;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 139
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure0.prototype = {
    call$1: function(value) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null);
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              N.timeDilation(value);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 93
  };
  N.WidgetsBindingObserver.prototype = {};
  N.WidgetsBinding.prototype = {
    handleLocaleChanged$0: function() {
      $.$get$window().toString;
      this.dispatchLocalesChanged$1(C.List_Locale_en_US);
    },
    dispatchLocalesChanged$1: function(locales) {
      var t1, _i;
      H.assertSubtype(locales, "$isList", [Q.Locale], "$asList");
      for (t1 = this.WidgetsBinding__observers, _i = 0; false; ++_i) {
        if (_i >= 0)
          return H.ioore(t1, _i);
        t1[_i].didChangeLocales$1(locales);
      }
    },
    handlePopRoute$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t1, t2, _i, $async$temp1;
      var $async$handlePopRoute$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.List_List$from($async$self.WidgetsBinding__observers, true, N.WidgetsBindingObserver), t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait(t1[_i].didPopRoute$0(), $async$handlePopRoute$0);
            case 6:
              // returning from await.
              if ($async$temp1.boolConversionCheck($async$result)) {
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // for update
              t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              M.SystemNavigator_pop();
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$handlePopRoute$0, $async$completer);
    },
    handlePushRoute$1: function(route) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t1, t2, _i, $async$temp1;
      var $async$handlePushRoute$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.List_List$from($async$self.WidgetsBinding__observers, true, N.WidgetsBindingObserver), t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait(t1[_i].didPushRoute$1(route), $async$handlePushRoute$1);
            case 6:
              // returning from await.
              if ($async$temp1.boolConversionCheck($async$result)) {
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // for update
              t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$handlePushRoute$1, $async$completer);
    },
    _handleNavigationInvocation$1: function(methodCall) {
      var t1;
      switch (methodCall.method) {
        case "popRoute":
          return this.handlePopRoute$0();
        case "pushRoute":
          return this.handlePushRoute$1(H.stringTypeCheck(methodCall.$arguments));
      }
      t1 = new P._Future($.Zone__current, [null]);
      t1._asyncComplete$1(null);
      return t1;
    },
    handleMemoryPressure$0: function() {
      var t1, _i;
      for (t1 = this.WidgetsBinding__observers, _i = 0; false; ++_i) {
        if (_i >= 0)
          return H.ioore(t1, _i);
        t1[_i].didHaveMemoryPressure$0();
      }
    },
    _handleSystemMessage$1: function(systemMessage) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this;
      var $async$_handleSystemMessage$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              switch (H.stringTypeCheck(J.$index$asx(H.assertSubtype(systemMessage, "$isMap", [P.String, null], "$asMap"), "type"))) {
                case "memoryPressure":
                  $async$self.handleMemoryPressure$0();
                  break;
              }
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleSystemMessage$1, $async$completer);
    },
    _handleBuildScheduled$0: function() {
      this.ensureVisualUpdate$0();
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.registerSignalServiceExtension$2$callback$name(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure(), "debugDumpApp");
      t1.registerServiceExtension$2$callback$name(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure0(t1), "didSendFirstFrameEvent");
    },
    $signature: 0
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure.prototype = {
    call$0: function() {
      var t1, _null = null;
      D.print__debugPrintThrottled$closure().call$1(J.get$runtimeType$($.WidgetsBinding__instance).toString$0(0) + " - RELEASE MODE");
      t1 = $.WidgetsBinding__instance.WidgetsBinding__renderViewElement;
      if (t1 != null)
        D.print__debugPrintThrottled$closure().call$1(new Y._DiagnosticableTreeNode(t1, _null, true, true, _null, _null).toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines(C.DiagnosticLevel_2, "", _null));
      else
        D.print__debugPrintThrottled$closure().call$1("<no tree currently mounted>");
      return D.debugPrintDone();
    },
    $signature: 6
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure0.prototype = {
    call$1: function(_) {
      var t1 = P.String;
      return this.$call$body$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure(H.assertSubtype(_, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]),
        $async$returnValue, $async$self = this;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = P.LinkedHashMap_LinkedHashMap$_literal(["enabled", $async$self.$this.WidgetsBinding__needToReportFirstFrame ? "false" : "true"], P.String, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 19
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1.WidgetsBinding__needToReportFirstFrame && t1.WidgetsBinding__deferFirstFrameReportCount === 0) {
        P.Timeline_instantSync("Widgets completed first useful frame");
        P.postEvent("Flutter.FirstFrame", P.LinkedHashMap_LinkedHashMap$_empty(P.String, null));
        t1.WidgetsBinding__needToReportFirstFrame = false;
      }
    },
    $signature: 0
  };
  N.RenderObjectToWidgetAdapter.prototype = {
    createElement$0: function(_) {
      var t1 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t1;
      return new N.RenderObjectToWidgetElement(t1, this, C._ElementLifecycle_0, this.$ti);
    },
    createRenderObject$1: function(context) {
      return this.container;
    },
    updateRenderObject$2: function(context, renderObject) {
    },
    attachToRenderTree$2: function(owner, element) {
      var t1 = {};
      t1.element = element;
      H.assertSubtype(element, "$isRenderObjectToWidgetElement", this.$ti, "$asRenderObjectToWidgetElement");
      if (element == null) {
        owner.lockState$1(new N.RenderObjectToWidgetAdapter_attachToRenderTree_closure(t1, this, owner));
        owner.buildScope$2(t1.element, new N.RenderObjectToWidgetAdapter_attachToRenderTree_closure0(t1));
      } else {
        element._newWidget = this;
        element.markNeedsBuild$0();
      }
      return t1.element;
    },
    toStringShort$0: function() {
      return this.debugShortDescription;
    }
  };
  N.RenderObjectToWidgetAdapter_attachToRenderTree_closure.prototype = {
    call$0: function() {
      var element,
        t1 = this.$this,
        t2 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t2;
      element = new N.RenderObjectToWidgetElement(t2, t1, C._ElementLifecycle_0, [H.getTypeArgumentByIndex(t1, 0)]);
      this._box_0.element = element;
      element._owner = this.owner;
    },
    $signature: 0
  };
  N.RenderObjectToWidgetAdapter_attachToRenderTree_closure0.prototype = {
    call$0: function() {
      var t1 = this._box_0.element;
      t1.super$RootRenderObjectElement$mount(null, null);
      t1._rebuild$0();
    },
    $signature: 0
  };
  N.RenderObjectToWidgetElement.prototype = {
    get$widget: function() {
      return H.assertSubtype(N.RenderObjectElement.prototype.get$widget.call(this), "$isRenderObjectToWidgetAdapter", this.$ti, "$asRenderObjectToWidgetAdapter");
    },
    visitChildren$1: function(visitor) {
      var t1;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [N.Element]});
      t1 = this._child;
      if (t1 != null)
        visitor.call$1(t1);
    },
    forgetChild$1: function(child) {
      this._child = null;
    },
    mount$2: function($parent, newSlot) {
      this.super$RootRenderObjectElement$mount($parent, newSlot);
      this._rebuild$0();
    },
    update$1: function(_, newWidget) {
      this.super$RenderObjectElement$update(0, H.assertSubtype(newWidget, "$isRenderObjectToWidgetAdapter", this.$ti, "$asRenderObjectToWidgetAdapter"));
      this._rebuild$0();
    },
    performRebuild$0: function() {
      var _this = this,
        t1 = _this._newWidget;
      if (t1 != null) {
        _this._newWidget = null;
        _this.super$RenderObjectElement$update(0, H.assertSubtype(t1, "$isRenderObjectToWidgetAdapter", _this.$ti, "$asRenderObjectToWidgetAdapter"));
        _this._rebuild$0();
      }
      _this.super$RenderObjectElement$performRebuild();
    },
    _rebuild$0: function() {
      var exception, stack, details, error, exception0, t1, _this = this, _null = null;
      try {
        _this._child = _this.updateChild$3(_this._child, H.assertSubtype(N.RenderObjectElement.prototype.get$widget.call(_this), "$isRenderObjectToWidgetAdapter", _this.$ti, "$asRenderObjectToWidgetAdapter").child, C.C_Object);
      } catch (exception0) {
        exception = H.unwrapException(exception0);
        stack = H.getTraceFromException(exception0);
        t1 = H.setRuntimeTypeInfo(["attaching to the render tree"], [P.Object]);
        details = U.FlutterErrorDetails$(new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), exception, _null, "widgets library", false, stack);
        U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(details);
        error = $.$get$ErrorWidget_builder().call$1(details);
        _this._child = _this.updateChild$3(_null, error, C.C_Object);
      }
    },
    get$renderObject: function() {
      return H.assertSubtype(N.RenderObjectElement.prototype.get$renderObject.call(this), "$isRenderObjectWithChildMixin", this.$ti, "$asRenderObjectWithChildMixin");
    },
    insertChildRenderObject$2: function(child, slot) {
      H.assertSubtype(N.RenderObjectElement.prototype.get$renderObject.call(this), "$isRenderObjectWithChildMixin", this.$ti, "$asRenderObjectWithChildMixin").set$child(H.assertSubtypeOfRuntimeType(child, H.getTypeArgumentByIndex(this, 0)));
    },
    moveChildRenderObject$2: function(child, slot) {
    },
    removeChildRenderObject$1: function(child) {
      H.assertSubtype(N.RenderObjectElement.prototype.get$renderObject.call(this), "$isRenderObjectWithChildMixin", this.$ti, "$asRenderObjectWithChildMixin").set$child(null);
    }
  };
  N.WidgetsFlutterBinding.prototype = {$isHitTestTarget: 1};
  N._WidgetsFlutterBinding_BindingBase_GestureBinding.prototype = {
    initInstances$0: function() {
      this.super$BindingBase$initInstances();
      var t1 = $.$get$window();
      t1.toString;
      t1.set$_onPointerDataPacket(H.functionTypeCheck(this.get$_handlePointerDataPacket(), {func: 1, ret: -1, args: [Q.PointerDataPacket]}));
    },
    unlocked$0: function() {
      this.super$BindingBase$unlocked();
      this._flushPointerEventQueue$0();
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding.prototype = {
    initInstances$0: function() {
      this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding$initInstances();
      var t1 = $.$get$window();
      t1.toString;
      t1.set$_onPlatformMessage(H.functionTypeCheck(B.platform_messages_BinaryMessages_handlePlatformMessage$closure(), {func: 1, ret: -1, args: [P.String, P.ByteData, {func: 1, ret: -1, args: [P.ByteData]}]}));
      t1 = $.LicenseRegistry__collectors;
      if (t1 == null)
        t1 = $.LicenseRegistry__collectors = H.setRuntimeTypeInfo([], [{func: 1, ret: [P.Stream, F.LicenseEntry]}]);
      C.JSArray_methods.add$1(t1, this.get$_addLicenses());
    },
    initServiceExtensions$0: function() {
      this.super$BindingBase$initServiceExtensions();
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding.prototype = {
    initInstances$0: function() {
      var t1, _this = this;
      _this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding$initInstances();
      $.SchedulerBinding__instance = _this;
      t1 = $.$get$window();
      t1.toString;
      t1.set$_onBeginFrame(H.functionTypeCheck(_this.get$_handleBeginFrame(), {func: 1, ret: -1, args: [P.Duration]}));
      t1.set$_onDrawFrame(H.functionTypeCheck(_this.get$_handleDrawFrame(), {func: 1, ret: -1}));
      C.BasicMessageChannel_No7.setMessageHandler$1(_this.get$_handleLifecycleMessage());
      if (_this.SchedulerBinding__lifecycleState == null && N.SchedulerBinding__parseAppLifecycleMessage(null) != null)
        _this._handleLifecycleMessage$1(null);
    },
    initServiceExtensions$0: function() {
      this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding$initServiceExtensions();
      this.registerNumericServiceExtension$3$getter$name$setter(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure(), "timeDilation", new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure0());
    },
    set$_transientCallbacks: function(_transientCallbacks) {
      this.SchedulerBinding__transientCallbacks = H.assertSubtype(_transientCallbacks, "$isMap", [P.int, N._FrameCallbackEntry], "$asMap");
    },
    set$_nextFrameCompleter: function(_nextFrameCompleter) {
      this.SchedulerBinding__nextFrameCompleter = H.assertSubtype(_nextFrameCompleter, "$isCompleter", [-1], "$asCompleter");
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding.prototype = {
    initInstances$0: function() {
      this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding$initInstances();
      var t1 = P.Object;
      this.PaintingBinding__imageCache = new E.ImageCache(P.LinkedHashMap_LinkedHashMap$_empty(t1, L.ImageStreamCompleter), P.LinkedHashMap_LinkedHashMap$_empty(t1, E._CachedImage));
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding.prototype = {
    initInstances$0: function() {
      this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding$initInstances();
      this.SemanticsBinding__accessibilityFeatures = $.$get$window()._accessibilityFeatures;
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding.prototype = {
    initInstances$0: function() {
      var t1, t2, _this = this;
      _this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding$initInstances();
      $.RendererBinding__instance = _this;
      t1 = K.RenderObject;
      t2 = [t1];
      _this.RendererBinding__pipelineOwner = new K.PipelineOwner(_this.get$ensureVisualUpdate(), _this.get$_handleSemanticsOwnerCreated(), _this.get$_handleSemanticsOwnerDisposed(), H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), P.LinkedHashSet_LinkedHashSet$_empty(t1));
      t1 = $.$get$window();
      t1.toString;
      t2 = {func: 1, ret: -1};
      t1.set$_onMetricsChanged(H.functionTypeCheck(_this.get$handleMetricsChanged(), t2));
      t1.set$_onTextScaleFactorChanged(H.functionTypeCheck(_this.get$handleTextScaleFactorChanged(), t2));
      t1.set$_onPlatformBrightnessChanged(H.functionTypeCheck(_this.get$handlePlatformBrightnessChanged(), t2));
      t1.set$_onSemanticsEnabledChanged(H.functionTypeCheck(_this.get$_handleSemanticsEnabledChanged(), t2));
      t1.set$_onSemanticsAction(H.functionTypeCheck(_this.get$_handleSemanticsAction(), {func: 1, ret: -1, args: [P.int, Q.SemanticsAction, P.ByteData]}));
      t1 = new A.RenderView(C.Size_0_0, _this.createViewConfiguration$0(), t1, null);
      t1.get$isRepaintBoundary();
      t1._needsCompositing = true;
      t1.set$child(null);
      _this.RendererBinding__pipelineOwner.set$rootNode(t1);
      t1 = _this.RendererBinding__pipelineOwner._rootNode;
      t1._relayoutBoundary = t1;
      C.JSArray_methods.add$1(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner")._nodesNeedingLayout, t1);
      t1._layer = t1._updateMatricesAndCreateNewRootLayer$0();
      C.JSArray_methods.add$1(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner")._nodesNeedingPaint, t1);
      H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner").onNeedVisualUpdate.call$0();
      _this.setSemanticsEnabled$1(T.EngineSemanticsOwner_instance()._semanticsEnabled);
      C.JSArray_methods.add$1(_this.SchedulerBinding__persistentCallbacks, H.functionTypeCheck(_this.get$_handlePersistentFrameCallback(), {func: 1, ret: -1, args: [P.Duration]}));
      _this.RendererBinding__mouseTracker = _this._createMouseTracker$0();
    },
    initServiceExtensions$0: function() {
      var _this = this;
      _this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding$initServiceExtensions();
      _this.registerSignalServiceExtension$2$callback$name(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure(), "debugDumpRenderTree");
      _this.registerSignalServiceExtension$2$callback$name(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure0(), "debugDumpSemanticsTreeInTraversalOrder");
      _this.registerSignalServiceExtension$2$callback$name(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure1(), "debugDumpSemanticsTreeInInverseHitTestOrder");
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding.prototype = {
    initServiceExtensions$0: function() {
      this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding$initServiceExtensions();
      U.profile(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure(this));
    },
    handleMetricsChanged$0: function() {
      var t1, _i;
      this.super$RendererBinding$handleMetricsChanged();
      for (t1 = this.WidgetsBinding__observers, _i = 0; false; ++_i) {
        if (_i >= 0)
          return H.ioore(t1, _i);
        t1[_i].didChangeMetrics$0();
      }
    },
    handleTextScaleFactorChanged$0: function() {
      var t1, _i;
      this.super$RendererBinding$handleTextScaleFactorChanged();
      for (t1 = this.WidgetsBinding__observers, _i = 0; false; ++_i) {
        if (_i >= 0)
          return H.ioore(t1, _i);
        t1[_i].didChangeTextScaleFactor$0();
      }
    },
    handlePlatformBrightnessChanged$0: function() {
      var t1, _i;
      this.super$RendererBinding$handlePlatformBrightnessChanged();
      for (t1 = this.WidgetsBinding__observers, _i = 0; false; ++_i) {
        if (_i >= 0)
          return H.ioore(t1, _i);
        t1[_i].didChangePlatformBrightness$0();
      }
    },
    handleAccessibilityFeaturesChanged$0: function() {
      var t1, _i;
      this.super$SemanticsBinding$handleAccessibilityFeaturesChanged();
      for (t1 = this.WidgetsBinding__observers, _i = 0; false; ++_i) {
        if (_i >= 0)
          return H.ioore(t1, _i);
        t1[_i].didChangeAccessibilityFeatures$0();
      }
    },
    handleAppLifecycleStateChanged$1: function(state) {
      var t1, _i;
      this.super$SchedulerBinding$handleAppLifecycleStateChanged(state);
      for (t1 = this.WidgetsBinding__observers, _i = 0; false; ++_i) {
        if (_i >= 0)
          return H.ioore(t1, _i);
        t1[_i].didChangeAppLifecycleState$1(state);
      }
    },
    drawFrame$0: function() {
      var t1, _this = this;
      try {
        t1 = _this.WidgetsBinding__renderViewElement;
        if (t1 != null)
          _this.WidgetsBinding__buildOwner.buildScope$1(t1);
        _this.super$RendererBinding$drawFrame();
        _this.WidgetsBinding__buildOwner.finalizeTree$0();
      } finally {
      }
      U.profile(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure(_this));
    }
  };
  O.FocusNode.prototype = {
    get$hasFocus: function() {
      return false;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$DiagnosticableTreeMixin$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("context", _null, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, N.BuildContext);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      t1 = this.get$hasFocus();
      C.JSArray_methods.add$1(t2, new Y.FlagProperty("FOCUSED", _null, _null, false, true, _null, _null, _null, false, t1, false, C.DiagnosticLevel_3, "hasFocus", true, false, _null, C.DiagnosticsTreeStyle_7));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("debugLabel", this._debugLabel, _null, true, true));
    },
    debugDescribeChildren$0: function() {
      var t2, t3, t4, t1 = {};
      t1.count = 1;
      t2 = this._children;
      t3 = Y.DiagnosticsNode;
      t4 = H.getTypeArgumentByIndex(t2, 0);
      return new H.MappedListIterable(t2, H.functionTypeCheck(new O.FocusNode_debugDescribeChildren_closure(t1), {func: 1, ret: t3, args: [t4]}), [t4, t3]).toList$0(0);
    },
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1
  };
  O.FocusNode_debugDescribeChildren_closure.prototype = {
    call$1: function(child) {
      var t1;
      H.interceptedTypeCheck(child, "$isFocusNode");
      t1 = "Child " + this._box_0.count++;
      child.toString;
      return new Y._DiagnosticableTreeNode(child, t1, true, true, null, null);
    },
    $signature: 96
  };
  O.FocusScopeNode.prototype = {
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$FocusNode$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("focusedChild", _null, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, O.FocusNode);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  O.FocusManager.prototype = {
    _handleRawKeyEvent$1: function($event) {
      H.interceptedTypeCheck($event, "$isRawKeyEvent");
      return;
    },
    debugDescribeChildren$0: function() {
      return H.setRuntimeTypeInfo([new Y._DiagnosticableTreeNode(this.rootScope, "rootScope", true, true, null, null)], [Y.DiagnosticsNode]);
    },
    debugFillProperties$1: function(properties) {
      var _null = null,
        t1 = properties.properties;
      C.JSArray_methods.add$1(t1, new Y.FlagProperty("UPDATE SCHEDULED", _null, _null, false, true, _null, _null, _null, false, false, _null, C.DiagnosticLevel_3, "haveScheduledUpdate", true, false, _null, C.DiagnosticsTreeStyle_7));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("currentFocus", _null, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, O.FocusNode));
    },
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1
  };
  O._FocusManager_Object_DiagnosticableTreeMixin.prototype = {};
  O._FocusNode_Object_DiagnosticableTreeMixin.prototype = {};
  O._FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier.prototype = {
    set$_change_notifier$_listeners: function(_listeners) {
      this.ChangeNotifier__listeners = H.assertSubtype(_listeners, "$isObserverList", [{func: 1, ret: -1}], "$asObserverList");
    }
  };
  N.UniqueKey.prototype = {
    toString$0: function(_) {
      return "[#" + Y.shortHash(this) + "]";
    }
  };
  N.GlobalKey.prototype = {};
  N.GlobalObjectKey.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      return this.value == H.assertSubtype(other, "$isGlobalObjectKey", this.$ti, "$asGlobalObjectKey").value;
    },
    get$hashCode: function(_) {
      return H.objectHashCode(this.value);
    },
    toString$0: function(_) {
      var selfType = new H.TypeImpl(H.getRti(this)).get$_typeName(),
        t1 = this.value;
      return "[" + (C.JSString_methods.endsWith$1(selfType, "<State<StatefulWidget>>") ? C.JSString_methods.substring$2(selfType, 0, selfType.length - 23) : selfType) + " " + (J.get$runtimeType$(t1).toString$0(0) + "#" + Y.shortHash(t1)) + "]";
    }
  };
  N.Widget.prototype = {
    toStringShort$0: function() {
      var t1 = this.key;
      return t1 == null ? new H.TypeImpl(H.getRti(this)).toString$0(0) : new H.TypeImpl(H.getRti(this)).toString$0(0) + "-" + t1.toString$0(0);
    },
    debugFillProperties$1: function(properties) {
      this.super$DiagnosticableMixin$debugFillProperties(properties);
      properties.defaultDiagnosticsTreeStyle = C.DiagnosticsTreeStyle_2;
    }
  };
  N.StatelessWidget.prototype = {
    createElement$0: function(_) {
      var t1 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t1;
      return new N.StatelessElement(t1, this, C._ElementLifecycle_0);
    }
  };
  N.StatefulWidget.prototype = {};
  N.State.prototype = {};
  N.ProxyWidget.prototype = {};
  N.InheritedWidget.prototype = {};
  N.RenderObjectWidget.prototype = {
    updateRenderObject$2: function(context, renderObject) {
    }
  };
  N.LeafRenderObjectWidget.prototype = {
    createElement$0: function(_) {
      var t1 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t1;
      return new N.LeafRenderObjectElement(t1, this, C._ElementLifecycle_0);
    }
  };
  N._ElementLifecycle.prototype = {
    toString$0: function(_) {
      return this._framework$_name;
    }
  };
  N._InactiveElements.prototype = {
    _unmount$1: function(element) {
      H.interceptedTypeCheck(element, "$isElement");
      element.visitChildren$1(new N._InactiveElements__unmount_closure(this, element));
      element.unmount$0();
    },
    _unmountAll$0: function() {
      var elements, t1, elements0, _this = this;
      _this._locked = true;
      t1 = _this._elements;
      elements0 = t1.toList$0(0);
      C.JSArray_methods.sort$1(elements0, N.framework_Element__sort$closure());
      elements = elements0;
      t1.clear$0(0);
      try {
        t1 = elements;
        new H.ReversedListIterable(t1, [H.getTypeArgumentByIndex(t1, 0)]).forEach$1(0, _this.get$_unmount());
      } finally {
        _this._locked = false;
      }
    }
  };
  N._InactiveElements__unmount_closure.prototype = {
    call$1: function(child) {
      this.$this._unmount$1(child);
    },
    $signature: 7
  };
  N.BuildContext.prototype = {};
  N.BuildOwner.prototype = {
    scheduleBuildFor$1: function(element) {
      var _this = this;
      if (element._inDirtyList) {
        _this._dirtyElementsNeedsResorting = true;
        return;
      }
      if (!_this._scheduledFlushDirtyElements && _this.onBuildScheduled != null) {
        _this._scheduledFlushDirtyElements = true;
        _this.onBuildScheduled.call$0();
      }
      C.JSArray_methods.add$1(_this._dirtyElements, element);
      element._inDirtyList = true;
    },
    lockState$1: function(callback) {
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      try {
        callback.call$0();
      } finally {
      }
    },
    buildScope$2: function(context, callback) {
      var e, stack, element, t1, t2, t3, t4, t5, exception, t6, t7, _i, _this = this, _null = null, _box_0 = {};
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      if (callback == null && _this._dirtyElements.length === 0)
        return;
      P.Timeline_startSync("Build", C.Map_9aZ6I, _null);
      try {
        _this._scheduledFlushDirtyElements = true;
        if (callback != null) {
          _box_0.debugPreviousBuildTarget = null;
          _this._dirtyElementsNeedsResorting = false;
          try {
            callback.call$0();
          } finally {
          }
        }
        t1 = _this._dirtyElements;
        C.JSArray_methods.sort$1(t1, N.framework_Element__sort$closure());
        _this._dirtyElementsNeedsResorting = false;
        _box_0.dirtyCount = t1.length;
        _box_0.index = 0;
        for (t2 = [P.Object], t3 = H.getTypeArgumentByIndex(t1, 0), t4 = {func: 1, ret: P.int, args: [t3, t3]}, t5 = 0; t5 < _box_0.dirtyCount;) {
          try {
            if (t5 < 0 || t5 >= t1.length)
              return H.ioore(t1, t5);
            t1[t5].rebuild$0();
          } catch (exception) {
            e = H.unwrapException(exception);
            stack = H.getTraceFromException(exception);
            t5 = H.setRuntimeTypeInfo(["while rebuilding dirty elements"], t2);
            U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(new U.FlutterErrorDetails(e, stack, "widgets library", new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t5, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), new N.BuildOwner_buildScope_closure(_box_0, _this), false));
          }
          t5 = ++_box_0.index;
          t6 = _box_0.dirtyCount;
          t7 = t1.length;
          if (t6 < t7 || H.boolConversionCheck(_this._dirtyElementsNeedsResorting)) {
            H.functionTypeCheck(N.framework_Element__sort$closure(), t4);
            t5 = t7 - 1;
            if (t5 - 0 <= 32)
              H.Sort__insertionSort(t1, 0, t5, N.framework_Element__sort$closure(), t3);
            else
              H.Sort__dualPivotQuicksort(t1, 0, t5, N.framework_Element__sort$closure(), t3);
            t5 = _this._dirtyElementsNeedsResorting = false;
            _box_0.dirtyCount = t1.length;
            while (true) {
              t6 = _box_0.index;
              if (t6 > 0) {
                t7 = t6 - 1;
                if (t7 >= t1.length)
                  return H.ioore(t1, t7);
                t7 = t1[t7]._dirty;
              } else
                t7 = t5;
              if (!t7)
                break;
              _box_0.index = t6 - 1;
            }
            t5 = t6;
          }
        }
      } finally {
        for (t1 = _this._dirtyElements, t2 = t1.length, _i = 0; _i < t2; ++_i) {
          element = t1[_i];
          element._inDirtyList = false;
        }
        C.JSArray_methods.set$length(t1, 0);
        _this._scheduledFlushDirtyElements = false;
        _this._dirtyElementsNeedsResorting = null;
        P.Timeline_finishSync();
      }
    },
    buildScope$1: function(context) {
      return this.buildScope$2(context, null);
    },
    finalizeTree$0: function() {
      var e, stack, exception, t1, _null = null;
      P.Timeline_startSync("Finalize tree", C.Map_9aZ6I, _null);
      try {
        this.lockState$1(new N.BuildOwner_finalizeTree_closure(this));
      } catch (exception) {
        e = H.unwrapException(exception);
        stack = H.getTraceFromException(exception);
        t1 = H.setRuntimeTypeInfo(["while finalizing the widget tree"], [P.Object]);
        N._debugReportException(new U.ErrorSummary(_null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_6, _null, false, false, _null, C.DiagnosticsTreeStyle_6), e, stack, _null);
      } finally {
        P.Timeline_finishSync();
      }
    },
    set$onBuildScheduled: function(onBuildScheduled) {
      this.onBuildScheduled = H.functionTypeCheck(onBuildScheduled, {func: 1, ret: -1});
    }
  };
  N.BuildOwner_buildScope_closure.prototype = {
    call$0: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 2, $async$currentError, t1, t2, t3;
        return function $async$call$0($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this._dirtyElements;
                t2 = $async$self._box_0;
                t3 = t2.index;
                if (t3 < 0 || t3 >= t1.length) {
                  H.ioore(t1, t3);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1 = t1[t3];
                $async$goto = 3;
                return Y.DiagnosticsProperty$("The element being rebuilt at the time was index " + t3 + " of " + t2.dirtyCount, t1, true, C.C__NoDefaultValue, null, false, null, null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_8, null, N.Element);
              case 3:
                // after yield
              case 1:
                // return
                return P._IterationMarker_endOfIteration();
              case 2:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, Y.DiagnosticsNode);
    },
    $signature: 24
  };
  N.BuildOwner_finalizeTree_closure.prototype = {
    call$0: function() {
      this.$this._inactiveElements._unmountAll$0();
    },
    $signature: 0
  };
  N.Element.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      return this === other;
    },
    get$hashCode: function(_) {
      return this._cachedHash;
    },
    get$widget: function() {
      return this._widget;
    },
    visitChildren$1: function(visitor) {
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [N.Element]});
    },
    updateChild$3: function(child, newWidget, newSlot) {
      var _this = this;
      if (newWidget == null) {
        if (child != null)
          _this.deactivateChild$1(child);
        return;
      }
      if (child != null) {
        if (child.get$widget() === newWidget) {
          if (child._slot != newSlot)
            _this.updateSlotForChild$2(child, newSlot);
          return child;
        }
        if (N.Widget_canUpdate(child.get$widget(), newWidget)) {
          if (child._slot != newSlot)
            _this.updateSlotForChild$2(child, newSlot);
          child.update$1(0, newWidget);
          return child;
        }
        _this.deactivateChild$1(child);
      }
      return _this.inflateWidget$2(newWidget, newSlot);
    },
    mount$2: function($parent, newSlot) {
      var t1, t2, key, _this = this;
      _this._parent = $parent;
      _this._slot = newSlot;
      t1 = $parent != null;
      if (t1) {
        t2 = $parent._depth;
        if (typeof t2 !== "number")
          return t2.$add();
        ++t2;
      } else
        t2 = 1;
      _this._depth = t2;
      _this._active = true;
      if (t1)
        _this._owner = $parent._owner;
      if (!!J.getInterceptor$(_this.get$widget().key).$isGlobalKey) {
        key = H.assertSubtype(_this.get$widget().key, "$isGlobalKey", [[N.State, N.StatefulWidget]], "$asGlobalKey");
        key.toString;
        $.GlobalKey__registry.$indexSet(0, key, _this);
      }
      _this._updateInheritance$0();
    },
    update$1: function(_, newWidget) {
      this._widget = newWidget;
    },
    updateSlotForChild$2: function(child, newSlot) {
      new N.Element_updateSlotForChild_visit(newSlot).call$1(child);
    },
    _updateSlot$1: function(newSlot) {
      this._slot = newSlot;
    },
    _updateDepth$1: function(parentDepth) {
      var expectedDepth, t1;
      if (typeof parentDepth !== "number")
        return parentDepth.$add();
      expectedDepth = parentDepth + 1;
      t1 = this._depth;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (t1 < expectedDepth) {
        this._depth = expectedDepth;
        this.visitChildren$1(new N.Element__updateDepth_closure(expectedDepth));
      }
    },
    detachRenderObject$0: function() {
      this.visitChildren$1(new N.Element_detachRenderObject_closure());
      this._slot = null;
    },
    attachRenderObject$1: function(newSlot) {
      this.visitChildren$1(new N.Element_attachRenderObject_closure(newSlot));
      this._slot = newSlot;
    },
    _retakeInactiveElement$2: function(key, newWidget) {
      var $parent,
        element = $.GlobalKey__registry.$index(0, H.assertSubtype(key, "$isGlobalKey", [[N.State, N.StatefulWidget]], "$asGlobalKey"));
      if (element == null)
        return;
      if (!N.Widget_canUpdate(element.get$widget(), newWidget))
        return;
      $parent = element._parent;
      if ($parent != null) {
        $parent.forgetChild$1(element);
        $parent.deactivateChild$1(element);
      }
      this._owner._inactiveElements._elements.remove$1(0, element);
      return element;
    },
    inflateWidget$2: function(newWidget, newSlot) {
      var newChild, _this = this,
        key = newWidget.key;
      if (!!J.getInterceptor$(key).$isGlobalKey) {
        newChild = _this._retakeInactiveElement$2(key, newWidget);
        if (newChild != null) {
          newChild._parent = _this;
          newChild._updateDepth$1(_this._depth);
          newChild.activate$0();
          newChild.visitChildren$1(N.framework_Element__activateRecursively$closure());
          newChild.attachRenderObject$1(newSlot);
          return _this.updateChild$3(newChild, newWidget, newSlot);
        }
      }
      newChild = newWidget.createElement$0(0);
      newChild.mount$2(_this, newSlot);
      return newChild;
    },
    deactivateChild$1: function(child) {
      var t1;
      child._parent = null;
      child.detachRenderObject$0();
      t1 = this._owner._inactiveElements;
      if (child._active) {
        child.deactivate$0();
        child.visitChildren$1(N.framework__InactiveElements__deactivateRecursively$closure());
      }
      t1._elements.add$1(0, child);
    },
    activate$0: function() {
      var _this = this,
        t1 = _this._dependencies,
        t2 = t1 == null,
        hadDependencies = !t2 && t1._collection$_length !== 0 || _this._hadUnsatisfiedDependencies;
      _this._active = true;
      if (!t2)
        t1.clear$0(0);
      _this._hadUnsatisfiedDependencies = false;
      _this._updateInheritance$0();
      if (_this._dirty)
        _this._owner.scheduleBuildFor$1(_this);
      if (hadDependencies)
        _this.markNeedsBuild$0();
    },
    deactivate$0: function() {
      var _this = this,
        t1 = _this._dependencies;
      if (t1 != null && t1._collection$_length !== 0)
        for (t1 = new P._HashSetIterator(t1, t1._computeElements$0(), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          t1._collection$_current._dependents.remove$1(0, _this);
      _this.set$_inheritedWidgets(null);
      _this._active = false;
    },
    unmount$0: function() {
      if (!!J.getInterceptor$(this.get$widget().key).$isGlobalKey) {
        var key = H.assertSubtype(this.get$widget().key, "$isGlobalKey", [[N.State, N.StatefulWidget]], "$asGlobalKey");
        key.toString;
        if (J.$eq$($.GlobalKey__registry.$index(0, key), this))
          $.GlobalKey__registry.remove$1(0, key);
      }
    },
    inheritFromWidgetOfExactType$1: function(targetType) {
      var _this = this,
        t1 = _this._inheritedWidgets,
        ancestor = t1 == null ? null : t1.$index(0, targetType);
      if (ancestor != null) {
        if (_this._dependencies == null)
          _this.set$_dependencies(P.HashSet_HashSet(N.InheritedElement));
        _this._dependencies.add$1(0, ancestor);
        ancestor._dependents.$indexSet(0, _this, null);
        return N.ProxyElement.prototype.get$widget.call(ancestor);
      }
      _this._hadUnsatisfiedDependencies = true;
      return;
    },
    _updateInheritance$0: function() {
      var t1 = this._parent;
      this.set$_inheritedWidgets(t1 == null ? null : t1._inheritedWidgets);
    },
    toStringShort$0: function() {
      return this.get$widget() != null ? this.get$widget().toStringShort$0() : "[" + new H.TypeImpl(H.getRti(this)).toString$0(0) + "]";
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, t4, _this = this, _null = null;
      _this.super$DiagnosticableMixin$debugFillProperties(properties);
      properties.defaultDiagnosticsTreeStyle = C.DiagnosticsTreeStyle_2;
      t1 = Y.ObjectFlagProperty$("depth", _this._depth, "no depth", P.int);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.ObjectFlagProperty$("widget", _this.get$widget(), "no widget", N.Widget));
      if (_this.get$widget() != null) {
        t1 = _this.get$widget();
        t1 = t1 == null ? _null : t1.key;
        C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("key", t1, true, _null, _null, false, _null, _null, C.DiagnosticLevel_0, false, false, true, C.DiagnosticsTreeStyle_7, _null, D.Key));
        _this.get$widget().debugFillProperties$1(properties);
      }
      t1 = _this._dirty;
      C.JSArray_methods.add$1(t2, new Y.FlagProperty("dirty", _null, _null, false, true, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, "dirty", true, false, _null, C.DiagnosticsTreeStyle_7));
      t1 = _this._dependencies;
      if (t1 != null && t1._collection$_length !== 0) {
        t3 = Y.DiagnosticsNode;
        t1.toString;
        t4 = H.getTypeArgumentByIndex(t1, 0);
        C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("dependencies", P.List_List$from(new H.EfficientLengthMappedIterable(t1, H.functionTypeCheck(new N.Element_debugFillProperties_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]), true, t3), true, C.C__NoDefaultValue, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, [P.List, Y.DiagnosticsNode]));
      }
    },
    debugDescribeChildren$0: function() {
      var children = H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
      this.visitChildren$1(new N.Element_debugDescribeChildren_closure(children));
      return children;
    },
    markNeedsBuild$0: function() {
      var _this = this;
      if (!_this._active)
        return;
      if (_this._dirty)
        return;
      _this._dirty = true;
      _this._owner.scheduleBuildFor$1(_this);
    },
    rebuild$0: function() {
      if (!this._active || !this._dirty)
        return;
      this.performRebuild$0();
    },
    set$_inheritedWidgets: function(_inheritedWidgets) {
      this._inheritedWidgets = H.assertSubtype(_inheritedWidgets, "$isMap", [P.Type, N.InheritedElement], "$asMap");
    },
    set$_dependencies: function(_dependencies) {
      this._dependencies = H.assertSubtype(_dependencies, "$isSet", [N.InheritedElement], "$asSet");
    },
    $isBuildContext: 1
  };
  N.Element_updateSlotForChild_visit.prototype = {
    call$1: function(element) {
      element._updateSlot$1(this.newSlot);
      if (!element.$isRenderObjectElement)
        element.visitChildren$1(this);
    },
    $signature: 13
  };
  N.Element__updateDepth_closure.prototype = {
    call$1: function(child) {
      child._updateDepth$1(this.expectedDepth);
    },
    $signature: 7
  };
  N.Element_detachRenderObject_closure.prototype = {
    call$1: function(child) {
      child.detachRenderObject$0();
    },
    $signature: 7
  };
  N.Element_attachRenderObject_closure.prototype = {
    call$1: function(child) {
      child.attachRenderObject$1(this.newSlot);
    },
    $signature: 7
  };
  N.Element_debugFillProperties_closure.prototype = {
    call$1: function(element) {
      var t1;
      H.interceptedTypeCheck(element, "$isInheritedElement");
      t1 = N.ProxyElement.prototype.get$widget.call(element);
      t1.toString;
      return new Y._DiagnosticableTreeNode(t1, null, true, true, null, C.DiagnosticsTreeStyle_0);
    },
    $signature: 138
  };
  N.Element_debugDescribeChildren_closure.prototype = {
    call$1: function(child) {
      var t1 = this.children;
      if (child != null)
        C.JSArray_methods.add$1(t1, new Y._DiagnosticableTreeNode(child, null, true, true, null, null));
      else
        C.JSArray_methods.add$1(t1, Y.DiagnosticsNode_DiagnosticsNode$message("<null child>", true));
    },
    $signature: 7
  };
  N.ErrorWidget.prototype = {
    createRenderObject$1: function(context) {
      return V.RenderErrorBox$(this.message);
    },
    debugFillProperties$1: function(properties) {
      var t1;
      this.super$Widget$debugFillProperties(properties);
      t1 = this._flutterError;
      if (t1 == null) {
        t1 = Y.StringProperty$("message", this.message, C.C__NoDefaultValue, false, true);
        C.JSArray_methods.add$1(properties.properties, t1);
      } else
        C.JSArray_methods.add$1(properties.properties, new Y._DiagnosticableTreeNode(t1, null, true, true, null, C.DiagnosticsTreeStyle_5));
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  N.ErrorWidget_closure.prototype = {
    call$1: function(details) {
      var t1 = details.exception,
        t2 = N.ErrorWidget__stringify(t1);
      t1 = t1 instanceof U.FlutterError ? t1 : null;
      return new N.ErrorWidget(t2, t1, new N.UniqueKey());
    },
    $signature: 101
  };
  N.ComponentElement.prototype = {
    mount$2: function($parent, newSlot) {
      this.super$Element$mount($parent, newSlot);
      this.rebuild$0();
    },
    performRebuild$0: function() {
      var built, e, stack, e0, stack0, exception, t2, _this = this, _null = null,
        t1 = $.debugProfileBuildsEnabled;
      if (t1)
        P.Timeline_startSync(J.get$runtimeType$(_this.get$widget()).toString$0(0), C.Map_9aZ6I, _null);
      built = null;
      try {
        built = _this.build$0();
        _this.get$widget();
      } catch (exception) {
        e = H.unwrapException(exception);
        stack = H.getTraceFromException(exception);
        t1 = $.$get$ErrorWidget_builder();
        t2 = H.setRuntimeTypeInfo(["building " + _this.toString$0(0)], [P.Object]);
        built = t1.call$1(N._debugReportException(new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t2, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), e, stack, _null));
      } finally {
        _this._dirty = false;
      }
      try {
        _this._framework$_child = _this.updateChild$3(_this._framework$_child, built, _this._slot);
      } catch (exception) {
        e0 = H.unwrapException(exception);
        stack0 = H.getTraceFromException(exception);
        t1 = $.$get$ErrorWidget_builder();
        t2 = H.setRuntimeTypeInfo(["building " + _this.toString$0(0)], [P.Object]);
        built = t1.call$1(N._debugReportException(new U.ErrorDescription(_null, false, true, _null, _null, _null, false, t2, _null, C.DiagnosticLevel_3, _null, false, false, _null, C.DiagnosticsTreeStyle_6), e0, stack0, _null));
        _this._framework$_child = _this.updateChild$3(_null, built, _this._slot);
      }
      t1 = $.debugProfileBuildsEnabled;
      if (t1)
        P.Timeline_finishSync();
    },
    visitChildren$1: function(visitor) {
      var t1;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [N.Element]});
      t1 = this._framework$_child;
      if (t1 != null)
        visitor.call$1(t1);
    },
    forgetChild$1: function(child) {
      this._framework$_child = null;
    }
  };
  N.StatelessElement.prototype = {
    get$widget: function() {
      return H.interceptedTypeCheck(N.Element.prototype.get$widget.call(this), "$isStatelessWidget");
    },
    build$0: function() {
      var effectiveTextStyle, t2, _this = this, _null = null,
        t1 = H.interceptedTypeCheck(N.Element.prototype.get$widget.call(_this), "$isStatelessWidget");
      t1.toString;
      _this.inheritFromWidgetOfExactType$1(C.Type_DefaultTextStyle_ird);
      effectiveTextStyle = C.TextStyle_v9c.merge$1(_null);
      F.MediaQuery_of(_this, true);
      t2 = t1.textDirection;
      F.MediaQuery_of(_this, true);
      t1 = t1.data;
      t1 = Q.TextSpan$(_null, effectiveTextStyle, t1);
      return new T.RichText(t1, C.TextAlign_4, t2, true, C.TextOverflow_0, 1, _null, _null, _null);
    },
    update$1: function(_, newWidget) {
      this.super$Element$update(0, H.interceptedTypeCheck(newWidget, "$isStatelessWidget"));
      this._dirty = true;
      this.rebuild$0();
    }
  };
  N.ProxyElement.prototype = {};
  N.InheritedElement.prototype = {};
  N.RenderObjectElement.prototype = {
    get$widget: function() {
      return H.interceptedTypeCheck(N.Element.prototype.get$widget.call(this), "$isRenderObjectWidget");
    },
    get$renderObject: function() {
      return this._renderObject;
    },
    _findAncestorRenderObjectElement$0: function() {
      var ancestor = this._parent;
      while (true) {
        if (!(ancestor != null && !ancestor.$isRenderObjectElement))
          break;
        ancestor = ancestor._parent;
      }
      return H.interceptedTypeCheck(ancestor, "$isRenderObjectElement");
    },
    _findAncestorParentDataElement$0: function() {
      var ancestor = this._parent;
      while (true) {
        if (!(ancestor != null && !ancestor.$isRenderObjectElement))
          break;
        if (!!J.getInterceptor$(ancestor).$isParentDataElement)
          return ancestor;
        ancestor = ancestor._parent;
      }
      return;
    },
    mount$2: function($parent, newSlot) {
      var _this = this;
      _this.super$Element$mount($parent, newSlot);
      _this._renderObject = _this.get$widget().createRenderObject$1(_this);
      _this.attachRenderObject$1(newSlot);
      _this._dirty = false;
    },
    update$1: function(_, newWidget) {
      var _this = this;
      _this.super$Element$update(0, H.interceptedTypeCheck(newWidget, "$isRenderObjectWidget"));
      _this.get$widget().updateRenderObject$2(_this, _this.get$renderObject());
      _this._dirty = false;
    },
    performRebuild$0: function() {
      var _this = this;
      _this.get$widget().updateRenderObject$2(_this, _this.get$renderObject());
      _this._dirty = false;
    },
    deactivate$0: function() {
      this.super$Element$deactivate();
    },
    unmount$0: function() {
      this.super$Element$unmount();
      var t1 = this.get$widget();
      this.get$renderObject();
      t1.toString;
    },
    _updateSlot$1: function(newSlot) {
      var _this = this;
      _this.super$Element$_updateSlot(newSlot);
      _this._ancestorRenderObjectElement.moveChildRenderObject$2(_this.get$renderObject(), _this._slot);
    },
    attachRenderObject$1: function(newSlot) {
      var t1, _this = this;
      _this._slot = newSlot;
      t1 = _this._ancestorRenderObjectElement = _this._findAncestorRenderObjectElement$0();
      if (t1 != null)
        t1.insertChildRenderObject$2(_this.get$renderObject(), newSlot);
      _this._findAncestorParentDataElement$0();
    },
    detachRenderObject$0: function() {
      var _this = this,
        t1 = _this._ancestorRenderObjectElement;
      if (t1 != null) {
        t1.removeChildRenderObject$1(_this.get$renderObject());
        _this._ancestorRenderObjectElement = null;
      }
      _this._slot = null;
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Element$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("renderObject", this.get$renderObject(), true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, K.RenderObject);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  N.RootRenderObjectElement.prototype = {
    mount$2: function($parent, newSlot) {
      this.super$RenderObjectElement$mount($parent, newSlot);
    }
  };
  N.LeafRenderObjectElement.prototype = {
    forgetChild$1: function(child) {
    },
    insertChildRenderObject$2: function(child, slot) {
    },
    moveChildRenderObject$2: function(child, slot) {
    },
    removeChildRenderObject$1: function(child) {
    },
    debugDescribeChildren$0: function() {
      H.interceptedTypeCheck(N.Element.prototype.get$widget.call(this), "$isRenderObjectWidget").toString;
      return C.List_empty;
    }
  };
  L._LocalizationsScope.prototype = {};
  F.MediaQuery.prototype = {};
  L.DefaultTextStyle.prototype = {};
  L.Text.prototype = {
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.StringProperty$("data", this.data, C.C__NoDefaultValue, true, false);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, _null, _null, C.DiagnosticLevel_3, "textAlign", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextAlign]));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, this.textDirection, _null, C.DiagnosticLevel_3, "textDirection", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextDirection]));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("locale", _null, true, _null, _null, false, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_7, _null, Q.Locale));
      C.JSArray_methods.add$1(t2, new Y.FlagProperty("wrapping at box width", "no wrapping except at line break characters", _null, false, true, _null, _null, _null, false, _null, _null, C.DiagnosticLevel_3, "softWrap", true, true, _null, C.DiagnosticsTreeStyle_7));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, false, true, _null, _null, _null, false, _null, _null, C.DiagnosticLevel_3, "overflow", true, true, _null, C.DiagnosticsTreeStyle_7, [Q.TextOverflow]));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("textScaleFactor", _null, _null, C.DiagnosticLevel_3, _null, _null));
      C.JSArray_methods.add$1(t2, Y.IntProperty$("maxLines", _null, _null, _null, C.DiagnosticLevel_3));
    }
  };
  T.webOnlyInitializeEngine_closure.prototype = {
    call$2: function(_, __) {
      var t1, _i;
      H.stringTypeCheck(_);
      t1 = P.String;
      H.assertSubtype(__, "$isMap", [t1, t1], "$asMap");
      for (t1 = $._hotRestartListeners.length, _i = 0; _i < $._hotRestartListeners.length; $._hotRestartListeners.length === t1 || (0, H.throwConcurrentModificationError)($._hotRestartListeners), ++_i)
        $._hotRestartListeners[_i].call$0();
      t1 = new P._Future($.Zone__current, [P.ServiceExtensionResponse]);
      t1._asyncComplete$1(new P.ServiceExtensionResponse("OK", null, null));
      return t1;
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 32
  };
  T.webOnlyInitializeEngine_closure0.prototype = {
    call$0: function() {
      var t1 = this._box_0;
      if (!t1.waitingForAnimation) {
        t1.waitingForAnimation = true;
        C.Window_methods.requestAnimationFrame$1(window, new T.webOnlyInitializeEngine__closure(t1));
      }
    },
    $signature: 0
  };
  T.webOnlyInitializeEngine__closure.prototype = {
    call$1: function(highResTime) {
      var highResTimeMicroseconds, t1;
      H.numTypeCheck(highResTime);
      this._box_0.waitingForAnimation = false;
      if (typeof highResTime !== "number")
        return H.iae(highResTime);
      highResTimeMicroseconds = C.JSNumber_methods.toInt$0(1000 * highResTime);
      t1 = $.$get$window();
      if (t1._onBeginFrame != null)
        t1.onBeginFrame$1(P.Duration$(highResTimeMicroseconds, 0, 0));
      if (t1._onDrawFrame != null)
        t1.onDrawFrame$0();
    },
    $signature: 17
  };
  T.AlarmClock.prototype = {
    set$datetime: function(value) {
      var now, t1, t2, _this = this;
      if (J.$eq$(value, _this._datetime))
        return;
      if (value == null) {
        _this._cancelTimer$0();
        return _this._datetime = null;
      }
      now = _this._timestampFunction.call$0();
      t1 = value._core$_value;
      t2 = now._core$_value;
      if (t1 < t2) {
        _this._cancelTimer$0();
        _this._datetime = value;
        return;
      }
      if (_this._timer == null)
        _this._timer = P.Timer_Timer(P.Duration$(0, t1 - t2, 0), _this.get$_timerDidFire());
      else if (_this._datetime._core$_value > t1) {
        _this._cancelTimer$0();
        _this._timer = P.Timer_Timer(P.Duration$(0, t1 - t2, 0), _this.get$_timerDidFire());
      }
      _this._datetime = value;
    },
    _cancelTimer$0: function() {
      var t1 = this._timer;
      if (t1 != null) {
        t1.cancel$0(0);
        this._timer = null;
      }
    },
    _timerDidFire$0: function() {
      var _this = this,
        now = _this._timestampFunction.call$0(),
        t1 = _this._datetime,
        t2 = now._core$_value;
      t1 = t1._core$_value;
      if (t2 >= t1) {
        _this._timer = null;
        _this.callback.call$0();
      } else
        _this._timer = P.Timer_Timer(P.Duration$(0, t1 - t2, 0), _this.get$_timerDidFire());
    },
    set$callback: function(callback) {
      this.callback = H.functionTypeCheck(callback, {func: 1, ret: -1});
    },
    get$callback: function() {
      return this.callback;
    }
  };
  T.AssetManager.prototype = {
    getAssetUrl$1: function(asset) {
      return P.Uri_parse(asset).get$hasScheme() ? asset : "assets/" + H.S(asset);
    },
    load$1: function(_, asset) {
      return this.load$body$AssetManager(_, asset);
    },
    load$body$AssetManager: function(_, asset) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.ByteData),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, request, response, e, target, t1, exception, url, $async$exception;
      var $async$load$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              url = $async$self.getAssetUrl$1(asset);
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait(W.HttpRequest_request(url, "arraybuffer"), $async$load$1);
            case 7:
              // returning from await.
              request = $async$result;
              response = H.interceptedTypeCheck(W._convertNativeToDart_XHR_Response(request.response), "$isByteBuffer");
              t1 = response;
              t1.toString;
              t1 = H.NativeByteData_NativeByteData$view(t1, 0, null);
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = H.unwrapException($async$exception);
              if (!!J.getInterceptor$(t1).$isProgressEvent) {
                e = t1;
                target = W._convertNativeToDart_EventTarget(e.target);
                if (!!J.getInterceptor$(target).$isHttpRequest) {
                  if (target.status === 404 && asset === "AssetManifest.json") {
                    t1 = "Asset manifest does not exist at `" + H.S(url) + "` \u2013 ignoring.";
                    if (typeof console != "undefined")
                      window.console.warn(t1);
                    t1 = new Uint8Array(H._ensureNativeList(C.C_Utf8Codec.get$encoder().convert$1("{}"))).buffer;
                    t1.toString;
                    $async$returnValue = H.NativeByteData_NativeByteData$view(t1, 0, null);
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  throw H.wrapException(new T.AssetManagerException(url, target.status));
                }
                throw $async$exception;
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$load$1, $async$completer);
    }
  };
  T.AssetManagerException.prototype = {
    toString$0: function(_) {
      return 'Failed to load asset at "' + H.S(this.url) + '" (' + H.S(this.httpStatus) + ")";
    },
    $isException: 1
  };
  T.BitmapCanvas.prototype = {
    dispose$0: function() {
      this.super$EngineCanvas$dispose();
      var t1 = $._browserEngine;
      if ((t1 == null ? $._browserEngine = T._detectBrowserEngine() : t1) === C.BrowserEngine_1) {
        t1 = this._engine$_canvas;
        t1.width = t1.height = 0;
      }
    },
    clear$0: function(_) {
      var t1, len, i, t2, t3, _this = this;
      _this.super$SaveStackTracking$clear(0);
      t1 = _this._engine$_children;
      len = t1.length;
      for (i = 0; i < len; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = t1[i];
        t3 = t2.parentNode;
        if (t3 != null)
          t3.removeChild(t2);
      }
      C.JSArray_methods.set$length(t1, 0);
      _this._cachedLastStyle = null;
      t1 = _this._ctx;
      if (t1 != null) {
        t1.restore();
        _this._ctx.clearRect(0, 0, _this._widthInBitmapPixels, _this._heightInBitmapPixels);
        _this._ctx.font = "";
        _this._initializeViewport$0();
      }
      t1 = _this._engine$_canvas;
      if (t1 != null) {
        t1 = t1.style;
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "transform-origin"), "", "");
        t1 = _this._engine$_canvas.style;
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "transform"), "", "");
      }
    },
    _initializeViewport$0: function() {
      var canvasPositionX, canvasPositionY, t1, t2, t3, t4, _this = this;
      _this._ctx.save();
      _this._ctx.setTransform(1, 0, 0, 1, 0, 0);
      _this._ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      canvasPositionX = J.floor$0$n(_this._bounds.left) - 1;
      canvasPositionY = J.floor$0$n(_this._bounds.top) - 1;
      t1 = _this._bounds;
      t2 = t1.left;
      if (typeof t2 !== "number")
        return t2.$sub();
      t1 = t1.top;
      if (typeof t1 !== "number")
        return t1.$sub();
      t3 = _this.rootElement.style;
      t4 = "translate(" + canvasPositionX + "px, " + canvasPositionY + "px)";
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t3, (t3 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t3, "transform"), t4, "");
      t4 = _this._bounds;
      t3 = t4.left;
      if (typeof t3 !== "number")
        return t3.$negate();
      t2 = -t3 + (t2 - 1 - canvasPositionX) + 1;
      t4 = t4.top;
      if (typeof t4 !== "number")
        return t4.$negate();
      t1 = -t4 + (t1 - 1 - canvasPositionY) + 1;
      _this.super$SaveStackTracking$translate(0, t2, t1);
      _this._ctx.translate(t2, t1);
    },
    _applyPaint$1: function(paint) {
      var paintStyle, colorString, _this = this,
        t1 = _this._ctx,
        t2 = T._stringForBlendMode(paint.blendMode);
      t1.globalCompositeOperation = t2 == null ? "source-over" : t2;
      t1 = _this._ctx;
      t1.lineWidth = 1;
      t1.lineCap = "butt";
      t1.lineJoin = "miter";
      t2 = paint.shader;
      if (t2 != null) {
        paintStyle = t2.createPaintStyle$1(t1);
        _this._setFillAndStrokeStyle$2(paintStyle, paintStyle);
      } else {
        t1 = paint.color;
        if (t1 != null) {
          colorString = t1.toCssString$0();
          _this._setFillAndStrokeStyle$2(colorString, colorString);
        }
      }
    },
    _strokeOrFill$1: function(paint) {
      var _this = this;
      switch (paint.style) {
        case C.PaintingStyle_1:
          _this._ctx.stroke();
          break;
        case C.PaintingStyle_0:
        default:
          _this._ctx.fill();
          break;
      }
      _this._setFilter$1("none");
      _this._setFillAndStrokeStyle$2(null, null);
    },
    _setFilter$1: function(value) {
      if (this._prevFilter !== value)
        this._prevFilter = this._ctx.filter = value;
    },
    _setFillAndStrokeStyle$2: function(fillStyle, strokeStyle) {
      var _this = this,
        _ctx = _this._ctx,
        t1 = _this._prevFillStyle;
      if (t1 == null ? fillStyle != null : t1 !== fillStyle)
        _this._prevFillStyle = _ctx.fillStyle = fillStyle;
      t1 = _this._prevStrokeStyle;
      if (t1 == null ? strokeStyle != null : t1 !== strokeStyle)
        _this._prevStrokeStyle = _ctx.strokeStyle = strokeStyle;
    },
    save$0: function(_) {
      this.super$SaveStackTracking$save(0);
      this._ctx.save();
      return this._saveCount++;
    },
    restore$0: function(_) {
      var _this = this;
      _this.super$SaveStackTracking$restore(0);
      _this._ctx.restore();
      --_this._saveCount;
      _this._cachedLastStyle = null;
    },
    translate$2: function(_, dx, dy) {
      this.super$SaveStackTracking$translate(0, dx, dy);
      this._ctx.translate(dx, dy);
    },
    clipRect$1: function(rect) {
      var t1, t2, t3, _this = this;
      _this.super$SaveStackTracking$clipRect(rect);
      _this._ctx.beginPath();
      t1 = _this._ctx;
      t2 = rect.left;
      t3 = rect.top;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t1.rect(t2, t3, rect.right - t2, rect.bottom - t3);
      _this._ctx.clip();
    },
    drawRect$2: function(rect, paint) {
      var t1, t2, t3, _this = this;
      _this._applyPaint$1(paint);
      _this._ctx.beginPath();
      t1 = _this._ctx;
      t2 = rect.left;
      t3 = rect.top;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t1.rect(t2, t3, rect.right - t2, rect.bottom - t3);
      _this._strokeOrFill$1(paint);
    },
    drawParagraph$2: function(paragraph, offset) {
      var t1, t2, t3, t4, t5, paragraphElement, clipElements, _i, clipElement, cssTransform, _this = this,
        style = paragraph._paragraphGeometricStyle;
      if (paragraph._measurementResult.isSingleLine)
        if (paragraph._plainText != null)
          if (style.ellipsis == null)
            if (style.decoration == null)
              t1 = paragraph._background == null;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      if (t1) {
        if (!style.$eq(0, _this._cachedLastStyle)) {
          _this._ctx.font = style.get$cssFontString();
          _this._cachedLastStyle = style;
        }
        t1 = paragraph._paint;
        t1._frozen = true;
        _this._applyPaint$1(t1._paintData);
        t1 = _this._ctx;
        t2 = offset._dx;
        t3 = paragraph.webOnlyAlignOffset;
        if (typeof t2 !== "number")
          return t2.$add();
        t4 = offset._dy;
        t5 = paragraph.get$alphabeticBaseline(paragraph);
        if (typeof t4 !== "number")
          return t4.$add();
        (t1 && C.CanvasRenderingContext2D_methods).fillText$3(t1, paragraph._plainText, t2 + t3, t4 + t5);
        _this._setFilter$1("none");
        _this._setFillAndStrokeStyle$2(null, null);
        return;
      }
      paragraphElement = T._drawParagraphElement(paragraph, offset, null);
      t1 = _this.SaveStackTracking__clipStack;
      t2 = _this.SaveStackTracking__currentTransform;
      if (t1 != null) {
        clipElements = T._clipContent(t1, H.interceptedTypeCheck(paragraphElement, "$isHtmlElement"), offset, t2);
        for (t1 = clipElements.length, t2 = _this.rootElement, t3 = J.getInterceptor$x(t2), t4 = _this._engine$_children, _i = 0; _i < clipElements.length; clipElements.length === t1 || (0, H.throwConcurrentModificationError)(clipElements), ++_i) {
          clipElement = clipElements[_i];
          t3.append$1(t2, clipElement);
          C.JSArray_methods.add$1(t4, clipElement);
        }
      } else {
        cssTransform = T.float64ListToCssTransform(T.transformWithOffset(t2, offset)._engine$_m4storage);
        t1 = paragraphElement.style;
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "transform"), cssTransform, "");
        _this.rootElement.appendChild(paragraphElement);
      }
      C.JSArray_methods.add$1(_this._engine$_children, paragraphElement);
    },
    get$rootElement: function(receiver) {
      return this.rootElement;
    }
  };
  T.BrowserEngine.prototype = {
    toString$0: function(_) {
      return this._engine$_name;
    }
  };
  T.LocationStrategy.prototype = {};
  T.HashLocationStrategy.prototype = {
    onPopState$1: function(_, fn) {
      H.functionTypeCheck(fn, {func: 1, args: [W.Event]});
      C.Window_methods.addEventListener$2(window, "popstate", fn);
      return new T.HashLocationStrategy_onPopState_closure(this, fn);
    },
    prepareExternalUrl$1: function(internalUrl) {
      return internalUrl.length === 0 ? H.S(window.location.pathname) + H.S(window.location.search) : "#" + internalUrl;
    },
    _waitForPopState$0: function() {
      var t1 = {},
        t2 = -1,
        t3 = new P._Future($.Zone__current, [t2]);
      t1.unsubscribe = null;
      t1.unsubscribe = this.onPopState$1(0, new T.HashLocationStrategy__waitForPopState_closure(t1, new P._AsyncCompleter(t3, [t2])));
      return t3;
    }
  };
  T.HashLocationStrategy_onPopState_closure.prototype = {
    call$0: function() {
      var t1 = H.functionTypeCheck(this.fn, {func: 1, args: [W.Event]});
      C.Window_methods.removeEventListener$2(window, "popstate", t1);
      return;
    },
    $signature: 1
  };
  T.HashLocationStrategy__waitForPopState_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isEvent");
      this._box_0.unsubscribe.call$0();
      this.completer.complete$0(0);
    },
    $signature: 2
  };
  T.PlatformLocation.prototype = {};
  T.BrowserPlatformLocation.prototype = {};
  T.DomCanvas.prototype = {
    clear$0: function(_) {
      this.super$SaveElementStackTracking$clear(0);
      $.$get$domRenderer().clearDom$1(this.rootElement);
    },
    clipRect$1: function(rect) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    drawRect$2: function(rect, paint) {
      var $top, bottom, effectiveTransform, translated, style, cssColor, _this = this,
        rectangle = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("draw-rect", null), "$isElement0"),
        isStroke = paint.style === C.PaintingStyle_1,
        t1 = rect.left,
        t2 = rect.right,
        left = Math.min(H.checkNum(t1), t2),
        right = Math.max(H.checkNum(t1), t2);
      t2 = rect.top;
      t1 = rect.bottom;
      $top = Math.min(H.checkNum(t2), t1);
      bottom = Math.max(H.checkNum(t2), t1);
      if (_this.SaveElementStackTracking__currentTransform.isIdentity$0(0))
        effectiveTransform = isStroke ? "translate(" + H.S(C.JSNumber_methods.$sub(left, C.JSNull_methods.$div(paint.strokeWidth, 2))) + "px, " + H.S(C.JSNumber_methods.$sub($top, C.JSNull_methods.$div(paint.strokeWidth, 2))) + "px)" : "translate(" + H.S(left) + "px, " + H.S($top) + "px)";
      else {
        t1 = _this.SaveElementStackTracking__currentTransform;
        t2 = new Float64Array(16);
        translated = new T.Matrix40(t2);
        translated.setFrom$1(t1);
        if (isStroke)
          translated.translate$2(0, C.JSNumber_methods.$sub(left, C.JSNull_methods.$div(paint.strokeWidth, 2)), C.JSNumber_methods.$sub($top, C.JSNull_methods.$div(paint.strokeWidth, 2)));
        else
          translated.translate$2(0, left, $top);
        effectiveTransform = T.float64ListToCssTransform(t2);
      }
      style = rectangle.style;
      style.position = "absolute";
      C.CssStyleDeclaration_methods._setPropertyHelper$3(style, (style && C.CssStyleDeclaration_methods)._browserPropertyName$1(style, "transform-origin"), "0 0 0", "");
      C.CssStyleDeclaration_methods._setPropertyHelper$3(style, C.CssStyleDeclaration_methods._browserPropertyName$1(style, "transform"), effectiveTransform, "");
      t1 = paint.color;
      cssColor = t1 == null ? null : t1.toCssString$0();
      if (cssColor == null)
        cssColor = "#000000";
      t1 = right - left;
      if (isStroke) {
        t2 = paint.strokeWidth;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = H.S(t1 - t2) + "px";
        style.width = t2;
        t1 = paint.strokeWidth;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = H.S(bottom - $top - t1) + "px";
        style.height = t1;
        t1 = H.S(paint.strokeWidth) + "px solid " + cssColor;
        style.border = t1;
      } else {
        t1 = H.S(t1) + "px";
        style.width = t1;
        t1 = H.S(bottom - $top) + "px";
        style.height = t1;
        style.backgroundColor = cssColor;
      }
      t1 = _this.SaveElementStackTracking__elementStack;
      (t1.length === 0 ? _this.rootElement : C.JSArray_methods.get$last(t1)).appendChild(rectangle);
    },
    drawParagraph$2: function(paragraph, offset) {
      var paragraphElement = T._drawParagraphElement(paragraph, offset, this.SaveElementStackTracking__currentTransform),
        t1 = this.SaveElementStackTracking__elementStack;
      (t1.length === 0 ? this.rootElement : C.JSArray_methods.get$last(t1)).appendChild(paragraphElement);
    },
    get$rootElement: function(receiver) {
      return this.rootElement;
    }
  };
  T.DomRenderer.prototype = {
    renderScene$1: function(sceneElement) {
      var t1 = this._sceneElement;
      if (sceneElement == null ? t1 != null : sceneElement !== t1) {
        if (t1 != null)
          J.remove$0$ax(t1);
        this._sceneElement = sceneElement;
        this._sceneHostElement.appendChild(sceneElement);
      }
    },
    createElement$1: function(_, tagName) {
      var element = document.createElement(tagName);
      return element;
    },
    setElementStyle$3: function(element, $name, value) {
      var t1;
      if (value == null)
        element.style.removeProperty($name);
      else {
        t1 = element.style;
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, $name), value, null);
      }
    },
    reset$0: function(_) {
      var t2, sheet, bodyElement, t3, t4, initialInnerWidth, _this = this, _s1_ = "0", _s4_ = "none", _box_0 = {},
        t1 = _this._styleElement;
      if (t1 != null)
        C.StyleElement_methods.remove$0(t1);
      t1 = document;
      t2 = t1.createElement("style");
      _this._styleElement = t2;
      t1.head.appendChild(t2);
      sheet = H.interceptedTypeCheck(_this._styleElement.sheet, "$isCssStyleSheet");
      sheet.insertRule("flt-ruler-host p, flt-scene p {\n  margin: 0;\n}", sheet.cssRules.length);
      sheet.insertRule("flt-semantics input[type=range] {\n  appearance: none;\n  -webkit-appearance: none;\n  width: 100%;\n  position: absolute;\n  border: none;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}", sheet.cssRules.length);
      t2 = $._browserEngine;
      if ((t2 == null ? $._browserEngine = T._detectBrowserEngine() : t2) === C.BrowserEngine_1) {
        sheet.insertRule("flt-semantics input[type=range]::-webkit-slider-thumb {  -webkit-appearance: none;}", sheet.cssRules.length);
        sheet.insertRule("flt-semantics ::selection {  background-color: transparent;}", sheet.cssRules.length);
      }
      sheet.insertRule('flt-semantics input,\nflt-semantics textarea,\nflt-semantics [contentEditable="true"] {\n  caret-color: transparent;\n}\n', sheet.cssRules.length);
      t2 = $._browserEngine;
      if ((t2 == null ? $._browserEngine = T._detectBrowserEngine() : t2) === C.BrowserEngine_1)
        sheet.insertRule("flt-glass-pane * {\n  -webkit-tap-highlight-color: transparent;\n}\n", sheet.cssRules.length);
      bodyElement = t1.body;
      _this.setElementStyle$3(bodyElement, "position", "fixed");
      _this.setElementStyle$3(bodyElement, "top", _s1_);
      _this.setElementStyle$3(bodyElement, "right", _s1_);
      _this.setElementStyle$3(bodyElement, "bottom", _s1_);
      _this.setElementStyle$3(bodyElement, "left", _s1_);
      _this.setElementStyle$3(bodyElement, "overflow", "hidden");
      _this.setElementStyle$3(bodyElement, "padding", _s1_);
      _this.setElementStyle$3(bodyElement, "margin", _s1_);
      _this.setElementStyle$3(bodyElement, "user-select", _s4_);
      _this.setElementStyle$3(bodyElement, "-webkit-user-select", _s4_);
      _this.setElementStyle$3(bodyElement, "-ms-user-select", _s4_);
      _this.setElementStyle$3(bodyElement, "-moz-user-select", _s4_);
      _this.setElementStyle$3(bodyElement, "touch-action", _s4_);
      _this.setElementStyle$3(bodyElement, "font", "normal normal 14px sans-serif");
      _this.setElementStyle$3(bodyElement, "color", "red");
      for (t2 = t1.head, t3 = W.Element0, t2.toString, H.assertIsSubtype(t3, t3, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'querySelectorAll'."), t2 = new W._FrozenElementList(t2.querySelectorAll('meta[name="viewport"]'), [t3]), t3 = new H.ListIterator(t2, t2.get$length(t2), [t3]); t3.moveNext$0();) {
        t2 = t3._current;
        t4 = t2.parentNode;
        if (t4 != null)
          t4.removeChild(t2);
      }
      t2 = _this._viewportMeta;
      if (t2 != null)
        C.MetaElement_methods.remove$0(t2);
      t2 = t1.createElement("meta");
      t2.setAttribute("flt-viewport", "");
      t2.name = "viewport";
      t2.content = "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no";
      _this._viewportMeta = t2;
      t1.head.appendChild(t2);
      t2 = _this._sceneHostElement;
      if (t2 != null)
        J.remove$0$ax(t2);
      t1 = _this.createElement$1(0, "flt-scene-host");
      _this._sceneHostElement = t1;
      bodyElement.appendChild(t1);
      t1 = _this._glassPaneElement;
      if (t1 != null)
        J.remove$0$ax(t1);
      t1 = _this._glassPaneElement = _this.createElement$1(0, "flt-glass-pane");
      t2 = t1.style;
      t2.position = "absolute";
      t2.top = _s1_;
      t2.right = _s1_;
      t2.bottom = _s1_;
      t2.left = _s1_;
      bodyElement.appendChild(t1);
      T.EngineSemanticsOwner_instance().autoEnableOnTap$1(_this);
      if ($.PointerBinding__instance == null) {
        t1 = $.PointerBinding__instance = new T.PointerBinding(_this);
        t1._detector = C.C_PointerSupportDetector;
        t1._adapter = t1._createAdapter$0();
      }
      _this._sceneHostElement.setAttribute("aria-hidden", "true");
      $.$get$window().toString;
      t1 = $._browserEngine;
      if ((t1 == null ? $._browserEngine = T._detectBrowserEngine() : t1) === C.BrowserEngine_1) {
        initialInnerWidth = window.innerWidth;
        _box_0.checkCount = 0;
        P.Timer_Timer$periodic(C.Duration_100000, new T.DomRenderer_reset_closure(_box_0, _this, initialInnerWidth));
      }
      t1 = W.Event;
      _this.set$_resizeSubscription(W._EventStreamSubscription$(window, "resize", H.functionTypeCheck(_this.get$_metricsDidChange(), {func: 1, ret: -1, args: [t1]}), false, t1));
    },
    _metricsDidChange$1: function($event) {
      var t1 = $.$get$window();
      if (t1._onMetricsChanged != null)
        t1.onMetricsChanged$0();
    },
    clearDom$1: function(node) {
      var t1, t2;
      for (; t1 = node.lastChild, t1 != null;) {
        t2 = t1.parentNode;
        if (t2 != null)
          t2.removeChild(t1);
      }
    },
    set$_resizeSubscription: function(_resizeSubscription) {
      this._resizeSubscription = H.assertSubtype(_resizeSubscription, "$isStreamSubscription", [W.Event], "$asStreamSubscription");
    }
  };
  T.DomRenderer_reset_closure.prototype = {
    call$1: function(t) {
      var t1;
      H.interceptedTypeCheck(t, "$isTimer");
      t1 = ++this._box_0.checkCount;
      if (this.initialInnerWidth != window.innerWidth) {
        t.cancel$0(0);
        t1 = $.$get$window();
        if (t1._onMetricsChanged != null)
          t1.onMetricsChanged$0();
      } else if (t1 > 5)
        t.cancel$0(0);
    },
    $signature: 104
  };
  T.EngineCanvas.prototype = {
    dispose$0: function() {
      this.clear$0(0);
    }
  };
  T._SaveStackEntry.prototype = {};
  T._SaveClipEntry.prototype = {};
  T.SaveStackTracking.prototype = {
    clear$0: function(_) {
      var t1;
      C.JSArray_methods.set$length(this.SaveStackTracking__saveStack, 0);
      this.set$_clipStack(null);
      t1 = new T.Matrix40(new Float64Array(16));
      t1.setIdentity$0();
      this.SaveStackTracking__currentTransform = t1;
    },
    save$0: function(_) {
      var t1 = this.SaveStackTracking__currentTransform,
        t2 = new T.Matrix40(new Float64Array(16));
      t2.setFrom$1(t1);
      t1 = this.SaveStackTracking__clipStack;
      t1 = t1 == null ? null : P.List_List$from(t1, true, T._SaveClipEntry);
      C.JSArray_methods.add$1(this.SaveStackTracking__saveStack, new T._SaveStackEntry(t2, t1));
    },
    restore$0: function(_) {
      var entry,
        t1 = this.SaveStackTracking__saveStack,
        t2 = t1.length;
      if (t2 === 0)
        return;
      if (0 >= t2)
        return H.ioore(t1, -1);
      entry = t1.pop();
      this.SaveStackTracking__currentTransform = entry.transform;
      this.set$_clipStack(entry.clipStack);
    },
    translate$2: function(_, dx, dy) {
      this.SaveStackTracking__currentTransform.translate$2(0, dx, dy);
    },
    clipRect$1: function(rect) {
      var t1, t2, t3, _this = this;
      if (_this.SaveStackTracking__clipStack == null)
        _this.set$_clipStack(H.setRuntimeTypeInfo([], [T._SaveClipEntry]));
      t1 = _this.SaveStackTracking__clipStack;
      t2 = _this.SaveStackTracking__currentTransform;
      t3 = new T.Matrix40(new Float64Array(16));
      t3.setFrom$1(t2);
      (t1 && C.JSArray_methods).add$1(t1, new T._SaveClipEntry(rect, t3));
    },
    set$_clipStack: function(_clipStack) {
      this.SaveStackTracking__clipStack = H.assertSubtype(_clipStack, "$isList", [T._SaveClipEntry], "$asList");
    }
  };
  T.BrowserHistory.prototype = {
    get$currentPath: function() {
      var t1, path;
      if (this._locationStrategy == null)
        t1 = null;
      else {
        path = window.location.hash;
        if (path == null)
          path = "";
        t1 = T.ensureLeading(path.length === 0 ? path : C.JSString_methods.substring$1(path, 1), "/");
      }
      return t1 == null ? "/" : t1;
    },
    exit$0: function() {
      var backFuture, _this = this,
        t1 = _this._locationStrategy;
      if (t1 != null) {
        _this._tearoffStrategy$1(t1);
        t1 = _this._locationStrategy;
        t1.toString;
        window.history.back();
        backFuture = t1._waitForPopState$0();
        _this._locationStrategy = null;
        return backFuture;
      }
      t1 = new P._Future($.Zone__current, [-1]);
      t1._asyncComplete$1(null);
      return t1;
    },
    _popStateListener$1: function($event) {
      var t1, t2, newRouteName, _this = this,
        _s18_ = "flutter/navigation";
      H.interceptedTypeCheck($event, "$isPopStateEvent");
      t1 = new P._AcceptStructuredCloneDart2Js([], []).convertNativeToDart_AcceptStructuredClone$2$mustCopy($event.state, true);
      t2 = J.getInterceptor$(t1);
      if (!!t2.$isMap && J.$eq$(t2.$index(t1, "origin"), true)) {
        _this._setupFlutterEntry$1(_this._locationStrategy);
        $.$get$window().onPlatformMessage$3(_s18_, C.C_JSONMethodCodec.encodeMethodCall$1(C.MethodCall_popRoute_null), new T.BrowserHistory__popStateListener_closure());
      } else if (T._isFlutterEntry(new P._AcceptStructuredCloneDart2Js([], []).convertNativeToDart_AcceptStructuredClone$2$mustCopy($event.state, true))) {
        newRouteName = _this._userProvidedRouteName;
        _this._userProvidedRouteName = null;
        $.$get$window().onPlatformMessage$3(_s18_, C.C_JSONMethodCodec.encodeMethodCall$1(new T.MethodCall("pushRoute", newRouteName)), new T.BrowserHistory__popStateListener_closure0());
      } else {
        _this._userProvidedRouteName = _this.get$currentPath();
        t1 = _this._locationStrategy;
        t1.toString;
        window.history.back();
        t1._waitForPopState$0();
      }
    },
    _setupFlutterEntry$3$path$replace: function(strategy, path, replace) {
      var t1, t2, t3;
      if (path == null)
        path = this.get$currentPath();
      t1 = $._flutterState;
      t2 = strategy.prepareExternalUrl$1(path);
      t3 = window.history;
      t3.toString;
      t3.pushState(new P._StructuredCloneDart2Js([], []).walk$1(t1), "flutter", t2);
    },
    _setupFlutterEntry$1: function(strategy) {
      return this._setupFlutterEntry$3$path$replace(strategy, null, false);
    },
    _setupStrategy$1: function(strategy) {
      var path, t1, t2, t3, _this = this;
      if (strategy == null)
        return;
      path = _this.get$currentPath();
      if (!T._isFlutterEntry(new P._AcceptStructuredCloneDart2Js([], []).convertNativeToDart_AcceptStructuredClone$2$mustCopy(window.history.state, true))) {
        t1 = $._originState;
        t2 = strategy.prepareExternalUrl$1("");
        t3 = window.history;
        t3.toString;
        t3.replaceState(new P._StructuredCloneDart2Js([], []).walk$1(t1), "origin", t2);
        _this._setupFlutterEntry$3$path$replace(strategy, path, false);
      }
      _this.set$_unsubscribe(strategy.onPopState$1(0, H.functionTypeCheck(_this.get$_popStateListener(), {func: 1, args: [W.Event]})));
    },
    _tearoffStrategy$1: function(strategy) {
      if (strategy == null)
        return;
      this._unsubscribe.call$0();
      this.set$_unsubscribe(null);
      window.history.back();
      strategy._waitForPopState$0();
    },
    set$_unsubscribe: function(_unsubscribe) {
      this._unsubscribe = H.functionTypeCheck(_unsubscribe, {func: 1, ret: -1});
    }
  };
  T.BrowserHistory__popStateListener_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isByteData");
    },
    $signature: 12
  };
  T.BrowserHistory__popStateListener_closure0.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isByteData");
    },
    $signature: 12
  };
  T._SaveElementStackEntry.prototype = {};
  T.SaveElementStackTracking.prototype = {
    clear$0: function(_) {
      var t1;
      C.JSArray_methods.set$length(this.SaveElementStackTracking__saveStack, 0);
      C.JSArray_methods.set$length(this.SaveElementStackTracking__elementStack, 0);
      t1 = new T.Matrix40(new Float64Array(16));
      t1.setIdentity$0();
      this.SaveElementStackTracking__currentTransform = t1;
    },
    save$0: function(_) {
      var t2, t3, _this = this,
        t1 = _this.SaveElementStackTracking__elementStack;
      t1 = t1.length === 0 ? _this.rootElement : C.JSArray_methods.get$last(t1);
      t2 = _this.SaveElementStackTracking__currentTransform;
      t3 = new T.Matrix40(new Float64Array(16));
      t3.setFrom$1(t2);
      C.JSArray_methods.add$1(_this.SaveElementStackTracking__saveStack, new T._SaveElementStackEntry(t1, t3));
    },
    restore$0: function(_) {
      var entry, t3, _this = this,
        t1 = _this.SaveElementStackTracking__saveStack,
        t2 = t1.length;
      if (t2 === 0)
        return;
      if (0 >= t2)
        return H.ioore(t1, -1);
      entry = t1.pop();
      _this.SaveElementStackTracking__currentTransform = entry.transform;
      t1 = _this.SaveElementStackTracking__elementStack;
      t2 = entry.savedElement;
      t3 = _this.rootElement;
      while (true) {
        if (!((t1.length === 0 ? t3 : C.JSArray_methods.get$last(t1)) !== t2))
          break;
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        t1.pop();
      }
    },
    translate$2: function(_, dx, dy) {
      this.SaveElementStackTracking__currentTransform.translate$2(0, dx, dy);
    }
  };
  T.Keyboard.prototype = {
    Keyboard$_$0: function() {
      var _this = this;
      _this.set$_keydownListener(new T.Keyboard$__closure(_this));
      C.Window_methods.addEventListener$2(window, "keydown", _this._keydownListener);
      _this.set$_keyupListener(new T.Keyboard$__closure0(_this));
      C.Window_methods.addEventListener$2(window, "keyup", _this._keyupListener);
      C.JSArray_methods.add$1($._hotRestartListeners, new T.Keyboard$__closure1(_this));
    },
    dispose$0: function() {
      var _this = this;
      C.Window_methods.removeEventListener$2(window, "keydown", _this._keydownListener);
      C.Window_methods.removeEventListener$2(window, "keyup", _this._keyupListener);
      _this.set$_keydownListener(null);
      _this.set$_keyupListener(null);
      $.Keyboard__instance = null;
    },
    _handleHtmlEvent$1: function($event) {
      var eventData = P.LinkedHashMap_LinkedHashMap$_literal(["type", $event.type, "keymap", "android", "keyCode", $event.keyCode], P.String, null),
        t1 = $event.key;
      if (t1.length === 1) {
        t1 = new H.CodeUnits(t1);
        eventData.$indexSet(0, "codePoint", t1.get$first(t1));
      }
      $.$get$window().onPlatformMessage$3("flutter/keyevent", C.C_JSONMessageCodec0.encodeMessage$1(eventData), T.engine___noopCallback$closure());
    },
    set$_keydownListener: function(_keydownListener) {
      this._keydownListener = H.functionTypeCheck(_keydownListener, {func: 1, args: [W.Event]});
    },
    set$_keyupListener: function(_keyupListener) {
      this._keyupListener = H.functionTypeCheck(_keyupListener, {func: 1, args: [W.Event]});
    }
  };
  T.Keyboard$__closure.prototype = {
    call$1: function($event) {
      this.$this._handleHtmlEvent$1(H.interceptedTypeCheck(H.interceptedTypeCheck($event, "$isEvent"), "$isKeyboardEvent"));
    },
    $signature: 2
  };
  T.Keyboard$__closure0.prototype = {
    call$1: function($event) {
      this.$this._handleHtmlEvent$1(H.interceptedTypeCheck(H.interceptedTypeCheck($event, "$isEvent"), "$isKeyboardEvent"));
    },
    $signature: 2
  };
  T.Keyboard$__closure1.prototype = {
    call$0: function() {
      var t1 = this.$this;
      C.Window_methods.removeEventListener$2(window, "keydown", t1._keydownListener);
      C.Window_methods.removeEventListener$2(window, "keyup", t1._keyupListener);
      t1.set$_keydownListener(null);
      t1.set$_keyupListener(null);
      $.Keyboard__instance = null;
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  T.PlatformViewRegistry.prototype = {};
  T.PointerBinding.prototype = {
    _createAdapter$0: function() {
      var t1, _this = this;
      _this._detector.toString;
      if ("PointerEvent" in window) {
        t1 = new T.PointerAdapter(_this.domRenderer, _this.get$_onPointerData(), P.LinkedHashMap_LinkedHashMap$_empty(P.int, P.bool));
        t1._setup$0();
        return t1;
      }
      if ("TouchEvent" in window) {
        t1 = new T.TouchAdapter(_this.domRenderer, _this.get$_onPointerData(), P.LinkedHashMap_LinkedHashMap$_empty(P.int, P.bool));
        t1._setup$0();
        return t1;
      }
      if ("MouseEvent" in window) {
        t1 = new T.MouseAdapter(_this.domRenderer, _this.get$_onPointerData(), P.LinkedHashMap_LinkedHashMap$_empty(P.int, P.bool));
        t1._setup$0();
        return t1;
      }
      return;
    },
    _onPointerData$1: function(data) {
      H.assertSubtype(data, "$isList", [Q.PointerData], "$asList");
      $.$get$window().onPointerDataPacket$1(new Q.PointerDataPacket(data));
    }
  };
  T.PointerSupportDetector.prototype = {
    toString$0: function(_) {
      return "pointers:" + ("PointerEvent" in window) + ", touch:" + ("TouchEvent" in window) + ", mouse:" + ("MouseEvent" in window);
    }
  };
  T.BaseAdapter.prototype = {
    _engine$_addEventListener$2: function(_, eventName, handler) {
      var loggedHandler = new T.BaseAdapter__addEventListener_closure(H.functionTypeCheck(handler, {func: 1, args: [W.Event]}));
      $.BaseAdapter__listeners.$indexSet(0, eventName, loggedHandler);
      J.addEventListener$3$x(this.domRenderer._glassPaneElement, eventName, loggedHandler, true);
    }
  };
  T.BaseAdapter__addEventListener_closure.prototype = {
    call$1: function($event) {
      H.interceptedTypeCheck($event, "$isEvent");
      if (T.EngineSemanticsOwner_instance().receiveGlobalEvent$1($event))
        this.handler.call$1($event);
    },
    $signature: 2
  };
  T.PointerAdapter.prototype = {
    _setup$0: function() {
      var _this = this;
      _this._engine$_addEventListener$2(0, "pointerdown", new T.PointerAdapter__setup_closure(_this));
      _this._engine$_addEventListener$2(0, "pointermove", new T.PointerAdapter__setup_closure0(_this));
      _this._engine$_addEventListener$2(0, "pointerup", new T.PointerAdapter__setup_closure1(_this));
      _this._engine$_addEventListener$2(0, "pointercancel", new T.PointerAdapter__setup_closure2(_this));
      T._addWheelEventListener(new T.PointerAdapter__setup_closure3(_this));
    },
    _convertEventToPointerData$2: function(change, evt) {
      var data, i, $event, ms, t3, t4, t5, t6, t7, t8, t9, t10,
        allEvents = this._expandEvents$1(evt),
        t1 = J.getInterceptor$asx(allEvents),
        t2 = t1.get$length(allEvents);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = new Array(t2);
      t2.fixed$length = Array;
      data = H.setRuntimeTypeInfo(t2, [Q.PointerData]);
      i = 0;
      while (true) {
        t2 = t1.get$length(allEvents);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        $event = t1.$index(allEvents, i);
        t2 = $event.timeStamp;
        ms = J.toInt$0$n(t2);
        t2 = P.Duration$(C.JSNumber_methods.toInt$0((t2 - ms) * 1000), ms, 0);
        t3 = this._pointerTypeToDeviceKind$1($event.pointerType);
        t4 = $event.pointerId;
        t5 = $event.clientX;
        t6 = $event.clientY;
        t7 = $event.buttons;
        t8 = $event.pressure;
        t9 = $event.tiltX;
        if (typeof t9 !== "number")
          return t9.abs$0();
        t10 = $event.tiltY;
        if (typeof t10 !== "number")
          return t10.abs$0();
        if (!(Math.abs(t9) > Math.abs(t10)))
          t9 = t10;
        C.JSArray_methods.$indexSet(data, i, Q.PointerData$(t7, change, t4, t3, t5, t6, t8, 1, 0, 0, 0, null, t9 / 180 * 3.141592653589793, t2));
        ++i;
      }
      return data;
    },
    _expandEvents$1: function($event) {
      var coalescedEvents;
      if ("getCoalescedEvents" in $event) {
        coalescedEvents = $event.getCoalescedEvents();
        if (J.get$isNotEmpty$asx(coalescedEvents))
          return coalescedEvents;
      }
      return H.setRuntimeTypeInfo([$event], [W.PointerEvent0]);
    },
    _pointerTypeToDeviceKind$1: function(pointerType) {
      switch (pointerType) {
        case "mouse":
          return C.PointerDeviceKind_1;
        case "pen":
          return C.PointerDeviceKind_2;
        case "touch":
          return C.PointerDeviceKind_0;
        default:
          return C.PointerDeviceKind_4;
      }
    }
  };
  T.PointerAdapter__setup_closure.prototype = {
    call$1: function($event) {
      var t3,
        pointerButton = T._pointerButtonFromHtmlEvent($event),
        t1 = this.$this,
        t2 = t1._isDownMap;
      if (t2.$index(0, pointerButton) === true) {
        t3 = t1._convertEventToPointerData$2(C.PointerChange_6, H.interceptedTypeCheck($event, "$isPointerEvent0"));
        t1._callback.call$1(t3);
      }
      t2.$indexSet(0, pointerButton, true);
      t2 = t1._convertEventToPointerData$2(C.PointerChange_4, H.interceptedTypeCheck($event, "$isPointerEvent0"));
      t1._callback.call$1(t2);
    },
    $signature: 2
  };
  T.PointerAdapter__setup_closure0.prototype = {
    call$1: function($event) {
      var t2,
        t1 = this.$this;
      if (t1._isDownMap.$index(0, T._pointerButtonFromHtmlEvent($event)) !== true)
        return;
      t2 = t1._convertEventToPointerData$2(C.PointerChange_5, H.interceptedTypeCheck($event, "$isPointerEvent0"));
      t1._callback.call$1(t2);
    },
    $signature: 2
  };
  T.PointerAdapter__setup_closure1.prototype = {
    call$1: function($event) {
      var pointerButton = T._pointerButtonFromHtmlEvent($event),
        t1 = this.$this,
        t2 = t1._isDownMap;
      if (t2.$index(0, pointerButton) !== true)
        return;
      t2.$indexSet(0, pointerButton, false);
      t2 = t1._convertEventToPointerData$2(C.PointerChange_6, H.interceptedTypeCheck($event, "$isPointerEvent0"));
      t1._callback.call$1(t2);
    },
    $signature: 2
  };
  T.PointerAdapter__setup_closure2.prototype = {
    call$1: function($event) {
      var t1 = this.$this,
        t2 = t1._convertEventToPointerData$2(C.PointerChange_0, H.interceptedTypeCheck($event, "$isPointerEvent0"));
      t1._callback.call$1(t2);
    },
    $signature: 2
  };
  T.PointerAdapter__setup_closure3.prototype = {
    call$1: function($event) {
      var t1 = T._convertWheelEventToPointerData($event);
      this.$this._callback.call$1(t1);
      $event.preventDefault();
    },
    $signature: 42
  };
  T.TouchAdapter.prototype = {
    _setup$0: function() {
      var _this = this;
      _this._engine$_addEventListener$2(0, "touchstart", new T.TouchAdapter__setup_closure(_this));
      _this._engine$_addEventListener$2(0, "touchmove", new T.TouchAdapter__setup_closure0(_this));
      _this._engine$_addEventListener$2(0, "touchend", new T.TouchAdapter__setup_closure1(_this));
      _this._engine$_addEventListener$2(0, "touchcancel", new T.TouchAdapter__setup_closure2(_this));
    },
    _convertEventToPointerData$2: function(change, $event) {
      var data, len, i, touch, ms, t2, t3,
        touches = $event.changedTouches,
        t1 = new Array(touches.length);
      t1.fixed$length = Array;
      data = H.setRuntimeTypeInfo(t1, [Q.PointerData]);
      len = touches.length;
      for (i = 0; i < len; ++i) {
        if (i >= touches.length)
          return H.ioore(touches, i);
        touch = touches[i];
        t1 = $event.timeStamp;
        ms = J.toInt$0$n(t1);
        t1 = P.Duration$(C.JSNumber_methods.toInt$0((t1 - ms) * 1000), ms, 0);
        t2 = touch.identifier;
        t3 = C.JSNumber_methods.round$0(touch.clientX);
        C.JSNumber_methods.round$0(touch.clientY);
        C.JSNumber_methods.round$0(touch.clientX);
        C.JSArray_methods.$indexSet(data, i, Q.PointerData$(0, change, t2, C.PointerDeviceKind_0, t3, C.JSNumber_methods.round$0(touch.clientY), 1, 1, 0, 0, 0, C.PointerSignalKind_0, 0, t1));
      }
      return data;
    }
  };
  T.TouchAdapter__setup_closure.prototype = {
    call$1: function($event) {
      var t2,
        t1 = this.$this;
      t1._isDownMap.$indexSet(0, 1, true);
      t2 = t1._convertEventToPointerData$2(C.PointerChange_4, H.interceptedTypeCheck($event, "$isTouchEvent"));
      t1._callback.call$1(t2);
    },
    $signature: 2
  };
  T.TouchAdapter__setup_closure0.prototype = {
    call$1: function($event) {
      var t1, t2;
      $event.preventDefault();
      t1 = this.$this;
      if (t1._isDownMap.$index(0, 1) !== true)
        return;
      t2 = t1._convertEventToPointerData$2(C.PointerChange_5, H.interceptedTypeCheck($event, "$isTouchEvent"));
      t1._callback.call$1(t2);
    },
    $signature: 2
  };
  T.TouchAdapter__setup_closure1.prototype = {
    call$1: function($event) {
      var t2,
        t1 = this.$this;
      t1._isDownMap.$indexSet(0, 1, false);
      t2 = t1._convertEventToPointerData$2(C.PointerChange_6, H.interceptedTypeCheck($event, "$isTouchEvent"));
      t1._callback.call$1(t2);
    },
    $signature: 2
  };
  T.TouchAdapter__setup_closure2.prototype = {
    call$1: function($event) {
      var t1 = this.$this,
        t2 = t1._convertEventToPointerData$2(C.PointerChange_0, H.interceptedTypeCheck($event, "$isTouchEvent"));
      t1._callback.call$1(t2);
    },
    $signature: 2
  };
  T.MouseAdapter.prototype = {
    _setup$0: function() {
      var _this = this;
      _this._engine$_addEventListener$2(0, "mousedown", new T.MouseAdapter__setup_closure(_this));
      _this._engine$_addEventListener$2(0, "mousemove", new T.MouseAdapter__setup_closure0(_this));
      _this._engine$_addEventListener$2(0, "mouseup", new T.MouseAdapter__setup_closure1(_this));
      T._addWheelEventListener(new T.MouseAdapter__setup_closure2(_this));
    },
    _convertEventToPointerData$2: function(change, $event) {
      var t1 = T._eventTimeStampToDuration($event.timeStamp),
        t2 = $event.clientX,
        t3 = $event.clientY;
      return H.setRuntimeTypeInfo([Q.PointerData$($event.buttons, change, -1, C.PointerDeviceKind_1, t2, t3, 1, 1, 0, 0, 0, C.PointerSignalKind_0, 0, t1)], [Q.PointerData]);
    }
  };
  T.MouseAdapter__setup_closure.prototype = {
    call$1: function($event) {
      var t3,
        pointerButton = T._pointerButtonFromHtmlEvent($event),
        t1 = this.$this,
        t2 = t1._isDownMap;
      if (t2.$index(0, pointerButton) === true) {
        t3 = t1._convertEventToPointerData$2(C.PointerChange_6, H.interceptedTypeCheck($event, "$isMouseEvent"));
        t1._callback.call$1(t3);
      }
      t2.$indexSet(0, pointerButton, true);
      t2 = t1._convertEventToPointerData$2(C.PointerChange_4, H.interceptedTypeCheck($event, "$isMouseEvent"));
      t1._callback.call$1(t2);
    },
    $signature: 2
  };
  T.MouseAdapter__setup_closure0.prototype = {
    call$1: function($event) {
      var t2,
        t1 = this.$this;
      if (t1._isDownMap.$index(0, T._pointerButtonFromHtmlEvent($event)) !== true)
        return;
      t2 = t1._convertEventToPointerData$2(C.PointerChange_5, H.interceptedTypeCheck($event, "$isMouseEvent"));
      t1._callback.call$1(t2);
    },
    $signature: 2
  };
  T.MouseAdapter__setup_closure1.prototype = {
    call$1: function($event) {
      var t2,
        t1 = this.$this;
      t1._isDownMap.$indexSet(0, T._pointerButtonFromHtmlEvent($event), false);
      t2 = t1._convertEventToPointerData$2(C.PointerChange_6, H.interceptedTypeCheck($event, "$isMouseEvent"));
      t1._callback.call$1(t2);
    },
    $signature: 2
  };
  T.MouseAdapter__setup_closure2.prototype = {
    call$1: function($event) {
      var t1 = T._convertWheelEventToPointerData($event);
      this.$this._callback.call$1(t1);
      $event.preventDefault();
    },
    $signature: 42
  };
  T._addWheelEventListener_closure.prototype = {
    call$1: function($event) {
      return this.listener.call$1(H.interceptedTypeCheck($event, "$isWheelEvent"));
    },
    $signature: 107
  };
  T.RecordingCanvas.prototype = {
    apply$1: function(engineCanvas) {
      var t1, i;
      for (t1 = this._commands, i = 0; i < t1.length; ++i)
        t1[i].apply$1(engineCanvas);
    },
    save$0: function(_) {
      this._paintBounds.saveTransformsAndClip$0();
      C.JSArray_methods.add$1(this._commands, C.C_PaintSave);
      ++this.saveCount;
    },
    saveLayer$2: function(bounds, paint) {
      var _this = this;
      _this._hasArbitraryPaint = true;
      C.JSArray_methods.add$1(_this._commands, C.C_PaintSave);
      _this._paintBounds.saveTransformsAndClip$0();
      ++_this.saveCount;
    },
    restore$0: function(_) {
      var clipRect,
        t1 = this._paintBounds,
        t2 = t1._transforms;
      if (0 >= t2.length)
        return H.ioore(t2, -1);
      t1._currentMatrix = t2.pop();
      t2 = t1._clipStack;
      if (0 >= t2.length)
        return H.ioore(t2, -1);
      clipRect = t2.pop();
      if (clipRect != null) {
        t1._currentClipLeft = clipRect.left;
        t1._currentClipTop = clipRect.top;
        t1._currentClipRight = clipRect.right;
        t1._currentClipBottom = clipRect.bottom;
        t1._clipRectInitialized = true;
      } else if (t1._clipRectInitialized)
        t1._clipRectInitialized = false;
      t1 = this._commands;
      if (t1.length !== 0 && !!C.JSArray_methods.get$last(t1).$isPaintSave) {
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        t1.pop();
      } else
        C.JSArray_methods.add$1(t1, C.C_PaintRestore);
      --this.saveCount;
    },
    translate$2: function(_, dx, dy) {
      var t1 = this._paintBounds;
      if (dx !== 0 || dy !== 0)
        t1._currentMatrixIsIdentity = false;
      t1._currentMatrix.translate$2(0, dx, dy);
      C.JSArray_methods.add$1(this._commands, new T.PaintTranslate(dx, dy));
    },
    clipRect$1: function(rect) {
      var t2, t3, t4, t5, leftTop, t6, rightTop, leftBottom, rightBottom, t7, t8, t9, t10, t11, rect0,
        t1 = this._paintBounds;
      if (!t1._currentMatrixIsIdentity) {
        t2 = t1._currentMatrix;
        t3 = rect.left;
        t4 = rect.top;
        t5 = new T.Vector30(new Float64Array(3));
        t5.setValues$3(t3, t4, 0);
        leftTop = t2.transform3$1(t5);
        t5 = t1._currentMatrix;
        t2 = rect.right;
        t6 = new T.Vector30(new Float64Array(3));
        t6.setValues$3(t2, t4, 0);
        rightTop = t5.transform3$1(t6);
        t6 = t1._currentMatrix;
        t5 = rect.bottom;
        t4 = new T.Vector30(new Float64Array(3));
        t4.setValues$3(t3, t5, 0);
        leftBottom = t6.transform3$1(t4);
        t4 = t1._currentMatrix;
        t3 = new T.Vector30(new Float64Array(3));
        t3.setValues$3(t2, t5, 0);
        rightBottom = t4.transform3$1(t3);
        t3 = leftTop._engine$_v3storage;
        t4 = t3[0];
        t5 = rightTop._engine$_v3storage;
        t2 = t5[0];
        t6 = Math.min(t4, t2);
        t7 = leftBottom._engine$_v3storage;
        t8 = t7[0];
        t6 = Math.min(t6, t8);
        t9 = rightBottom._engine$_v3storage;
        t10 = t9[0];
        t6 = Math.min(t6, t10);
        t3 = t3[1];
        t5 = t5[1];
        t11 = Math.min(t3, t5);
        t7 = t7[1];
        t11 = Math.min(t11, t7);
        t9 = t9[1];
        rect0 = new Q.Rect(t6, Math.min(t11, t9), Math.max(Math.max(Math.max(t4, t2), t8), t10), Math.max(Math.max(Math.max(t3, t5), t7), t9));
      } else
        rect0 = rect;
      if (!t1._clipRectInitialized) {
        t1._currentClipLeft = rect0.left;
        t1._currentClipTop = rect0.top;
        t1._currentClipRight = rect0.right;
        t1._currentClipBottom = rect0.bottom;
        t1._clipRectInitialized = true;
      } else {
        t2 = rect0.left;
        t3 = t1._currentClipLeft;
        if (typeof t2 !== "number")
          return t2.$gt();
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (t2 > t3)
          t1._currentClipLeft = t2;
        t2 = rect0.top;
        t3 = t1._currentClipTop;
        if (typeof t2 !== "number")
          return t2.$gt();
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (t2 > t3)
          t1._currentClipTop = t2;
        t2 = rect0.right;
        if (t2 < t1._currentClipRight)
          t1._currentClipRight = t2;
        t2 = rect0.bottom;
        if (t2 < t1._currentClipBottom)
          t1._currentClipBottom = t2;
      }
      this._hasArbitraryPaint = true;
      C.JSArray_methods.add$1(this._commands, new T.PaintClipRect(rect));
    },
    drawRect$2: function(rect, paint) {
      var t1, t2, _this = this;
      if (paint._paintData.shader != null)
        _this._hasArbitraryPaint = true;
      _this._didDraw = true;
      paint.get$strokeWidth();
      t1 = paint.get$strokeWidth();
      t2 = _this._paintBounds;
      if (t1 !== 0)
        t2.grow$1(rect.inflate$1(paint.get$strokeWidth() / 2));
      else
        t2.grow$1(rect);
      paint._frozen = true;
      C.JSArray_methods.add$1(_this._commands, new T.PaintDrawRect(rect, paint._paintData));
    },
    drawParagraph$2: function(paragraph, offset) {
      var left, $top, t1, t2;
      if (paragraph._measurementResult == null)
        return;
      this._didDraw = true;
      left = offset._dx;
      $top = offset._dy;
      t1 = paragraph.get$width(paragraph);
      if (typeof left !== "number")
        return left.$add();
      t2 = paragraph.get$height(paragraph);
      if (typeof $top !== "number")
        return $top.$add();
      this._paintBounds.growLTRB$4(left, $top, left + t1, $top + t2);
      C.JSArray_methods.add$1(this._commands, new T.PaintDrawParagraph(paragraph, offset));
    }
  };
  T.PaintCommand.prototype = {};
  T.PaintSave.prototype = {
    apply$1: function(canvas) {
      canvas.save$0(0);
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  T.PaintRestore.prototype = {
    apply$1: function(canvas) {
      canvas.restore$0(0);
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  T.PaintTranslate.prototype = {
    apply$1: function(canvas) {
      canvas.translate$2(0, this.dx, this.dy);
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  T.PaintClipRect.prototype = {
    apply$1: function(canvas) {
      canvas.clipRect$1(this.rect);
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  T.PaintDrawRect.prototype = {
    apply$1: function(canvas) {
      canvas.drawRect$2(this.rect, this.paint);
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  T.PaintDrawParagraph.prototype = {
    apply$1: function(canvas) {
      canvas.drawParagraph$2(this.paragraph, this.offset);
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  T._PaintBounds.prototype = {
    grow$1: function(r) {
      this.growLTRB$4(r.left, r.top, r.right, r.bottom);
    },
    growLTRB$4: function(left, $top, right, bottom) {
      var transformedRect, transformedPointLeft, transformedPointTop, transformedPointRight, transformedPointBottom, transformedPointRight0, t1, transformedPointBottom0, t2, _this = this;
      if (left === right || $top === bottom)
        return;
      if (!_this._currentMatrixIsIdentity) {
        transformedRect = T.localClipToGlobalClip(bottom, left, right, $top, _this._currentMatrix);
        transformedPointLeft = transformedRect.left;
        transformedPointTop = transformedRect.top;
        transformedPointRight = transformedRect.right;
        transformedPointBottom = transformedRect.bottom;
      } else {
        transformedPointBottom = bottom;
        transformedPointRight = right;
        transformedPointTop = $top;
        transformedPointLeft = left;
      }
      if (_this._clipRectInitialized) {
        transformedPointRight0 = _this._currentClipRight;
        if (typeof transformedPointLeft !== "number")
          return transformedPointLeft.$gt();
        if (transformedPointLeft > transformedPointRight0)
          return;
        t1 = _this._currentClipLeft;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (transformedPointRight < t1)
          return;
        transformedPointBottom0 = _this._currentClipBottom;
        if (typeof transformedPointTop !== "number")
          return transformedPointTop.$gt();
        if (transformedPointTop > transformedPointBottom0)
          return;
        t2 = _this._currentClipTop;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (transformedPointBottom < t2)
          return;
        if (transformedPointLeft < t1)
          transformedPointLeft = t1;
        if (transformedPointRight > transformedPointRight0)
          transformedPointRight = transformedPointRight0;
        if (transformedPointTop < t2)
          transformedPointTop = t2;
        if (transformedPointBottom > transformedPointBottom0)
          transformedPointBottom = transformedPointBottom0;
      }
      if (_this._didPaintInsideClipArea) {
        _this._left = Math.min(Math.min(H.checkNum(_this._left), H.checkNum(transformedPointLeft)), transformedPointRight);
        _this._right = Math.max(Math.max(H.checkNum(_this._right), H.checkNum(transformedPointLeft)), transformedPointRight);
        _this._top = Math.min(Math.min(H.checkNum(_this._top), H.checkNum(transformedPointTop)), transformedPointBottom);
        _this._bottom = Math.max(Math.max(H.checkNum(_this._bottom), H.checkNum(transformedPointTop)), transformedPointBottom);
      } else {
        _this._left = Math.min(H.checkNum(transformedPointLeft), transformedPointRight);
        _this._right = Math.max(H.checkNum(transformedPointLeft), transformedPointRight);
        _this._top = Math.min(H.checkNum(transformedPointTop), transformedPointBottom);
        _this._bottom = Math.max(H.checkNum(transformedPointTop), transformedPointBottom);
      }
      _this._didPaintInsideClipArea = true;
    },
    saveTransformsAndClip$0: function() {
      var t1, t2, t3, _this = this;
      if (_this._clipStack == null)
        _this.set$_clipStack(H.setRuntimeTypeInfo([], [Q.Rect]));
      if (_this._transforms == null)
        _this.set$_transforms(H.setRuntimeTypeInfo([], [T.Matrix40]));
      t1 = _this._transforms;
      t2 = _this._currentMatrix;
      if (t2 == null)
        t2 = null;
      else {
        t3 = new T.Matrix40(new Float64Array(16));
        t3.setFrom$1(t2);
        t2 = t3;
      }
      (t1 && C.JSArray_methods).add$1(t1, t2);
      t2 = _this._clipStack;
      t1 = _this._clipRectInitialized ? new Q.Rect(_this._currentClipLeft, _this._currentClipTop, _this._currentClipRight, _this._currentClipBottom) : null;
      (t2 && C.JSArray_methods).add$1(t2, t1);
    },
    computeBounds$0: function() {
      var t1, maxLeft, maxRight, maxTop, maxBottom, t2, left, right, $top, bottom, _this = this;
      if (!_this._didPaintInsideClipArea)
        return C.Rect_0_0_0_0;
      t1 = _this.maxPaintBounds;
      maxLeft = t1.left;
      maxLeft.toString;
      if (isNaN(maxLeft))
        maxLeft = -1 / 0;
      maxRight = t1.right;
      if (isNaN(maxRight))
        maxRight = 1 / 0;
      maxTop = t1.top;
      maxTop.toString;
      if (isNaN(maxTop))
        maxTop = -1 / 0;
      maxBottom = t1.bottom;
      if (isNaN(maxBottom))
        maxBottom = 1 / 0;
      t1 = _this._left;
      t2 = _this._right;
      left = Math.min(H.checkNum(t1), H.checkNum(t2));
      right = Math.max(H.checkNum(t1), H.checkNum(t2));
      t2 = _this._top;
      t1 = _this._bottom;
      $top = Math.min(H.checkNum(t2), H.checkNum(t1));
      bottom = Math.max(H.checkNum(t2), H.checkNum(t1));
      if (typeof maxLeft !== "number")
        return H.iae(maxLeft);
      if (!(right < maxLeft)) {
        if (typeof maxTop !== "number")
          return H.iae(maxTop);
        t1 = bottom < maxTop;
      } else
        t1 = true;
      if (t1)
        return C.Rect_0_0_0_0;
      return new Q.Rect(Math.max(left, maxLeft), Math.max($top, H.checkNum(maxTop)), Math.min(right, maxRight), Math.min(bottom, maxBottom));
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    },
    set$_transforms: function(_transforms) {
      this._transforms = H.assertSubtype(_transforms, "$isList", [T.Matrix40], "$asList");
    },
    set$_clipStack: function(_clipStack) {
      this._clipStack = H.assertSubtype(_clipStack, "$isList", [Q.Rect], "$asList");
    }
  };
  T.AccessibilityAnnouncements.prototype = {
    AccessibilityAnnouncements$_$0: function() {
      C.JSArray_methods.add$1($._hotRestartListeners, new T.AccessibilityAnnouncements$__closure(this));
    },
    get$_domElement: function() {
      var liveRegion,
        t1 = this._element;
      if (t1 == null) {
        liveRegion = document.createElement("label");
        liveRegion.setAttribute("id", "accessibility-element");
        t1 = liveRegion.style;
        t1.position = "fixed";
        t1.overflow = "hidden";
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "transform"), "translate(-99999px, -99999px)", "");
        t1.width = "1px";
        t1.height = "1px";
        this._element = liveRegion;
        t1 = liveRegion;
      }
      return t1;
    },
    handleMessage$1: function(data) {
      var _this = this,
        message = H.stringTypeCheck(J.$index$asx(H.interceptedTypeCheck(J.$index$asx(H.interceptedTypeCheck(C.C_StandardMessageCodec.decodeMessage$1(data), "$isMap"), "data"), "$isMap"), "message"));
      if (message != null && message.length !== 0) {
        _this.get$_domElement().setAttribute("aria-live", "polite");
        _this.get$_domElement().textContent = message;
        document.body.appendChild(_this.get$_domElement());
        _this._removeElementTimer = P.Timer_Timer(C.Duration_5000000, new T.AccessibilityAnnouncements_handleMessage_closure(_this));
      }
    }
  };
  T.AccessibilityAnnouncements$__closure.prototype = {
    call$0: function() {
      var t1 = this.$this._removeElementTimer;
      if (t1 != null)
        t1.cancel$0(0);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  T.AccessibilityAnnouncements_handleMessage_closure.prototype = {
    call$0: function() {
      var t1 = this.$this._element;
      (t1 && C.LabelElement_methods).remove$0(t1);
    },
    $signature: 0
  };
  T._CheckableKind.prototype = {
    toString$0: function(_) {
      return this._engine$_name;
    }
  };
  T.Checkable.prototype = {
    update$0: function(_) {
      var t2, element, _s4_ = "true",
        t1 = this.semanticsObject;
      if ((t1._dirtyFields & 1) !== 0) {
        switch (this._engine$_kind) {
          case C._CheckableKind_0:
            t1.setAriaRole$2("checkbox", true);
            break;
          case C._CheckableKind_1:
            t1.setAriaRole$2("radio", true);
            break;
          case C._CheckableKind_2:
            t1.setAriaRole$2("switch", true);
            break;
        }
        t2 = t1._engine$_flags;
        if (typeof t2 !== "number")
          return t2.$and();
        if ((t2 & 128) === 0) {
          element = t1.element;
          element.setAttribute("aria-disabled", _s4_);
          element.setAttribute("disabled", _s4_);
        } else
          this._removeDisabledAttribute$0();
        t2 = t1._engine$_flags;
        if (typeof t2 !== "number")
          return t2.$and();
        t2 = (t2 & 2) !== 0 || (t2 & 131072) !== 0 ? _s4_ : "false";
        t1.element.setAttribute("aria-checked", t2);
      }
    },
    dispose$0: function() {
      var _this = this;
      switch (_this._engine$_kind) {
        case C._CheckableKind_0:
          _this.semanticsObject.setAriaRole$2("checkbox", false);
          break;
        case C._CheckableKind_1:
          _this.semanticsObject.setAriaRole$2("radio", false);
          break;
        case C._CheckableKind_2:
          _this.semanticsObject.setAriaRole$2("switch", false);
          break;
      }
      _this._removeDisabledAttribute$0();
    },
    _removeDisabledAttribute$0: function() {
      var element = this.semanticsObject.element;
      element.removeAttribute("aria-disabled");
      element.removeAttribute("disabled");
    }
  };
  T.ImageRoleManager.prototype = {
    update$0: function(_) {
      var t2, t3, t4, _this = this,
        t1 = _this.semanticsObject;
      if (t1.get$isVisualOnly()) {
        t2 = t1._engine$_childrenInTraversalOrder;
        t2 = t2 != null && !C.NativeInt32List_methods.get$isEmpty(t2);
      } else
        t2 = false;
      if (t2) {
        if (_this._auxiliaryImageElement == null) {
          _this._auxiliaryImageElement = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("flt-semantics-img", null), "$isElement0");
          t2 = t1._engine$_childrenInTraversalOrder;
          if (t2 != null && !C.NativeInt32List_methods.get$isEmpty(t2)) {
            t2 = _this._auxiliaryImageElement.style;
            t2.position = "absolute";
            t2.top = "0";
            t2.left = "0";
            t3 = t1._engine$_rect;
            t4 = t3.right;
            t3 = t3.left;
            if (typeof t3 !== "number")
              return H.iae(t3);
            t3 = H.S(t4 - t3) + "px";
            t2.width = t3;
            t3 = t1._engine$_rect;
            t4 = t3.bottom;
            t3 = t3.top;
            if (typeof t3 !== "number")
              return H.iae(t3);
            t3 = H.S(t4 - t3) + "px";
            t2.height = t3;
          }
          t2 = _this._auxiliaryImageElement;
          t3 = t2.style;
          t3.fontSize = "6px";
          t1.element.appendChild(t2);
        }
        _this._auxiliaryImageElement.setAttribute("role", "img");
        _this._setLabel$1(_this._auxiliaryImageElement);
      } else if (t1.get$isVisualOnly()) {
        t1.setAriaRole$2("img", true);
        _this._setLabel$1(t1.element);
        _this._cleanUpAuxiliaryElement$0();
      } else {
        _this._cleanUpAuxiliaryElement$0();
        _this._cleanupElement$0();
      }
    },
    _setLabel$1: function(element) {
      var t1 = this.semanticsObject._engine$_label;
      if (t1 != null && t1.length !== 0)
        element.setAttribute("aria-label", t1);
    },
    _cleanUpAuxiliaryElement$0: function() {
      var t1 = this._auxiliaryImageElement;
      if (t1 != null) {
        J.remove$0$ax(t1);
        this._auxiliaryImageElement = null;
      }
    },
    _cleanupElement$0: function() {
      var t1 = this.semanticsObject;
      t1.setAriaRole$2("img", false);
      t1.element.removeAttribute("aria-label");
    },
    dispose$0: function() {
      this._cleanUpAuxiliaryElement$0();
      this._cleanupElement$0();
    }
  };
  T.Incrementable.prototype = {
    Incrementable$1: function(semanticsObject) {
      var _this = this,
        t1 = _this._element;
      semanticsObject.element.appendChild(t1);
      t1.type = "range";
      t1.setAttribute("role", "slider");
      C.InputElement_methods.addEventListener$2(t1, "change", new T.Incrementable_closure(_this, semanticsObject));
      _this.set$_gestureModeListener(new T.Incrementable_closure0(_this));
      C.JSArray_methods.add$1(semanticsObject.owner._gestureModeListeners, H.functionTypeCheck(_this._gestureModeListener, {func: 1, ret: -1, args: [T.GestureMode]}));
    },
    update$0: function(_) {
      var _this = this;
      switch (_this.semanticsObject.owner._gestureMode) {
        case C.GestureMode_1:
          _this._enableBrowserGestureHandling$0();
          _this._updateInputValues$0();
          break;
        case C.GestureMode_0:
          _this._disableBrowserGestureHandling$0();
          break;
      }
    },
    _enableBrowserGestureHandling$0: function() {
      var t1 = this._element;
      if (!H.boolConversionCheck(t1.disabled))
        return;
      t1.disabled = false;
    },
    _updateInputValues$0: function() {
      var t1, updateNeeded, surrogateTextValue, t2, surrogateMaxTextValue, surrogateMinTextValue, _this = this;
      if (!_this._pendingResync) {
        t1 = _this.semanticsObject._dirtyFields;
        updateNeeded = (t1 & 4096) !== 0 || (t1 & 8192) !== 0 || (t1 & 16384) !== 0;
      } else
        updateNeeded = true;
      if (!updateNeeded)
        return;
      _this._pendingResync = false;
      surrogateTextValue = "" + _this._currentSurrogateValue;
      t1 = _this._element;
      t1.value = surrogateTextValue;
      t1.setAttribute("aria-valuenow", surrogateTextValue);
      t2 = _this.semanticsObject;
      t1.setAttribute("aria-valuetext", t2._engine$_value);
      surrogateMaxTextValue = t2._engine$_increasedValue != null ? "" + (_this._currentSurrogateValue + 1) : surrogateTextValue;
      t1.max = surrogateMaxTextValue;
      t1.setAttribute("aria-valuemax", surrogateMaxTextValue);
      surrogateMinTextValue = t2._engine$_decreasedValue != null ? "" + (_this._currentSurrogateValue - 1) : surrogateTextValue;
      t1.min = surrogateMinTextValue;
      t1.setAttribute("aria-valuemin", surrogateMinTextValue);
    },
    _disableBrowserGestureHandling$0: function() {
      var t1 = this._element;
      if (H.boolConversionCheck(t1.disabled))
        return;
      t1.disabled = true;
    },
    dispose$0: function() {
      var t1, _this = this;
      C.JSArray_methods.remove$1(_this.semanticsObject.owner._gestureModeListeners, H.functionTypeCheck(_this._gestureModeListener, {func: 1, ret: -1, args: [T.GestureMode]}));
      _this.set$_gestureModeListener(null);
      _this._disableBrowserGestureHandling$0();
      t1 = _this._element;
      (t1 && C.InputElement_methods).remove$0(t1);
    },
    set$_gestureModeListener: function(_gestureModeListener) {
      this._gestureModeListener = H.functionTypeCheck(_gestureModeListener, {func: 1, ret: -1, args: [T.GestureMode]});
    }
  };
  T.Incrementable_closure.prototype = {
    call$1: function(_) {
      var t1, t2, newInputValue, _null = null;
      H.interceptedTypeCheck(_, "$isEvent");
      t1 = this.$this;
      t2 = t1._element;
      if (H.boolConversionCheck(t2.disabled))
        return;
      t1._pendingResync = true;
      newInputValue = P.int_parse(t2.value, _null, _null);
      t2 = t1._currentSurrogateValue;
      if (typeof newInputValue !== "number")
        return newInputValue.$gt();
      if (newInputValue > t2) {
        t1._currentSurrogateValue = t2 + 1;
        $.$get$window().onSemanticsAction$3(this.semanticsObject.id, C.SemanticsAction_64, _null);
      } else if (newInputValue < t2) {
        t1._currentSurrogateValue = t2 - 1;
        $.$get$window().onSemanticsAction$3(this.semanticsObject.id, C.SemanticsAction_128, _null);
      }
    },
    $signature: 2
  };
  T.Incrementable_closure0.prototype = {
    call$1: function(mode) {
      H.interceptedTypeCheck(mode, "$isGestureMode");
      this.$this.update$0(0);
    },
    $signature: 43
  };
  T.LabelAndValue.prototype = {
    update$0: function(_) {
      var hasLabel, t3, shouldDisplayValue, t4, t5, t6, _this = this,
        t1 = _this.semanticsObject,
        t2 = t1._engine$_value,
        hasValue = t2 != null && t2.length !== 0;
      t2 = t1._engine$_label;
      hasLabel = t2 != null && t2.length !== 0;
      if (hasValue) {
        t3 = t1._engine$_actions;
        if (typeof t3 !== "number")
          return t3.$and();
        if (!((t3 & 64) !== 0 || (t3 & 128) !== 0)) {
          t3 = t1._engine$_flags;
          if (typeof t3 !== "number")
            return t3.$and();
          t3 = (t3 & 16) === 0;
          shouldDisplayValue = t3;
        } else
          shouldDisplayValue = false;
      } else
        shouldDisplayValue = false;
      if (!hasLabel && !shouldDisplayValue) {
        _this._cleanUpDom$0();
        return;
      }
      if (hasLabel) {
        t2 = H.S(t2);
        if (shouldDisplayValue)
          t2 += " ";
      } else
        t2 = "";
      if (shouldDisplayValue)
        t2 += H.S(t1._engine$_value);
      t3 = t1.element;
      t2 = t2.charCodeAt(0) == 0 ? t2 : t2;
      t3.setAttribute("aria-label", t2);
      t4 = t1._engine$_flags;
      if (typeof t4 !== "number")
        return t4.$and();
      if ((t4 & 512) !== 0)
        t1.setAriaRole$2("heading", true);
      if (_this._auxiliaryValueElement == null) {
        _this._auxiliaryValueElement = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("flt-semantics-value", null), "$isElement0");
        t4 = t1._engine$_childrenInTraversalOrder;
        if (t4 != null && !C.NativeInt32List_methods.get$isEmpty(t4)) {
          t4 = _this._auxiliaryValueElement.style;
          t4.position = "absolute";
          t4.top = "0";
          t4.left = "0";
          t5 = t1._engine$_rect;
          t6 = t5.right;
          t5 = t5.left;
          if (typeof t5 !== "number")
            return H.iae(t5);
          t5 = H.S(t6 - t5) + "px";
          t4.width = t5;
          t1 = t1._engine$_rect;
          t5 = t1.bottom;
          t1 = t1.top;
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = H.S(t5 - t1) + "px";
          t4.height = t1;
        }
        t1 = _this._auxiliaryValueElement;
        t4 = t1.style;
        t4.fontSize = "6px";
        t3.appendChild(t1);
      }
      _this._auxiliaryValueElement.textContent = t2;
    },
    _cleanUpDom$0: function() {
      var t1 = this._auxiliaryValueElement;
      if (t1 != null) {
        J.remove$0$ax(t1);
        this._auxiliaryValueElement = null;
      }
      t1 = this.semanticsObject;
      t1.element.removeAttribute("aria-label");
      t1.setAriaRole$2("heading", false);
    },
    dispose$0: function() {
      this._cleanUpDom$0();
    }
  };
  T.LiveRegion.prototype = {
    update$0: function(_) {
      var t1 = this.semanticsObject,
        t2 = t1._engine$_label;
      t2 = t2 != null && t2.length !== 0;
      t1 = t1.element;
      if (t2)
        t1.setAttribute("aria-live", "polite");
      else
        t1.removeAttribute("aria-live");
    },
    dispose$0: function() {
      this.semanticsObject.element.removeAttribute("aria-live");
    }
  };
  T.Scrollable.prototype = {
    _recomputeScrollPosition$0: function() {
      var t1, t2, t3, semanticsId, _this = this, _null = null;
      if (_this.get$_domScrollPosition() !== _this._effectiveNeutralScrollPosition) {
        t1 = _this.semanticsObject;
        if (!t1.owner.shouldAcceptBrowserGesture$1("scroll"))
          return;
        t2 = _this.get$_domScrollPosition();
        t3 = _this._effectiveNeutralScrollPosition;
        _this._neutralizeDomScrollPosition$0();
        t1.recomputePositionAndSize$0();
        semanticsId = t1.id;
        if (t2 > t3) {
          t1 = t1._engine$_actions;
          if (typeof t1 !== "number")
            return t1.$and();
          if ((t1 & 32) !== 0 || (t1 & 16) !== 0)
            $.$get$window().onSemanticsAction$3(semanticsId, C.SemanticsAction_16, _null);
          else
            $.$get$window().onSemanticsAction$3(semanticsId, C.SemanticsAction_4, _null);
        } else {
          t1 = t1._engine$_actions;
          if (typeof t1 !== "number")
            return t1.$and();
          if ((t1 & 32) !== 0 || (t1 & 16) !== 0)
            $.$get$window().onSemanticsAction$3(semanticsId, C.SemanticsAction_32, _null);
          else
            $.$get$window().onSemanticsAction$3(semanticsId, C.SemanticsAction_8, _null);
        }
      }
    },
    update$0: function(_) {
      var t1, t2, t3, _this = this;
      if (_this._scrollListener == null) {
        t1 = _this.semanticsObject;
        t2 = t1.element;
        t3 = t2.style;
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t3, (t3 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t3, "touch-action"), "none", "");
        _this._gestureModeDidChange$0();
        t1 = t1.owner;
        t3 = H.functionTypeCheck(new T.Scrollable_update_closure(_this), {func: 1, ret: -1});
        C.JSArray_methods.add$1(t1._oneTimePostUpdateCallbacks, t3);
        _this.set$_gestureModeListener(new T.Scrollable_update_closure0(_this));
        C.JSArray_methods.add$1(t1._gestureModeListeners, H.functionTypeCheck(_this._gestureModeListener, {func: 1, ret: -1, args: [T.GestureMode]}));
        _this.set$_scrollListener(new T.Scrollable_update_closure1(_this));
        J.addEventListener$2$x(t2, "scroll", _this._scrollListener);
      }
    },
    get$_domScrollPosition: function() {
      var t1 = this.semanticsObject,
        t2 = t1._engine$_actions;
      if (typeof t2 !== "number")
        return t2.$and();
      t2 = (t2 & 32) !== 0 || (t2 & 16) !== 0;
      t1 = t1.element;
      if (t2)
        return C.JSNumber_methods.round$0(t1.scrollTop);
      else
        return C.JSNumber_methods.round$0(t1.scrollLeft);
    },
    _neutralizeDomScrollPosition$0: function() {
      var t1 = this.semanticsObject,
        element = t1.element,
        t2 = t1._engine$_actions;
      if (typeof t2 !== "number")
        return t2.$and();
      if ((t2 & 32) !== 0 || (t2 & 16) !== 0) {
        element.scrollTop = 10;
        t1.verticalContainerAdjustment = this._effectiveNeutralScrollPosition = C.JSNumber_methods.round$0(element.scrollTop);
        t1.horizontalContainerAdjustment = 0;
      } else {
        element.scrollLeft = 10;
        t2 = C.JSNumber_methods.round$0(element.scrollLeft);
        this._effectiveNeutralScrollPosition = t2;
        t1.verticalContainerAdjustment = 0;
        t1.horizontalContainerAdjustment = t2;
      }
    },
    _gestureModeDidChange$0: function() {
      var t2, t3,
        _s10_ = "overflow-y",
        _s10_0 = "overflow-x",
        t1 = this.semanticsObject,
        element = t1.element;
      switch (t1.owner._gestureMode) {
        case C.GestureMode_1:
          t1 = t1._engine$_actions;
          if (typeof t1 !== "number")
            return t1.$and();
          t1 = (t1 & 32) !== 0 || (t1 & 16) !== 0;
          t2 = element.style;
          t3 = t2 && C.CssStyleDeclaration_methods;
          if (t1)
            C.CssStyleDeclaration_methods._setPropertyHelper$3(t2, t3._browserPropertyName$1(t2, _s10_), "scroll", "");
          else
            C.CssStyleDeclaration_methods._setPropertyHelper$3(t2, t3._browserPropertyName$1(t2, _s10_0), "scroll", "");
          break;
        case C.GestureMode_0:
          t1 = t1._engine$_actions;
          if (typeof t1 !== "number")
            return t1.$and();
          t1 = (t1 & 32) !== 0 || (t1 & 16) !== 0;
          t2 = element.style;
          t3 = t2 && C.CssStyleDeclaration_methods;
          if (t1)
            C.CssStyleDeclaration_methods._setPropertyHelper$3(t2, t3._browserPropertyName$1(t2, _s10_), "hidden", "");
          else
            C.CssStyleDeclaration_methods._setPropertyHelper$3(t2, t3._browserPropertyName$1(t2, _s10_0), "hidden", "");
          break;
      }
    },
    dispose$0: function() {
      var t3, _this = this,
        t1 = _this.semanticsObject,
        t2 = t1.element,
        style = t2.style;
      style.removeProperty("overflowY");
      style.removeProperty("overflowX");
      style.removeProperty("touch-action");
      t3 = _this._scrollListener;
      if (t3 != null)
        J.removeEventListener$2$x(t2, "scroll", t3);
      C.JSArray_methods.remove$1(t1.owner._gestureModeListeners, H.functionTypeCheck(_this._gestureModeListener, {func: 1, ret: -1, args: [T.GestureMode]}));
      _this.set$_gestureModeListener(null);
    },
    set$_gestureModeListener: function(_gestureModeListener) {
      this._gestureModeListener = H.functionTypeCheck(_gestureModeListener, {func: 1, ret: -1, args: [T.GestureMode]});
    },
    set$_scrollListener: function(_scrollListener) {
      this._scrollListener = H.functionTypeCheck(_scrollListener, {func: 1, args: [W.Event]});
    }
  };
  T.Scrollable_update_closure.prototype = {
    call$0: function() {
      this.$this._neutralizeDomScrollPosition$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  T.Scrollable_update_closure0.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isGestureMode");
      this.$this._gestureModeDidChange$0();
    },
    $signature: 43
  };
  T.Scrollable_update_closure1.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isEvent");
      this.$this._recomputeScrollPosition$0();
    },
    $signature: 2
  };
  T.SemanticsUpdate.prototype = {$isSemanticsUpdate0: 1};
  T.SemanticsNodeUpdate.prototype = {};
  T.Role.prototype = {
    toString$0: function(_) {
      return this._engine$_name;
    }
  };
  T.closure.prototype = {
    call$1: function(object) {
      return T.Incrementable$(object);
    },
    $signature: 109
  };
  T.closure0.prototype = {
    call$1: function(object) {
      return new T.Scrollable(object);
    },
    $signature: 110
  };
  T.closure1.prototype = {
    call$1: function(object) {
      return new T.LabelAndValue(object);
    },
    $signature: 111
  };
  T.closure2.prototype = {
    call$1: function(object) {
      return new T.Tappable(object);
    },
    $signature: 112
  };
  T.closure3.prototype = {
    call$1: function(object) {
      var editableDomElement,
        t1 = new T.TextField(object),
        t2 = object._engine$_flags;
      if (typeof t2 !== "number")
        return t2.$and();
      editableDomElement = (t2 & 524288) !== 0 ? document.createElement("textarea") : W.InputElement_InputElement();
      t2 = new T.PersistentTextEditingElement(H.setRuntimeTypeInfo([], [[P.StreamSubscription, W.Event]]));
      t2.domElement = editableDomElement;
      t1.persistentTextEditingElement = t2;
      t1._setupDomElement$0();
      return t1;
    },
    $signature: 113
  };
  T.closure4.prototype = {
    call$1: function(object) {
      var t1 = new T.Checkable(object),
        t2 = object._engine$_flags;
      if (typeof t2 !== "number")
        return t2.$and();
      if ((t2 & 256) !== 0)
        t1._engine$_kind = C._CheckableKind_1;
      else if ((t2 & 65536) !== 0)
        t1._engine$_kind = C._CheckableKind_2;
      else
        t1._engine$_kind = C._CheckableKind_0;
      return t1;
    },
    $signature: 114
  };
  T.closure5.prototype = {
    call$1: function(object) {
      return new T.ImageRoleManager(object);
    },
    $signature: 115
  };
  T.closure6.prototype = {
    call$1: function(object) {
      return new T.LiveRegion(object);
    },
    $signature: 116
  };
  T.RoleManager.prototype = {};
  T.SemanticsObject.prototype = {
    getOrCreateChildContainer$0: function() {
      var t1, t2, _this = this;
      if (_this._childContainerElement == null) {
        t1 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("flt-semantics-container", null), "$isElement0");
        _this._childContainerElement = t1;
        t2 = t1.style;
        t2.position = "absolute";
        _this.element.appendChild(t1);
      }
      return _this._childContainerElement;
    },
    get$isVisualOnly: function() {
      var t2,
        t1 = this._engine$_flags;
      if (typeof t1 !== "number")
        return t1.$and();
      if ((t1 & 16384) !== 0) {
        t2 = this._engine$_actions;
        if (typeof t2 !== "number")
          return t2.$and();
        t1 = (t2 & 1) === 0 && (t1 & 8) === 0;
      } else
        t1 = false;
      return t1;
    },
    setAriaRole$2: function(ariaRoleName, condition) {
      var t1;
      if (condition)
        this.element.setAttribute("role", ariaRoleName);
      else {
        t1 = this.element;
        if (t1.getAttribute("role") === ariaRoleName)
          t1.removeAttribute("role");
      }
    },
    _updateRole$2: function(role, enabled) {
      var t1 = this._roleManagers,
        manager = t1.$index(0, role);
      if (enabled) {
        if (manager == null) {
          manager = $.$get$_roleFactories().$index(0, role).call$1(this);
          t1.$indexSet(0, role, manager);
        }
        manager.update$0(0);
      } else if (manager != null) {
        manager.dispose$0();
        t1.remove$1(0, role);
      }
    },
    recomputePositionAndSize$0: function() {
      var containerElement, effectiveTransformIsIdentity, hasZeroRectOffset, t5, hasIdentityTransform, left, effectiveTransform, _this = this,
        _s16_ = "transform-origin",
        _s9_ = "transform",
        t1 = _this.element,
        t2 = t1.style,
        t3 = _this._engine$_rect,
        t4 = t3.right;
      t3 = t3.left;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = H.S(t4 - t3) + "px";
      t2.width = t3;
      t3 = _this._engine$_rect;
      t4 = t3.bottom;
      t3 = t3.top;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = H.S(t4 - t3) + "px";
      t2.height = t3;
      t2 = _this._engine$_childrenInTraversalOrder;
      containerElement = t2 != null && !C.NativeInt32List_methods.get$isEmpty(t2) ? _this.getOrCreateChildContainer$0() : null;
      t2 = _this._engine$_rect;
      t3 = t2.top;
      effectiveTransformIsIdentity = t3 === 0;
      hasZeroRectOffset = effectiveTransformIsIdentity && t2.left === 0;
      t4 = _this._engine$_transform;
      t5 = t4 == null;
      if (!t5)
        hasIdentityTransform = t4[0] === 1 && t4[1] === 0 && t4[2] === 0 && t4[3] === 0 && t4[4] === 0 && t4[5] === 1 && t4[6] === 0 && t4[7] === 0 && t4[8] === 0 && t4[9] === 0 && t4[10] === 1 && t4[11] === 0 && t4[12] === 0 && t4[13] === 0 && t4[14] === 0 && t4[15] === 1;
      else
        hasIdentityTransform = true;
      if (hasZeroRectOffset && hasIdentityTransform && _this.verticalContainerAdjustment === 0 && _this.horizontalContainerAdjustment === 0) {
        t1 = t1.style;
        t1.removeProperty(_s16_);
        t1.removeProperty(_s9_);
        if (containerElement != null) {
          t1 = containerElement.style;
          t1.removeProperty(_s16_);
          t1.removeProperty(_s9_);
        }
        return;
      }
      if (!hasZeroRectOffset)
        if (t5) {
          left = t2.left;
          effectiveTransform = T.Matrix4_Matrix4$translationValues(left, t3, 0);
          effectiveTransformIsIdentity = left === 0 && effectiveTransformIsIdentity;
        } else {
          effectiveTransform = new T.Matrix40(new Float64Array(16));
          effectiveTransform.setFrom$1(new T.Matrix40(t4));
          t2 = _this._engine$_rect;
          effectiveTransform.translate$3(0, t2.left, t2.top, 0);
          effectiveTransformIsIdentity = effectiveTransform.isIdentity$0(0);
        }
      else if (!hasIdentityTransform) {
        effectiveTransform = new T.Matrix40(t4);
        effectiveTransformIsIdentity = false;
      } else {
        effectiveTransform = null;
        effectiveTransformIsIdentity = true;
      }
      t1 = t1.style;
      if (!effectiveTransformIsIdentity) {
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, _s16_), "0 0 0", "");
        t2 = T.float64ListToCssTransform(effectiveTransform._engine$_m4storage);
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, C.CssStyleDeclaration_methods._browserPropertyName$1(t1, _s9_), t2, "");
      } else {
        t1.removeProperty(_s16_);
        t1.removeProperty(_s9_);
      }
      if (containerElement != null) {
        t1 = !hasZeroRectOffset || _this.verticalContainerAdjustment !== 0 || _this.horizontalContainerAdjustment !== 0;
        t2 = containerElement.style;
        if (t1) {
          t1 = _this._engine$_rect;
          t3 = t1.left;
          if (typeof t3 !== "number")
            return t3.$negate();
          t4 = _this.horizontalContainerAdjustment;
          t1 = t1.top;
          if (typeof t1 !== "number")
            return t1.$negate();
          t5 = _this.verticalContainerAdjustment;
          C.CssStyleDeclaration_methods._setPropertyHelper$3(t2, (t2 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t2, _s16_), "0 0 0", "");
          t5 = "translate(" + H.S(-t3 + t4) + "px, " + H.S(-t1 + t5) + "px)";
          C.CssStyleDeclaration_methods._setPropertyHelper$3(t2, C.CssStyleDeclaration_methods._browserPropertyName$1(t2, _s9_), t5, "");
        } else {
          t2.removeProperty(_s16_);
          t2.removeProperty(_s9_);
        }
      }
    },
    _updateChildrenInTraversalOrder$0: function() {
      var t2, len, i, t3, object, containerElement, t4, _i, id, intersectionIndicesNew, intersectionIndicesOld, minLength, newIndex, oldIndex, longestSequence, stationaryIds, refNode, childId, _this = this,
        t1 = _this._engine$_childrenInTraversalOrder;
      if (t1 == null || t1.length === 0) {
        t2 = _this._previousChildrenInTraversalOrder;
        if (t2 == null || t2.length === 0) {
          _this._previousChildrenInTraversalOrder = t1;
          return;
        }
        len = t2.length;
        for (t1 = _this.owner, t2 = t1._semanticsTree, i = 0; i < len; ++i) {
          t3 = _this._previousChildrenInTraversalOrder;
          if (i >= t3.length)
            return H.ioore(t3, i);
          object = t2.$index(0, t3[i]);
          C.JSArray_methods.add$1(t1._detachments, object);
        }
        _this._previousChildrenInTraversalOrder = null;
        J.remove$0$ax(_this._childContainerElement);
        _this._childContainerElement = null;
        _this._previousChildrenInTraversalOrder = _this._engine$_childrenInTraversalOrder;
        return;
      }
      containerElement = _this.getOrCreateChildContainer$0();
      t1 = _this._previousChildrenInTraversalOrder;
      if (t1 == null || t1.length === 0) {
        t1 = _this._previousChildrenInTraversalOrder = _this._engine$_childrenInTraversalOrder;
        for (t2 = t1.length, t3 = _this.owner, t4 = t3._semanticsTree, _i = 0; _i < t2; ++_i) {
          id = t1[_i];
          object = t4.$index(0, id);
          if (object == null) {
            object = T.SemanticsObject$(id, t3);
            t4.$indexSet(0, id, object);
          }
          containerElement.appendChild(object.element);
          object._engine$_parent = _this;
          t3._attachments.$indexSet(0, object.id, _this);
        }
        _this._previousChildrenInTraversalOrder = _this._engine$_childrenInTraversalOrder;
        return;
      }
      t1 = [P.int];
      intersectionIndicesNew = H.setRuntimeTypeInfo([], t1);
      intersectionIndicesOld = H.setRuntimeTypeInfo([], t1);
      minLength = Math.min(_this._previousChildrenInTraversalOrder.length, _this._engine$_childrenInTraversalOrder.length);
      newIndex = 0;
      while (true) {
        if (newIndex < minLength) {
          t2 = _this._previousChildrenInTraversalOrder;
          if (newIndex >= t2.length)
            return H.ioore(t2, newIndex);
          t2 = t2[newIndex];
          t3 = _this._engine$_childrenInTraversalOrder;
          if (newIndex >= t3.length)
            return H.ioore(t3, newIndex);
          t3 = t2 === t3[newIndex];
          t2 = t3;
        } else
          t2 = false;
        if (!t2)
          break;
        C.JSArray_methods.add$1(intersectionIndicesNew, newIndex);
        C.JSArray_methods.add$1(intersectionIndicesOld, newIndex);
        ++newIndex;
      }
      t2 = _this._previousChildrenInTraversalOrder.length;
      t3 = _this._engine$_childrenInTraversalOrder.length;
      if (t2 === t3 && newIndex === t3)
        return;
      for (; t2 = _this._engine$_childrenInTraversalOrder, newIndex < t2.length;) {
        for (t3 = _this._previousChildrenInTraversalOrder, t4 = t3.length, oldIndex = 0; oldIndex < t4; ++oldIndex)
          if (t3[oldIndex] === t2[newIndex]) {
            C.JSArray_methods.add$1(intersectionIndicesNew, newIndex);
            C.JSArray_methods.add$1(intersectionIndicesOld, oldIndex);
            break;
          }
        ++newIndex;
      }
      longestSequence = T.longestIncreasingSubsequence(intersectionIndicesOld);
      stationaryIds = H.setRuntimeTypeInfo([], t1);
      for (t1 = longestSequence.length, i = 0; i < t1; ++i) {
        t2 = _this._previousChildrenInTraversalOrder;
        t3 = C.JSArray_methods.$index(intersectionIndicesOld, longestSequence[i]);
        if (t3 >= t2.length)
          return H.ioore(t2, t3);
        C.JSArray_methods.add$1(stationaryIds, t2[t3]);
      }
      for (t1 = _this.owner, t2 = t1._semanticsTree, i = 0; i < _this._previousChildrenInTraversalOrder.length; ++i)
        if (!C.JSArray_methods.contains$1(intersectionIndicesOld, i)) {
          t3 = _this._previousChildrenInTraversalOrder;
          if (i >= t3.length)
            return H.ioore(t3, i);
          object = t2.$index(0, t3[i]);
          C.JSArray_methods.add$1(t1._detachments, object);
        }
      for (i = _this._engine$_childrenInTraversalOrder.length - 1, refNode = null; i >= 0; --i) {
        t3 = _this._engine$_childrenInTraversalOrder;
        if (i >= t3.length)
          return H.ioore(t3, i);
        childId = t3[i];
        object = t2.$index(0, childId);
        if (object == null) {
          object = T.SemanticsObject$(childId, t1);
          t2.$indexSet(0, childId, object);
        }
        if (!C.JSArray_methods.contains$1(stationaryIds, childId)) {
          t3 = object.element;
          if (refNode == null)
            containerElement.appendChild(t3);
          else
            containerElement.insertBefore(t3, refNode);
          object._engine$_parent = _this;
          t1._attachments.$indexSet(0, object.id, _this);
        }
        refNode = object.element;
      }
      _this._previousChildrenInTraversalOrder = _this._engine$_childrenInTraversalOrder;
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  T.AccessibilityMode.prototype = {
    toString$0: function(_) {
      return this._engine$_name;
    }
  };
  T.GestureMode.prototype = {
    toString$0: function(_) {
      return this._engine$_name;
    }
  };
  T.EngineSemanticsOwner.prototype = {
    EngineSemanticsOwner$_$0: function() {
      C.JSArray_methods.add$1($._hotRestartListeners, new T.EngineSemanticsOwner$__closure(this));
    },
    _finalizeTree$0: function() {
      var t1, t2, t3, _i, object, t4, t5, _this = this;
      for (t1 = _this._detachments, t2 = t1.length, t3 = _this._semanticsTree, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        object = t1[_i];
        t4 = _this._attachments;
        t5 = object.id;
        if (t4.$index(0, t5) == null) {
          t3.remove$1(0, t5);
          object._engine$_parent = null;
          t4 = object.element;
          t5 = t4.parentNode;
          if (t5 != null)
            t5.removeChild(t4);
        }
      }
      t1 = T.SemanticsObject;
      _this.set$_detachments(H.setRuntimeTypeInfo([], [t1]));
      _this.set$_attachments(P.LinkedHashMap_LinkedHashMap$_empty(P.int, t1));
      t1 = _this._oneTimePostUpdateCallbacks;
      t2 = t1.length;
      if (t2 !== 0) {
        for (_i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          t1[_i].call$0();
        _this.set$_oneTimePostUpdateCallbacks(H.setRuntimeTypeInfo([], [{func: 1, ret: -1}]));
      }
    },
    _tryEnableSemantics$1: function($event) {
      var t1, t2, blinkEnableConditionPassed, activationPoint, activatingElementRect, t3, t4, t5, t6, t7, deltaX, deltaY, safariEnableConditionPassed, _this = this;
      if (_this._schedulePlaceholderRemoval) {
        t1 = $._browserEngine;
        if ((t1 == null ? $._browserEngine = T._detectBrowserEngine() : t1) !== C.BrowserEngine_1 || $event.type === "touchend") {
          J.remove$0$ax(_this._semanticsPlaceholder);
          _this._semanticsActivationTimer = _this._semanticsPlaceholder = null;
        }
        return true;
      }
      if (_this._semanticsEnabled)
        return true;
      if (++_this._semanticsActivationAttempts >= 20)
        return _this._schedulePlaceholderRemoval = true;
      if (!C.JSArray_methods.contains$1(C.List_click_touchstart_touchend, $event.type))
        return true;
      if (_this._semanticsActivationTimer != null)
        return false;
      t1 = $._browserEngine;
      if (t1 == null) {
        t1 = $._browserEngine = T._detectBrowserEngine();
        t2 = t1;
      } else
        t2 = t1;
      blinkEnableConditionPassed = t1 === C.BrowserEngine_0 && _this._gestureMode === C.GestureMode_1;
      if (t2 === C.BrowserEngine_1) {
        switch ($event.type) {
          case "click":
            activationPoint = J.get$offset$x(H.interceptedTypeCheck($event, "$isMouseEvent"));
            break;
          case "touchstart":
          case "touchend":
            t1 = H.interceptedTypeCheck($event, "$isTouchEvent").changedTouches;
            t1 = (t1 && C.TouchList_methods).get$first(t1);
            activationPoint = new P.Point(C.JSNumber_methods.round$0(t1.clientX), C.JSNumber_methods.round$0(t1.clientY), [P.num]);
            break;
          default:
            return true;
        }
        activatingElementRect = $.$get$domRenderer()._glassPaneElement.getBoundingClientRect();
        t1 = activatingElementRect.left;
        t2 = activatingElementRect.right;
        t3 = activatingElementRect.left;
        t4 = activatingElementRect.top;
        t5 = activatingElementRect.bottom;
        t6 = activatingElementRect.top;
        t7 = activationPoint.x;
        if (typeof t7 !== "number")
          return t7.$sub();
        deltaX = t7 - (t1 + (t2 - t3) / 2);
        t3 = activationPoint.y;
        if (typeof t3 !== "number")
          return t3.$sub();
        deltaY = t3 - (t4 + (t5 - t6) / 2);
        safariEnableConditionPassed = deltaX * deltaX + deltaY * deltaY < 1 && true;
      } else
        safariEnableConditionPassed = false;
      if (blinkEnableConditionPassed || safariEnableConditionPassed) {
        _this._semanticsActivationTimer = P.Timer_Timer(C.Duration_300000, new T.EngineSemanticsOwner__tryEnableSemantics_closure(_this));
        return false;
      }
      return true;
    },
    autoEnableOnTap$1: function(domRenderer) {
      var t2, _this = this,
        t1 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("flt-semantics-placeholder", null), "$isElement0");
      _this._semanticsPlaceholder = t1;
      J.addEventListener$3$x(t1, "click", new T.EngineSemanticsOwner_autoEnableOnTap_closure(_this), true);
      t1 = _this._semanticsPlaceholder;
      t1.setAttribute("role", "button");
      t1.setAttribute("aria-label", "Enable accessibility");
      t1 = _this._semanticsPlaceholder;
      t2 = t1.style;
      t2.position = "absolute";
      t2.left = "0";
      t2.top = "0";
      t2.right = "0";
      t2.bottom = "0";
      domRenderer._glassPaneElement.appendChild(t1);
    },
    set$semanticsEnabled: function(value) {
      var t1;
      if (this._semanticsEnabled)
        return;
      this._semanticsEnabled = true;
      t1 = $.$get$window();
      if (t1._onSemanticsEnabledChanged != null)
        t1.onSemanticsEnabledChanged$0();
    },
    _getGestureModeClock$0: function() {
      var t1, _this = this;
      if (_this._gestureModeClock == null) {
        t1 = new T.AlarmClock(_this._now);
        _this._gestureModeClock = t1;
        t1.set$callback(new T.EngineSemanticsOwner__getGestureModeClock_closure(_this));
      }
      return _this._gestureModeClock;
    },
    receiveGlobalEvent$1: function($event) {
      var t1, t2, _this = this;
      if (C.JSArray_methods.contains$1(C.List_e3D, $event.type)) {
        t1 = _this._getGestureModeClock$0();
        t2 = _this._now.call$0();
        t1.set$datetime(P.DateTime$_withValue(t2._core$_value + 500, t2.isUtc));
        if (_this._gestureMode !== C.GestureMode_0) {
          _this._gestureMode = C.GestureMode_0;
          _this._notifyGestureModeListeners$0();
        }
      }
      if (_this._semanticsPlaceholder == null)
        return true;
      else
        return _this._tryEnableSemantics$1($event);
    },
    _notifyGestureModeListeners$0: function() {
      var t1, i;
      for (t1 = this._gestureModeListeners, i = 0; i < t1.length; ++i)
        t1[i].call$1(this._gestureMode);
    },
    shouldAcceptBrowserGesture$1: function(eventType) {
      if (C.JSArray_methods.contains$1(C.List_click_scroll, eventType))
        return this._gestureMode === C.GestureMode_1;
      return false;
    },
    updateSemantics$1: function(uiUpdate) {
      var t1, t2, t3, _i, nodeUpdate, t4, object, t5, t6, _this = this;
      if (!_this._semanticsEnabled)
        return;
      for (t1 = uiUpdate._engine$_nodeUpdates, t2 = t1.length, t3 = _this._semanticsTree, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        nodeUpdate = t1[_i];
        t4 = nodeUpdate.id;
        object = t3.$index(0, t4);
        if (object == null) {
          object = T.SemanticsObject$(t4, _this);
          t3.$indexSet(0, t4, object);
        }
        t4 = nodeUpdate.flags;
        if (object._engine$_flags !== t4) {
          object._engine$_flags = t4;
          object._dirtyFields = (object._dirtyFields | 1) >>> 0;
        }
        t4 = nodeUpdate.value;
        if (object._engine$_value != t4) {
          object._engine$_value = t4;
          object._dirtyFields = (object._dirtyFields | 4096) >>> 0;
        }
        t4 = nodeUpdate.label;
        if (object._engine$_label != t4) {
          object._engine$_label = t4;
          object._dirtyFields = (object._dirtyFields | 1024) >>> 0;
        }
        t4 = nodeUpdate.rect;
        if (!J.$eq$(object._engine$_rect, t4)) {
          object._engine$_rect = t4;
          object._dirtyFields = (object._dirtyFields | 512) >>> 0;
        }
        t4 = nodeUpdate.transform;
        if (object._engine$_transform !== t4) {
          object._engine$_transform = t4;
          object._dirtyFields = (object._dirtyFields | 65536) >>> 0;
        }
        t4 = nodeUpdate.scrollPosition;
        if (object._engine$_scrollPosition != t4) {
          object._engine$_scrollPosition = t4;
          object._dirtyFields = (object._dirtyFields | 64) >>> 0;
        }
        t4 = object._engine$_actions;
        t5 = nodeUpdate.actions;
        if (t4 !== t5) {
          object._engine$_actions = t5;
          object._dirtyFields = (object._dirtyFields | 2) >>> 0;
          t4 = t5;
        }
        t5 = nodeUpdate.textSelectionBase;
        if (object._textSelectionBase !== t5) {
          object._textSelectionBase = t5;
          object._dirtyFields = (object._dirtyFields | 4) >>> 0;
        }
        t5 = nodeUpdate.textSelectionExtent;
        if (object._textSelectionExtent !== t5) {
          object._textSelectionExtent = t5;
          object._dirtyFields = (object._dirtyFields | 8) >>> 0;
        }
        t5 = nodeUpdate.scrollChildren;
        if (object._scrollChildren != t5) {
          object._scrollChildren = t5;
          object._dirtyFields = (object._dirtyFields | 16) >>> 0;
        }
        t5 = nodeUpdate.scrollIndex;
        if (object._engine$_scrollIndex != t5) {
          object._engine$_scrollIndex = t5;
          object._dirtyFields = (object._dirtyFields | 32) >>> 0;
        }
        t5 = nodeUpdate.scrollExtentMax;
        if (object._engine$_scrollExtentMax != t5) {
          object._engine$_scrollExtentMax = t5;
          object._dirtyFields = (object._dirtyFields | 128) >>> 0;
        }
        t5 = nodeUpdate.scrollExtentMin;
        if (object._engine$_scrollExtentMin != t5) {
          object._engine$_scrollExtentMin = t5;
          object._dirtyFields = (object._dirtyFields | 256) >>> 0;
        }
        t5 = nodeUpdate.hint;
        if (object._engine$_hint != t5) {
          object._engine$_hint = t5;
          object._dirtyFields = (object._dirtyFields | 2048) >>> 0;
        }
        t5 = nodeUpdate.increasedValue;
        if (object._engine$_increasedValue != t5) {
          object._engine$_increasedValue = t5;
          object._dirtyFields = (object._dirtyFields | 8192) >>> 0;
        }
        t5 = nodeUpdate.decreasedValue;
        if (object._engine$_decreasedValue != t5) {
          object._engine$_decreasedValue = t5;
          object._dirtyFields = (object._dirtyFields | 16384) >>> 0;
        }
        t5 = nodeUpdate.textDirection;
        if (object._engine$_textDirection != t5) {
          object._engine$_textDirection = t5;
          object._dirtyFields = (object._dirtyFields | 32768) >>> 0;
        }
        t5 = object._childrenInHitTestOrder;
        t6 = nodeUpdate.childrenInHitTestOrder;
        if (t5 == null ? t6 != null : t5 !== t6) {
          object._childrenInHitTestOrder = t6;
          object._dirtyFields = (object._dirtyFields | 1048576) >>> 0;
        }
        t5 = object._engine$_childrenInTraversalOrder;
        t6 = nodeUpdate.childrenInTraversalOrder;
        if (t5 == null ? t6 != null : t5 !== t6) {
          object._engine$_childrenInTraversalOrder = t6;
          object._dirtyFields = (object._dirtyFields | 524288) >>> 0;
        }
        t5 = object._additionalActions;
        t6 = nodeUpdate.additionalActions;
        if (t5 == null ? t6 != null : t5 !== t6) {
          object._additionalActions = t6;
          object._dirtyFields = (object._dirtyFields | 2097152) >>> 0;
        }
        t5 = object._engine$_label;
        if (!(t5 != null && t5.length !== 0)) {
          t5 = object._engine$_value;
          t5 = t5 != null && t5.length !== 0;
        } else
          t5 = true;
        if (t5) {
          t5 = object._engine$_flags;
          if (typeof t5 !== "number")
            return t5.$and();
          if ((t5 & 16384) !== 0) {
            if (typeof t4 !== "number")
              return t4.$and();
            t4 = (t4 & 1) === 0 && (t5 & 8) === 0;
          } else
            t4 = false;
          t4 = !t4;
        } else
          t4 = false;
        object._updateRole$2(C.Role_2, t4);
        t4 = object._engine$_flags;
        if (typeof t4 !== "number")
          return t4.$and();
        object._updateRole$2(C.Role_4, (t4 & 16) !== 0);
        t4 = object._engine$_actions;
        if (typeof t4 !== "number")
          return t4.$and();
        if ((t4 & 1) === 0) {
          t4 = object._engine$_flags;
          if (typeof t4 !== "number")
            return t4.$and();
          t4 = (t4 & 8) !== 0;
        } else
          t4 = true;
        object._updateRole$2(C.Role_3, t4);
        t4 = object._engine$_actions;
        if (typeof t4 !== "number")
          return t4.$and();
        object._updateRole$2(C.Role_0, (t4 & 64) !== 0 || (t4 & 128) !== 0);
        t4 = object._engine$_actions;
        if (typeof t4 !== "number")
          return t4.$and();
        object._updateRole$2(C.Role_1, (t4 & 32) !== 0 || (t4 & 16) !== 0 || (t4 & 4) !== 0 || (t4 & 8) !== 0);
        t4 = object._engine$_flags;
        if (typeof t4 !== "number")
          return t4.$and();
        object._updateRole$2(C.Role_5, (t4 & 1) !== 0 || (t4 & 65536) !== 0);
        t4 = object._engine$_flags;
        if (typeof t4 !== "number")
          return t4.$and();
        if ((t4 & 16384) !== 0) {
          t5 = object._engine$_actions;
          if (typeof t5 !== "number")
            return t5.$and();
          t4 = (t5 & 1) === 0 && (t4 & 8) === 0;
        } else
          t4 = false;
        object._updateRole$2(C.Role_6, t4);
        t4 = object._engine$_flags;
        if (typeof t4 !== "number")
          return t4.$and();
        object._updateRole$2(C.Role_7, (t4 & 32768) !== 0 && (t4 & 8192) === 0);
        object._updateChildrenInTraversalOrder$0();
        t4 = object._dirtyFields;
        if ((t4 & 512) !== 0 || (t4 & 65536) !== 0 || (t4 & 64) !== 0)
          object.recomputePositionAndSize$0();
        object._dirtyFields = 0;
      }
      if (_this._rootSemanticsElement == null) {
        t1 = t3.$index(0, 0).element;
        _this._rootSemanticsElement = t1;
        $.$get$domRenderer()._glassPaneElement.appendChild(t1);
      }
      _this._finalizeTree$0();
    },
    set$_attachments: function(_attachments) {
      this._attachments = H.assertSubtype(_attachments, "$isMap", [P.int, T.SemanticsObject], "$asMap");
    },
    set$_detachments: function(_detachments) {
      this._detachments = H.assertSubtype(_detachments, "$isList", [T.SemanticsObject], "$asList");
    },
    set$_oneTimePostUpdateCallbacks: function(_oneTimePostUpdateCallbacks) {
      this._oneTimePostUpdateCallbacks = H.assertSubtype(_oneTimePostUpdateCallbacks, "$isList", [{func: 1, ret: -1}], "$asList");
    }
  };
  T.EngineSemanticsOwner$__closure.prototype = {
    call$0: function() {
      var t1 = this.$this._rootSemanticsElement;
      if (t1 != null)
        J.remove$0$ax(t1);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  T.EngineSemanticsOwner_closure.prototype = {
    call$0: function() {
      return new P.DateTime(Date.now(), false);
    },
    $signature: 117
  };
  T.EngineSemanticsOwner__tryEnableSemantics_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.set$semanticsEnabled(true);
      t1._schedulePlaceholderRemoval = true;
    },
    $signature: 0
  };
  T.EngineSemanticsOwner_autoEnableOnTap_closure.prototype = {
    call$1: function($event) {
      this.$this._tryEnableSemantics$1(H.interceptedTypeCheck($event, "$isEvent"));
    },
    $signature: 2
  };
  T.EngineSemanticsOwner__getGestureModeClock_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1._gestureMode === C.GestureMode_1)
        return;
      t1._gestureMode = C.GestureMode_1;
      t1._notifyGestureModeListeners$0();
    },
    $signature: 0
  };
  T.Tappable.prototype = {
    update$0: function(_) {
      var _this = this,
        t1 = _this.semanticsObject,
        element = t1.element,
        t2 = t1._engine$_flags;
      if (typeof t2 !== "number")
        return t2.$and();
      t1.setAriaRole$2("button", (t2 & 8) !== 0);
      t2 = t1._engine$_flags;
      if (typeof t2 !== "number")
        return t2.$and();
      if ((t2 & 128) === 0 && (t2 & 8) !== 0) {
        element.setAttribute("aria-disabled", "true");
        _this._stopListening$0();
      } else {
        t1 = t1._engine$_actions;
        if (typeof t1 !== "number")
          return t1.$and();
        if ((t1 & 1) !== 0 && (t2 & 16) === 0) {
          if (_this._clickListener == null) {
            _this.set$_clickListener(new T.Tappable_update_closure(_this));
            J.addEventListener$2$x(element, "click", _this._clickListener);
          }
        } else
          _this._stopListening$0();
      }
    },
    _stopListening$0: function() {
      var t1 = this._clickListener;
      if (t1 == null)
        return;
      J.removeEventListener$2$x(this.semanticsObject.element, "click", t1);
      this.set$_clickListener(null);
    },
    dispose$0: function() {
      this._stopListening$0();
      this.semanticsObject.setAriaRole$2("button", false);
    },
    set$_clickListener: function(_clickListener) {
      this._clickListener = H.functionTypeCheck(_clickListener, {func: 1, args: [W.Event]});
    }
  };
  T.Tappable_update_closure.prototype = {
    call$1: function(_) {
      var t1;
      H.interceptedTypeCheck(_, "$isEvent");
      t1 = this.$this.semanticsObject;
      if (t1.owner._gestureMode !== C.GestureMode_1)
        return;
      $.$get$window().onSemanticsAction$3(t1.id, C.SemanticsAction_1, null);
    },
    $signature: 2
  };
  T.TextField.prototype = {
    _setupDomElement$0: function() {
      var t2, t3, t4, _this = this,
        t1 = _this.persistentTextEditingElement.domElement;
      t1.spellcheck = false;
      t1.setAttribute("spellcheck", "false");
      t1.setAttribute("autocorrect", "off");
      t1.setAttribute("autocomplete", "off");
      t1.setAttribute("data-semantics-role", "text-field");
      t1 = _this.persistentTextEditingElement.domElement.style;
      t1.position = "absolute";
      t1.top = "0";
      t1.left = "0";
      t2 = _this.semanticsObject;
      t3 = t2._engine$_rect;
      t4 = t3.right;
      t3 = t3.left;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = H.S(t4 - t3) + "px";
      t1.width = t3;
      t3 = t2._engine$_rect;
      t4 = t3.bottom;
      t3 = t3.top;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = H.S(t4 - t3) + "px";
      t1.height = t3;
      t2.element.appendChild(_this.persistentTextEditingElement.domElement);
      t1 = $._browserEngine;
      switch (t1 == null ? $._browserEngine = T._detectBrowserEngine() : t1) {
        case C.BrowserEngine_0:
        case C.BrowserEngine_2:
          _this._initializeForBlink$0();
          break;
        case C.BrowserEngine_1:
          _this._initializeForWebkit$0();
          break;
      }
    },
    _initializeForBlink$0: function() {
      J.addEventListener$2$x(this.persistentTextEditingElement.domElement, "focus", new T.TextField__initializeForBlink_closure(this));
    },
    _initializeForWebkit$0: function() {
      var _this = this, t1 = {};
      t1.lastTouchStartOffsetY = t1.lastTouchStartOffsetX = null;
      J.addEventListener$3$x(_this.persistentTextEditingElement.domElement, "touchstart", new T.TextField__initializeForWebkit_closure(t1, _this), true);
      J.addEventListener$3$x(_this.persistentTextEditingElement.domElement, "touchend", new T.TextField__initializeForWebkit_closure0(t1, _this), true);
    },
    update$0: function(_) {
    },
    dispose$0: function() {
      J.remove$0$ax(this.persistentTextEditingElement.domElement);
      $.$get$textEditing().useCustomEditableElement$1(null);
    }
  };
  T.TextField__initializeForBlink_closure.prototype = {
    call$1: function($event) {
      var t1, t2;
      H.interceptedTypeCheck($event, "$isEvent");
      t1 = this.$this;
      t2 = t1.semanticsObject;
      if (t2.owner._gestureMode !== C.GestureMode_1)
        return;
      $.$get$textEditing().useCustomEditableElement$1(t1.persistentTextEditingElement);
      $.$get$window().onSemanticsAction$3(t2.id, C.SemanticsAction_1, null);
    },
    $signature: 2
  };
  T.TextField__initializeForWebkit_closure.prototype = {
    call$1: function($event) {
      var t1, t2;
      H.interceptedTypeCheck($event, "$isEvent");
      $.$get$textEditing().useCustomEditableElement$1(this.$this.persistentTextEditingElement);
      H.interceptedTypeCheck($event, "$isTouchEvent");
      t1 = $event.changedTouches;
      t1 = (t1 && C.TouchList_methods).get$last(t1);
      t2 = C.JSNumber_methods.round$0(t1.clientX);
      C.JSNumber_methods.round$0(t1.clientY);
      t1 = this._box_0;
      t1.lastTouchStartOffsetX = t2;
      t2 = $event.changedTouches;
      t2 = (t2 && C.TouchList_methods).get$last(t2);
      C.JSNumber_methods.round$0(t2.clientX);
      t1.lastTouchStartOffsetY = C.JSNumber_methods.round$0(t2.clientY);
    },
    $signature: 2
  };
  T.TextField__initializeForWebkit_closure0.prototype = {
    call$1: function($event) {
      var t1, t2, offsetX, offsetY;
      $event = H.interceptedTypeCheck(H.interceptedTypeCheck($event, "$isEvent"), "$isTouchEvent");
      t1 = this._box_0;
      if (t1.lastTouchStartOffsetX != null) {
        t2 = $event.changedTouches;
        t2 = (t2 && C.TouchList_methods).get$last(t2);
        offsetX = C.JSNumber_methods.round$0(t2.clientX);
        C.JSNumber_methods.round$0(t2.clientY);
        t2 = $event.changedTouches;
        t2 = (t2 && C.TouchList_methods).get$last(t2);
        C.JSNumber_methods.round$0(t2.clientX);
        offsetY = C.JSNumber_methods.round$0(t2.clientY);
        if (offsetX * offsetX + offsetY * offsetY < 324)
          $.$get$window().onSemanticsAction$3(this.$this.semanticsObject.id, C.SemanticsAction_1, null);
      }
      t1.lastTouchStartOffsetY = t1.lastTouchStartOffsetX = null;
    },
    $signature: 2
  };
  T.MethodCall.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + this.method + ", " + H.S(this.$arguments) + ")";
    }
  };
  T.StringCodec0.prototype = {
    decodeMessage$1: function(message) {
      var t1 = message.buffer;
      t1.toString;
      return new P.Utf8Decoder(false).convert$1(H.NativeUint8List_NativeUint8List$view(t1, 0, null));
    },
    encodeMessage$1: function(message) {
      var t1 = C.C_Utf8Encoder.convert$1(message).buffer;
      t1.toString;
      return H.NativeByteData_NativeByteData$view(t1, 0, null);
    }
  };
  T.JSONMessageCodec0.prototype = {
    encodeMessage$1: function(message) {
      return C.C_StringCodec0.encodeMessage$1(C.C_JsonCodec.encode$1(message));
    },
    decodeMessage$1: function(message) {
      if (message == null)
        return message;
      return C.C_JsonCodec.decode$1(0, C.C_StringCodec0.decodeMessage$1(message));
    }
  };
  T.JSONMethodCodec0.prototype = {
    encodeMethodCall$1: function($call) {
      return C.C_JSONMessageCodec0.encodeMessage$1(P.LinkedHashMap_LinkedHashMap$_literal(["method", $call.method, "args", $call.$arguments], P.String, null));
    },
    decodeMethodCall$1: function(methodCall) {
      var method, $arguments, _null = null,
        decoded = C.C_JSONMessageCodec0.decodeMessage$1(methodCall),
        t1 = J.getInterceptor$(decoded);
      if (!t1.$isMap)
        throw H.wrapException(P.FormatException$("Expected method call Map, got " + H.S(decoded), _null, _null));
      method = t1.$index(decoded, "method");
      $arguments = t1.$index(decoded, "args");
      if (typeof method === "string")
        return new T.MethodCall(method, $arguments);
      throw H.wrapException(P.FormatException$("Invalid method call: " + H.S(decoded), _null, _null));
    }
  };
  T.StandardMessageCodec.prototype = {
    decodeMessage$1: function(message) {
      var buffer, result, t1, t2;
      if (message == null)
        return;
      buffer = new T.ReadBuffer(message);
      result = this.readValue$1(0, buffer);
      t1 = buffer._engine$_position;
      t2 = message.byteLength;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 < t2)
        throw H.wrapException(C.FormatException_oCg);
      return result;
    },
    readValue$1: function(_, buffer) {
      var t1 = buffer._engine$_position,
        t2 = buffer.data.byteLength;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 >= t2)
        throw H.wrapException(C.FormatException_oCg);
      return this.readValueOfType$2(buffer.getUint8$0(0), buffer);
    },
    readValueOfType$2: function(type, buffer) {
      var result, value, $length, t1, t2, t3, list, i, t4, _this = this;
      switch (type) {
        case 0:
          result = null;
          break;
        case 1:
          result = true;
          break;
        case 2:
          result = false;
          break;
        case 3:
          value = buffer.data.getInt32(buffer._engine$_position, C.C_Endian === $.$get$Endian_host());
          buffer._engine$_position += 4;
          result = value;
          break;
        case 4:
          result = buffer.getInt64$0(0);
          break;
        case 5:
          result = P.int_parse(new P.Utf8Decoder(false).convert$1(buffer.getUint8List$1(_this.readSize$1(buffer))), null, 16);
          break;
        case 6:
          buffer._alignTo$1(8);
          value = buffer.data.getFloat64(buffer._engine$_position, C.C_Endian === $.$get$Endian_host());
          buffer._engine$_position += 8;
          result = value;
          break;
        case 7:
          result = new P.Utf8Decoder(false).convert$1(buffer.getUint8List$1(_this.readSize$1(buffer)));
          break;
        case 8:
          result = buffer.getUint8List$1(_this.readSize$1(buffer));
          break;
        case 9:
          $length = _this.readSize$1(buffer);
          buffer._alignTo$1(4);
          t1 = buffer.data;
          t2 = t1.buffer;
          t1 = t1.byteOffset;
          t3 = buffer._engine$_position;
          if (typeof t1 !== "number")
            return t1.$add();
          t3 = t1 + t3;
          t2.toString;
          H._checkViewArguments(t2, t3, $length);
          list = $length == null ? new Int32Array(t2, t3) : new Int32Array(t2, t3, $length);
          t1 = buffer._engine$_position;
          if (typeof $length !== "number")
            return H.iae($length);
          buffer._engine$_position = t1 + 4 * $length;
          result = list;
          break;
        case 10:
          result = buffer.getInt64List$1(_this.readSize$1(buffer));
          break;
        case 11:
          $length = _this.readSize$1(buffer);
          buffer._alignTo$1(8);
          t1 = buffer.data;
          t2 = t1.buffer;
          t1 = t1.byteOffset;
          t3 = buffer._engine$_position;
          if (typeof t1 !== "number")
            return t1.$add();
          t3 = t1 + t3;
          t2.toString;
          H._checkViewArguments(t2, t3, $length);
          list = $length == null ? new Float64Array(t2, t3) : new Float64Array(t2, t3, $length);
          t1 = buffer._engine$_position;
          if (typeof $length !== "number")
            return H.iae($length);
          buffer._engine$_position = t1 + 8 * $length;
          result = list;
          break;
        case 12:
          $length = _this.readSize$1(buffer);
          if (typeof $length !== "number")
            return H.iae($length);
          result = new Array($length);
          result.fixed$length = Array;
          for (t1 = buffer.data, i = 0; i < $length; ++i) {
            t2 = buffer._engine$_position;
            t3 = t1.byteLength;
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (t2 >= t3)
              H.throwExpression(C.FormatException_oCg);
            buffer._engine$_position = t2 + 1;
            C.JSArray_methods.$indexSet(result, i, _this.readValueOfType$2(t1.getUint8(t2), buffer));
          }
          break;
        case 13:
          $length = _this.readSize$1(buffer);
          result = P.LinkedHashMap__makeEmpty();
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = buffer.data;
          i = 0;
          for (; i < $length; ++i) {
            t2 = buffer._engine$_position;
            t3 = t1.byteLength;
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (t2 >= t3)
              H.throwExpression(C.FormatException_oCg);
            buffer._engine$_position = t2 + 1;
            t2 = _this.readValueOfType$2(t1.getUint8(t2), buffer);
            t3 = buffer._engine$_position;
            t4 = t1.byteLength;
            if (typeof t4 !== "number")
              return H.iae(t4);
            if (t3 >= t4)
              H.throwExpression(C.FormatException_oCg);
            buffer._engine$_position = t3 + 1;
            result.$indexSet(0, t2, _this.readValueOfType$2(t1.getUint8(t3), buffer));
          }
          break;
        default:
          throw H.wrapException(C.FormatException_oCg);
      }
      return result;
    },
    readSize$1: function(buffer) {
      var value = buffer.getUint8$0(0);
      switch (value) {
        case 254:
          value = buffer.data.getUint16(buffer._engine$_position, C.C_Endian === $.$get$Endian_host());
          buffer._engine$_position += 2;
          return value;
        case 255:
          value = buffer.data.getUint32(buffer._engine$_position, C.C_Endian === $.$get$Endian_host());
          buffer._engine$_position += 4;
          return value;
        default:
          return value;
      }
    }
  };
  T.StandardMethodCodec.prototype = {
    decodeMethodCall$1: function(methodCall) {
      var t1, t2,
        buffer = new T.ReadBuffer(methodCall),
        method = C.C_StandardMessageCodec.readValue$1(0, buffer),
        $arguments = C.C_StandardMessageCodec.readValue$1(0, buffer);
      if (typeof method === "string") {
        t1 = buffer._engine$_position;
        t2 = methodCall.byteLength;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = t1 >= t2;
        t1 = t2;
      } else
        t1 = false;
      if (t1)
        return new T.MethodCall(method, $arguments);
      else
        throw H.wrapException(C.FormatException_Qi2);
    }
  };
  T.ReadBuffer.prototype = {
    getUint8$0: function(_) {
      return this.data.getUint8(this._engine$_position++);
    },
    getInt64$0: function(_) {
      var t1 = this.data;
      (t1 && C.NativeByteData_methods).getInt64$2(t1, this._engine$_position, $.$get$Endian_host());
    },
    getUint8List$1: function($length) {
      var t3, list, _this = this,
        t1 = _this.data,
        t2 = t1.buffer;
      t1 = t1.byteOffset;
      t3 = _this._engine$_position;
      if (typeof t1 !== "number")
        return t1.$add();
      t2.toString;
      list = H.NativeUint8List_NativeUint8List$view(t2, t1 + t3, $length);
      t3 = _this._engine$_position;
      if (typeof $length !== "number")
        return H.iae($length);
      _this._engine$_position = t3 + $length;
      return list;
    },
    getInt64List$1: function($length) {
      var t1, t2, t3;
      this._alignTo$1(8);
      t1 = this.data;
      t2 = t1.buffer;
      t1 = t1.byteOffset;
      t3 = this._engine$_position;
      if (typeof t1 !== "number")
        return t1.$add();
      (t2 && C.NativeByteBuffer_methods).asInt64List$2(t2, t1 + t3, $length);
    },
    _alignTo$1: function(alignment) {
      var t1 = this._engine$_position,
        mod = C.JSInt_methods.$mod(t1, alignment);
      if (mod !== 0)
        this._engine$_position = t1 + (alignment - mod);
    }
  };
  T.PersistedOffset.prototype = {
    recomputeTransformAndClip$0: function() {
      var t3, _this = this,
        t1 = _this._engine$_transform = _this.parent._engine$_transform,
        t2 = _this.dx;
      if (t2 !== 0 || _this.dy !== 0) {
        t1.toString;
        t3 = new T.Matrix40(new Float64Array(16));
        t3.setFrom$1(t1);
        _this._engine$_transform = t3;
        t3.translate$2(0, t2, _this.dy);
      }
      _this._globalClip = _this.parent._globalClip;
    },
    createElement$0: function(_) {
      var t1 = this.defaultCreateElement$1("flt-offset"),
        t2 = t1.style;
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t2, (t2 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t2, "transform-origin"), "0 0 0", "");
      return t1;
    },
    apply$0: function() {
      var t1 = this.rootElement.style,
        t2 = "translate(" + H.S(this.dx) + "px, " + H.S(this.dy) + "px)";
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "transform"), t2, "");
    },
    update$1: function(_, oldSurface) {
      var _this = this;
      H.interceptedTypeCheck(oldSurface, "$isPersistedOffset");
      _this.super$PersistedContainerSurface$update(0, oldSurface);
      if (oldSurface.dx !== _this.dx || oldSurface.dy !== _this.dy)
        _this.apply$0();
    }
  };
  T._PaintRequest.prototype = {};
  T.PersistedStandardPicture.prototype = {
    matchForUpdate$1: function(existingSurface) {
      var t1, t2, didRequireBitmap, requiresBitmap, oldCanvas, t3, t4, t5, t6, t7, t8, oldPixelCount;
      H.interceptedTypeCheck(existingSurface, "$isPersistedStandardPicture");
      t1 = existingSurface.picture;
      t2 = this.picture;
      if (t1 == t2)
        return 0;
      if (!t1.get$recordingCanvas()._didDraw)
        return 1;
      didRequireBitmap = t1.get$recordingCanvas()._hasArbitraryPaint;
      requiresBitmap = t2.get$recordingCanvas()._hasArbitraryPaint;
      if (didRequireBitmap !== requiresBitmap)
        return 1;
      else if (!requiresBitmap)
        return 1;
      else {
        oldCanvas = H.interceptedTypeCheck(existingSurface._engine$_canvas, "$isBitmapCanvas");
        if (!T.PersistedStandardPicture__doesCanvasFitBounds(oldCanvas, this._exactLocalCullRect))
          return 1;
        else {
          t1 = this._exactLocalCullRect;
          t2 = t1.right;
          t3 = t1.left;
          if (typeof t3 !== "number")
            return H.iae(t3);
          t4 = t1.bottom;
          t1 = t1.top;
          if (typeof t1 !== "number")
            return H.iae(t1);
          t5 = oldCanvas._bounds;
          t6 = t5.right;
          t7 = t5.left;
          if (typeof t7 !== "number")
            return H.iae(t7);
          t8 = t5.bottom;
          t5 = t5.top;
          if (typeof t5 !== "number")
            return H.iae(t5);
          oldPixelCount = (t6 - t7) * (t8 - t5);
          if (oldPixelCount === 0)
            return 1;
          return 1 - (t2 - t3) * (t4 - t1) / oldPixelCount;
        }
      }
    },
    _applyBitmapPaint$1: function(oldCanvas) {
      var t1, t2, t3, t4, t5, _this = this;
      if (oldCanvas instanceof T.BitmapCanvas && T.PersistedStandardPicture__doesCanvasFitBounds(oldCanvas, _this._optimalLocalCullRect) && oldCanvas._devicePixelRatio == window.devicePixelRatio) {
        oldCanvas._bounds = _this._optimalLocalCullRect;
        _this._engine$_canvas = oldCanvas;
        oldCanvas.clear$0(0);
        _this.picture.get$recordingCanvas().apply$1(_this._engine$_canvas);
      } else {
        T._recycleCanvas(oldCanvas);
        t1 = $._paintQueue;
        t2 = _this._optimalLocalCullRect;
        t3 = t2.right;
        t4 = t2.left;
        if (typeof t4 !== "number")
          return H.iae(t4);
        t5 = t2.bottom;
        t2 = t2.top;
        if (typeof t2 !== "number")
          return H.iae(t2);
        C.JSArray_methods.add$1(t1, new T._PaintRequest(new Q.Size(t3 - t4, t5 - t2), new T.PersistedStandardPicture__applyBitmapPaint_closure(_this)));
      }
    },
    _findOrCreateCanvas$1: function(bounds) {
      var t3, bestRecycledCanvas, lastPixelCount, i, candidate, t4, t5, t6, candidatePixelCount, fits, isSmaller, t7, canvas,
        _s8_ = "absolute",
        t1 = bounds.right,
        t2 = bounds.left;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = t1 - t2;
      t1 = bounds.bottom;
      t3 = bounds.top;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = t1 - t3;
      for (t1 = $._recycledCanvases.length, bestRecycledCanvas = null, lastPixelCount = 1 / 0, i = 0; i < t1; ++i) {
        candidate = $._recycledCanvases[i];
        if (candidate._devicePixelRatio != window.devicePixelRatio)
          continue;
        t4 = candidate._bounds;
        t5 = t4.right;
        t6 = t4.left;
        if (typeof t6 !== "number")
          return H.iae(t6);
        t6 = t5 - t6;
        t5 = t4.bottom;
        t4 = t4.top;
        if (typeof t4 !== "number")
          return H.iae(t4);
        t4 = t5 - t4;
        candidatePixelCount = t6 * t4;
        fits = t6 >= t2 && t4 >= t3;
        isSmaller = candidatePixelCount < lastPixelCount;
        if (fits && isSmaller) {
          if (t6 === t2 && t4 === t3) {
            bestRecycledCanvas = candidate;
            break;
          }
          lastPixelCount = candidatePixelCount;
          bestRecycledCanvas = candidate;
        }
      }
      if (bestRecycledCanvas != null) {
        C.JSArray_methods.remove$1($._recycledCanvases, bestRecycledCanvas);
        bestRecycledCanvas._bounds = bounds;
        return bestRecycledCanvas;
      }
      t1 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("flt-canvas", null), "$isElement0");
      t4 = H.setRuntimeTypeInfo([], [W.Element0]);
      t5 = window.devicePixelRatio;
      t6 = H.setRuntimeTypeInfo([], [T._SaveStackEntry]);
      t7 = new T.Matrix40(new Float64Array(16));
      t7.setIdentity$0();
      canvas = new T.BitmapCanvas(bounds, t1, t4, t5, t6, null, t7);
      t7 = t1.style;
      t7.position = _s8_;
      t4 = window.devicePixelRatio;
      if (typeof t4 !== "number")
        return H.iae(t4);
      t4 = canvas._widthInBitmapPixels = C.JSNumber_methods.ceil$0((t2 + 1 + 2) * t4);
      t2 = window.devicePixelRatio;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = canvas._heightInBitmapPixels = C.JSNumber_methods.ceil$0((t3 + 1 + 2) * t2);
      t3 = window.devicePixelRatio;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t5 = window.devicePixelRatio;
      if (typeof t5 !== "number")
        return H.iae(t5);
      t6 = canvas._engine$_canvas = W.CanvasElement_CanvasElement(t2, t4);
      t7 = t6.style;
      t7.position = _s8_;
      t3 = H.S(t4 / t3) + "px";
      t7.width = t3;
      t2 = H.S(t2 / t5) + "px";
      t7.height = t2;
      canvas._ctx = t6.getContext("2d");
      t1.appendChild(t6);
      canvas._initializeViewport$0();
      return canvas;
    }
  };
  T.PersistedStandardPicture__applyBitmapPaint_closure.prototype = {
    call$0: function() {
      var t2, t3,
        t1 = this.$this;
      t1._engine$_canvas = t1._findOrCreateCanvas$1(t1._optimalLocalCullRect);
      $.$get$domRenderer().clearDom$1(t1.rootElement);
      t2 = t1.rootElement;
      t3 = t1._engine$_canvas;
      t2.appendChild(t3.get$rootElement(t3));
      t1._engine$_canvas.clear$0(0);
      t1.picture.get$recordingCanvas().apply$1(t1._engine$_canvas);
    },
    $signature: 0
  };
  T.PersistedPicture.prototype = {
    createElement$0: function(_) {
      return this.defaultCreateElement$1("flt-picture");
    },
    recomputeTransformAndClip$0: function() {
      var t3, tightGlobalCullRect, tightLocalCullRect, invertedTransform, _this = this,
        t1 = _this._engine$_transform = _this.parent._engine$_transform,
        t2 = _this.dx;
      if (t2 !== 0 || _this.dy !== 0) {
        t1.toString;
        t3 = new T.Matrix40(new Float64Array(16));
        t3.setFrom$1(t1);
        _this._engine$_transform = t3;
        t3.translate$2(0, t2, _this.dy);
      }
      _this._globalClip = _this.parent._globalClip;
      tightGlobalCullRect = T.localClipRectToGlobalClip(_this.localPaintBounds, _this._engine$_transform).intersect$1(_this._globalClip);
      t1 = tightGlobalCullRect.left;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (!(tightGlobalCullRect.right - t1 <= 0)) {
        t1 = tightGlobalCullRect.top;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = tightGlobalCullRect.bottom - t1 <= 0;
      } else
        t1 = true;
      if (t1) {
        tightGlobalCullRect = C.Rect_0_0_0_0;
        tightLocalCullRect = C.Rect_0_0_0_0;
      } else {
        invertedTransform = new T.Matrix40(new Float64Array(16));
        if (invertedTransform.copyInverse$1(_this._engine$_transform) === 0) {
          tightGlobalCullRect = C.Rect_0_0_0_0;
          tightLocalCullRect = C.Rect_0_0_0_0;
        } else
          tightLocalCullRect = T.localClipRectToGlobalClip(tightGlobalCullRect, invertedTransform);
      }
      _this._exactLocalCullRect = tightLocalCullRect;
      _this._exactGlobalCullRect = tightGlobalCullRect;
    },
    _computeOptimalCullRect$1: function(oldSurface) {
      var oldOptimalLocalCullRect, t1, t2, t3, t4, t5, t6, t7, t8, newLocalCullRect, _this = this;
      if (oldSurface == null || !oldSurface.picture.get$recordingCanvas()._didDraw) {
        _this._optimalLocalCullRect = _this._exactLocalCullRect;
        return true;
      }
      oldOptimalLocalCullRect = oldSurface === _this ? _this._optimalLocalCullRect : oldSurface._optimalLocalCullRect;
      if (J.$eq$(_this._exactLocalCullRect, C.Rect_0_0_0_0)) {
        _this._optimalLocalCullRect = C.Rect_0_0_0_0;
        return !J.$eq$(oldOptimalLocalCullRect, C.Rect_0_0_0_0);
      }
      t1 = _this._exactLocalCullRect;
      t2 = oldOptimalLocalCullRect.left;
      t3 = t1.left;
      if (typeof t2 !== "number")
        return t2.$le();
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (t2 <= t3) {
        t4 = oldOptimalLocalCullRect.top;
        t5 = t1.top;
        if (typeof t4 !== "number")
          return t4.$le();
        if (typeof t5 !== "number")
          return H.iae(t5);
        t4 = t4 <= t5 && oldOptimalLocalCullRect.right >= t1.right && oldOptimalLocalCullRect.bottom >= t1.bottom;
      } else
        t4 = false;
      if (t4) {
        _this._optimalLocalCullRect = oldOptimalLocalCullRect;
        return false;
      }
      t3 = Math.max(t2 - t3, 0);
      t4 = oldOptimalLocalCullRect.top;
      t5 = t1.top;
      if (typeof t4 !== "number")
        return t4.$sub();
      if (typeof t5 !== "number")
        return H.iae(t5);
      t5 = Math.max(t4 - t5, 0);
      t6 = t1.right;
      t7 = oldOptimalLocalCullRect.right;
      t6 = Math.max(t6 - t7, 0);
      t1 = t1.bottom;
      t8 = oldOptimalLocalCullRect.bottom;
      newLocalCullRect = new Q.Rect(t2 - 3 * t3, t4 - 3 * t5, t7 + 3 * t6, t8 + 3 * Math.max(t1 - t8, 0)).intersect$1(_this.localPaintBounds);
      t8 = J.$eq$(_this._optimalLocalCullRect, newLocalCullRect);
      _this._optimalLocalCullRect = newLocalCullRect;
      return !t8;
    },
    _applyPaint$1: function(oldSurface) {
      var t2, t3, t4, t5, t6, _this = this,
        oldCanvas = oldSurface == null ? null : oldSurface._engine$_canvas,
        t1 = _this.picture;
      if (!t1.get$recordingCanvas()._didDraw) {
        T._recycleCanvas(oldCanvas);
        $.$get$domRenderer().clearDom$1(_this.rootElement);
        return;
      }
      if (t1.get$recordingCanvas()._hasArbitraryPaint)
        _this._applyBitmapPaint$1(oldCanvas);
      else {
        T._recycleCanvas(oldCanvas);
        t2 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("flt-dom-canvas", null), "$isElement0");
        t3 = H.setRuntimeTypeInfo([], [T._SaveElementStackEntry]);
        t4 = H.setRuntimeTypeInfo([], [W.Element0]);
        t5 = new T.Matrix40(new Float64Array(16));
        t5.setIdentity$0();
        t6 = t2.style;
        t6.position = "absolute";
        t6.top = "0";
        t6.right = "0";
        t6.bottom = "0";
        t6.left = "0";
        _this._engine$_canvas = new T.DomCanvas(t2, t3, t4, t5);
        $.$get$domRenderer().clearDom$1(_this.rootElement);
        t2 = _this.rootElement;
        t3 = _this._engine$_canvas;
        t2.appendChild(t3.get$rootElement(t3));
        t1.get$recordingCanvas().apply$1(_this._engine$_canvas);
      }
      _this._didApplyPaint.set$value(0, true);
    },
    _applyTranslate$0: function() {
      var t1 = this.rootElement.style,
        t2 = "translate(" + H.S(this.dx) + "px, " + H.S(this.dy) + "px)";
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "transform"), t2, "");
    },
    apply$0: function() {
      this._applyTranslate$0();
      this._applyPaint$1(null);
    },
    build$0: function() {
      this._computeOptimalCullRect$1(null);
      this.super$PersistedSurface$build();
    },
    update$1: function(_, oldSurface) {
      var cullRectChangeRequiresRepaint, _this = this;
      H.interceptedTypeCheck(oldSurface, "$isPersistedPicture");
      _this.super$PersistedSurface$update(0, oldSurface);
      if (_this.dx != oldSurface.dx || _this.dy != oldSurface.dy)
        _this._applyTranslate$0();
      cullRectChangeRequiresRepaint = _this._computeOptimalCullRect$1(oldSurface);
      if (_this.picture == oldSurface.picture)
        if (cullRectChangeRequiresRepaint)
          _this._applyPaint$1(oldSurface);
        else
          _this._engine$_canvas = oldSurface._engine$_canvas;
      else
        _this._applyPaint$1(oldSurface);
    },
    retain$0: function() {
      var _this = this;
      _this.super$PersistedSurface$retain();
      if (_this._computeOptimalCullRect$1(_this))
        _this._applyPaint$1(_this);
    },
    discard$0: function() {
      T._recycleCanvas(this._engine$_canvas);
      this.super$PersistedSurface$discard();
    }
  };
  T.PersistedScene.prototype = {
    recomputeTransformAndClip$0: function() {
      var screenHeight,
        screenWidth = window.innerWidth;
      screenWidth.toString;
      screenHeight = window.innerHeight;
      screenHeight.toString;
      this._globalClip = new Q.Rect(0, 0, screenWidth, screenHeight);
    },
    createElement$0: function(_) {
      return this.defaultCreateElement$1("flt-scene");
    },
    apply$0: function() {
    }
  };
  T.FrameReference.prototype = {
    set$value: function(_, value) {
      this.value = H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
    }
  };
  T.commitScene_closure.prototype = {
    call$2: function(a, b) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(a, "$is_PaintRequest");
      H.interceptedTypeCheck(b, "$is_PaintRequest");
      t1 = a.canvasSize;
      t2 = t1._dy;
      t1 = t1._dx;
      if (typeof t2 !== "number")
        return t2.$mul();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t3 = b.canvasSize;
      t4 = t3._dy;
      t3 = t3._dx;
      if (typeof t4 !== "number")
        return t4.$mul();
      if (typeof t3 !== "number")
        return H.iae(t3);
      return C.JSNumber_methods.compareTo$1(t4 * t3, t2 * t1);
    },
    $signature: 118
  };
  T.PersistedSurfaceState.prototype = {
    toString$0: function(_) {
      return this._engine$_name;
    }
  };
  T.PersistedSurface.prototype = {
    revive$0: function() {
      this._engine$_state = C.PersistedSurfaceState_0;
    },
    build$0: function() {
      var _this = this;
      _this.rootElement = _this.createElement$0(0);
      _this.apply$0();
      _this._engine$_state = C.PersistedSurfaceState_1;
    },
    update$1: function(_, oldSurface) {
      this.rootElement = oldSurface.rootElement;
      oldSurface.rootElement = null;
      oldSurface._engine$_state = C.PersistedSurfaceState_4;
      this._engine$_state = C.PersistedSurfaceState_1;
    },
    retain$0: function() {
      if (this._engine$_state === C.PersistedSurfaceState_2)
        C.JSArray_methods.add$1($._retainedSurfaces, this);
    },
    discard$0: function() {
      J.remove$0$ax(this.rootElement);
      this.rootElement = null;
      this._engine$_state = C.PersistedSurfaceState_4;
    },
    defaultCreateElement$1: function(tagName) {
      var element = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(tagName, null), "$isElement0"),
        t1 = element.style;
      t1.position = "absolute";
      return element;
    },
    recomputeTransformAndClip$0: function() {
      var t1 = this.parent;
      this._engine$_transform = t1._engine$_transform;
      this._globalClip = t1._globalClip;
    },
    preroll$0: function() {
      this.recomputeTransformAndClip$0();
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    },
    $isEngineLayer: 1
  };
  T.PersistedLeafSurface.prototype = {};
  T.PersistedContainerSurface.prototype = {
    preroll$0: function() {
      var t1, $length, i;
      this.super$PersistedSurface$preroll();
      t1 = this._engine$_children;
      $length = t1.length;
      for (i = 0; i < $length; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].preroll$0();
      }
    },
    recomputeTransformAndClip$0: function() {
      var t1 = this.parent;
      this._engine$_transform = t1._engine$_transform;
      this._globalClip = t1._globalClip;
    },
    build$0: function() {
      var t1, len, containerElement, i, child;
      this.super$PersistedSurface$build();
      t1 = this._engine$_children;
      len = t1.length;
      containerElement = this.rootElement;
      for (i = 0; i < len; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        child = t1[i];
        if (child._engine$_state === C.PersistedSurfaceState_2)
          child.retain$0();
        else if (child instanceof T.PersistedContainerSurface && child._oldLayer.value != null)
          child.update$1(0, child._oldLayer.value);
        else
          child.build$0();
        containerElement.appendChild(child.rootElement);
      }
    },
    matchForUpdate$1: function(existingSurface) {
      H.interceptedTypeCheck(existingSurface, "$isPersistedContainerSurface");
      return 1;
    },
    update$1: function(_, oldSurface) {
      var t1, _this = this;
      H.interceptedTypeCheck(oldSurface, "$isPersistedContainerSurface");
      _this.super$PersistedSurface$update(0, oldSurface);
      if (oldSurface._engine$_children.length === 0)
        _this._updateZeroToMany$1(oldSurface);
      else {
        t1 = _this._engine$_children.length;
        if (t1 === 1)
          _this._updateManyToOne$1(oldSurface);
        else if (t1 === 0)
          T.PersistedContainerSurface__discardActiveChildren(oldSurface);
        else
          _this._updateManyToMany$1(oldSurface);
      }
    },
    _updateZeroToMany$1: function(oldSurface) {
      var i, newChild,
        containerElement = this.rootElement,
        t1 = this._engine$_children,
        $length = t1.length;
      for (i = 0; i < $length; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        newChild = t1[i];
        if (newChild._engine$_state === C.PersistedSurfaceState_2)
          newChild.retain$0();
        else if (newChild instanceof T.PersistedContainerSurface && newChild._oldLayer.value != null)
          newChild.update$1(0, newChild._oldLayer.value);
        else
          newChild.build$0();
        containerElement.appendChild(newChild.rootElement);
      }
    },
    _updateManyToOne$1: function(oldSurface) {
      var newChild, t2, t3, t4, bestMatch, bestScore, i, candidate, score, oldChild, _this = this,
        t1 = _this._engine$_children;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      newChild = t1[0];
      if (newChild._engine$_state === C.PersistedSurfaceState_2) {
        t1 = newChild.rootElement;
        t2 = t1.parentElement;
        t3 = _this.rootElement;
        if (t2 == null ? t3 != null : t2 !== t3)
          t3.appendChild(t1);
        newChild.retain$0();
        T.PersistedContainerSurface__discardActiveChildren(oldSurface);
        return;
      }
      if (newChild instanceof T.PersistedContainerSurface && newChild._oldLayer.value != null) {
        t1 = newChild._oldLayer.value;
        t2 = t1.rootElement;
        t3 = t2.parentElement;
        t4 = _this.rootElement;
        if (t3 == null ? t4 != null : t3 !== t4)
          t4.appendChild(t2);
        newChild.update$1(0, t1);
        T.PersistedContainerSurface__discardActiveChildren(oldSurface);
        return;
      }
      for (t1 = oldSurface._engine$_children, bestMatch = null, bestScore = 2, i = 0; i < t1.length; ++i) {
        candidate = t1[i];
        if (!(candidate._engine$_state === C.PersistedSurfaceState_1 && new H.TypeImpl(H.getRti(newChild)).$eq(0, new H.TypeImpl(H.getRti(candidate)))))
          continue;
        score = newChild.matchForUpdate$1(candidate);
        if (score < bestScore) {
          bestScore = score;
          bestMatch = candidate;
        }
      }
      if (bestMatch != null) {
        newChild.update$1(0, bestMatch);
        t2 = newChild.rootElement;
        t3 = t2.parentElement;
        t4 = _this.rootElement;
        if (t3 == null ? t4 != null : t3 !== t4)
          t4.appendChild(t2);
      } else {
        newChild.build$0();
        _this.rootElement.appendChild(newChild.rootElement);
      }
      for (i = 0; i < t1.length; ++i) {
        oldChild = t1[i];
        if (oldChild != bestMatch && oldChild._engine$_state === C.PersistedSurfaceState_1)
          oldChild.discard$0();
      }
    },
    _updateManyToMany$1: function(oldSurface) {
      var insertDomNodeIfMoved, matches, t1, bottomInNew, newChild, matchedOldChild, _this = this, _box_0 = {},
        containerElement = _this.rootElement;
      _box_0.nextSibling = null;
      insertDomNodeIfMoved = new T.PersistedContainerSurface__updateManyToMany_insertDomNodeIfMoved(_box_0, _this, containerElement);
      matches = _this._matchChildren$1(oldSurface);
      for (t1 = _this._engine$_children, bottomInNew = t1.length - 1; bottomInNew >= 0; --bottomInNew) {
        if (bottomInNew >= t1.length)
          return H.ioore(t1, bottomInNew);
        newChild = t1[bottomInNew];
        if (newChild._engine$_state === C.PersistedSurfaceState_2)
          newChild.retain$0();
        else if (newChild instanceof T.PersistedContainerSurface && newChild._oldLayer.value != null)
          newChild.update$1(0, newChild._oldLayer.value);
        else {
          matchedOldChild = matches.$index(0, newChild);
          if (matchedOldChild != null)
            newChild.update$1(0, matchedOldChild);
          else
            newChild.build$0();
        }
        insertDomNodeIfMoved.call$1(newChild);
        _box_0.nextSibling = newChild;
      }
      T.PersistedContainerSurface__discardActiveChildren(oldSurface);
    },
    _matchChildren$1: function(oldSurface) {
      var i, child, oldChildren, newChildCount, oldChildCount, allMatches, indexInNew, newChild, indexInOld, oldChild, result, match, matchedChild,
        t1 = this._engine$_children,
        newUnfilteredChildCount = t1.length,
        t2 = oldSurface._engine$_children,
        oldUnfilteredChildCount = t2.length,
        t3 = T.PersistedSurface,
        t4 = [t3],
        newChildren = H.setRuntimeTypeInfo([], t4);
      for (i = 0; i < newUnfilteredChildCount; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        child = t1[i];
        if (child._engine$_state === C.PersistedSurfaceState_0)
          C.JSArray_methods.add$1(newChildren, child);
      }
      oldChildren = H.setRuntimeTypeInfo([], t4);
      for (i = 0; i < oldUnfilteredChildCount; ++i) {
        if (i >= t2.length)
          return H.ioore(t2, i);
        child = t2[i];
        if (child._engine$_state === C.PersistedSurfaceState_1)
          C.JSArray_methods.add$1(oldChildren, child);
      }
      newChildCount = newChildren.length;
      oldChildCount = oldChildren.length;
      if (newChildCount === 0 || oldChildCount === 0)
        return C.Map_empty0;
      allMatches = H.setRuntimeTypeInfo([], [T._PersistedSurfaceMatch]);
      for (indexInNew = 0; indexInNew < newChildCount; ++indexInNew) {
        if (indexInNew >= newChildren.length)
          return H.ioore(newChildren, indexInNew);
        newChild = newChildren[indexInNew];
        for (indexInOld = 0; indexInOld < oldChildCount; ++indexInOld) {
          if (indexInOld >= oldChildren.length)
            return H.ioore(oldChildren, indexInOld);
          oldChild = oldChildren[indexInOld];
          if (oldChild != null)
            t1 = !(oldChild._engine$_state === C.PersistedSurfaceState_1 && new H.TypeImpl(H.getRti(newChild)).$eq(0, new H.TypeImpl(H.getRti(oldChild))));
          else
            t1 = true;
          if (t1)
            continue;
          C.JSArray_methods.add$1(allMatches, new T._PersistedSurfaceMatch(newChild, indexInOld, newChild.matchForUpdate$1(oldChild)));
        }
      }
      C.JSArray_methods.sort$1(allMatches, new T.PersistedContainerSurface__matchChildren_closure());
      result = P.LinkedHashMap_LinkedHashMap$_empty(t3, t3);
      for (i = 0; i < allMatches.length; ++i) {
        match = allMatches[i];
        t1 = match.oldChildIndex;
        if (t1 >= oldChildren.length)
          return H.ioore(oldChildren, t1);
        matchedChild = oldChildren[t1];
        if (matchedChild != null) {
          C.JSArray_methods.$indexSet(oldChildren, t1, null);
          result.$indexSet(0, match.newChild, matchedChild);
        }
      }
      return result;
    },
    retain$0: function() {
      var t1, len, i;
      this.super$PersistedSurface$retain();
      t1 = this._engine$_children;
      len = t1.length;
      for (i = 0; i < len; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].retain$0();
      }
    },
    revive$0: function() {
      var t1, len, i;
      this.super$PersistedSurface$revive();
      t1 = this._engine$_children;
      len = t1.length;
      for (i = 0; i < len; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].revive$0();
      }
    },
    discard$0: function() {
      this.super$PersistedSurface$discard();
      T.PersistedContainerSurface__discardActiveChildren(this);
    }
  };
  T.PersistedContainerSurface__updateManyToMany_insertDomNodeIfMoved.prototype = {
    call$1: function(newChild) {
      var t4, moved,
        t1 = newChild.rootElement,
        t2 = t1.parentElement,
        t3 = this.containerElement;
      if (t2 == null ? t3 == null : t2 === t3) {
        t2 = t1.nextElementSibling;
        t4 = this._box_0.nextSibling;
        moved = t2 == null ? (t4 == null ? null : t4.rootElement) != null : t2 !== (t4 == null ? null : t4.rootElement);
      } else
        moved = true;
      if (moved) {
        t2 = this._box_0.nextSibling;
        if (t2 == null)
          t3.appendChild(t1);
        else
          t3.insertBefore(t1, t2.rootElement);
      }
    },
    $signature: 119
  };
  T.PersistedContainerSurface__matchChildren_closure.prototype = {
    call$2: function(m1, m2) {
      H.interceptedTypeCheck(m1, "$is_PersistedSurfaceMatch");
      H.interceptedTypeCheck(m2, "$is_PersistedSurfaceMatch");
      return C.JSNumber_methods.compareTo$1(m1.matchQuality, m2.matchQuality);
    },
    $signature: 120
  };
  T._PersistedSurfaceMatch.prototype = {};
  T.PersistedTransform.prototype = {
    recomputeTransformAndClip$0: function() {
      var _this = this;
      _this._engine$_transform = _this.parent._engine$_transform.multiplied$1(new T.Matrix40(_this.matrix4));
      _this._globalClip = _this.parent._globalClip;
    },
    createElement$0: function(_) {
      var t1 = this.defaultCreateElement$1("flt-transform"),
        t2 = t1.style;
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t2, (t2 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t2, "transform-origin"), "0 0 0", "");
      return t1;
    },
    apply$0: function() {
      var t1 = this.rootElement.style,
        t2 = T.float64ListToCssTransform(this.matrix4);
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "transform"), t2, "");
    },
    update$1: function(_, oldSurface) {
      var t1, t2, matrixChanged, i;
      H.interceptedTypeCheck(oldSurface, "$isPersistedTransform");
      this.super$PersistedContainerSurface$update(0, oldSurface);
      t1 = oldSurface.matrix4;
      t2 = this.matrix4;
      if (t1 === t2)
        return;
      i = 0;
      while (true) {
        if (!(i < 16)) {
          matrixChanged = false;
          break;
        }
        if (t2[i] !== t1[i]) {
          matrixChanged = true;
          break;
        }
        ++i;
      }
      if (matrixChanged) {
        t1 = this.rootElement.style;
        t2 = T.float64ListToCssTransform(t2);
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "transform"), t2, "");
      }
    }
  };
  T.FontCollection.prototype = {
    registerFonts$1: function(assetManager) {
      return this.registerFonts$body$FontCollection(assetManager);
    },
    registerFonts$body$FontCollection: function(assetManager) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, e, exception, t1, fontManifest, t2, t3, fontFamily, t4, family, fontAsset, t5, asset, descriptors, t6, t7, byteData, $async$exception;
      var $async$registerFonts$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              byteData = null;
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait(assetManager.load$1(0, "FontManifest.json"), $async$registerFonts$1);
            case 7:
              // returning from await.
              byteData = $async$result;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = H.unwrapException($async$exception);
              if (t1 instanceof T.AssetManagerException) {
                e = t1;
                if (e.httpStatus === 404) {
                  t1 = "Font manifest does not exist at `" + H.S(e.url) + "` \u2013 ignoring.";
                  if (typeof console != "undefined")
                    window.console.warn(t1);
                  // goto return
                  $async$goto = 1;
                  break;
                } else
                  throw $async$exception;
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
              if (byteData == null)
                throw H.wrapException(P.AssertionError$("There was a problem trying to load FontManifest.json"));
              t1 = byteData.buffer;
              t1.toString;
              fontManifest = H.listTypeCheck(C.C_JsonCodec.decode$1(0, C.C_Utf8Codec.decode$1(0, H.NativeUint8List_NativeUint8List$view(t1, 0, null))));
              if (fontManifest == null)
                throw H.wrapException(P.AssertionError$("There was a problem trying to load FontManifest.json"));
              if ($.$get$supportsFontLoadingApi())
                $async$self._assetFontManager = T._FontManager__FontManager();
              else
                $async$self._assetFontManager = new T._PolyfillFontManager(H.setRuntimeTypeInfo([], [[P.Future, -1]]));
              t1 = $._browserEngine;
              if ((t1 == null ? $._browserEngine = T._detectBrowserEngine() : t1) !== C.BrowserEngine_0) {
                t1 = P.String;
                $async$self._assetFontManager.registerAsset$3("Roboto", "url(packages/flutter_web_ui/assets/Roboto-Regular.ttf)", P.LinkedHashMap_LinkedHashMap$_empty(t1, t1));
              }
              for (t1 = J.get$iterator$ax(fontManifest), t2 = P.String, t3 = [t2, null]; t1.moveNext$0();) {
                fontFamily = H.assertSubtype(t1.get$current(t1), "$isMap", t3, "$asMap");
                t4 = J.getInterceptor$asx(fontFamily);
                family = H.stringTypeCheck(t4.$index(fontFamily, "family"));
                for (t4 = J.get$iterator$ax(H.listTypeCheck(t4.$index(fontFamily, "fonts"))); t4.moveNext$0();) {
                  fontAsset = H.assertSubtype(t4.get$current(t4), "$isMap", t3, "$asMap");
                  t5 = J.getInterceptor$asx(fontAsset);
                  asset = H.stringTypeCheck(t5.$index(fontAsset, "asset"));
                  descriptors = P.LinkedHashMap_LinkedHashMap$_empty(t2, t2);
                  for (t6 = J.get$iterator$ax(t5.get$keys(fontAsset)); t6.moveNext$0();) {
                    t7 = t6.get$current(t6);
                    if (t7 !== "asset")
                      descriptors.$indexSet(0, t7, H.S(t5.$index(fontAsset, t7)));
                  }
                  t5 = $async$self._assetFontManager;
                  assetManager.toString;
                  t5.registerAsset$3(family, "url(" + H.S(P.Uri_parse(asset).get$hasScheme() ? asset : "assets/" + H.S(asset)) + ")", descriptors);
                }
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$registerFonts$1, $async$completer);
    },
    ensureFontsLoaded$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1;
      var $async$ensureFontsLoaded$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._assetFontManager;
              $async$goto = 2;
              return P._asyncAwait(t1 == null ? null : P.Future_wait(t1._fontLoadingFutures, -1), $async$ensureFontsLoaded$0);
            case 2:
              // returning from await.
              t1 = $async$self._testFontManager;
              $async$goto = 3;
              return P._asyncAwait(t1 == null ? null : P.Future_wait(t1._fontLoadingFutures, -1), $async$ensureFontsLoaded$0);
            case 3:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$ensureFontsLoaded$0, $async$completer);
    }
  };
  T._FontManager.prototype = {
    registerAsset$3: function(family, asset, descriptors) {
      var t1 = P.String,
        fontFace = W.FontFace_FontFace(family, asset, H.assertSubtype(descriptors, "$isMap", [t1, t1], "$asMap"));
      C.JSArray_methods.add$1(this._fontLoadingFutures, W.promiseToFuture(fontFace.load(), W.FontFace).then$1$2$onError(new T._FontManager_registerAsset_closure(fontFace), new T._FontManager_registerAsset_closure0(family), -1));
    }
  };
  T._FontManager_registerAsset_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isFontFace");
      return document.fonts.add(this.fontFace);
    },
    $signature: 121
  };
  T._FontManager_registerAsset_closure0.prototype = {
    call$1: function(e) {
      var t1;
      window;
      t1 = 'Error while trying to load font family "' + H.S(this.family) + '":\n' + H.S(e);
      if (typeof console != "undefined")
        window.console.warn(t1);
      return;
    },
    $signature: 4
  };
  T._PolyfillFontManager.prototype = {
    registerAsset$3: function(family, asset, descriptors) {
      var t3, paragraph, t4, t5, sansSerifWidth, fontStyleMap, t6, t7, fontFaceDeclaration, fontLoadStyle, _s5_ = "style", _s6_ = "weight", t1 = {},
        t2 = P.String;
      H.assertSubtype(descriptors, "$isMap", [t2, t2], "$asMap");
      t3 = document;
      paragraph = t3.createElement("p");
      t4 = paragraph.style;
      t4.position = "absolute";
      t4 = paragraph.style;
      t4.visibility = "hidden";
      t4 = paragraph.style;
      t4.fontSize = "72px";
      t4 = paragraph.style;
      t4.fontFamily = "sans-serif";
      if (descriptors.$index(0, _s5_) != null) {
        t4 = paragraph.style;
        t5 = descriptors.$index(0, _s5_);
        t4.toString;
        t4.fontStyle = t5 == null ? "" : t5;
      }
      if (descriptors.$index(0, _s6_) != null) {
        t4 = paragraph.style;
        t5 = descriptors.$index(0, _s6_);
        t4.toString;
        t4.fontWeight = t5 == null ? "" : t5;
      }
      paragraph.textContent = "giItT1WQy@!-/#";
      t3.body.appendChild(paragraph);
      sansSerifWidth = C.JSNumber_methods.round$0(paragraph.offsetWidth);
      t4 = paragraph.style;
      t5 = H.S(family) + ", sans-serif";
      t4.fontFamily = t5;
      t4 = -1;
      t5 = new P._Future($.Zone__current, [t4]);
      t1._fontLoadStart = null;
      fontStyleMap = P.LinkedHashMap_LinkedHashMap$_empty(t2, t2);
      fontStyleMap.$indexSet(0, "font-family", "'" + H.S(family) + "'");
      fontStyleMap.$indexSet(0, "src", asset);
      if (descriptors.$index(0, _s5_) != null)
        fontStyleMap.$indexSet(0, "font-style", descriptors.$index(0, _s5_));
      if (descriptors.$index(0, _s6_) != null)
        fontStyleMap.$indexSet(0, "font-weight", descriptors.$index(0, _s6_));
      t6 = fontStyleMap.get$keys(fontStyleMap);
      t7 = H.getRuntimeTypeArgument(t6, "Iterable", 0);
      fontFaceDeclaration = H.MappedIterable_MappedIterable(t6, H.functionTypeCheck(new T._PolyfillFontManager_registerAsset_closure(fontStyleMap), {func: 1, ret: t2, args: [t7]}), t7, t2).join$1(0, " ");
      fontLoadStyle = t3.createElement("style");
      fontLoadStyle.type = "text/css";
      C.StyleElement_methods.setInnerHtml$1(fontLoadStyle, "@font-face { " + fontFaceDeclaration + " }");
      t3.head.appendChild(fontLoadStyle);
      if (C.JSString_methods.contains$1(family.toLowerCase(), "icon")) {
        C.ParagraphElement_methods.remove$0(paragraph);
        return;
      }
      t1._fontLoadStart = new P.DateTime(Date.now(), false);
      new T._PolyfillFontManager_registerAsset__watchWidth(t1, paragraph, sansSerifWidth, new P._AsyncCompleter(t5, [t4]), family).call$0();
      C.JSArray_methods.add$1(this._fontLoadingFutures, t5);
    }
  };
  T._PolyfillFontManager_registerAsset__watchWidth.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.paragraph;
      if (C.JSNumber_methods.round$0(t1.offsetWidth) !== _this.sansSerifWidth) {
        C.ParagraphElement_methods.remove$0(t1);
        _this.completer.complete$0(0);
      } else if (P.Duration$(0, Date.now() - _this._box_0._fontLoadStart._core$_value, 0)._duration > 2000000)
        _this.completer.completeError$1(new P._Exception("Timed out trying to load font: " + H.S(_this.family)));
      else
        P.Timer_Timer(C.Duration_50000, _this);
    },
    $signature: 1
  };
  T._PolyfillFontManager_registerAsset_closure.prototype = {
    call$1: function($name) {
      H.stringTypeCheck($name);
      return H.S($name) + ": " + H.S(this.fontStyleMap.$index(0, $name)) + ";";
    },
    $signature: 8
  };
  T.LineBreakType.prototype = {
    toString$0: function(_) {
      return this._engine$_name;
    }
  };
  T.LineBreakResult.prototype = {};
  T.RulerManager.prototype = {
    _scheduleRulerCacheCleanup$0: function() {
      if (!this._rulerCacheCleanupScheduled) {
        this._rulerCacheCleanupScheduled = true;
        P.scheduleMicrotask(new T.RulerManager__scheduleRulerCacheCleanup_closure(this));
      }
    },
    dispose$0: function() {
      J.remove$0$ax(this._rulerHost);
    },
    cleanUpRulerCache$0: function() {
      var sortedByUsage, i, ruler, t3, _this = this,
        t1 = _this._rulers,
        t2 = _this.rulerCacheCapacity;
      if (t1.get$length(t1) > t2) {
        t1 = _this._rulers;
        t1 = t1.get$values(t1);
        sortedByUsage = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
        C.JSArray_methods.sort$1(sortedByUsage, new T.RulerManager_cleanUpRulerCache_closure());
        _this.set$_rulers(P.LinkedHashMap_LinkedHashMap$_empty(T.ParagraphGeometricStyle, T.ParagraphRuler));
        for (i = 0; i < sortedByUsage.length; ++i) {
          ruler = sortedByUsage[i];
          ruler._hitCount = 0;
          if (i < t2)
            _this._rulers.$indexSet(0, ruler.style, ruler);
          else {
            t1 = ruler._singleLineHost;
            t3 = t1.parentNode;
            if (t3 != null)
              t3.removeChild(t1);
            t1 = ruler._minIntrinsicHost;
            t3 = t1.parentNode;
            if (t3 != null)
              t3.removeChild(t1);
            t1 = ruler._constrainedHost;
            t3 = t1.parentNode;
            if (t3 != null)
              t3.removeChild(t1);
            t1 = ruler._lineHeightHost;
            if (t1 != null) {
              t3 = t1.parentNode;
              if (t3 != null)
                t3.removeChild(t1);
            }
          }
        }
      }
    },
    findOrCreateRuler$1: function(style) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, elementStyle, _this = this, _s6_ = "hidden",
        _s8_ = "absolute",
        _s1_ = "0", _s4_ = "flex",
        _s14_ = "flex-direction",
        _s8_0 = "baseline",
        _s11_ = "align-items",
        _s8_1 = "pre-wrap",
        ruler = _this._rulers.$index(0, style);
      if (ruler == null) {
        t1 = _this._rulers;
        t2 = document;
        t3 = t2.createElement("div");
        t4 = t2.createElement("div");
        t5 = t2.createElement("p");
        t6 = new T.TextDimensions(t5);
        t7 = t2.createElement("div");
        t8 = t2.createElement("p");
        t9 = new T.TextDimensions(t8);
        t10 = t2.createElement("div");
        t2 = t2.createElement("p");
        t11 = new T.TextDimensions(t2);
        t12 = P.String;
        ruler = new T.ParagraphRuler(style, _this, t3, t4, t6, t7, t9, t10, t11, P.LinkedHashMap_LinkedHashMap$_empty(t12, [P.List, T.MeasurementResult]), H.setRuntimeTypeInfo([], [t12]));
        t12 = t4.style;
        t12.visibility = _s6_;
        t12.position = _s8_;
        t12.top = _s1_;
        t12.left = _s1_;
        t12.display = _s4_;
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t12, (t12 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t12, _s14_), "row", "");
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t12, C.CssStyleDeclaration_methods._browserPropertyName$1(t12, _s11_), _s8_0, "");
        t12.margin = _s1_;
        t12.border = _s1_;
        t12.padding = _s1_;
        t6.applyStyle$1(style);
        t12 = t5.style;
        t12.whiteSpace = "pre";
        t4.appendChild(t5);
        t6.set$_cachedBoundingClientRect(null);
        t5 = _this._rulerHost;
        t5.appendChild(t4);
        t4.appendChild(t3);
        t3 = t7.style;
        t3.visibility = _s6_;
        t3.position = _s8_;
        t3.top = _s1_;
        t3.left = _s1_;
        t3.display = _s4_;
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t3, (t3 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t3, _s14_), "row", "");
        t3.margin = _s1_;
        t3.border = _s1_;
        t3.padding = _s1_;
        t9.applyStyle$1(style);
        t3 = t8.style;
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t3, (t3 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t3, _s4_), _s1_, "");
        t3.display = "inline";
        t3.whiteSpace = _s8_1;
        t7.appendChild(t8);
        t5.appendChild(t7);
        t3 = t10.style;
        t3.visibility = _s6_;
        t3.position = _s8_;
        t3.top = _s1_;
        t3.left = _s1_;
        t3.display = _s4_;
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t3, (t3 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t3, _s14_), "row", "");
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t3, C.CssStyleDeclaration_methods._browserPropertyName$1(t3, _s11_), _s8_0, "");
        t3.margin = _s1_;
        t3.border = _s1_;
        t3.padding = _s1_;
        t11.applyStyle$1(style);
        elementStyle = t2.style;
        elementStyle.display = "block";
        C.CssStyleDeclaration_methods._setPropertyHelper$3(elementStyle, (elementStyle && C.CssStyleDeclaration_methods)._browserPropertyName$1(elementStyle, "overflow-wrap"), "break-word", "");
        if (style.ellipsis == null)
          elementStyle.whiteSpace = _s8_1;
        else {
          elementStyle.whiteSpace = "pre";
          elementStyle.overflow = _s6_;
          C.CssStyleDeclaration_methods._setPropertyHelper$3(elementStyle, C.CssStyleDeclaration_methods._browserPropertyName$1(elementStyle, "text-overflow"), "ellipsis", "");
        }
        t10.appendChild(t2);
        t11.set$_cachedBoundingClientRect(null);
        t5.appendChild(t10);
        t1.$indexSet(0, style, ruler);
        _this._scheduleRulerCacheCleanup$0();
      }
      ++ruler._hitCount;
      return ruler;
    },
    set$_rulers: function(_rulers) {
      this._rulers = H.assertSubtype(_rulers, "$isMap", [T.ParagraphGeometricStyle, T.ParagraphRuler], "$asMap");
    }
  };
  T.RulerManager__scheduleRulerCacheCleanup_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._rulerCacheCleanupScheduled = false;
      t1.cleanUpRulerCache$0();
    },
    $signature: 0
  };
  T.RulerManager_cleanUpRulerCache_closure.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isParagraphRuler");
      return H.interceptedTypeCheck(b, "$isParagraphRuler")._hitCount - a._hitCount;
    },
    $signature: 122
  };
  T.TextMeasurementService.prototype = {
    measure$2: function(_, paragraph, constraints) {
      var ruler = $.TextMeasurementService_rulerManager.findOrCreateRuler$1(paragraph._paragraphGeometricStyle),
        result = ruler.cacheLookup$2(paragraph, constraints);
      if (result != null)
        return result;
      result = this._doMeasure$3(paragraph, constraints, ruler);
      ruler.cacheMeasurement$2(paragraph, result);
      return result;
    }
  };
  T.DomTextMeasurementService.prototype = {
    _doMeasure$3: function(paragraph, constraints, ruler) {
      var plainText, t1, t2, t3, t4, t5, minIntrinsicWidth, maxIntrinsicWidth, alphabeticBaseline, height, result, naturalHeight, _null = null;
      ruler._engine$_paragraph = paragraph;
      plainText = paragraph._plainText;
      ruler.measureAsSingleLine$0();
      t1 = ruler.minIntrinsicDimensions;
      t2 = ruler.style;
      t1.updateText$2(ruler._engine$_paragraph, t2);
      t3 = ruler.constrainedDimensions;
      t3.updateText$2(ruler._engine$_paragraph, t2);
      t2 = constraints.width;
      if (typeof t2 !== "number")
        return t2.$add();
      t4 = H.S(t2 + 0.5) + "px";
      t3.set$_cachedBoundingClientRect(_null);
      t5 = t3._element.style;
      t5.width = t4;
      t4 = plainText == null ? _null : C.JSString_methods.contains$1(plainText, "\n");
      t4 = t4 !== true && ruler.singleLineDimensions._readAndCacheMetrics$0().width <= t2;
      t5 = ruler.singleLineDimensions;
      if (t4) {
        minIntrinsicWidth = t1._readAndCacheMetrics$0().width;
        maxIntrinsicWidth = t5._readAndCacheMetrics$0().width;
        alphabeticBaseline = ruler.get$alphabeticBaseline(ruler);
        height = t5._readAndCacheMetrics$0().height;
        result = T.MeasurementResult$(t2, alphabeticBaseline, height, alphabeticBaseline * 1.1662499904632568, true, _null, T.DomTextMeasurementService__applySubPixelRoundingHack(minIntrinsicWidth, maxIntrinsicWidth), minIntrinsicWidth, height, t2);
      } else {
        minIntrinsicWidth = t1._readAndCacheMetrics$0().width;
        maxIntrinsicWidth = t5._readAndCacheMetrics$0().width;
        alphabeticBaseline = ruler.get$alphabeticBaseline(ruler);
        naturalHeight = t3._readAndCacheMetrics$0().height;
        result = T.MeasurementResult$(t2, alphabeticBaseline, naturalHeight, alphabeticBaseline * 1.1662499904632568, false, _null, T.DomTextMeasurementService__applySubPixelRoundingHack(minIntrinsicWidth, maxIntrinsicWidth), minIntrinsicWidth, naturalHeight, t2);
      }
      ruler.didMeasure$0();
      return result;
    },
    measureSubstringWidth$3: function(paragraph, start, end) {
      var style = paragraph._paragraphGeometricStyle,
        ruler = $.TextMeasurementService_rulerManager.findOrCreateRuler$1(style),
        text = J.substring$2$s(paragraph._plainText, start, end);
      ruler._engine$_paragraph = Q.Paragraph$_(paragraph._background, paragraph._paint, H.interceptedTypeCheck(paragraph._paragraphElement.cloneNode(true), "$isHtmlElement"), style, text, paragraph._textAlign, paragraph._ui$_textDirection);
      ruler.measureAsSingleLine$0();
      ruler.didMeasure$0();
      return ruler.singleLineDimensions._readAndCacheMetrics$0().width;
    }
  };
  T.CanvasTextMeasurementService.prototype = {
    _doMeasure$3: function(paragraph, constraints, ruler) {
      var t2, linesCalculator, maxIntrinsicCalculator, reachedEndOfText, i, t3, t4, brk, chunkEnd, width, lineCount, naturalHeight,
        text = paragraph._plainText,
        style = paragraph._paragraphGeometricStyle,
        t1 = this._canvasContext;
      t1.font = style.get$cssFontString();
      t2 = constraints.width;
      linesCalculator = new T.LinesCalculator(t1, text, style, t2, H.setRuntimeTypeInfo([], [P.String]));
      maxIntrinsicCalculator = new T.MaxIntrinsicCalculator(t1, text);
      for (reachedEndOfText = false, i = 0, t3 = 0, t4 = 0; !reachedEndOfText; t4 = chunkEnd, i = t4) {
        brk = T.nextLineBreak(text, i);
        linesCalculator.update$1(0, brk);
        chunkEnd = brk.index;
        width = T._measureSubstring(t1, text, t4, T._excludeTrailing(text, t4, chunkEnd, T.engine___whitespacePredicate$closure()));
        if (width > t3)
          t3 = width;
        maxIntrinsicCalculator.update$1(0, brk);
        if (brk.type === C.LineBreakType_2)
          reachedEndOfText = true;
      }
      t1 = linesCalculator.lines;
      lineCount = t1.length;
      naturalHeight = lineCount * ruler.get$lineHeightDimensions()._readAndCacheMetrics$0().height;
      return T.MeasurementResult$(t2, ruler.get$alphabeticBaseline(ruler), naturalHeight, ruler.get$alphabeticBaseline(ruler) * 1.1662499904632568, lineCount === 1, t1, maxIntrinsicCalculator.value, t3, naturalHeight, t2);
    },
    measureSubstringWidth$3: function(paragraph, start, end) {
      var t1 = this._canvasContext;
      t1.font = paragraph._paragraphGeometricStyle.get$cssFontString();
      return T._measureSubstring(t1, paragraph._plainText, start, end);
    }
  };
  T.LinesCalculator.prototype = {
    update$1: function(_, brk) {
      var chunkEndWithoutSpace, t2, t3, t4, t5, t6, t7, lineWidth, t8, t9, isLastLine, breakingPoint, _this = this,
        t1 = brk.type,
        isHardBreak = t1 === C.LineBreakType_1 || t1 === C.LineBreakType_2,
        chunkEnd = brk.index;
      t1 = _this._engine$_text;
      chunkEndWithoutSpace = T._excludeTrailing(t1, _this._chunkStart, chunkEnd, T.engine___whitespacePredicate$closure());
      for (t2 = _this._style.ellipsis, t3 = t2 != null, t4 = _this._maxWidth, t5 = _this._canvasContext, t6 = _this.lines, t7 = J.getInterceptor$s(t1); !_this._reachedMaxLines;) {
        lineWidth = T._measureSubstring(t5, t1, _this._lineStart, chunkEndWithoutSpace);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (lineWidth <= t4)
          break;
        t8 = _this._chunkStart;
        t9 = _this._lineStart;
        isLastLine = t3 && true || false;
        _this._reachedMaxLines = isLastLine;
        if (isLastLine && t3) {
          t8 = _this._cachedEllipsisWidth;
          if (t8 == null) {
            t8 = t5.measureText(t2).width;
            if (typeof t8 !== "number")
              return t8.$mul();
            t8 = _this._cachedEllipsisWidth = C.JSNumber_methods.round$0(t8 * 100) / 100;
          }
          breakingPoint = _this._forceBreak$4(t4 - t8, t1, _this._lineStart, chunkEndWithoutSpace);
          C.JSArray_methods.add$1(t6, t7.substring$2(t1, _this._lineStart, breakingPoint) + t2);
        } else if (t8 === t9) {
          breakingPoint = _this._forceBreak$4(t4, t1, t9, chunkEndWithoutSpace);
          if (breakingPoint === chunkEndWithoutSpace)
            break;
          _this._addLineBreak$1$lineEnd(breakingPoint);
          _this._chunkStart = breakingPoint;
        } else
          _this._addLineBreak$1$lineEnd(t8);
      }
      if (_this._reachedMaxLines)
        return;
      if (isHardBreak)
        _this._addLineBreak$1$lineEnd(chunkEnd);
      _this._chunkStart = chunkEnd;
    },
    _addLineBreak$1$lineEnd: function(lineEnd) {
      var _this = this,
        t1 = _this._engine$_text,
        indexWithoutNewlines = T._excludeTrailing(t1, _this._lineStart, lineEnd, T.engine___newlinePredicate$closure());
      C.JSArray_methods.add$1(_this.lines, J.substring$2$s(t1, _this._lineStart, indexWithoutNewlines));
      _this._lineStart = lineEnd;
    },
    _forceBreak$4: function(maxWidth, text, start, end) {
      var mid, width,
        low = this._style.ellipsis != null ? start : start + 1,
        t1 = this._canvasContext,
        high = end;
      do {
        mid = C.JSInt_methods._tdivFast$1(low + high, 2);
        width = T._measureSubstring(t1, text, start, mid);
        if (typeof maxWidth !== "number")
          return H.iae(maxWidth);
        if (width < maxWidth)
          low = mid;
        else {
          low = width > maxWidth ? low : mid;
          high = mid;
        }
      } while (high - low > 1);
      return low;
    }
  };
  T.MaxIntrinsicCalculator.prototype = {
    update$1: function(_, brk) {
      var hardLineEnd, t1, hardLineEndWithoutNewlines, lineWidth, _this = this;
      if (brk.type === C.LineBreakType_0)
        return;
      hardLineEnd = brk.index;
      t1 = _this._engine$_text;
      hardLineEndWithoutNewlines = T._excludeTrailing(t1, _this._lastHardLineEnd, hardLineEnd, T.engine___newlinePredicate$closure());
      lineWidth = T._measureSubstring(_this._canvasContext, t1, _this._lastHardLineEnd, hardLineEndWithoutNewlines);
      if (lineWidth > _this.value)
        _this.value = lineWidth;
      _this._lastHardLineEnd = hardLineEnd;
    }
  };
  T.ParagraphGeometricStyle.prototype = {
    get$effectiveFontFamily: function() {
      var t1 = this.fontFamily;
      if (t1 == null || t1.length === 0)
        return "sans-serif";
      return t1;
    },
    get$cssFontString: function() {
      var t2, _this = this,
        t1 = _this._cssFontString;
      if (t1 == null) {
        t1 = _this.fontWeight;
        t1 = (t1 != null ? "normal " + H.S(Q.webOnlyFontWeightToCss(t1)) : "normal normal") + " ";
        t2 = _this.fontSize;
        t1 = (t2 != null ? t1 + C.JSInt_methods.floor$0(t2) + "px" : t1 + "14px") + " " + H.S(_this.get$effectiveFontFamily());
        t1 = _this._cssFontString = t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      return t1;
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isParagraphGeometricStyle");
      if (_this.fontWeight == other.fontWeight)
        if (_this.fontFamily == other.fontFamily)
          if (_this.fontSize == other.fontSize)
            if (_this.lineHeight == other.lineHeight)
              t1 = _this.decoration == other.decoration && _this.ellipsis == other.ellipsis;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var _this = this,
        t1 = _this._cachedHashCode;
      return t1 == null ? _this._cachedHashCode = Q.hashValues(_this.fontWeight, _this.fontStyle, _this.fontFamily, _this.fontSize, _this.lineHeight, _this.maxLines, _this.letterSpacing, _this.wordSpacing, _this.decoration, _this.ellipsis, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd) : t1;
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  T.TextDimensions.prototype = {
    updateText$2: function(from, style) {
      var plainText, t1, copy;
      this.set$_cachedBoundingClientRect(null);
      plainText = from._plainText;
      t1 = this._element;
      if (plainText != null)
        t1.textContent = plainText;
      else {
        copy = H.interceptedTypeCheck(from._paragraphElement.cloneNode(true), "$isElement0");
        new W._ChildrenElementList(t1, t1.children).addAll$1(0, J.get$children$x(copy));
      }
    },
    applyStyle$1: function(style) {
      var t4,
        t1 = this._element,
        t2 = t1.style,
        t3 = style.fontSize;
      t3 = t3 != null ? "" + C.JSInt_methods.floor$0(t3) + "px" : null;
      t2.toString;
      t2.fontSize = t3 == null ? "" : t3;
      t3 = style.get$effectiveFontFamily();
      t2.fontFamily = t3 == null ? "" : t3;
      t3 = style.fontWeight;
      t3 = t3 != null ? Q.webOnlyFontWeightToCss(t3) : null;
      t2.fontWeight = t3 == null ? "" : t3;
      t2.fontStyle = "";
      t2.letterSpacing = "";
      t3 = t2.wordSpacing = "";
      t4 = style.decoration;
      t2.textDecoration = t4 == null ? t3 : t4;
      t2 = style.lineHeight;
      if (t2 != null) {
        t1 = t1.style;
        t2 = C.JSInt_methods.toString$0(t2);
        t1.lineHeight = t2;
      }
      this.set$_cachedBoundingClientRect(null);
    },
    _readAndCacheMetrics$0: function() {
      var t1 = this._cachedBoundingClientRect;
      if (t1 == null) {
        t1 = this._element.getBoundingClientRect();
        this.set$_cachedBoundingClientRect(t1);
      }
      return t1;
    },
    set$_cachedBoundingClientRect: function(_cachedBoundingClientRect) {
      this._cachedBoundingClientRect = H.assertSubtype(_cachedBoundingClientRect, "$isRectangle", [P.num], "$asRectangle");
    }
  };
  T.ParagraphRuler.prototype = {
    get$alphabeticBaseline: function(_) {
      var t1 = this._cachedAlphabeticBaseline;
      return t1 == null ? this._cachedAlphabeticBaseline = this._probe.getBoundingClientRect().bottom : t1;
    },
    get$lineHeightDimensions: function() {
      var t1, _this = this;
      if (_this._lineHeightDimensions == null) {
        t1 = document;
        _this._lineHeightHost = t1.createElement("div");
        _this._lineHeightDimensions = new T.TextDimensions(t1.createElement("p"));
        t1 = _this._lineHeightHost.style;
        t1.visibility = "hidden";
        t1.position = "absolute";
        t1.top = "0";
        t1.left = "0";
        t1.display = "flex";
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "flex-direction"), "row", "");
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, C.CssStyleDeclaration_methods._browserPropertyName$1(t1, "align-items"), "baseline", "");
        t1.margin = "0";
        t1.border = "0";
        t1.padding = "0";
        _this.get$lineHeightDimensions().applyStyle$1(_this.style);
        t1 = _this.get$lineHeightDimensions()._element.style;
        t1.whiteSpace = "pre";
        t1 = _this.get$lineHeightDimensions();
        t1.set$_cachedBoundingClientRect(null);
        t1._element.textContent = " ";
        t1 = _this.get$lineHeightDimensions();
        _this._lineHeightHost.appendChild(t1._element);
        t1.set$_cachedBoundingClientRect(null);
        _this.rulerManager._rulerHost.appendChild(_this._lineHeightHost);
        _this._lineHeightHost.appendChild(_this._probe);
      }
      return _this._lineHeightDimensions;
    },
    measureAsSingleLine$0: function() {
      var t1 = this._engine$_paragraph,
        t2 = this.singleLineDimensions;
      if (t1._plainText === "") {
        t2.set$_cachedBoundingClientRect(null);
        t2._element.textContent = " ";
      } else
        t2.updateText$2(t1, this.style);
    },
    didMeasure$0: function() {
      var t1, _this = this;
      if (_this._engine$_paragraph._plainText == null) {
        t1 = $.$get$domRenderer();
        t1.clearDom$1(_this.singleLineDimensions._element);
        t1.clearDom$1(_this.minIntrinsicDimensions._element);
        t1.clearDom$1(_this.constrainedDimensions._element);
      }
      _this._engine$_paragraph = null;
    },
    measureBoxesForRange$6$alignOffset$end$start$textDirection: function(plainText, constraints, alignOffset, end, start, textDirection) {
      var t2, t3, value, boxes, _i, rect,
        before = J.getInterceptor$s(plainText).substring$2(plainText, 0, start),
        rangeText = C.JSString_methods.substring$2(plainText, start, end),
        after = C.JSString_methods.substring$1(plainText, end),
        t1 = document,
        rangeSpan = t1.createElement("span");
      rangeSpan.textContent = rangeText;
      t2 = this.constrainedDimensions;
      t3 = t2._element;
      $.$get$domRenderer().clearDom$1(t3);
      t3.appendChild(t1.createTextNode(before));
      t3.appendChild(rangeSpan);
      t3.appendChild(t1.createTextNode(after));
      t1 = H.S(constraints.width) + "px";
      t2.set$_cachedBoundingClientRect(null);
      t2 = t3.style;
      t2.width = t1;
      value = rangeSpan.getClientRects();
      if (value.prototype == null)
        value.prototype = Object.create(null);
      boxes = H.setRuntimeTypeInfo([], [Q.TextBox]);
      for (t1 = value.length, _i = 0; _i < value.length; value.length === t1 || (0, H.throwConcurrentModificationError)(value), ++_i) {
        rect = value[_i];
        C.JSArray_methods.add$1(boxes, new Q.TextBox(rect.left + alignOffset, rect.top, rect.right + alignOffset, rect.bottom, textDirection));
      }
      $.$get$domRenderer().clearDom$1(t3);
      return boxes;
    },
    dispose$0: function() {
      var t1, _this = this;
      C.DivElement_methods.remove$0(_this._singleLineHost);
      C.DivElement_methods.remove$0(_this._minIntrinsicHost);
      C.DivElement_methods.remove$0(_this._constrainedHost);
      t1 = _this._lineHeightHost;
      if (t1 != null)
        C.DivElement_methods.remove$0(t1);
    },
    cacheMeasurement$2: function(paragraph, item) {
      var t2, i,
        plainText = paragraph._plainText,
        t1 = this._measurementCache,
        constraintCache = t1.$index(0, plainText);
      if (constraintCache == null) {
        constraintCache = H.setRuntimeTypeInfo([], [T.MeasurementResult]);
        t1.$indexSet(0, plainText, constraintCache);
      }
      C.JSArray_methods.add$1(constraintCache, item);
      if (constraintCache.length > 8)
        C.JSArray_methods.removeAt$1(constraintCache, 0);
      t2 = this._mruList;
      C.JSArray_methods.add$1(t2, plainText);
      if (t2.length > 2400) {
        for (i = 0; i < 100; ++i) {
          if (i >= t2.length)
            return H.ioore(t2, i);
          t1.remove$1(0, t2[i]);
        }
        P.RangeError_checkValidRange(0, 100, t2.length);
        t2.splice(0, 100);
      }
    },
    cacheLookup$2: function(paragraph, constraints) {
      var len, t1, i, item,
        constraintCache = this._measurementCache.$index(0, paragraph._plainText);
      if (constraintCache == null)
        return;
      len = constraintCache.length;
      for (t1 = constraints.width, i = 0; i < len; ++i) {
        item = constraintCache[i];
        if (item.constraintWidth == t1)
          return item;
      }
      return;
    }
  };
  T.MeasurementResult.prototype = {};
  T._styleEditingElement_closure.prototype = {
    call$1: function(_) {
      var t1;
      H.numTypeCheck(_);
      t1 = this.domElement.style;
      t1.position = "absolute";
      t1.bottom = "0";
      t1.right = "0";
    },
    $signature: 17
  };
  T.EditingState.prototype = {
    get$hashCode: function(_) {
      return Q.hashValues(this.text, this.baseOffset, this.extentOffset, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isEditingState");
      return _this.text == other.text && _this.baseOffset == other.baseOffset && _this.extentOffset == other.extentOffset;
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  T.InputType.prototype = {
    toString$0: function(_) {
      return this._engine$_name;
    }
  };
  T.InputConfiguration.prototype = {};
  T.ElementType.prototype = {
    toString$0: function(_) {
      return this._engine$_name;
    }
  };
  T.TextEditingElement.prototype = {
    enable$2$onChange: function(_, inputConfig, onChange) {
      var t1, t2, t3, t4, _this = this;
      H.functionTypeCheck(onChange, {func: 1, ret: -1, args: [T.EditingState]});
      _this._initDomElement$1(inputConfig);
      t1 = _this._enabled = true;
      _this.set$_onChange(onChange);
      t2 = $._browserEngine;
      if (t2 == null) {
        t2 = $._browserEngine = T._detectBrowserEngine();
        t3 = t2;
      } else
        t3 = t2;
      if (t2 !== C.BrowserEngine_0)
        t1 = t3 === C.BrowserEngine_2;
      if (t1) {
        t1 = _this.domElement;
        t1.toString;
        t2 = W.Event;
        C.JSArray_methods.add$1(_this._subscriptions, W._EventStreamSubscription$(t1, "blur", H.functionTypeCheck(new T.TextEditingElement_enable_closure(_this), {func: 1, ret: -1, args: [t2]}), false, t2));
      }
      _this.domElement.focus();
      t1 = _this._lastEditingState;
      if (t1 != null)
        _this.setEditingState$1(t1);
      t1 = _this._subscriptions;
      t2 = document;
      t3 = W.Event;
      t4 = H.functionTypeCheck(_this.get$_handleChange(), {func: 1, ret: -1, args: [t3]});
      C.JSArray_methods.add$1(t1, W._EventStreamSubscription$(t2, "selectionchange", t4, false, t3));
      t2 = _this.domElement;
      t2.toString;
      C.JSArray_methods.add$1(t1, W._EventStreamSubscription$(t2, "input", t4, false, t3));
    },
    disable$0: function(_) {
      var t1, i, _this = this;
      _this._enabled = false;
      _this._lastEditingState = null;
      for (t1 = _this._subscriptions, i = 0; i < t1.length; ++i)
        t1[i].cancel$0(0);
      C.JSArray_methods.set$length(t1, 0);
      _this._removeDomElement$0();
    },
    _initDomElement$1: function(inputConfig) {
      var input, textarea,
        t1 = inputConfig.inputType;
      switch (t1) {
        case C.InputType_0:
          input = W.InputElement_InputElement();
          T._styleEditingElement(input);
          this.domElement = input;
          t1 = input;
          break;
        case C.InputType_1:
          textarea = document.createElement("textarea");
          T._styleEditingElement(textarea);
          this.domElement = textarea;
          t1 = textarea;
          break;
        default:
          throw H.wrapException(P.UnsupportedError$("Unsupported input type: " + t1.toString$0(0)));
      }
      document.body.appendChild(t1);
    },
    _removeDomElement$0: function() {
      J.remove$0$ax(this.domElement);
      this.domElement = null;
    },
    _refocus$0: function() {
      this.domElement.focus();
    },
    setEditingState$1: function(editingState) {
      var t1, input, textarea, t2, t3, firstChild, _this = this;
      _this._lastEditingState = editingState;
      if (_this._enabled) {
        t1 = editingState.baseOffset;
        if (typeof t1 !== "number")
          return t1.$ge();
        if (t1 >= 0) {
          t1 = editingState.extentOffset;
          if (typeof t1 !== "number")
            return t1.$ge();
          t1 = t1 >= 0;
        } else
          t1 = false;
        t1 = !t1;
      } else
        t1 = true;
      if (t1)
        return;
      switch (T._getTypeFromElement(_this.domElement)) {
        case C.ElementType_0:
          input = H.interceptedTypeCheck(_this.domElement, "$isInputElement");
          input.value = editingState.text;
          input.setSelectionRange(editingState.baseOffset, editingState.extentOffset);
          break;
        case C.ElementType_1:
          textarea = H.interceptedTypeCheck(_this.domElement, "$isTextAreaElement");
          textarea.value = editingState.text;
          textarea.setSelectionRange(editingState.baseOffset, editingState.extentOffset);
          break;
        case C.ElementType_2:
          $.$get$domRenderer().clearDom$1(_this.domElement);
          t1 = _this.domElement;
          t2 = editingState.text;
          t3 = document;
          t1.appendChild(t3.createTextNode(t2));
          t2 = window.getSelection();
          t2.removeAllRanges();
          firstChild = _this.domElement.firstChild;
          t3 = t3.createRange();
          t3.setStart(firstChild, editingState.baseOffset);
          t3.setEnd(firstChild, editingState.extentOffset);
          t2.addRange(t3);
          break;
      }
      _this.domElement.focus();
    },
    _handleChange$1: function($event) {
      var inputElement, editingState, textAreaElement, t1, text, t2, t3, prevSelectionEnd, newSelectionExtent, selection, _this = this;
      switch (T._getTypeFromElement(_this.domElement)) {
        case C.ElementType_0:
          inputElement = H.interceptedTypeCheck(_this.domElement, "$isInputElement");
          editingState = new T.EditingState(inputElement.value, inputElement.selectionStart, inputElement.selectionEnd);
          break;
        case C.ElementType_1:
          textAreaElement = H.interceptedTypeCheck(_this.domElement, "$isTextAreaElement");
          editingState = new T.EditingState(textAreaElement.value, textAreaElement.selectionStart, textAreaElement.selectionEnd);
          break;
        case C.ElementType_2:
          t1 = _this.domElement;
          text = H.stringTypeCheck(t1.innerText);
          if (t1.childNodes.length > 1) {
            t1 = _this._lastEditingState;
            t2 = t1.baseOffset;
            t3 = t1.extentOffset;
            prevSelectionEnd = Math.max(H.checkNum(t2), H.checkNum(t3));
            t1 = t1.text.length;
            newSelectionExtent = text.length - (t1 - prevSelectionEnd);
            editingState = new T.EditingState(text, newSelectionExtent, newSelectionExtent);
          } else {
            selection = window.getSelection();
            editingState = new T.EditingState(text, selection.baseOffset, selection.extentOffset);
          }
          break;
        default:
          editingState = null;
      }
      _this._lastEditingState = editingState;
      _this._onChange.call$1(editingState);
    },
    set$_onChange: function(_onChange) {
      this._onChange = H.functionTypeCheck(_onChange, {func: 1, ret: -1, args: [T.EditingState]});
    }
  };
  T.TextEditingElement_enable_closure.prototype = {
    call$1: function(_) {
      var t1 = this.$this;
      if (t1._enabled)
        t1._refocus$0();
    },
    $signature: 2
  };
  T.PersistentTextEditingElement.prototype = {
    _initDomElement$1: function(inputConfig) {
    },
    _removeDomElement$0: function() {
      this.domElement.blur();
    },
    _refocus$0: function() {
    }
  };
  T.HybridTextEditing.prototype = {
    get$editingElement: function() {
      var t1 = this._customEditingElement;
      if (t1 != null)
        return t1;
      return this._defaultEditingElement;
    },
    useCustomEditableElement$1: function(customEditingElement) {
      var _this = this;
      if (_this._isEditing && customEditingElement != _this._customEditingElement) {
        _this._isEditing = false;
        _this.get$editingElement().disable$0(0);
      }
      _this._customEditingElement = customEditingElement;
    },
    _syncEditingStateToFlutter$1: function(editingState) {
      $.$get$window().onPlatformMessage$3("flutter/textinput", C.C_JSONMethodCodec.encodeMethodCall$1(new T.MethodCall("TextInputClient.updateEditingState", [this._clientId, P.LinkedHashMap_LinkedHashMap$_literal(["text", editingState.text, "selectionBase", editingState.baseOffset, "selectionExtent", editingState.extentOffset], P.String, null)])), T.engine___emptyCallback$closure());
    },
    set$_configuration: function(_configuration) {
      this._configuration = H.assertSubtype(_configuration, "$isMap", [P.String, null], "$asMap");
    }
  };
  T.Matrix40.prototype = {
    setFrom$1: function(arg) {
      var argStorage = arg._engine$_m4storage,
        t1 = this._engine$_m4storage;
      t1[15] = argStorage[15];
      t1[14] = argStorage[14];
      t1[13] = argStorage[13];
      t1[12] = argStorage[12];
      t1[11] = argStorage[11];
      t1[10] = argStorage[10];
      t1[9] = argStorage[9];
      t1[8] = argStorage[8];
      t1[7] = argStorage[7];
      t1[6] = argStorage[6];
      t1[5] = argStorage[5];
      t1[4] = argStorage[4];
      t1[3] = argStorage[3];
      t1[2] = argStorage[2];
      t1[1] = argStorage[1];
      t1[0] = argStorage[0];
    },
    $index: function(_, i) {
      var t1;
      H.intTypeCheck(i);
      t1 = this._engine$_m4storage;
      t1.length;
      if (i >= 16)
        return H.ioore(t1, i);
      return t1[i];
    },
    $indexSet: function(_, i, v) {
      var t1 = this._engine$_m4storage;
      (t1 && C.NativeFloat64List_methods).$indexSet(t1, i, v);
    },
    translate$3: function(_, x, y, z) {
      var tz, ty, tx, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17;
      if (typeof x === "number") {
        tz = z;
        ty = y;
        tx = x;
      } else {
        tx = null;
        ty = null;
        tz = null;
      }
      t1 = this._engine$_m4storage;
      t2 = t1[0];
      if (typeof tx !== "number")
        return H.iae(tx);
      t3 = t1[4];
      if (typeof ty !== "number")
        return H.iae(ty);
      t4 = t1[8];
      if (typeof tz !== "number")
        return H.iae(tz);
      t5 = t1[12];
      t6 = t1[1];
      t7 = t1[5];
      t8 = t1[9];
      t9 = t1[13];
      t10 = t1[2];
      t11 = t1[6];
      t12 = t1[10];
      t13 = t1[14];
      t14 = t1[3];
      t15 = t1[7];
      t16 = t1[11];
      t17 = t1[15];
      t1[12] = t2 * tx + t3 * ty + t4 * tz + t5;
      t1[13] = t6 * tx + t7 * ty + t8 * tz + t9;
      t1[14] = t10 * tx + t11 * ty + t12 * tz + t13;
      t1[15] = t14 * tx + t15 * ty + t16 * tz + t17;
    },
    translate$2: function($receiver, x, y) {
      return this.translate$3($receiver, x, y, 0);
    },
    setIdentity$0: function() {
      var t1 = this._engine$_m4storage;
      t1[0] = 1;
      t1[1] = 0;
      t1[2] = 0;
      t1[3] = 0;
      t1[4] = 0;
      t1[5] = 1;
      t1[6] = 0;
      t1[7] = 0;
      t1[8] = 0;
      t1[9] = 0;
      t1[10] = 1;
      t1[11] = 0;
      t1[12] = 0;
      t1[13] = 0;
      t1[14] = 0;
      t1[15] = 1;
    },
    isIdentity$0: function(_) {
      var t1 = this._engine$_m4storage;
      return t1[0] === 1 && t1[1] === 0 && t1[2] === 0 && t1[3] === 0 && t1[4] === 0 && t1[5] === 1 && t1[6] === 0 && t1[7] === 0 && t1[8] === 0 && t1[9] === 0 && t1[10] === 1 && t1[11] === 0 && t1[12] === 0 && t1[13] === 0 && t1[14] === 0 && t1[15] === 1;
    },
    setTranslationRaw$3: function(x, y, z) {
      var t1 = this._engine$_m4storage;
      t1[14] = z;
      (t1 && C.NativeFloat64List_methods).$indexSet(t1, 13, y);
      C.NativeFloat64List_methods.$indexSet(t1, 12, x);
    },
    copyInverse$1: function(arg) {
      var invDet, t1, t2, t3,
        argStorage = arg._engine$_m4storage,
        a00 = argStorage[0],
        a01 = argStorage[1],
        a02 = argStorage[2],
        a03 = argStorage[3],
        a10 = argStorage[4],
        a11 = argStorage[5],
        a12 = argStorage[6],
        a13 = argStorage[7],
        a20 = argStorage[8],
        a21 = argStorage[9],
        a22 = argStorage[10],
        a23 = argStorage[11],
        a30 = argStorage[12],
        a31 = argStorage[13],
        a32 = argStorage[14],
        a33 = argStorage[15],
        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (det === 0) {
        this.setFrom$1(arg);
        return 0;
      }
      invDet = 1 / det;
      t1 = this._engine$_m4storage;
      t1[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
      t1[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
      t1[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
      t1[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
      t2 = -a10;
      t1[4] = (t2 * b11 + a12 * b08 - a13 * b07) * invDet;
      t1[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
      t3 = -a30;
      t1[6] = (t3 * b05 + a32 * b02 - a33 * b01) * invDet;
      t1[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
      t1[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
      t1[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
      t1[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
      t1[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
      t1[12] = (t2 * b09 + a11 * b07 - a12 * b06) * invDet;
      t1[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
      t1[14] = (t3 * b03 + a31 * b01 - a32 * b00) * invDet;
      t1[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
      return det;
    },
    multiplied$1: function(arg) {
      var m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33, argStorage, n00, n01, n02, n03, n10, n11, n12, n13, n20, n21, n22, n23, n30, n31, n32, n33,
        t1 = new Float64Array(16),
        t2 = new T.Matrix40(t1);
      t2.setFrom$1(this);
      m00 = t1[0];
      m01 = t1[4];
      m02 = t1[8];
      m03 = t1[12];
      m10 = t1[1];
      m11 = t1[5];
      m12 = t1[9];
      m13 = t1[13];
      m20 = t1[2];
      m21 = t1[6];
      m22 = t1[10];
      m23 = t1[14];
      m30 = t1[3];
      m31 = t1[7];
      m32 = t1[11];
      m33 = t1[15];
      argStorage = arg._engine$_m4storage;
      n00 = argStorage[0];
      n01 = argStorage[4];
      n02 = argStorage[8];
      n03 = argStorage[12];
      n10 = argStorage[1];
      n11 = argStorage[5];
      n12 = argStorage[9];
      n13 = argStorage[13];
      n20 = argStorage[2];
      n21 = argStorage[6];
      n22 = argStorage[10];
      n23 = argStorage[14];
      n30 = argStorage[3];
      n31 = argStorage[7];
      n32 = argStorage[11];
      n33 = argStorage[15];
      t1[0] = m00 * n00 + m01 * n10 + m02 * n20 + m03 * n30;
      t1[4] = m00 * n01 + m01 * n11 + m02 * n21 + m03 * n31;
      t1[8] = m00 * n02 + m01 * n12 + m02 * n22 + m03 * n32;
      t1[12] = m00 * n03 + m01 * n13 + m02 * n23 + m03 * n33;
      t1[1] = m10 * n00 + m11 * n10 + m12 * n20 + m13 * n30;
      t1[5] = m10 * n01 + m11 * n11 + m12 * n21 + m13 * n31;
      t1[9] = m10 * n02 + m11 * n12 + m12 * n22 + m13 * n32;
      t1[13] = m10 * n03 + m11 * n13 + m12 * n23 + m13 * n33;
      t1[2] = m20 * n00 + m21 * n10 + m22 * n20 + m23 * n30;
      t1[6] = m20 * n01 + m21 * n11 + m22 * n21 + m23 * n31;
      t1[10] = m20 * n02 + m21 * n12 + m22 * n22 + m23 * n32;
      t1[14] = m20 * n03 + m21 * n13 + m22 * n23 + m23 * n33;
      t1[3] = m30 * n00 + m31 * n10 + m32 * n20 + m33 * n30;
      t1[7] = m30 * n01 + m31 * n11 + m32 * n21 + m33 * n31;
      t1[11] = m30 * n02 + m31 * n12 + m32 * n22 + m33 * n32;
      t1[15] = m30 * n03 + m31 * n13 + m32 * n23 + m33 * n33;
      return t2;
    },
    transform3$1: function(arg) {
      var argStorage = arg._engine$_v3storage,
        t1 = this._engine$_m4storage,
        t2 = t1[0],
        t3 = argStorage[0],
        t4 = t1[4],
        t5 = argStorage[1],
        t6 = t1[8],
        t7 = argStorage[2],
        t8 = t1[12],
        t9 = t1[1],
        t10 = t1[5],
        t11 = t1[9],
        t12 = t1[13],
        t13 = t1[2],
        t14 = t1[6],
        t15 = t1[10];
      t1 = t1[14];
      argStorage[0] = t2 * t3 + t4 * t5 + t6 * t7 + t8;
      argStorage[1] = t9 * t3 + t10 * t5 + t11 * t7 + t12;
      argStorage[2] = t13 * t3 + t14 * t5 + t15 * t7 + t1;
      return arg;
    }
  };
  T.Vector30.prototype = {
    setValues$3: function(x, y, z) {
      var t1 = this._engine$_v3storage;
      C.NativeFloat64List_methods.$indexSet(t1, 0, x);
      C.NativeFloat64List_methods.$indexSet(t1, 1, y);
      t1[2] = z;
    },
    $index: function(_, i) {
      var t1;
      H.intTypeCheck(i);
      t1 = this._engine$_v3storage;
      if (i >= 3)
        return H.ioore(t1, i);
      return t1[i];
    },
    $indexSet: function(_, i, v) {
      C.NativeFloat64List_methods.$indexSet(this._engine$_v3storage, i, v);
    },
    get$length: function(_) {
      var t1 = this._engine$_v3storage,
        t2 = t1[0],
        t3 = t1[1];
      t1 = t1[2];
      return Math.sqrt(t2 * t2 + t3 * t3 + t1 * t1);
    }
  };
  T.EngineWindow.prototype = {
    get$physicalSize: function() {
      var _this = this,
        windowInnerWidth = window.innerWidth,
        windowInnerHeight = window.innerHeight;
      if (windowInnerWidth != _this._lastKnownWindowInnerWidth || windowInnerHeight != _this._lastKnownWindowInnerHeight) {
        _this._lastKnownWindowInnerWidth = windowInnerWidth;
        _this._lastKnownWindowInnerHeight = windowInnerHeight;
        windowInnerWidth.toString;
        windowInnerHeight.toString;
        _this._physicalSize = new Q.Size(windowInnerWidth, windowInnerHeight);
      }
      return _this._physicalSize;
    },
    sendPlatformMessage$3: function($name, data, callback) {
      var t1, url, decoded, type, t2, $navigator, $arguments, t3, theme, $call, t4, t5, _this = this;
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.ByteData]});
      switch ($name) {
        case "flutter/assets":
          t1 = data.buffer;
          t1.toString;
          url = C.C_Utf8Codec.decode$1(0, H.NativeUint8List_NativeUint8List$view(t1, 0, null));
          $._assetManager.load$1(0, url).then$1$2$onError(new T.EngineWindow_sendPlatformMessage_closure(_this, callback), new T.EngineWindow_sendPlatformMessage_closure0(_this, callback), null);
          return;
        case "flutter/platform":
          decoded = C.C_JSONMethodCodec.decodeMethodCall$1(data);
          switch (decoded.method) {
            case "SystemNavigator.pop":
              _this._browserHistory.exit$0().then$1$1(new T.EngineWindow_sendPlatformMessage_closure1(_this, callback, C.C_JSONMethodCodec), null);
              return;
            case "HapticFeedback.vibrate":
              type = H.stringTypeCheck(decoded.$arguments);
              t1 = $.$get$domRenderer();
              t2 = _this._getHapticFeedbackDuration$1(type);
              t1.toString;
              $navigator = window.navigator;
              if ("vibrate" in $navigator)
                $navigator.vibrate.apply($navigator, H.setRuntimeTypeInfo([t2], [P.num]));
              return;
            case "SystemChrome.setApplicationSwitcherDescription":
              $arguments = H.assertSubtype(decoded.$arguments, "$isMap", [P.String, null], "$asMap");
              t1 = $.$get$domRenderer();
              t2 = J.getInterceptor$asx($arguments);
              t3 = H.stringTypeCheck(t2.$index($arguments, "label"));
              t1.toString;
              t1 = document;
              t1.title = t3;
              t2 = H.intTypeCheck(t2.$index($arguments, "primaryColor"));
              if (typeof t2 !== "number")
                return t2.$and();
              theme = H.interceptedTypeCheck(t1.querySelector("#flutterweb-theme"), "$isMetaElement");
              if (theme == null) {
                theme = t1.createElement("meta");
                theme.id = "flutterweb-theme";
                theme.name = "theme-color";
                t1.head.appendChild(theme);
              }
              theme.content = new Q.Color((t2 & 4294967295) >>> 0).toCssString$0();
              return;
          }
          break;
        case "flutter/textinput":
          t1 = $.$get$textEditing();
          t1.toString;
          $call = C.C_JSONMethodCodec.decodeMethodCall$1(data);
          switch ($call.method) {
            case "TextInput.setClient":
              t2 = $call.$arguments;
              t3 = J.getInterceptor$asx(t2);
              t1._clientId = H.intTypeCheck(t3.$index(t2, 0));
              t1.set$_configuration(H.assertSubtype(t3.$index(t2, 1), "$isMap", [P.String, null], "$asMap"));
              break;
            case "TextInput.setEditingState":
              t1 = t1.get$editingElement();
              t2 = H.assertSubtype($call.$arguments, "$isMap", [P.String, null], "$asMap");
              t3 = J.getInterceptor$asx(t2);
              t1.setEditingState$1(new T.EditingState(H.stringTypeCheck(t3.$index(t2, "text")), H.intTypeCheck(t3.$index(t2, "selectionBase")), H.intTypeCheck(t3.$index(t2, "selectionExtent"))));
              break;
            case "TextInput.show":
              if (!t1._isEditing) {
                t1._isEditing = true;
                t2 = t1.get$editingElement();
                t3 = t1._configuration;
                t4 = J.getInterceptor$asx(t3);
                t5 = T._getInputTypeFromString(H.stringTypeCheck(J.$index$asx(t4.$index(t3, "inputType"), "name")));
                H.boolTypeCheck(t4.$index(t3, "obscureText"));
                t2.enable$2$onChange(0, new T.InputConfiguration(t5), t1.get$_syncEditingStateToFlutter());
              }
              break;
            case "TextInput.clearClient":
            case "TextInput.hide":
              if (t1._isEditing) {
                t1._isEditing = false;
                t1.get$editingElement().disable$0(0);
              }
              break;
          }
          return;
        case "flutter/platform_views":
          T.handlePlatformViewCall(data, callback);
          return;
        case "flutter/accessibility":
          $.$get$accessibilityAnnouncements().handleMessage$1(data);
          break;
      }
    },
    _getHapticFeedbackDuration$1: function(type) {
      switch (type) {
        case "HapticFeedbackType.lightImpact":
          return 10;
        case "HapticFeedbackType.mediumImpact":
          return 20;
        case "HapticFeedbackType.heavyImpact":
          return 30;
        case "HapticFeedbackType.selectionClick":
          return 10;
        default:
          return 50;
      }
    },
    _replyToPlatformMessage$2: function(callback, data) {
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.ByteData]});
      P.Future_Future$delayed(C.Duration_0, -1).then$1$1(new T.EngineWindow__replyToPlatformMessage_closure(callback, data), null);
    }
  };
  T.EngineWindow_sendPlatformMessage_closure.prototype = {
    call$1: function(assetData) {
      this.$this._replyToPlatformMessage$2(this.callback, H.interceptedTypeCheck(assetData, "$isByteData"));
    },
    $signature: 12
  };
  T.EngineWindow_sendPlatformMessage_closure0.prototype = {
    call$1: function(error) {
      var t1;
      window;
      t1 = "Error while trying to load an asset: " + H.S(error);
      if (typeof console != "undefined")
        window.console.warn(t1);
      this.$this._replyToPlatformMessage$2(this.callback, null);
    },
    $signature: 4
  };
  T.EngineWindow_sendPlatformMessage_closure1.prototype = {
    call$1: function(_) {
      this.$this._replyToPlatformMessage$2(this.callback, C.C_JSONMessageCodec0.encodeMessage$1([true]));
    },
    $signature: 44
  };
  T.EngineWindow__replyToPlatformMessage_closure.prototype = {
    call$1: function(_) {
      this.callback.call$1(this.data);
    },
    $signature: 44
  };
  T._BitmapCanvas_EngineCanvas_SaveStackTracking.prototype = {
    set$_clipStack: function(_clipStack) {
      this.SaveStackTracking__clipStack = H.assertSubtype(_clipStack, "$isList", [T._SaveClipEntry], "$asList");
    }
  };
  T._DomCanvas_EngineCanvas_SaveElementStackTracking.prototype = {};
  Q.ClipOp.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  Q.PictureRecorder.prototype = {
    beginRecording$1: function(bounds) {
      var t1, t2;
      this.cullRect = bounds;
      this._isRecording = true;
      t1 = H.setRuntimeTypeInfo([], [T.PaintCommand]);
      t2 = new T.Matrix40(new Float64Array(16));
      t2.setIdentity$0();
      return this._ui$_canvas = new T.RecordingCanvas(new T._PaintBounds(bounds, t2), t1);
    },
    get$isRecording: function() {
      return this._isRecording;
    },
    endRecording$0: function() {
      var _this = this;
      if (!_this._isRecording)
        return;
      _this._isRecording = false;
      return new Q.Picture(_this._ui$_canvas, _this.cullRect);
    }
  };
  Q.Canvas.prototype = {
    save$0: function(_) {
      this._ui$_canvas.save$0(0);
    },
    saveLayer$2: function(bounds, paint) {
      this._ui$_canvas.saveLayer$2(bounds, paint);
    },
    restore$0: function(_) {
      this._ui$_canvas.restore$0(0);
    },
    translate$2: function(_, dx, dy) {
      this._ui$_canvas.translate$2(0, dx, dy);
    },
    clipRect$3$clipOp$doAntiAlias: function(rect, clipOp, doAntiAlias) {
      this._ui$_canvas.clipRect$1(rect);
    },
    clipRect$1: function(rect) {
      return this.clipRect$3$clipOp$doAntiAlias(rect, C.ClipOp_1, true);
    },
    drawRect$2: function(rect, paint) {
      this._ui$_canvas.drawRect$2(rect, paint);
    },
    drawParagraph$2: function(paragraph, offset) {
      this._ui$_canvas.drawParagraph$2(paragraph, offset);
    }
  };
  Q.Picture.prototype = {
    get$recordingCanvas: function() {
      return this.recordingCanvas;
    }
  };
  Q.Scene.prototype = {
    dispose$0: function() {
    },
    get$webOnlyRootElement: function() {
      return this.webOnlyRootElement;
    }
  };
  Q.SceneBuilder.prototype = {
    _pushSurface$1: function(surface) {
      var t2,
        t1 = surface._oldLayer.value;
      if (t1 != null)
        t1._engine$_state = C.PersistedSurfaceState_3;
      t1 = this._surfaceStack;
      t2 = C.JSArray_methods.get$last(t1);
      C.JSArray_methods.add$1(t2._engine$_children, surface);
      surface.parent = t2;
      C.JSArray_methods.add$1(t1, surface);
      return surface;
    },
    pushOffset$3$oldLayer: function(dx, dy, oldLayer) {
      var t1, t2, t3;
      H.interceptedTypeCheck(oldLayer, "$isPersistedOffset");
      t1 = T.PersistedSurface;
      t2 = H.setRuntimeTypeInfo([], [t1]);
      t3 = oldLayer != null && oldLayer._engine$_state === C.PersistedSurfaceState_1 ? oldLayer : null;
      t1 = new T.FrameReference(t3, [t1]);
      C.JSArray_methods.add$1($._frameReferences, t1);
      return this._pushSurface$1(new T.PersistedOffset(dx, dy, t1, t2, C.PersistedSurfaceState_0));
    },
    pushTransform$2$oldLayer: function(matrix4, oldLayer) {
      var t1, t2, t3;
      H.interceptedTypeCheck(oldLayer, "$isPersistedTransform");
      t1 = T.PersistedSurface;
      t2 = H.setRuntimeTypeInfo([], [t1]);
      t3 = oldLayer != null && oldLayer._engine$_state === C.PersistedSurfaceState_1 ? oldLayer : null;
      t1 = new T.FrameReference(t3, [t1]);
      C.JSArray_methods.add$1($._frameReferences, t1);
      return this._pushSurface$1(new T.PersistedTransform(matrix4, t1, t2, C.PersistedSurfaceState_0));
    },
    addRetained$1: function(retainedLayer) {
      var t1;
      H.interceptedTypeCheck(retainedLayer, "$isPersistedContainerSurface");
      if (retainedLayer._engine$_state === C.PersistedSurfaceState_1)
        retainedLayer._engine$_state = C.PersistedSurfaceState_2;
      else
        retainedLayer.revive$0();
      t1 = C.JSArray_methods.get$last(this._surfaceStack);
      C.JSArray_methods.add$1(t1._engine$_children, retainedLayer);
      retainedLayer.parent = t1;
    },
    pop$0: function() {
      var t1 = this._surfaceStack;
      if (0 >= t1.length)
        return H.ioore(t1, -1);
      t1.pop();
    },
    addPicture$4$isComplexHint$willChangeHint: function(offset, picture, isComplexHint, willChangeHint) {
      var t1 = H.interceptedTypeCheck(T.standardPictureFactory(offset._dx, offset._dy, picture, 0), "$isPersistedSurface"),
        t2 = C.JSArray_methods.get$last(this._surfaceStack);
      C.JSArray_methods.add$1(t2._engine$_children, t1);
      t1.parent = t2;
    },
    build$0: function() {
      var t1 = this._surfaceStack;
      H.interceptedTypeCheck(C.JSArray_methods.get$first(t1), "$isPersistedScene").preroll$0();
      if ($.SceneBuilder__lastFrameScene == null)
        H.interceptedTypeCheck(C.JSArray_methods.get$first(t1), "$isPersistedScene").build$0();
      else
        H.interceptedTypeCheck(C.JSArray_methods.get$first(t1), "$isPersistedScene").update$1(0, $.SceneBuilder__lastFrameScene);
      T.commitScene(H.interceptedTypeCheck(C.JSArray_methods.get$first(t1), "$isPersistedScene"));
      $.SceneBuilder__lastFrameScene = H.interceptedTypeCheck(C.JSArray_methods.get$first(t1), "$isPersistedScene");
      return new Q.Scene(H.interceptedTypeCheck(C.JSArray_methods.get$first(t1), "$isPersistedScene").rootElement);
    }
  };
  Q.OffsetBase.prototype = {
    $gt: function(_, other) {
      var t1 = this._dx,
        t2 = other.get$_dx();
      if (typeof t1 !== "number")
        return t1.$gt();
      if (C.JSNumber_methods.$gt(t1, t2)) {
        t1 = this._dy;
        t2 = other.get$_dy();
        if (typeof t1 !== "number")
          return t1.$gt();
        t2 = C.JSNumber_methods.$gt(t1, t2);
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof Q.OffsetBase))
        return false;
      return this._dx == other._dx && this._dy == other._dy;
    },
    get$hashCode: function(_) {
      return Q.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = new H.TypeImpl(H.getRti(this)).toString$0(0) + "(",
        t2 = this._dx;
      t1 = t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ", ";
      t2 = this._dy;
      return t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ")";
    }
  };
  Q.Offset.prototype = {
    $sub: function(_, other) {
      var t3, t4,
        t1 = this._dx,
        t2 = other._dx;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this._dy;
      t4 = other._dy;
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new Q.Offset(t1 - t2, t3 - t4);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof Q.Offset))
        return false;
      return this._dx == other._dx && this._dy == other._dy;
    },
    get$hashCode: function(_) {
      return Q.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t2,
        t1 = this._dx;
      t1 = "Offset(" + H.S(t1 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t1, 1)) + ", ";
      t2 = this._dy;
      return t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ")";
    }
  };
  Q.Size.prototype = {
    get$isEmpty: function(_) {
      var t1 = this._dx;
      if (typeof t1 !== "number")
        return t1.$le();
      if (!(t1 <= 0)) {
        t1 = this._dy;
        if (typeof t1 !== "number")
          return t1.$le();
        t1 = t1 <= 0;
      } else
        t1 = true;
      return t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof Q.Size))
        return false;
      return this._dx == other._dx && this._dy == other._dy;
    },
    get$hashCode: function(_) {
      return Q.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t2,
        t1 = this._dx;
      t1 = "Size(" + H.S(t1 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t1, 1)) + ", ";
      t2 = this._dy;
      return t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ")";
    }
  };
  Q.Rect.prototype = {
    get$isEmpty: function(_) {
      var _this = this,
        t1 = _this.left;
      if (typeof t1 !== "number")
        return t1.$ge();
      if (!(t1 >= _this.right)) {
        t1 = _this.top;
        if (typeof t1 !== "number")
          return t1.$ge();
        t1 = t1 >= _this.bottom;
      } else
        t1 = true;
      return t1;
    },
    shift$1: function(offset) {
      var t3, t4, _this = this,
        t1 = _this.left,
        t2 = offset._dx;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = _this.top;
      t4 = offset._dy;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new Q.Rect(t1 + t2, t3 + t4, _this.right + t2, _this.bottom + t4);
    },
    inflate$1: function(delta) {
      var t2, _this = this,
        t1 = _this.left;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof delta !== "number")
        return H.iae(delta);
      t2 = _this.top;
      if (typeof t2 !== "number")
        return t2.$sub();
      return new Q.Rect(t1 - delta, t2 - delta, _this.right + delta, _this.bottom + delta);
    },
    intersect$1: function(other) {
      var t2, _this = this,
        t1 = other.left;
      t1 = Math.max(H.checkNum(_this.left), H.checkNum(t1));
      t2 = other.top;
      return new Q.Rect(t1, Math.max(H.checkNum(_this.top), H.checkNum(t2)), Math.min(_this.right, other.right), Math.min(_this.bottom, other.bottom));
    },
    expandToInclude$1: function(other) {
      var _this = this;
      return new Q.Rect(Math.min(H.checkNum(_this.left), H.checkNum(other.left)), Math.min(H.checkNum(_this.top), H.checkNum(other.top)), Math.max(_this.right, other.right), Math.max(_this.bottom, other.bottom));
    },
    get$center: function() {
      var t2, _this = this,
        t1 = _this.left;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = _this.top;
      if (typeof t2 !== "number")
        return H.iae(t2);
      return new Q.Offset(t1 + (_this.right - t1) / 2, t2 + (_this.bottom - t2) / 2);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isRect");
      return _this.left == other.left && _this.top == other.top && _this.right === other.right && _this.bottom === other.bottom;
    },
    get$hashCode: function(_) {
      var _this = this;
      return Q.hashValues(_this.left, _this.top, _this.right, _this.bottom, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var _this = this;
      return "Rect.fromLTRB(" + J.toStringAsFixed$1$n(_this.left, 1) + ", " + J.toStringAsFixed$1$n(_this.top, 1) + ", " + C.JSNumber_methods.toStringAsFixed$1(_this.right, 1) + ", " + C.JSNumber_methods.toStringAsFixed$1(_this.bottom, 1) + ")";
    }
  };
  Q._HashEnd.prototype = {};
  Q.Color.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      return this._ui$_value === H.interceptedTypeCheck(other, "$isColor")._ui$_value;
    },
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this._ui$_value);
    },
    toCssString$0: function() {
      var paddedValue,
        t1 = this._ui$_value;
      if ((4278190080 & t1) >>> 0 === 4278190080) {
        paddedValue = "00000" + C.JSInt_methods.toRadixString$1(t1, 16);
        return "#" + C.JSString_methods.substring$1(paddedValue, paddedValue.length - 6);
      } else {
        t1 = "rgba(" + C.JSInt_methods.toString$0(t1 >>> 16 & 255) + "," + C.JSInt_methods.toString$0(t1 >>> 8 & 255) + "," + C.JSInt_methods.toString$0(t1 & 255) + "," + C.JSDouble_methods.toString$0((t1 >>> 24 & 255) / 255) + ")";
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  Q.PaintingStyle.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  Q.BlendMode.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  Q.PaintData.prototype = {
    clone$0: function(_) {
      var _this = this,
        t1 = new Q.PaintData();
      t1.blendMode = _this.blendMode;
      t1.filterQuality = _this.filterQuality;
      t1.maskFilter = _this.maskFilter;
      t1.shader = _this.shader;
      t1.color = _this.color;
      t1.colorFilter = _this.colorFilter;
      t1.strokeWidth = _this.strokeWidth;
      t1.style = _this.style;
      t1.strokeJoin = _this.strokeJoin;
      t1.strokeCap = _this.strokeCap;
      return t1;
    }
  };
  Q.Paint.prototype = {
    get$strokeWidth: function() {
      return 0;
    },
    set$color: function(_, value) {
      var _this = this;
      if (_this._frozen) {
        _this._paintData = _this._paintData.clone$0(0);
        _this._frozen = false;
      }
      _this._paintData.color = value;
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  Q.Shader.prototype = {};
  Q.Gradient.prototype = {};
  Q._GradientLinear.prototype = {
    createPaintStyle$1: function(ctx) {
      var t1 = this.from,
        t2 = this.to,
        gradient = ctx.createLinearGradient(t1._dx, t1._dy, t2._dx, t2._dy);
      t1 = this.colors;
      gradient.addColorStop(0, t1[0].toCssString$0());
      gradient.addColorStop(1, t1[1].toCssString$0());
      return gradient;
    }
  };
  Q.Shadow.prototype = {};
  Q.PointerChange.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  Q.PointerDeviceKind.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  Q.PointerSignalKind.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  Q.PointerData.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(x: " + H.S(this.physicalX) + ", y: " + H.S(this.physicalY) + ")";
    }
  };
  Q.PointerDataPacket.prototype = {};
  Q.SemanticsAction.prototype = {
    toString$0: function(_) {
      switch (this.index) {
        case 1:
          return "SemanticsAction.tap";
        case 2:
          return "SemanticsAction.longPress";
        case 4:
          return "SemanticsAction.scrollLeft";
        case 8:
          return "SemanticsAction.scrollRight";
        case 16:
          return "SemanticsAction.scrollUp";
        case 32:
          return "SemanticsAction.scrollDown";
        case 64:
          return "SemanticsAction.increase";
        case 128:
          return "SemanticsAction.decrease";
        case 256:
          return "SemanticsAction.showOnScreen";
        case 512:
          return "SemanticsAction.moveCursorForwardByCharacter";
        case 1024:
          return "SemanticsAction.moveCursorBackwardByCharacter";
        case 2048:
          return "SemanticsAction.setSelection";
        case 4096:
          return "SemanticsAction.copy";
        case 8192:
          return "SemanticsAction.cut";
        case 16384:
          return "SemanticsAction.paste";
        case 32768:
          return "SemanticsAction.didGainAccessibilityFocus";
        case 65536:
          return "SemanticsAction.didLoseAccessibilityFocus";
        case 131072:
          return "SemanticsAction.customAction";
        case 262144:
          return "SemanticsAction.dismiss";
        case 524288:
          return "SemanticsAction.moveCursorForwardByWord";
        case 1048576:
          return "SemanticsAction.moveCursorBackwardByWord";
      }
      return;
    }
  };
  Q.SemanticsFlag.prototype = {
    toString$0: function(_) {
      switch (this.index) {
        case 1:
          return "SemanticsFlag.hasCheckedState";
        case 2:
          return "SemanticsFlag.isChecked";
        case 4:
          return "SemanticsFlag.isSelected";
        case 8:
          return "SemanticsFlag.isButton";
        case 16:
          return "SemanticsFlag.isTextField";
        case 32:
          return "SemanticsFlag.isFocused";
        case 64:
          return "SemanticsFlag.hasEnabledState";
        case 128:
          return "SemanticsFlag.isEnabled";
        case 256:
          return "SemanticsFlag.isInMutuallyExclusiveGroup";
        case 512:
          return "SemanticsFlag.isHeader";
        case 1024:
          return "SemanticsFlag.isObscured";
        case 2048:
          return "SemanticsFlag.scopesRoute";
        case 4096:
          return "SemanticsFlag.namesRoute";
        case 8192:
          return "SemanticsFlag.isHidden";
        case 16384:
          return "SemanticsFlag.isImage";
        case 32768:
          return "SemanticsFlag.isLiveRegion";
        case 65536:
          return "SemanticsFlag.hasToggledState";
        case 131072:
          return "SemanticsFlag.isToggled";
        case 262144:
          return "SemanticsFlag.hasImplicitScrolling";
        case 524288:
          return "SemanticsFlag.isMultiline";
      }
      return;
    }
  };
  Q.SemanticsUpdateBuilder.prototype = {
    build$0: function() {
      return new T.SemanticsUpdate(this._nodeUpdates);
    }
  };
  Q.FontStyle.prototype = {};
  Q.FontWeight.prototype = {
    toString$0: function(_) {
      return C.Map_yXAeS.$index(0, this.index);
    }
  };
  Q.TextAlign.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  Q.TextBaseline.prototype = {};
  Q.TextStyle.prototype = {
    get$_effectiveFontFamily: function() {
      var t1 = this._fontFamily;
      if (t1.length === 0)
        return "sans-serif";
      return t1;
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof Q.TextStyle))
        return false;
      if (J.$eq$(_this._color, other._color))
        if (_this._fontWeight == other._fontWeight)
          if (_this._fontFamily === other._fontFamily)
            if (_this._fontSize == other._fontSize)
              if (_this._background == other._background)
                t1 = Q._listEquals(_this._shadows, other._shadows, Q.Shadow) && Q._listEquals(_this._fontFamilyFallback, other._fontFamilyFallback, P.String);
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var _this = this;
      return Q.hashValues(_this._color, _this._decoration, _this._decorationColor, _this._decorationStyle, _this._fontWeight, _this._fontStyle, _this._textBaseline, _this._fontFamily, _this._fontFamilyFallback, _this._fontSize, _this._letterSpacing, _this._wordSpacing, _this._height, _this._locale, _this._background, _this._foreground, _this._shadows, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  Q.ParagraphStyle.prototype = {
    get$_effectiveFontFamily: function() {
      var t1 = this._fontFamily;
      if (t1 == null || t1.length === 0)
        return "sans-serif";
      return t1;
    },
    get$_webOnlyLineHeight: function() {
      var t2,
        t1 = this._strutStyle;
      if (t1 == null || false)
        return this._height;
      t1 = t1._height;
      t2 = this._height;
      if (t2 == null)
        t2 = 0;
      return Math.max(H.checkNum(t1), t2);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isParagraphStyle");
      if (_this._textAlign != other._textAlign)
        if (_this._ui$_textDirection != other._ui$_textDirection)
          _this._fontWeight != other._fontWeight;
      return true;
    },
    get$hashCode: function(_) {
      var _this = this;
      return Q.hashValues(_this._fontFamily, _this._fontSize, _this._height, _this._ellipsis, _this._locale, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = this.super$Object$toString(0);
      return t1;
    }
  };
  Q.TextDirection.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  Q.TextBox.prototype = {
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isTextBox");
      return other.left === _this.left && other.top === _this.top && other.right === _this.right && other.bottom === _this.bottom && other.direction == _this.direction;
    },
    get$hashCode: function(_) {
      var _this = this;
      return Q.hashValues(_this.left, _this.top, _this.right, _this.bottom, _this.direction, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return this.super$Object$toString(0);
    }
  };
  Q.TextAffinity.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  Q.TextPosition.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      H.interceptedTypeCheck(other, "$isTextPosition");
      return other.offset === this.offset && other.affinity === this.affinity;
    },
    get$hashCode: function(_) {
      return Q.hashValues(this.offset, this.affinity, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(offset: " + this.offset + ", affinity: " + this.affinity.toString$0(0) + ")";
    }
  };
  Q.ParagraphConstraints.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      return H.interceptedTypeCheck(other, "$isParagraphConstraints").width == this.width;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.width);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(width: " + H.S(this.width) + ")";
    }
  };
  Q.Paragraph.prototype = {
    get$width: function(_) {
      var t1 = this._measurementResult;
      t1 = t1 == null ? null : t1.width;
      return t1 == null ? -1 : t1;
    },
    get$height: function(_) {
      var t1 = this._measurementResult;
      t1 = t1 == null ? null : t1.height;
      return t1 == null ? 0 : t1;
    },
    get$maxIntrinsicWidth: function() {
      var t1 = this._measurementResult;
      t1 = t1 == null ? null : t1.maxIntrinsicWidth;
      return t1 == null ? 0 : t1;
    },
    get$alphabeticBaseline: function(_) {
      var t1 = this._measurementResult;
      t1 = t1 == null ? null : t1.alphabeticBaseline;
      return t1 == null ? -1 : t1;
    },
    layout$1: function(constraints) {
      var t1, t2, _this = this;
      if (constraints.$eq(0, _this._lastUsedConstraints))
        return;
      t1 = T.TextMeasurementService_forParagraph(_this).measure$2(0, _this, constraints);
      _this._measurementResult = t1;
      _this._lastUsedConstraints = constraints;
      _this._didExceedMaxLines = false;
      if (t1.isSingleLine && true)
        switch (_this._textAlign) {
          case C.TextAlign_2:
            t1 = constraints.width;
            t2 = _this.get$maxIntrinsicWidth();
            if (typeof t1 !== "number")
              return t1.$sub();
            _this.webOnlyAlignOffset = (t1 - t2) / 2;
            break;
          case C.TextAlign_1:
            t1 = constraints.width;
            t2 = _this.get$maxIntrinsicWidth();
            if (typeof t1 !== "number")
              return t1.$sub();
            _this.webOnlyAlignOffset = t1 - t2;
            break;
          case C.TextAlign_4:
            if (_this._ui$_textDirection === C.TextDirection_0) {
              t1 = constraints.width;
              t2 = _this.get$maxIntrinsicWidth();
              if (typeof t1 !== "number")
                return t1.$sub();
              t2 = t1 - t2;
              t1 = t2;
            } else
              t1 = 0;
            _this.webOnlyAlignOffset = t1;
            break;
          case C.TextAlign_5:
            if (_this._ui$_textDirection === C.TextDirection_1) {
              t1 = constraints.width;
              t2 = _this.get$maxIntrinsicWidth();
              if (typeof t1 !== "number")
                return t1.$sub();
              t2 = t1 - t2;
              t1 = t2;
            } else
              t1 = 0;
            _this.webOnlyAlignOffset = t1;
            break;
          default:
            _this.webOnlyAlignOffset = 0;
            break;
        }
    },
    _getBoxesForRange$4: function(start, end, boxHeightStyle, boxWidthStyle) {
      var $length, t2, t3, _this = this,
        t1 = _this._plainText;
      if (t1 == null)
        return H.setRuntimeTypeInfo([], [Q.TextBox]);
      $length = t1.length;
      if (typeof start !== "number")
        return start.$lt();
      if (start >= 0) {
        if (typeof end !== "number")
          return end.$lt();
        t2 = end < 0 || start > $length || end > $length;
      } else
        t2 = true;
      if (t2)
        return H.setRuntimeTypeInfo([], [Q.TextBox]);
      T.TextMeasurementService_forParagraph(_this);
      t2 = _this._lastUsedConstraints;
      t3 = _this.webOnlyAlignOffset;
      return $.TextMeasurementService_rulerManager.findOrCreateRuler$1(_this._paragraphGeometricStyle).measureBoxesForRange$6$alignOffset$end$start$textDirection(t1, t2, t3, end, start, _this._ui$_textDirection);
    },
    getPositionForOffset$1: function(offset) {
      var t2, t3, dx, instance, high, low, current, width, _this = this,
        t1 = _this._plainText;
      if (t1 == null)
        return C.TextPosition_0_TextAffinity_1;
      t2 = offset._dx;
      t3 = _this.webOnlyAlignOffset;
      if (typeof t2 !== "number")
        return t2.$sub();
      dx = t2 - t3;
      instance = T.TextMeasurementService_forParagraph(_this);
      high = t1.length;
      low = 0;
      do {
        current = C.JSInt_methods._tdivFast$1(low + high, 2);
        width = instance.measureSubstringWidth$3(_this, 0, current);
        if (width < dx)
          low = current;
        else {
          low = width > dx ? low : current;
          high = current;
        }
      } while (high - low > 1);
      if (low === high)
        return new Q.TextPosition(high, C.TextAffinity_0);
      if (dx - instance.measureSubstringWidth$3(_this, 0, low) < instance.measureSubstringWidth$3(_this, 0, high) - dx)
        return new Q.TextPosition(low, C.TextAffinity_1);
      else
        return new Q.TextPosition(high, C.TextAffinity_0);
    }
  };
  Q.ParagraphBuilder.prototype = {
    build$0: function() {
      var t1 = this._tryBuildPlainText$0();
      return t1 == null ? this._buildRichText$0() : t1;
    },
    _tryBuildPlainText$0: function() {
      var style, color0, fontWeight0, fontSize0, background0, cumulativeStyle, paint, plainTextBuffer, t4, t5, plainText, _this = this, _null = null,
        t1 = _this._paragraphStyle,
        fontWeight = t1._fontWeight,
        fontStyle = t1._fontStyle,
        fontFamily = t1._fontFamily,
        fontSize = t1._fontSize,
        textAlign = t1._textAlign,
        textDirection = t1._ui$_textDirection,
        locale = t1._locale,
        t2 = _this._ops,
        t3 = t2.length,
        background = _null,
        color = background,
        i = 0;
      while (true) {
        if (!(i < t3 && t2[i] instanceof Q.TextStyle))
          break;
        if (i >= t3)
          return H.ioore(t2, i);
        style = H.interceptedTypeCheck(t2[i], "$isTextStyle");
        color0 = style._color;
        if (color0 != null)
          color = color0;
        fontWeight0 = style._fontWeight;
        if (fontWeight0 != null)
          fontWeight = fontWeight0;
        fontFamily = style._fontFamily;
        fontSize0 = style._fontSize;
        if (fontSize0 != null)
          fontSize = fontSize0;
        background0 = style._background;
        if (background0 != null)
          background = background0;
        style._foreground;
        ++i;
      }
      cumulativeStyle = Q.TextStyle$(background, color, _null, _null, _null, _null, fontFamily, _null, fontSize, fontStyle, fontWeight, _null, _null, _null, locale, _null, _null, _null);
      paint = new Q.Paint(new Q.PaintData());
      if (color != null)
        paint.set$color(0, color);
      if (i >= t2.length) {
        t2 = _this._paragraphElement;
        Q.applyTextStyleToElement(t2, cumulativeStyle);
        t3 = t1._maxLines;
        return Q.Paragraph$_(cumulativeStyle._background, paint, t2, T.ParagraphGeometricStyle$(Q._textDecorationToCssString(_null, _null), t1._ellipsis, fontFamily, fontSize, fontStyle, fontWeight, _null, _null, t3, _null), "", textAlign, textDirection);
      }
      t3 = t2[i];
      if (typeof t3 !== "string")
        return;
      plainTextBuffer = new P.StringBuffer("");
      t3 = "";
      while (true) {
        t4 = t2.length;
        if (i < t4) {
          t5 = t2[i];
          t5 = typeof t5 === "string";
        } else
          t5 = false;
        if (!t5)
          break;
        if (i >= t4)
          return H.ioore(t2, i);
        t3 += H.S(t2[i]);
        plainTextBuffer._contents = t3;
        ++i;
      }
      for (; i < t2.length; ++i)
        if (!J.$eq$(t2[i], $.$get$ParagraphBuilder__paragraphBuilderPop()))
          return;
      t2 = plainTextBuffer._contents;
      plainText = t2.charCodeAt(0) == 0 ? t2 : t2;
      t2 = _this._paragraphElement;
      $.$get$domRenderer().toString;
      t2.toString;
      t2.appendChild(document.createTextNode(plainText));
      Q.applyTextStyleToElement(t2, cumulativeStyle);
      t3 = cumulativeStyle._background;
      if (t3 != null)
        Q.applyTextBackgroundToElement(t2, cumulativeStyle);
      t4 = t1._maxLines;
      return Q.Paragraph$_(t3, paint, t2, T.ParagraphGeometricStyle$(Q._textDecorationToCssString(_null, _null), t1._ellipsis, fontFamily, fontSize, fontStyle, fontWeight, _null, _null, t4, _null), plainText, textAlign, textDirection);
    },
    _buildRichText$0: function() {
      var t1, i, op, element, t2, t3, t4, t5, t6, t7, _this = this, _null = null, elementStack = [],
        currentElement = new Q.ParagraphBuilder__buildRichText_currentElement(_this, elementStack);
      for (t1 = _this._ops, i = 0; i < t1.length; ++i) {
        op = t1[i];
        if (op instanceof Q.TextStyle) {
          $.$get$domRenderer().toString;
          element = document.createElement("span");
          H.interceptedTypeCheck(element, "$isSpanElement");
          Q.applyTextStyleToElement(element, op);
          if (op._background != null)
            Q.applyTextBackgroundToElement(element, op);
          H.interceptedTypeCheck(currentElement.call$0(), "$isElement0").appendChild(element);
          elementStack.push(element);
        } else if (typeof op === "string") {
          t2 = $.$get$domRenderer();
          t3 = H.interceptedTypeCheck(currentElement.call$0(), "$isElement0");
          t2.toString;
          t3.toString;
          t3.appendChild(document.createTextNode(op));
        } else {
          t2 = $.$get$ParagraphBuilder__paragraphBuilderPop();
          if (op == null ? t2 == null : op === t2) {
            if (0 >= elementStack.length)
              return H.ioore(elementStack, -1);
            elementStack.pop();
          } else
            throw H.wrapException(P.UnsupportedError$("Unsupported ParagraphBuilder operation: " + H.S(op)));
        }
      }
      t1 = _this._paragraphStyle;
      t2 = t1._fontFamily;
      t3 = t1._fontWeight;
      t4 = t1._fontStyle;
      t5 = t1._fontSize;
      t6 = t1._height;
      t7 = t1._maxLines;
      return Q.Paragraph$_(_null, _null, _this._paragraphElement, T.ParagraphGeometricStyle$(_null, t1._ellipsis, t2, t5, t4, t3, _null, t6, t7, _null), _null, t1._textAlign, t1._ui$_textDirection);
    }
  };
  Q.ParagraphBuilder__buildRichText_currentElement.prototype = {
    call$0: function() {
      var t1 = this.elementStack;
      return t1.length !== 0 ? C.JSArray_methods.get$last(t1) : this.$this._paragraphElement;
    },
    $signature: 125
  };
  Q.TileMode.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  Q.AppLifecycleState.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  Q.Locale.prototype = {
    $eq: function(_, other) {
      var t1;
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof Q.Locale))
        return false;
      if (Q.Locale__replaceDeprecatedLanguageSubtag(this._languageCode) === Q.Locale__replaceDeprecatedLanguageSubtag(other._languageCode))
        t1 = Q.Locale__replaceDeprecatedRegionSubtag(this._countryCode) === Q.Locale__replaceDeprecatedRegionSubtag(other._countryCode);
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return Q.hashValues(Q.Locale__replaceDeprecatedLanguageSubtag(this._languageCode), null, Q.Locale__replaceDeprecatedRegionSubtag(this._countryCode), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = Q.Locale__replaceDeprecatedLanguageSubtag(this._languageCode);
      t1 += "_" + Q.Locale__replaceDeprecatedRegionSubtag(this._countryCode);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  Q.Window.prototype = {
    get$onMetricsChanged: function() {
      return this._onMetricsChanged;
    },
    scheduleFrame$0: function() {
      var t1 = $.webOnlyScheduleFrameCallback;
      if (t1 == null)
        throw H.wrapException(P.Exception_Exception("webOnlyScheduleFrameCallback must be initialized first."));
      t1.call$0();
    },
    get$onBeginFrame: function() {
      return this._onBeginFrame;
    },
    get$onDrawFrame: function() {
      return this._onDrawFrame;
    },
    get$onPointerDataPacket: function() {
      return this._onPointerDataPacket;
    },
    get$onSemanticsEnabledChanged: function() {
      return this._onSemanticsEnabledChanged;
    },
    get$onSemanticsAction: function() {
      return this._onSemanticsAction;
    },
    get$onPlatformMessage: function() {
      return this._onPlatformMessage;
    },
    set$_onTextScaleFactorChanged: function(_onTextScaleFactorChanged) {
      H.functionTypeCheck(_onTextScaleFactorChanged, {func: 1, ret: -1});
    },
    set$_onPlatformBrightnessChanged: function(_onPlatformBrightnessChanged) {
      H.functionTypeCheck(_onPlatformBrightnessChanged, {func: 1, ret: -1});
    },
    set$_onMetricsChanged: function(_onMetricsChanged) {
      this._onMetricsChanged = H.functionTypeCheck(_onMetricsChanged, {func: 1, ret: -1});
    },
    set$_onLocaleChanged: function(_onLocaleChanged) {
      H.functionTypeCheck(_onLocaleChanged, {func: 1, ret: -1});
    },
    set$_onBeginFrame: function(_onBeginFrame) {
      this._onBeginFrame = H.functionTypeCheck(_onBeginFrame, {func: 1, ret: -1, args: [P.Duration]});
    },
    set$_onDrawFrame: function(_onDrawFrame) {
      this._onDrawFrame = H.functionTypeCheck(_onDrawFrame, {func: 1, ret: -1});
    },
    set$_onPointerDataPacket: function(_onPointerDataPacket) {
      this._onPointerDataPacket = H.functionTypeCheck(_onPointerDataPacket, {func: 1, ret: -1, args: [Q.PointerDataPacket]});
    },
    set$_onSemanticsEnabledChanged: function(_onSemanticsEnabledChanged) {
      this._onSemanticsEnabledChanged = H.functionTypeCheck(_onSemanticsEnabledChanged, {func: 1, ret: -1});
    },
    set$_onSemanticsAction: function(_onSemanticsAction) {
      this._onSemanticsAction = H.functionTypeCheck(_onSemanticsAction, {func: 1, ret: -1, args: [P.int, Q.SemanticsAction, P.ByteData]});
    },
    set$_onAccessibilityFeaturesChanged: function(_onAccessibilityFeaturesChanged) {
      H.functionTypeCheck(_onAccessibilityFeaturesChanged, {func: 1, ret: -1});
    },
    set$_onPlatformMessage: function(_onPlatformMessage) {
      this._onPlatformMessage = H.functionTypeCheck(_onPlatformMessage, {func: 1, ret: -1, args: [P.String, P.ByteData, {func: 1, ret: -1, args: [P.ByteData]}]});
    },
    onMetricsChanged$0: function() {
      return this.get$onMetricsChanged().call$0();
    },
    onBeginFrame$1: function(arg0) {
      return this.get$onBeginFrame().call$1(arg0);
    },
    onDrawFrame$0: function() {
      return this.get$onDrawFrame().call$0();
    },
    onPointerDataPacket$1: function(arg0) {
      return this.get$onPointerDataPacket().call$1(arg0);
    },
    onSemanticsEnabledChanged$0: function() {
      return this.get$onSemanticsEnabledChanged().call$0();
    },
    onSemanticsAction$3: function(arg0, arg1, arg2) {
      return this.get$onSemanticsAction().call$3(arg0, arg1, arg2);
    },
    onPlatformMessage$3: function(arg0, arg1, arg2) {
      return this.get$onPlatformMessage().call$3(arg0, arg1, arg2);
    }
  };
  Q.AccessibilityFeatures.prototype = {
    toString$0: function(_) {
      var features = H.setRuntimeTypeInfo([], [P.String]),
        t1 = this._ui$_index;
      if ((1 & t1) !== 0)
        C.JSArray_methods.add$1(features, "accessibleNavigation");
      if ((2 & t1) !== 0)
        C.JSArray_methods.add$1(features, "invertColors");
      if ((4 & t1) !== 0)
        C.JSArray_methods.add$1(features, "disableAnimations");
      if ((8 & t1) !== 0)
        C.JSArray_methods.add$1(features, "boldText");
      if ((16 & t1) !== 0)
        C.JSArray_methods.add$1(features, "reduceMotion");
      return "AccessibilityFeatures" + H.S(features);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      return this._ui$_index === H.interceptedTypeCheck(other, "$isAccessibilityFeatures")._ui$_index;
    },
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this._ui$_index);
    }
  };
  A.hashObjects_closure.prototype = {
    call$2: function(h, i) {
      var t1, hash;
      H.intTypeCheck(h);
      t1 = J.get$hashCode$(i);
      if (typeof h !== "number")
        return h.$add();
      hash = 536870911 & h + t1;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    $signature: 126
  };
  E.Matrix4.prototype = {
    setFrom$1: function(arg) {
      var argStorage = arg._m4storage,
        t1 = this._m4storage;
      t1[15] = argStorage[15];
      t1[14] = argStorage[14];
      t1[13] = argStorage[13];
      t1[12] = argStorage[12];
      t1[11] = argStorage[11];
      t1[10] = argStorage[10];
      t1[9] = argStorage[9];
      t1[8] = argStorage[8];
      t1[7] = argStorage[7];
      t1[6] = argStorage[6];
      t1[5] = argStorage[5];
      t1[4] = argStorage[4];
      t1[3] = argStorage[3];
      t1[2] = argStorage[2];
      t1[1] = argStorage[1];
      t1[0] = argStorage[0];
    },
    toString$0: function(_) {
      var _this = this;
      return "[0] " + _this.getRow$1(0).toString$0(0) + "\n[1] " + _this.getRow$1(1).toString$0(0) + "\n[2] " + _this.getRow$1(2).toString$0(0) + "\n[3] " + _this.getRow$1(3).toString$0(0) + "\n";
    },
    $index: function(_, i) {
      var t1;
      H.intTypeCheck(i);
      t1 = this._m4storage;
      if (i >= 16)
        return H.ioore(t1, i);
      return t1[i];
    },
    $indexSet: function(_, i, v) {
      C.NativeFloat64List_methods.$indexSet(this._m4storage, i, v);
    },
    $eq: function(_, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      if (other instanceof E.Matrix4) {
        t1 = this._m4storage;
        t2 = t1[0];
        t3 = other._m4storage;
        t1 = t2 === t3[0] && t1[1] === t3[1] && t1[2] === t3[2] && t1[3] === t3[3] && t1[4] === t3[4] && t1[5] === t3[5] && t1[6] === t3[6] && t1[7] === t3[7] && t1[8] === t3[8] && t1[9] === t3[9] && t1[10] === t3[10] && t1[11] === t3[11] && t1[12] === t3[12] && t1[13] === t3[13] && t1[14] === t3[14] && t1[15] === t3[15];
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return A.hashObjects(this._m4storage);
    },
    getRow$1: function(row) {
      var t3,
        t1 = new Float64Array(4),
        t2 = this._m4storage;
      if (row >= 16)
        return H.ioore(t2, row);
      t1[0] = t2[row];
      t3 = 4 + row;
      if (t3 >= 16)
        return H.ioore(t2, t3);
      t1[1] = t2[t3];
      t3 = 8 + row;
      if (t3 >= 16)
        return H.ioore(t2, t3);
      t1[2] = t2[t3];
      t3 = 12 + row;
      if (t3 >= 16)
        return H.ioore(t2, t3);
      t1[3] = t2[t3];
      return new E.Vector4(t1);
    },
    setIdentity$0: function() {
      var t1 = this._m4storage;
      t1[0] = 1;
      t1[1] = 0;
      t1[2] = 0;
      t1[3] = 0;
      t1[4] = 0;
      t1[5] = 1;
      t1[6] = 0;
      t1[7] = 0;
      t1[8] = 0;
      t1[9] = 0;
      t1[10] = 1;
      t1[11] = 0;
      t1[12] = 0;
      t1[13] = 0;
      t1[14] = 0;
      t1[15] = 1;
    },
    copyInverse$1: function(arg) {
      var invDet, t1, t2, t3,
        argStorage = arg._m4storage,
        a00 = argStorage[0],
        a01 = argStorage[1],
        a02 = argStorage[2],
        a03 = argStorage[3],
        a10 = argStorage[4],
        a11 = argStorage[5],
        a12 = argStorage[6],
        a13 = argStorage[7],
        a20 = argStorage[8],
        a21 = argStorage[9],
        a22 = argStorage[10],
        a23 = argStorage[11],
        a30 = argStorage[12],
        a31 = argStorage[13],
        a32 = argStorage[14],
        a33 = argStorage[15],
        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (det === 0) {
        this.setFrom$1(arg);
        return 0;
      }
      invDet = 1 / det;
      t1 = this._m4storage;
      t1[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
      t1[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
      t1[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
      t1[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
      t2 = -a10;
      t1[4] = (t2 * b11 + a12 * b08 - a13 * b07) * invDet;
      t1[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
      t3 = -a30;
      t1[6] = (t3 * b05 + a32 * b02 - a33 * b01) * invDet;
      t1[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
      t1[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
      t1[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
      t1[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
      t1[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
      t1[12] = (t2 * b09 + a11 * b07 - a12 * b06) * invDet;
      t1[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
      t1[14] = (t3 * b03 + a31 * b01 - a32 * b00) * invDet;
      t1[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
      return det;
    },
    multiply$1: function(_, arg) {
      var t1 = this._m4storage,
        m00 = t1[0],
        m01 = t1[4],
        m02 = t1[8],
        m03 = t1[12],
        m10 = t1[1],
        m11 = t1[5],
        m12 = t1[9],
        m13 = t1[13],
        m20 = t1[2],
        m21 = t1[6],
        m22 = t1[10],
        m23 = t1[14],
        m30 = t1[3],
        m31 = t1[7],
        m32 = t1[11],
        m33 = t1[15],
        argStorage = arg._m4storage,
        n00 = argStorage[0],
        n01 = argStorage[4],
        n02 = argStorage[8],
        n03 = argStorage[12],
        n10 = argStorage[1],
        n11 = argStorage[5],
        n12 = argStorage[9],
        n13 = argStorage[13],
        n20 = argStorage[2],
        n21 = argStorage[6],
        n22 = argStorage[10],
        n23 = argStorage[14],
        n30 = argStorage[3],
        n31 = argStorage[7],
        n32 = argStorage[11],
        n33 = argStorage[15];
      t1[0] = m00 * n00 + m01 * n10 + m02 * n20 + m03 * n30;
      t1[4] = m00 * n01 + m01 * n11 + m02 * n21 + m03 * n31;
      t1[8] = m00 * n02 + m01 * n12 + m02 * n22 + m03 * n32;
      t1[12] = m00 * n03 + m01 * n13 + m02 * n23 + m03 * n33;
      t1[1] = m10 * n00 + m11 * n10 + m12 * n20 + m13 * n30;
      t1[5] = m10 * n01 + m11 * n11 + m12 * n21 + m13 * n31;
      t1[9] = m10 * n02 + m11 * n12 + m12 * n22 + m13 * n32;
      t1[13] = m10 * n03 + m11 * n13 + m12 * n23 + m13 * n33;
      t1[2] = m20 * n00 + m21 * n10 + m22 * n20 + m23 * n30;
      t1[6] = m20 * n01 + m21 * n11 + m22 * n21 + m23 * n31;
      t1[10] = m20 * n02 + m21 * n12 + m22 * n22 + m23 * n32;
      t1[14] = m20 * n03 + m21 * n13 + m22 * n23 + m23 * n33;
      t1[3] = m30 * n00 + m31 * n10 + m32 * n20 + m33 * n30;
      t1[7] = m30 * n01 + m31 * n11 + m32 * n21 + m33 * n31;
      t1[11] = m30 * n02 + m31 * n12 + m32 * n22 + m33 * n32;
      t1[15] = m30 * n03 + m31 * n13 + m32 * n23 + m33 * n33;
    }
  };
  E.Vector3.prototype = {
    setValues$3: function(x_, y_, z_) {
      var t1 = this._v3storage;
      C.NativeFloat64List_methods.$indexSet(t1, 0, x_);
      C.NativeFloat64List_methods.$indexSet(t1, 1, y_);
      t1[2] = z_;
    },
    toString$0: function(_) {
      var t1 = this._v3storage;
      return "[" + H.S(t1[0]) + "," + H.S(t1[1]) + "," + H.S(t1[2]) + "]";
    },
    $eq: function(_, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      if (other instanceof E.Vector3) {
        t1 = this._v3storage;
        t2 = t1[0];
        t3 = other._v3storage;
        t1 = t2 === t3[0] && t1[1] === t3[1] && t1[2] === t3[2];
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return A.hashObjects(this._v3storage);
    },
    $index: function(_, i) {
      var t1;
      H.intTypeCheck(i);
      t1 = this._v3storage;
      if (i >= 3)
        return H.ioore(t1, i);
      return t1[i];
    },
    $indexSet: function(_, i, v) {
      C.NativeFloat64List_methods.$indexSet(this._v3storage, i, v);
    },
    get$length: function(_) {
      var t1 = this._v3storage,
        t2 = t1[0],
        t3 = t1[1];
      t1 = t1[2];
      return Math.sqrt(t2 * t2 + t3 * t3 + t1 * t1);
    }
  };
  E.Vector4.prototype = {
    toString$0: function(_) {
      var t1 = this._v4storage;
      return H.S(t1[0]) + "," + H.S(t1[1]) + "," + H.S(t1[2]) + "," + H.S(t1[3]);
    },
    $eq: function(_, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      if (other instanceof E.Vector4) {
        t1 = this._v4storage;
        t2 = t1[0];
        t3 = other._v4storage;
        t1 = t2 === t3[0] && t1[1] === t3[1] && t1[2] === t3[2] && t1[3] === t3[3];
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return A.hashObjects(this._v4storage);
    },
    $index: function(_, i) {
      var t1;
      H.intTypeCheck(i);
      t1 = this._v4storage;
      if (i >= 4)
        return H.ioore(t1, i);
      return t1[i];
    },
    $indexSet: function(_, i, v) {
      C.NativeFloat64List_methods.$indexSet(this._v4storage, i, v);
    },
    get$length: function(_) {
      var t1 = this._v4storage,
        t2 = t1[0],
        t3 = t1[1],
        t4 = t1[2];
      t1 = t1[3];
      return Math.sqrt(t2 * t2 + t3 * t3 + t4 * t4 + t1 * t1);
    }
  };
  (function aliases() {
    var _ = J.Interceptor.prototype;
    _.super$Interceptor$toString = _.toString$0;
    _.super$Interceptor$noSuchMethod = _.noSuchMethod$1;
    _ = J.JavaScriptObject.prototype;
    _.super$JavaScriptObject$toString = _.toString$0;
    _ = P.Iterable.prototype;
    _.super$Iterable$where = _.where$1;
    _ = P.Object.prototype;
    _.super$Object$toString = _.toString$0;
    _ = W.Element0.prototype;
    _.super$Element$createFragment = _.createFragment$3$treeSanitizer$validator;
    _ = W.EventTarget.prototype;
    _.super$EventTarget$addEventListener = _.addEventListener$3;
    _ = W._SimpleNodeValidator.prototype;
    _.super$_SimpleNodeValidator$allowsAttribute = _.allowsAttribute$3;
    _ = N.BindingBase.prototype;
    _.super$BindingBase$initInstances = _.initInstances$0;
    _.super$BindingBase$initServiceExtensions = _.initServiceExtensions$0;
    _.super$BindingBase$unlocked = _.unlocked$0;
    _ = B.ChangeNotifier.prototype;
    _.super$ChangeNotifier$dispose = _.dispose$0;
    _ = Y.DiagnosticsProperty.prototype;
    _.super$DiagnosticsProperty$valueToString = _.valueToString$1$parentConfiguration;
    _ = Y.DiagnosticableMixin.prototype;
    _.super$DiagnosticableMixin$debugFillProperties = _.debugFillProperties$1;
    _ = Y.DiagnosticableTreeMixin.prototype;
    _.super$DiagnosticableTreeMixin$toStringDeep = _.toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines;
    _.super$DiagnosticableTreeMixin$toStringShort = _.toStringShort$0;
    _.super$DiagnosticableTreeMixin$debugFillProperties = _.debugFillProperties$1;
    _ = B.AbstractNode.prototype;
    _.super$AbstractNode$attach = _.attach$1;
    _.super$AbstractNode$detach = _.detach$0;
    _.super$AbstractNode$adoptChild = _.adoptChild$1;
    _.super$AbstractNode$dropChild = _.dropChild$1;
    _ = N.GestureBinding.prototype;
    _.super$GestureBinding$hitTest = _.hitTest$2;
    _ = F.PointerEvent.prototype;
    _.super$PointerEvent$debugFillProperties = _.debugFillProperties$1;
    _ = O.HitTestEntry.prototype;
    _.super$HitTestEntry$toString = _.toString$0;
    _ = N.RendererBinding.prototype;
    _.super$RendererBinding$handleMetricsChanged = _.handleMetricsChanged$0;
    _.super$RendererBinding$handleTextScaleFactorChanged = _.handleTextScaleFactorChanged$0;
    _.super$RendererBinding$handlePlatformBrightnessChanged = _.handlePlatformBrightnessChanged$0;
    _.super$RendererBinding$drawFrame = _.drawFrame$0;
    _ = S.RenderBox.prototype;
    _.super$RenderBox$debugFillProperties = _.debugFillProperties$1;
    _ = T.Layer.prototype;
    _.super$Layer$updateSubtreeNeedsAddToScene = _.updateSubtreeNeedsAddToScene$0;
    _.super$Layer$debugFillProperties = _.debugFillProperties$1;
    _ = T.ContainerLayer.prototype;
    _.super$ContainerLayer$find = _.find$1$1;
    _.super$ContainerLayer$findAll = _.findAll$1$1;
    _ = T.OffsetLayer.prototype;
    _.super$OffsetLayer$find = _.find$1$1;
    _.super$OffsetLayer$findAll = _.findAll$1$1;
    _.super$OffsetLayer$debugFillProperties = _.debugFillProperties$1;
    _ = K.ParentData.prototype;
    _.super$ParentData$toString = _.toString$0;
    _ = K.RenderObject.prototype;
    _.super$RenderObject$attach = _.attach$1;
    _.super$RenderObject$markNeedsLayout = _.markNeedsLayout$0;
    _.super$RenderObject$applyPaintTransform = _.applyPaintTransform$2;
    _.super$RenderObject$describeSemanticsConfiguration = _.describeSemanticsConfiguration$1;
    _.super$RenderObject$handleEvent = _.handleEvent$2;
    _.super$RenderObject$debugFillProperties = _.debugFillProperties$1;
    _ = N.SchedulerBinding.prototype;
    _.super$SchedulerBinding$handleAppLifecycleStateChanged = _.handleAppLifecycleStateChanged$1;
    _ = N.SemanticsBinding.prototype;
    _.super$SemanticsBinding$handleAccessibilityFeaturesChanged = _.handleAccessibilityFeaturesChanged$0;
    _ = A.SemanticsSortKey.prototype;
    _.super$SemanticsSortKey$debugFillProperties = _.debugFillProperties$1;
    _ = Q.AssetBundle.prototype;
    _.super$AssetBundle$loadString = _.loadString$2$cache;
    _ = A.MethodChannel.prototype;
    _.super$MethodChannel$invokeMethod = _.invokeMethod$1$2;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding$initInstances = _.initInstances$0;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding$unlocked = _.unlocked$0;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding$initInstances = _.initInstances$0;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding$initServiceExtensions = _.initServiceExtensions$0;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding$initInstances = _.initInstances$0;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding$initServiceExtensions = _.initServiceExtensions$0;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding$initInstances = _.initInstances$0;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding$initInstances = _.initInstances$0;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding$initInstances = _.initInstances$0;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding$initServiceExtensions = _.initServiceExtensions$0;
    _ = O.FocusNode.prototype;
    _.super$FocusNode$debugFillProperties = _.debugFillProperties$1;
    _ = N.Widget.prototype;
    _.super$Widget$debugFillProperties = _.debugFillProperties$1;
    _ = N.Element.prototype;
    _.super$Element$mount = _.mount$2;
    _.super$Element$update = _.update$1;
    _.super$Element$_updateSlot = _._updateSlot$1;
    _.super$Element$deactivate = _.deactivate$0;
    _.super$Element$unmount = _.unmount$0;
    _.super$Element$debugFillProperties = _.debugFillProperties$1;
    _ = N.RenderObjectElement.prototype;
    _.super$RenderObjectElement$mount = _.mount$2;
    _.super$RenderObjectElement$update = _.update$1;
    _.super$RenderObjectElement$performRebuild = _.performRebuild$0;
    _ = N.RootRenderObjectElement.prototype;
    _.super$RootRenderObjectElement$mount = _.mount$2;
    _ = T.EngineCanvas.prototype;
    _.super$EngineCanvas$dispose = _.dispose$0;
    _ = T.SaveStackTracking.prototype;
    _.super$SaveStackTracking$clear = _.clear$0;
    _.super$SaveStackTracking$save = _.save$0;
    _.super$SaveStackTracking$restore = _.restore$0;
    _.super$SaveStackTracking$translate = _.translate$2;
    _.super$SaveStackTracking$clipRect = _.clipRect$1;
    _ = T.SaveElementStackTracking.prototype;
    _.super$SaveElementStackTracking$clear = _.clear$0;
    _ = T.PersistedSurface.prototype;
    _.super$PersistedSurface$revive = _.revive$0;
    _.super$PersistedSurface$build = _.build$0;
    _.super$PersistedSurface$update = _.update$1;
    _.super$PersistedSurface$retain = _.retain$0;
    _.super$PersistedSurface$discard = _.discard$0;
    _.super$PersistedSurface$preroll = _.preroll$0;
    _ = T.PersistedContainerSurface.prototype;
    _.super$PersistedContainerSurface$update = _.update$1;
  })();
  (function installTearOffs() {
    var _static_2 = hunkHelpers._static_2,
      _static_0 = hunkHelpers._static_0,
      _static_1 = hunkHelpers._static_1,
      _instance = hunkHelpers.installInstanceTearOff,
      _instance_1_i = hunkHelpers._instance_1i,
      _instance_2_u = hunkHelpers._instance_2u,
      _instance_0_u = hunkHelpers._instance_0u,
      _static = hunkHelpers.installStaticTearOff,
      _instance_1_u = hunkHelpers._instance_1u;
    _static_2(J, "_interceptors_JSArray__compareAny$closure", "JSArray__compareAny", 45);
    _static_0(H, "_js_helper_Primitives_dateNow$closure", "Primitives_dateNow", 33);
    _static_1(P, "async__AsyncRun__scheduleImmediateJsOverride$closure", "_AsyncRun__scheduleImmediateJsOverride", 14);
    _static_1(P, "async__AsyncRun__scheduleImmediateWithSetImmediate$closure", "_AsyncRun__scheduleImmediateWithSetImmediate", 14);
    _static_1(P, "async__AsyncRun__scheduleImmediateWithTimer$closure", "_AsyncRun__scheduleImmediateWithTimer", 14);
    _static_0(P, "async___startMicrotaskLoop$closure", "_startMicrotaskLoop", 1);
    _instance(P._Completer.prototype, "get$completeError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["completeError$2", "completeError$1"], 31, 0);
    _instance(P._SyncCompleter.prototype, "get$complete", 1, 0, null, ["call$1", "call$0"], ["complete$1", "complete$0"], 48, 0);
    _instance(P._Future.prototype, "get$_completeError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["_completeError$2", "_completeError$1"], 31, 0);
    var _;
    _instance_1_i(_ = P._StreamController.prototype, "get$_add", "_add$1", 38);
    _instance_2_u(_, "get$_addError", "_addError$2", 73);
    _instance_0_u(_, "get$_close", "_close$0", 1);
    _instance_0_u(_ = P._ControllerSubscription.prototype, "get$_onPause", "_onPause$0", 1);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 1);
    _instance_0_u(_ = P._BufferingStreamSubscription.prototype, "get$_onPause", "_onPause$0", 1);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 1);
    _static_2(P, "collection_ListMixin__compareAny$closure", "ListMixin__compareAny", 45);
    _static_1(P, "convert___defaultToEncodable$closure", "_defaultToEncodable", 15);
    _static(W, "html__Html5NodeValidator__standardAttributeValidator$closure", 4, null, ["call$4"], ["_Html5NodeValidator__standardAttributeValidator"], 25, 0);
    _static(W, "html__Html5NodeValidator__uriAttributeValidator$closure", 4, null, ["call$4"], ["_Html5NodeValidator__uriAttributeValidator"], 25, 0);
    _static(U, "assertions_FlutterError_dumpErrorToConsole$closure", 1, null, ["call$2$forceReport", "call$1"], ["FlutterError_dumpErrorToConsole", function(details) {
      return U.FlutterError_dumpErrorToConsole(details, false);
    }], 130, 0);
    _static_1(U, "assertions_FlutterError_defaultStackFilter$closure", "FlutterError_defaultStackFilter", 131);
    _static_1(U, "assertions_DiagnosticsStackTrace__createStackFrame$closure", "DiagnosticsStackTrace__createStackFrame", 132);
    _instance_1_i(Y.DiagnosticPropertiesBuilder.prototype, "get$add", "add$1", 34);
    _instance_1_u(B.AbstractNode.prototype, "get$redepthChild", "redepthChild$1", 50);
    _instance_1_u(N.GestureBinding.prototype, "get$_handlePointerDataPacket", "_handlePointerDataPacket$1", 51);
    _instance_1_u(Y.MouseTracker.prototype, "get$_handleEvent", "_handleEvent$1", 55);
    _instance_0_u(_ = N.RendererBinding.prototype, "get$_handleSemanticsEnabledChanged", "_handleSemanticsEnabledChanged$0", 1);
    _instance(_, "get$_handleSemanticsAction", 0, 3, null, ["call$3"], ["_handleSemanticsAction$3"], 64, 0);
    _instance_0_u(_, "get$_handleSemanticsOwnerCreated", "_handleSemanticsOwnerCreated$0", 1);
    _instance_0_u(_, "get$_handleSemanticsOwnerDisposed", "_handleSemanticsOwnerDisposed$0", 1);
    _instance_1_u(_, "get$_handlePersistentFrameCallback", "_handlePersistentFrameCallback$1", 37);
    _instance(K.RenderObject.prototype, "get$showOnScreen", 0, 0, null, ["call$4$curve$descendant$duration$rect", "call$0"], ["showOnScreen$4$curve$descendant$duration$rect", "showOnScreen$0"], 68, 0);
    _static_2(N, "binding_SchedulerBinding__taskSorter$closure", "SchedulerBinding__taskSorter", 133);
    _static(N, "binding__defaultSchedulingStrategy$closure", 0, null, ["call$2$priority$scheduler", "call$0"], ["defaultSchedulingStrategy", function() {
      return N.defaultSchedulingStrategy(null, null);
    }], 134, 0);
    _instance_1_u(_ = N.SchedulerBinding.prototype, "get$_handleLifecycleMessage", "_handleLifecycleMessage$1", 72);
    _instance_0_u(_, "get$_runTasks", "_runTasks$0", 1);
    _instance_0_u(_, "get$ensureVisualUpdate", "ensureVisualUpdate$0", 1);
    _instance_1_u(_, "get$_handleBeginFrame", "_handleBeginFrame$1", 37);
    _instance_0_u(_, "get$_handleDrawFrame", "_handleDrawFrame$0", 1);
    _static_1(N, "binding0_ServicesBinding__parseLicenses$closure", "ServicesBinding__parseLicenses", 135);
    _instance_0_u(N.ServicesBinding.prototype, "get$_addLicenses", "_addLicenses$0", 86);
    _static(B, "platform_messages_BinaryMessages_handlePlatformMessage$closure", 3, null, ["call$3"], ["BinaryMessages_handlePlatformMessage"], 136, 0);
    _instance_1_u(B.RawKeyboard.prototype, "get$_handleKeyEvent", "_handleKeyEvent$1", 89);
    _instance_0_u(_ = N.WidgetsBinding.prototype, "get$handleLocaleChanged", "handleLocaleChanged$0", 1);
    _instance_1_u(_, "get$_handleNavigationInvocation", "_handleNavigationInvocation$1", 94);
    _instance_1_u(_, "get$_handleSystemMessage", "_handleSystemMessage$1", 95);
    _instance_0_u(_, "get$_handleBuildScheduled", "_handleBuildScheduled$0", 1);
    _instance_0_u(_ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding.prototype, "get$handleMetricsChanged", "handleMetricsChanged$0", 1);
    _instance_0_u(_, "get$handleTextScaleFactorChanged", "handleTextScaleFactorChanged$0", 1);
    _instance_0_u(_, "get$handlePlatformBrightnessChanged", "handlePlatformBrightnessChanged$0", 1);
    _instance_0_u(_, "get$handleAccessibilityFeaturesChanged", "handleAccessibilityFeaturesChanged$0", 1);
    _instance_1_u(O.FocusManager.prototype, "get$_handleRawKeyEvent", "_handleRawKeyEvent$1", 97);
    _static_1(N, "framework__InactiveElements__deactivateRecursively$closure", "_InactiveElements__deactivateRecursively", 13);
    _static_2(N, "framework_Element__sort$closure", "Element__sort", 137);
    _static_1(N, "framework_Element__activateRecursively$closure", "Element__activateRecursively", 13);
    _instance_1_u(N._InactiveElements.prototype, "get$_unmount", "_unmount$1", 13);
    _static_1(T, "engine___noopCallback$closure", "_noopCallback", 100);
    _static_1(T, "engine___whitespacePredicate$closure", "_whitespacePredicate", 20);
    _static_1(T, "engine___newlinePredicate$closure", "_newlinePredicate", 20);
    _static_1(T, "engine___emptyCallback$closure", "_emptyCallback", 3);
    _instance_0_u(T.AlarmClock.prototype, "get$_timerDidFire", "_timerDidFire$0", 1);
    _instance_1_u(T.DomRenderer.prototype, "get$_metricsDidChange", "_metricsDidChange$1", 41);
    _instance_1_u(T.BrowserHistory.prototype, "get$_popStateListener", "_popStateListener$1", 38);
    _instance_1_u(T.PointerBinding.prototype, "get$_onPointerData", "_onPointerData$1", 105);
    _instance_0_u(T.RulerManager.prototype, "get$dispose", "dispose$0", 1);
    _instance_1_u(T.TextEditingElement.prototype, "get$_handleChange", "_handleChange$1", 41);
    _instance_1_u(T.HybridTextEditing.prototype, "get$_syncEditingStateToFlutter", "_syncEditingStateToFlutter$1", 123);
    _static(D, "print__debugPrintThrottled$closure", 1, null, ["call$2$wrapWidth", "call$1"], ["debugPrintThrottled", function(message) {
      return D.debugPrintThrottled(message, null);
    }], 92, 0);
    _static_0(D, "print___debugPrintTask$closure", "_debugPrintTask", 1);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(P.Object, null);
    _inheritMany(P.Object, [H.JS_CONST, J.Interceptor, J.JSObject, J.ArrayIterator, P._ListBase_Object_ListMixin, P.Iterable, H.ListIterator, P.Iterator, H.EmptyIterator, H.FixedLengthListMixin, H.UnmodifiableListMixin, H.Symbol, P.MapView, H.ConstantMap, H.Closure, H.JSInvocationMirror, H.TypeErrorDecoder, P.Error, H.ExceptionAndStackTrace, H._StackTrace, H.TypeImpl, P.MapMixin, H.LinkedHashMapCell, H.LinkedHashMapKeyIterator, H.JSSyntaxRegExp, H._MatchImplementation, H.StringMatch, P._TimerImpl, P._AsyncAwaitCompleter, P._AsyncStarStreamController, P._IterationMarker, P._SyncStarIterator, P.Future, P._Completer, P._FutureListener, P._Future, P._AsyncCallbackEntry, P.Stream, P.StreamSubscription, P.StreamTransformerBase, P._StreamController, P._AsyncStreamControllerDispatch, P._BufferingStreamSubscription, P._AddStreamState, P._PendingEvents, P._DelayedEvent, P._DelayedDone, P._StreamIterator, P.Timer, P.AsyncError, P._Zone, P._SetBase, P._HashSetIterator, P._LinkedHashSetCell, P._LinkedHashSetIterator, P.LinkedHashSet, P.ListMixin, P._UnmodifiableMapMixin, P._ListQueueIterator, P.Codec, P._JsonStringifier, P._Utf8Encoder, P._Utf8Decoder, P.bool, P.Comparable, P.DateTime, P.num, P.Duration, P.OutOfMemoryError, P.StackOverflowError, P._Exception, P.FormatException, P.Function, P.List, P.Map, P.Null, P.StackTrace, P.Stopwatch, P.String, P.StringBuffer, P.Symbol0, P.Type, P._Uri, P.UriData, P._SimpleUri, P.ServiceExtensionResponse, P._SyncBlock, W.CssStyleDeclarationBase, W._Html5NodeValidator, W.ImmutableListMixin, W.NodeValidatorBuilder, W._SimpleNodeValidator, W._SvgNodeValidator, W.FixedSizeListIterator, W._DOMWindowCrossFrame, W.NodeValidator, W._SameOriginUriPolicy, W._ValidatingTreeSanitizer, P._StructuredClone, P._AcceptStructuredClone, P.Point, P._RectangleBase, P.ByteBuffer, P.Endian, P.ByteData, P.Int8List, P.Uint8List, P.Uint8ClampedList, P.Int16List, P.Uint16List, P.Int32List, P.Uint32List, P.Float32List, P.Float64List, Y.HeapPriorityQueue, Z.Curve, Y.DiagnosticsNode, Y._Diagnosticable_Object_DiagnosticableMixin, N.BindingBase, B.ChangeNotifier, Y.DiagnosticLevel, Y.DiagnosticsTreeStyle, Y.TextTreeConfiguration, Y._WordWrapParseMode, Y._PrefixedStringBuilder, Y._NoDefaultValue, Y.TextTreeRenderer, Y.DiagnosticPropertiesBuilder, Y.DiagnosticableMixin, Y.DiagnosticableTreeMixin, D.Key, F.LicenseEntry, B.AbstractNode, T.TargetPlatform, D.GestureArenaMember, D._GestureArena, D.GestureArenaManager, N.GestureBinding, G._PointerState, O.HitTestTarget, O.HitTestEntry, O.HitTestResult, Y.MouseTrackerAnnotation, Y._TrackedAnnotation, O.PointerRouter, G.PointerSignalResolver, G.RenderComparison, N.PaintingBinding, Z.ClipContext, E.ImageCache, E._CachedImage, U.TextWidthBasis, U.TextPainter, N.RendererBinding, K.Constraints, K.ParentData, S._IntrinsicDimensionsCacheEntry, K.SemanticsHandle, K.PipelineOwner, K.RenderObjectWithChildMixin, K._SemanticsFragment, K._SemanticsGeometry, Q.TextOverflow, A.ViewConfiguration, N._TaskEntry, N._FrameCallbackEntry, N.SchedulerPhase, N.SchedulerBinding, N.SemanticsBinding, A.SemanticsTag, A.CustomSemanticsAction, A._BoxEdge, A._TraversalSortNode, A.SemanticsConfiguration, A.DebugSemanticsDumpOrder, Q.AssetBundle, N.ServicesBinding, F.MethodCall0, F.PlatformException, F.MissingPluginException, U.StringCodec, U.JSONMessageCodec, U.JSONMethodCodec, A.BasicMessageChannel, A.MethodChannel, B.KeyboardSide, B.ModifierKey, B.RawKeyEventData, B.RawKeyEvent, B.RawKeyboard, X.TextRange, N.WidgetsBindingObserver, N.WidgetsBinding, O._FocusNode_Object_DiagnosticableTreeMixin, O._FocusManager_Object_DiagnosticableTreeMixin, N._ElementLifecycle, N._InactiveElements, N.BuildContext, N.BuildOwner, T.AlarmClock, T.AssetManager, T.AssetManagerException, T.EngineCanvas, T.BrowserEngine, T.LocationStrategy, T.PlatformLocation, T.DomRenderer, T._SaveStackEntry, T._SaveClipEntry, T.SaveStackTracking, T.BrowserHistory, T._SaveElementStackEntry, T.SaveElementStackTracking, T.Keyboard, T.PlatformViewRegistry, T.PointerBinding, T.PointerSupportDetector, T.BaseAdapter, T.RecordingCanvas, T.PaintCommand, T._PaintBounds, T.AccessibilityAnnouncements, T._CheckableKind, T.RoleManager, T.SemanticsUpdate, T.SemanticsNodeUpdate, T.Role, T.SemanticsObject, T.AccessibilityMode, T.GestureMode, T.EngineSemanticsOwner, T.MethodCall, T.StringCodec0, T.JSONMessageCodec0, T.JSONMethodCodec0, T.StandardMessageCodec, T.StandardMethodCodec, T.ReadBuffer, T.PersistedSurface, T._PaintRequest, T.FrameReference, T.PersistedSurfaceState, T._PersistedSurfaceMatch, T.FontCollection, T._FontManager, T.LineBreakType, T.LineBreakResult, T.RulerManager, T.TextMeasurementService, T.LinesCalculator, T.MaxIntrinsicCalculator, T.ParagraphGeometricStyle, T.TextDimensions, T.ParagraphRuler, T.MeasurementResult, T.EditingState, T.InputType, T.InputConfiguration, T.ElementType, T.TextEditingElement, T.HybridTextEditing, T.Matrix40, T.Vector30, Q.Window, Q.ClipOp, Q.PictureRecorder, Q.Canvas, Q.Picture, Q.Scene, Q.SceneBuilder, Q.OffsetBase, Q.Rect, Q._HashEnd, Q.Color, Q.PaintingStyle, Q.BlendMode, Q.PaintData, Q.Paint, Q.Shader, Q.Shadow, Q.PointerChange, Q.PointerDeviceKind, Q.PointerSignalKind, Q.PointerData, Q.PointerDataPacket, Q.SemanticsAction, Q.SemanticsFlag, Q.SemanticsUpdateBuilder, Q.FontStyle, Q.FontWeight, Q.TextAlign, Q.TextBaseline, Q.TextStyle, Q.ParagraphStyle, Q.TextDirection, Q.TextBox, Q.TextAffinity, Q.TextPosition, Q.ParagraphConstraints, Q.Paragraph, Q.ParagraphBuilder, Q.TileMode, Q.AppLifecycleState, Q.Locale, Q.AccessibilityFeatures, E.Matrix4, E.Vector3, E.Vector4]);
    _inheritMany(J.Interceptor, [J.JSBool, J.JSNull, J.JavaScriptObject, J.JSArray, J.JSNumber, J.JSString, H.NativeByteBuffer, H.NativeTypedData, W.EventTarget, W.AccessibleNodeList, W.Event, W.Blob, W.CanvasRenderingContext2D, W.CssStyleValue, W.CssTransformComponent, W.CssRule, W._CssStyleDeclaration_Interceptor_CssStyleDeclarationBase, W.StyleSheet, W.DataTransferItemList, W.ReportBody, W.DomError, W.DomException, W._DomRectList_Interceptor_ListMixin, W.DomRectReadOnly, W._DomStringList_Interceptor_ListMixin, W.DomTokenList, W._FileList_Interceptor_ListMixin, W.FontFace, W.Gamepad, W.History, W._HtmlCollection_Interceptor_ListMixin, W.ImageData, W.Location, W.MediaError, W.MediaList, W._MidiInputMap_Interceptor_MapMixin, W._MidiOutputMap_Interceptor_MapMixin, W.MimeType, W._MimeTypeArray_Interceptor_ListMixin, W.NavigatorUserMediaError, W._NodeList_Interceptor_ListMixin, W.OverconstrainedError, W.Plugin, W._PluginArray_Interceptor_ListMixin, W.PositionError, W._RtcStatsReport_Interceptor_MapMixin, W.SpeechGrammar, W._SpeechGrammarList_Interceptor_ListMixin, W.SpeechRecognitionResult, W._Storage_Interceptor_MapMixin, W._TextTrackCueList_Interceptor_ListMixin, W.TimeRanges, W.Touch, W._TouchList_Interceptor_ListMixin, W.TrackDefaultList, W.Url, W.__CssRuleList_Interceptor_ListMixin, W.__GamepadList_Interceptor_ListMixin, W.__NamedNodeMap_Interceptor_ListMixin, W.__SpeechRecognitionResultList_Interceptor_ListMixin, W.__StyleSheetList_Interceptor_ListMixin, P.Length, P._LengthList_Interceptor_ListMixin, P.Number, P._NumberList_Interceptor_ListMixin, P.PointList, P._StringList_Interceptor_ListMixin, P.Transform, P._TransformList_Interceptor_ListMixin, P.AudioBuffer, P._AudioParamMap_Interceptor_MapMixin, P.SqlError, P._SqlResultSetRowList_Interceptor_ListMixin]);
    _inheritMany(J.JavaScriptObject, [J.PlainJavaScriptObject, J.UnknownJavaScriptObject, J.JavaScriptFunction]);
    _inherit(J.JSUnmodifiableArray, J.JSArray);
    _inheritMany(J.JSNumber, [J.JSInt, J.JSDouble]);
    _inherit(P.ListBase, P._ListBase_Object_ListMixin);
    _inheritMany(P.ListBase, [H.UnmodifiableListBase, W._ChildrenElementList, W._FrozenElementList, W._ChildNodeListLazy, P.FilteredElementList]);
    _inherit(H.CodeUnits, H.UnmodifiableListBase);
    _inheritMany(P.Iterable, [H.EfficientLengthIterable, H.MappedIterable, H.WhereIterable, H.TakeIterable, H._ConstantMapKeyIterable, P.IterableBase, R.ObserverList]);
    _inheritMany(H.EfficientLengthIterable, [H.ListIterable, H.LinkedHashMapKeyIterable, P.Set]);
    _inheritMany(H.ListIterable, [H.SubListIterable, H.MappedListIterable, H.ReversedListIterable, P.ListQueue, P._JsonMapKeyIterable]);
    _inherit(H.EfficientLengthMappedIterable, H.MappedIterable);
    _inheritMany(P.Iterator, [H.MappedIterator, H.WhereIterator, H.TakeIterator]);
    _inherit(H.EfficientLengthTakeIterable, H.TakeIterable);
    _inherit(P._UnmodifiableMapView_MapView__UnmodifiableMapMixin, P.MapView);
    _inherit(P.UnmodifiableMapView, P._UnmodifiableMapView_MapView__UnmodifiableMapMixin);
    _inherit(H.ConstantMapView, P.UnmodifiableMapView);
    _inheritMany(H.ConstantMap, [H.ConstantStringMap, H.GeneralConstantMap]);
    _inheritMany(H.Closure, [H.ConstantStringMap_values_closure, H.Primitives_initTicker_closure, H.Primitives_functionNoSuchMethod_closure, H.unwrapException_saveStackTrace, H.TearOffClosure, H.JsLinkedHashMap_values_closure, H.JsLinkedHashMap_addAll_closure, H.initHooks_closure, H.initHooks_closure0, H.initHooks_closure1, P._AsyncRun__initializeScheduleImmediate_internalCallback, P._AsyncRun__initializeScheduleImmediate_closure, P._AsyncRun__scheduleImmediateJsOverride_internalCallback, P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback, P._TimerImpl_internalCallback, P._TimerImpl$periodic_closure, P._AsyncAwaitCompleter_complete_closure, P._AsyncAwaitCompleter_completeError_closure, P._awaitOnObject_closure, P._awaitOnObject_closure0, P._wrapJsFunctionForAsync_closure, P._asyncStarHelper_closure, P._asyncStarHelper_closure0, P._AsyncStarStreamController__resumeBody, P._AsyncStarStreamController__resumeBody_closure, P._AsyncStarStreamController_closure, P._AsyncStarStreamController_closure0, P._AsyncStarStreamController_closure1, P._AsyncStarStreamController__closure, P.Future_Future$delayed_closure, P.Future_wait_handleError, P.Future_wait_closure, P._Future__addListener_closure, P._Future__prependListeners_closure, P._Future__chainForeignFuture_closure, P._Future__chainForeignFuture_closure0, P._Future__chainForeignFuture_closure1, P._Future__asyncComplete_closure, P._Future__chainFuture_closure, P._Future__asyncCompleteError_closure, P._Future__propagateToListeners_handleWhenCompleteCallback, P._Future__propagateToListeners_handleWhenCompleteCallback_closure, P._Future__propagateToListeners_handleValueCallback, P._Future__propagateToListeners_handleError, P.Stream_Stream$fromIterable_closure, P.Stream_length_closure, P.Stream_length_closure0, P.Stream_isEmpty_closure, P.Stream_isEmpty_closure0, P._StreamController__subscribe_closure, P._StreamController__recordCancel_complete, P._AddStreamState_cancel_closure, P._BufferingStreamSubscription__sendError_sendError, P._BufferingStreamSubscription__sendDone_sendDone, P._PendingEvents_schedule_closure, P._cancelAndValue_closure, P._rootHandleUncaughtError_closure, P._RootZone_bindCallback_closure, P._RootZone_bindCallbackGuarded_closure, P._RootZone_bindUnaryCallbackGuarded_closure, P.LinkedHashMap_LinkedHashMap$from_closure, P.MapBase_mapToString_closure, P._JsonStringifier_writeMap_closure, P.NoSuchMethodError_toString_closure, P.Duration_toString_sixDigits, P.Duration_toString_twoDigits, P.Uri__parseIPv4Address_error, P.Uri_parseIPv6Address_error, P.Uri_parseIPv6Address_parseHex, P._Uri__Uri$notSimple_closure, P._Uri__makePath_closure, P._createTables_closure, P._createTables_build, P._createTables_setChars, P._createTables_setRange, W.promiseToFuture_closure, W.promiseToFuture_closure0, W.Element_Element$html_closure, W.HttpRequest_request_closure, W.MidiInputMap_keys_closure, W.MidiOutputMap_keys_closure, W.RtcStatsReport_keys_closure, W.Storage_keys_closure, W.Window_animationFrame_closure, W._EventStreamSubscription_closure, W.NodeValidatorBuilder_allowsElement_closure, W.NodeValidatorBuilder_allowsAttribute_closure, W._SimpleNodeValidator_closure, W._SimpleNodeValidator_closure0, W._TemplatingNodeValidator_closure, W._ValidatingTreeSanitizer_sanitizeTree_walk, P._StructuredClone_walk_closure, P._AcceptStructuredClone_walk_closure, P.convertDartToNative_Dictionary_closure, P.convertNativePromiseToDartFuture_closure, P.convertNativePromiseToDartFuture_closure0, P.FilteredElementList__iterable_closure, P.FilteredElementList__iterable_closure0, P.AudioParamMap_keys_closure, U.FlutterErrorDetails_summary_closure, U.FlutterErrorDetails_summary_closure0, U.FlutterError_FlutterError_closure, U.FlutterError_toString_closure, N.BindingBase_lockEvents_closure, N.BindingBase_registerSignalServiceExtension_closure, N.BindingBase_registerNumericServiceExtension_closure, N.BindingBase_registerServiceExtension_closure, N.BindingBase_registerServiceExtension__closure, B.ChangeNotifier_notifyListeners_closure, Y._PrefixedStringBuilder__wordWrapLine_noWrap, Y.TextTreeRenderer_render_visitor, Y.TextTreeRenderer_render_closure, N.GestureBinding_dispatchEvent_closure, N.GestureBinding_dispatchEvent_closure0, G.PointerEventConverter__ensureStateForPointer_closure, Y.MouseTracker__scheduleMousePositionCheck_closure, Y.MouseTracker_collectMousePositions_exitAnnotation, Y.MouseTracker_collectMousePositions_exitAllDevices, Y.MouseTracker_collectMousePositions_closure, O.PointerRouter__dispatch_closure, T.TransformProperty_valueToString_closure, T.TransformProperty_valueToString__closure, Q.TextSpan_getSpanForPosition_closure, Q.TextSpan_toPlainText_closure, Q.TextSpan_debugDescribeChildren_closure, A.TextStyle_debugFillProperties_closure, N.RendererBinding__createMouseTracker_closure, K.PipelineOwner_flushLayout_closure, K.PipelineOwner_flushCompositingBits_closure, K.PipelineOwner_flushPaint_closure, K.PipelineOwner_flushSemantics_closure, K.RenderObject__debugReportException_closure, K.RenderObject__cleanRelayoutBoundary_closure, K.RenderObject__updateCompositingBits_closure, K.RenderObject_clearSemantics_closure, K.RenderObject__getSemanticsForParent_closure, Q.RenderParagraph_describeSemanticsConfiguration_closure, Q.RenderParagraph_assembleSemanticsNode_buildSemanticsConfig, N.SchedulerBinding_endOfFrame_closure, N.SchedulerBinding_scheduleWarmUpFrame_closure, N.SchedulerBinding_scheduleWarmUpFrame_closure0, N.SchedulerBinding_scheduleWarmUpFrame_closure1, N.SchedulerBinding_handleBeginFrame_closure, A.SemanticsData_debugFillProperties_closure, A.SemanticsNode__childrenInTraversalOrder_closure, A.SemanticsNode_debugFillProperties_closure, A.SemanticsNode_debugFillProperties_closure0, A.SemanticsNode_debugFillProperties_closure1, A.SemanticsNode_debugFillProperties_closure2, A.SemanticsNode_debugFillProperties_closure3, A.SemanticsNode_debugDescribeChildren_closure, A._SemanticsSortGroup_sortedWithinKnot_closure, A._SemanticsSortGroup_sortedWithinKnot_search, A._SemanticsSortGroup_sortedWithinKnot_closure0, A._SemanticsSortGroup_sortedWithinKnot_closure1, A.SemanticsOwner_sendSemanticsUpdate_closure, A.SemanticsOwner_sendSemanticsUpdate_closure0, A.SemanticsOwner_sendSemanticsUpdate_closure1, A.SemanticsOwner__getSemanticsActionHandlerForId_closure, N.ServicesBinding__addLicenses_closure, N.ServicesBinding__addLicenses_closure0, A.BasicMessageChannel_setMessageHandler_closure, A.MethodChannel_setMethodCallHandler_closure, B.BinaryMessages__sendPlatformMessage_closure, Q.RawKeyEventDataAndroid_getModifierSide_findSide, Q.RawKeyEventDataFuchsia_getModifierSide_findSide, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure0, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure1, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure0, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure0, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure, N.RenderObjectToWidgetAdapter_attachToRenderTree_closure, N.RenderObjectToWidgetAdapter_attachToRenderTree_closure0, O.FocusNode_debugDescribeChildren_closure, N._InactiveElements__unmount_closure, N.BuildOwner_buildScope_closure, N.BuildOwner_finalizeTree_closure, N.Element_updateSlotForChild_visit, N.Element__updateDepth_closure, N.Element_detachRenderObject_closure, N.Element_attachRenderObject_closure, N.Element_debugFillProperties_closure, N.Element_debugDescribeChildren_closure, N.ErrorWidget_closure, T.webOnlyInitializeEngine_closure, T.webOnlyInitializeEngine_closure0, T.webOnlyInitializeEngine__closure, T.HashLocationStrategy_onPopState_closure, T.HashLocationStrategy__waitForPopState_closure, T.DomRenderer_reset_closure, T.BrowserHistory__popStateListener_closure, T.BrowserHistory__popStateListener_closure0, T.Keyboard$__closure, T.Keyboard$__closure0, T.Keyboard$__closure1, T.BaseAdapter__addEventListener_closure, T.PointerAdapter__setup_closure, T.PointerAdapter__setup_closure0, T.PointerAdapter__setup_closure1, T.PointerAdapter__setup_closure2, T.PointerAdapter__setup_closure3, T.TouchAdapter__setup_closure, T.TouchAdapter__setup_closure0, T.TouchAdapter__setup_closure1, T.TouchAdapter__setup_closure2, T.MouseAdapter__setup_closure, T.MouseAdapter__setup_closure0, T.MouseAdapter__setup_closure1, T.MouseAdapter__setup_closure2, T._addWheelEventListener_closure, T.AccessibilityAnnouncements$__closure, T.AccessibilityAnnouncements_handleMessage_closure, T.Incrementable_closure, T.Incrementable_closure0, T.Scrollable_update_closure, T.Scrollable_update_closure0, T.Scrollable_update_closure1, T.closure, T.closure0, T.closure1, T.closure2, T.closure3, T.closure4, T.closure5, T.closure6, T.EngineSemanticsOwner$__closure, T.EngineSemanticsOwner_closure, T.EngineSemanticsOwner__tryEnableSemantics_closure, T.EngineSemanticsOwner_autoEnableOnTap_closure, T.EngineSemanticsOwner__getGestureModeClock_closure, T.Tappable_update_closure, T.TextField__initializeForBlink_closure, T.TextField__initializeForWebkit_closure, T.TextField__initializeForWebkit_closure0, T.PersistedStandardPicture__applyBitmapPaint_closure, T.commitScene_closure, T.PersistedContainerSurface__updateManyToMany_insertDomNodeIfMoved, T.PersistedContainerSurface__matchChildren_closure, T._FontManager_registerAsset_closure, T._FontManager_registerAsset_closure0, T._PolyfillFontManager_registerAsset__watchWidth, T._PolyfillFontManager_registerAsset_closure, T.RulerManager__scheduleRulerCacheCleanup_closure, T.RulerManager_cleanUpRulerCache_closure, T._styleEditingElement_closure, T.TextEditingElement_enable_closure, T.EngineWindow_sendPlatformMessage_closure, T.EngineWindow_sendPlatformMessage_closure0, T.EngineWindow_sendPlatformMessage_closure1, T.EngineWindow__replyToPlatformMessage_closure, Q.ParagraphBuilder__buildRichText_currentElement, A.hashObjects_closure]);
    _inheritMany(P.Error, [H.NullError, H.JsNoSuchMethodError, H.UnknownJsTypeError, H.TypeErrorImplementation, H.CastErrorImplementation, H.RuntimeError, P.AssertionError, P.JsonUnsupportedObjectError, P.NullThrownError, P.ArgumentError, P.NoSuchMethodError, P.UnsupportedError, P.UnimplementedError, P.StateError, P.ConcurrentModificationError, P.CyclicInitializationError, U._FlutterError_Error_DiagnosticableTreeMixin]);
    _inheritMany(H.TearOffClosure, [H.StaticClosure, H.BoundClosure]);
    _inherit(H._AssertionError, P.AssertionError);
    _inherit(P.MapBase, P.MapMixin);
    _inheritMany(P.MapBase, [H.JsLinkedHashMap, P._JsonMap, W._AttributeMap]);
    _inheritMany(H.NativeTypedData, [H.NativeByteData, H.NativeTypedArray]);
    _inheritMany(H.NativeTypedArray, [H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin]);
    _inherit(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin);
    _inherit(H.NativeTypedArrayOfDouble, H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inherit(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin);
    _inherit(H.NativeTypedArrayOfInt, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inheritMany(H.NativeTypedArrayOfDouble, [H.NativeFloat32List, H.NativeFloat64List]);
    _inheritMany(H.NativeTypedArrayOfInt, [H.NativeInt16List, H.NativeInt32List, H.NativeInt8List, H.NativeUint16List, H.NativeUint32List, H.NativeUint8ClampedList, H.NativeUint8List]);
    _inherit(P._SyncStarIterable, P.IterableBase);
    _inheritMany(P._Completer, [P._AsyncCompleter, P._SyncCompleter]);
    _inherit(P._AsyncStreamController, P._StreamController);
    _inheritMany(P.Stream, [P._StreamImpl, W._EventStream]);
    _inheritMany(P._StreamImpl, [P._ControllerStream, P._GeneratedStreamImpl]);
    _inherit(P._ControllerSubscription, P._BufferingStreamSubscription);
    _inherit(P._StreamControllerAddStreamState, P._AddStreamState);
    _inheritMany(P._PendingEvents, [P._IterablePendingEvents, P._StreamImplEvents]);
    _inheritMany(P._DelayedEvent, [P._DelayedData, P._DelayedError]);
    _inherit(P._RootZone, P._Zone);
    _inheritMany(P._SetBase, [P._HashSet, P._LinkedHashSet]);
    _inheritMany(P.Codec, [P.Base64Codec, P.Encoding, P.JsonCodec]);
    _inherit(P.Converter, P.StreamTransformerBase);
    _inheritMany(P.Converter, [P.Base64Encoder, P.JsonEncoder, P.JsonDecoder, P.Utf8Encoder, P.Utf8Decoder]);
    _inherit(P.JsonCyclicError, P.JsonUnsupportedObjectError);
    _inherit(P._JsonStringStringifier, P._JsonStringifier);
    _inherit(P.Utf8Codec, P.Encoding);
    _inheritMany(P.num, [P.double, P.int]);
    _inheritMany(P.ArgumentError, [P.RangeError, P.IndexError]);
    _inherit(P._DataUri, P._Uri);
    _inheritMany(W.EventTarget, [W.Node, W.FileWriter, W.FontFaceSet, W.HttpRequestEventTarget, W.MessagePort, W.SourceBuffer, W._SourceBufferList_EventTarget_ListMixin, W.TextTrack, W.TextTrackCue, W._TextTrackList_EventTarget_ListMixin, W.VideoTrackList, W.Window0, P.AudioTrackList, P.BaseAudioContext]);
    _inheritMany(W.Node, [W.Element0, W.CharacterData, W.Document, W._Attr]);
    _inheritMany(W.Element0, [W.HtmlElement, P.SvgElement]);
    _inheritMany(W.HtmlElement, [W.AnchorElement, W.AreaElement, W.BaseElement, W.BodyElement, W.CanvasElement, W.DivElement, W.FormElement, W.InputElement, W.LabelElement, W.MetaElement, W.ParagraphElement, W.ScriptElement, W.SelectElement, W.SpanElement, W.StyleElement, W.TableElement, W.TableRowElement, W.TableSectionElement, W.TemplateElement, W.TextAreaElement]);
    _inheritMany(W.Event, [W.ApplicationCacheErrorEvent, W.ErrorEvent, W.UIEvent, W.MediaKeyMessageEvent, W.PopStateEvent, W.PresentationConnectionCloseEvent, W.ProgressEvent, W.SpeechRecognitionError]);
    _inheritMany(W.CssStyleValue, [W.CssNumericValue, W.CssTransformValue, W.CssUnparsedValue]);
    _inherit(W.CssPerspective, W.CssTransformComponent);
    _inherit(W.CssStyleDeclaration, W._CssStyleDeclaration_Interceptor_CssStyleDeclarationBase);
    _inherit(W.CssStyleSheet, W.StyleSheet);
    _inheritMany(W.ReportBody, [W.DeprecationReport, W.InterventionReport]);
    _inherit(W._DomRectList_Interceptor_ListMixin_ImmutableListMixin, W._DomRectList_Interceptor_ListMixin);
    _inherit(W.DomRectList, W._DomRectList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._DomStringList_Interceptor_ListMixin_ImmutableListMixin, W._DomStringList_Interceptor_ListMixin);
    _inherit(W.DomStringList, W._DomStringList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.File, W.Blob);
    _inherit(W._FileList_Interceptor_ListMixin_ImmutableListMixin, W._FileList_Interceptor_ListMixin);
    _inherit(W.FileList, W._FileList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._HtmlCollection_Interceptor_ListMixin_ImmutableListMixin, W._HtmlCollection_Interceptor_ListMixin);
    _inherit(W.HtmlCollection, W._HtmlCollection_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.HttpRequest, W.HttpRequestEventTarget);
    _inheritMany(W.UIEvent, [W.KeyboardEvent, W.MouseEvent, W.TouchEvent]);
    _inherit(W.MidiInputMap, W._MidiInputMap_Interceptor_MapMixin);
    _inherit(W.MidiOutputMap, W._MidiOutputMap_Interceptor_MapMixin);
    _inherit(W._MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin, W._MimeTypeArray_Interceptor_ListMixin);
    _inherit(W.MimeTypeArray, W._MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._NodeList_Interceptor_ListMixin_ImmutableListMixin, W._NodeList_Interceptor_ListMixin);
    _inherit(W.NodeList, W._NodeList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._PluginArray_Interceptor_ListMixin_ImmutableListMixin, W._PluginArray_Interceptor_ListMixin);
    _inherit(W.PluginArray, W._PluginArray_Interceptor_ListMixin_ImmutableListMixin);
    _inheritMany(W.MouseEvent, [W.PointerEvent0, W.WheelEvent]);
    _inherit(W.RtcStatsReport, W._RtcStatsReport_Interceptor_MapMixin);
    _inherit(W._SourceBufferList_EventTarget_ListMixin_ImmutableListMixin, W._SourceBufferList_EventTarget_ListMixin);
    _inherit(W.SourceBufferList, W._SourceBufferList_EventTarget_ListMixin_ImmutableListMixin);
    _inherit(W._SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin, W._SpeechGrammarList_Interceptor_ListMixin);
    _inherit(W.SpeechGrammarList, W._SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.Storage, W._Storage_Interceptor_MapMixin);
    _inherit(W._TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin, W._TextTrackCueList_Interceptor_ListMixin);
    _inherit(W.TextTrackCueList, W._TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._TextTrackList_EventTarget_ListMixin_ImmutableListMixin, W._TextTrackList_EventTarget_ListMixin);
    _inherit(W.TextTrackList, W._TextTrackList_EventTarget_ListMixin_ImmutableListMixin);
    _inherit(W._TouchList_Interceptor_ListMixin_ImmutableListMixin, W._TouchList_Interceptor_ListMixin);
    _inherit(W.TouchList, W._TouchList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.__CssRuleList_Interceptor_ListMixin_ImmutableListMixin, W.__CssRuleList_Interceptor_ListMixin);
    _inherit(W._CssRuleList, W.__CssRuleList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._DomRect, W.DomRectReadOnly);
    _inherit(W.__GamepadList_Interceptor_ListMixin_ImmutableListMixin, W.__GamepadList_Interceptor_ListMixin);
    _inherit(W._GamepadList, W.__GamepadList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.__NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin, W.__NamedNodeMap_Interceptor_ListMixin);
    _inherit(W._NamedNodeMap, W.__NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.__SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin, W.__SpeechRecognitionResultList_Interceptor_ListMixin);
    _inherit(W._SpeechRecognitionResultList, W.__SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.__StyleSheetList_Interceptor_ListMixin_ImmutableListMixin, W.__StyleSheetList_Interceptor_ListMixin);
    _inherit(W._StyleSheetList, W.__StyleSheetList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._ElementAttributeMap, W._AttributeMap);
    _inherit(W._ElementEventStreamImpl, W._EventStream);
    _inherit(W._EventStreamSubscription, P.StreamSubscription);
    _inherit(W._TemplatingNodeValidator, W._SimpleNodeValidator);
    _inherit(P._StructuredCloneDart2Js, P._StructuredClone);
    _inherit(P._AcceptStructuredCloneDart2Js, P._AcceptStructuredClone);
    _inherit(P.Rectangle, P._RectangleBase);
    _inherit(P._LengthList_Interceptor_ListMixin_ImmutableListMixin, P._LengthList_Interceptor_ListMixin);
    _inherit(P.LengthList, P._LengthList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(P._NumberList_Interceptor_ListMixin_ImmutableListMixin, P._NumberList_Interceptor_ListMixin);
    _inherit(P.NumberList, P._NumberList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(P.ScriptElement0, P.SvgElement);
    _inherit(P._StringList_Interceptor_ListMixin_ImmutableListMixin, P._StringList_Interceptor_ListMixin);
    _inherit(P.StringList, P._StringList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(P._TransformList_Interceptor_ListMixin_ImmutableListMixin, P._TransformList_Interceptor_ListMixin);
    _inherit(P.TransformList, P._TransformList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(P.AudioParamMap, P._AudioParamMap_Interceptor_MapMixin);
    _inherit(P.OfflineAudioContext, P.BaseAudioContext);
    _inherit(P._SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin, P._SqlResultSetRowList_Interceptor_ListMixin);
    _inherit(P.SqlResultSetRowList, P._SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(Z.Cubic, Z.Curve);
    _inheritMany(Y.DiagnosticsNode, [Y.DiagnosticsProperty, Y.DiagnosticsBlock, Y.DiagnosticableNode]);
    _inheritMany(Y.DiagnosticsProperty, [U._ErrorDiagnostic, Y.StringProperty, Y._NumProperty, Y.FlagProperty, Y.IterableProperty, Y.EnumProperty, Y.ObjectFlagProperty, T.TransformProperty]);
    _inheritMany(U._ErrorDiagnostic, [U.ErrorDescription, U.ErrorSummary, U.ErrorHint]);
    _inherit(Y.Diagnosticable, Y._Diagnosticable_Object_DiagnosticableMixin);
    _inheritMany(Y.Diagnosticable, [U.FlutterErrorDetails, Y.DiagnosticableTree, F.PointerEvent, L.ImageStreamCompleter, A.TextStyle0, A.SemanticsData, A.SemanticsSortKey, G.LogicalKeyboardKey, N.State]);
    _inherit(U.FlutterError, U._FlutterError_Error_DiagnosticableTreeMixin);
    _inherit(U.DiagnosticsStackTrace, Y.DiagnosticsBlock);
    _inheritMany(Y._NumProperty, [Y.DoubleProperty, Y.IntProperty]);
    _inheritMany(Y.DiagnosticableNode, [Y._DiagnosticableTreeNode, A._SemanticsDiagnosticableNode]);
    _inheritMany(D.Key, [D.LocalKey, N.GlobalKey]);
    _inherit(F.LicenseEntryWithLineBreaks, F.LicenseEntry);
    _inheritMany(U.FlutterErrorDetails, [N.FlutterErrorDetailsForPointerEventDispatcher, O.FlutterErrorDetailsForPointerRouter, K.FlutterErrorDetailsForRendering]);
    _inheritMany(F.PointerEvent, [F.PointerAddedEvent, F.PointerRemovedEvent, F.PointerHoverEvent, F.PointerDownEvent, F.PointerMoveEvent, F.PointerUpEvent, F.PointerSignalEvent, F.PointerCancelEvent]);
    _inherit(F.PointerScrollEvent, F.PointerSignalEvent);
    _inheritMany(B.ChangeNotifier, [Y.MouseTracker, A.SemanticsOwner]);
    _inherit(S._GestureRecognizer_GestureArenaMember_DiagnosticableTreeMixin, D.GestureArenaMember);
    _inherit(S.GestureRecognizer, S._GestureRecognizer_GestureArenaMember_DiagnosticableTreeMixin);
    _inheritMany(Y.DiagnosticableTree, [Q.TextSpan, N.Widget, N.Element]);
    _inherit(S.BoxConstraints, K.Constraints);
    _inherit(S.BoxHitTestResult, O.HitTestResult);
    _inherit(S.BoxHitTestEntry, O.HitTestEntry);
    _inherit(S.BoxParentData, K.ParentData);
    _inheritMany(B.AbstractNode, [K._RenderObject_AbstractNode_DiagnosticableTreeMixin, T._Layer_AbstractNode_DiagnosticableTreeMixin, A._SemanticsNode_AbstractNode_DiagnosticableTreeMixin]);
    _inherit(K.RenderObject, K._RenderObject_AbstractNode_DiagnosticableTreeMixin);
    _inheritMany(K.RenderObject, [S.RenderBox, A._RenderView_RenderObject_RenderObjectWithChildMixin]);
    _inheritMany(S.RenderBox, [V.RenderErrorBox, Q.RenderParagraph]);
    _inherit(T.Layer, T._Layer_AbstractNode_DiagnosticableTreeMixin);
    _inheritMany(T.Layer, [T.PictureLayer, T.ContainerLayer]);
    _inherit(T.OffsetLayer, T.ContainerLayer);
    _inherit(T.TransformLayer, T.OffsetLayer);
    _inherit(K.PaintingContext, Z.ClipContext);
    _inheritMany(K._SemanticsFragment, [K._ContainerSemanticsFragment, K._InterestingSemanticsFragment]);
    _inheritMany(K._InterestingSemanticsFragment, [K._RootSemanticsFragment, K._SwitchableSemanticsFragment, K._AbortingSemanticsFragment]);
    _inherit(A.RenderView, A._RenderView_RenderObject_RenderObjectWithChildMixin);
    _inherit(A.SemanticsNode, A._SemanticsNode_AbstractNode_DiagnosticableTreeMixin);
    _inherit(A._SemanticsSortGroup, P.Comparable);
    _inherit(A.OrdinalSortKey, A.SemanticsSortKey);
    _inherit(Q.CachingAssetBundle, Q.AssetBundle);
    _inherit(Q.PlatformAssetBundle, Q.CachingAssetBundle);
    _inherit(A.OptionalMethodChannel, A.MethodChannel);
    _inheritMany(B.RawKeyEvent, [B.RawKeyDownEvent, B.RawKeyUpEvent]);
    _inheritMany(B.RawKeyEventData, [Q.RawKeyEventDataAndroid, Q.RawKeyEventDataFuchsia]);
    _inherit(X.TextSelection, X.TextRange);
    _inheritMany(N.Widget, [N.RenderObjectWidget, N.StatelessWidget, N.StatefulWidget, N.ProxyWidget]);
    _inheritMany(N.RenderObjectWidget, [N.LeafRenderObjectWidget, N.RenderObjectToWidgetAdapter]);
    _inheritMany(N.LeafRenderObjectWidget, [T.RichText, N.ErrorWidget]);
    _inheritMany(N.Element, [N.RenderObjectElement, N.ComponentElement]);
    _inheritMany(N.RenderObjectElement, [N.RootRenderObjectElement, N.LeafRenderObjectElement]);
    _inherit(N.RenderObjectToWidgetElement, N.RootRenderObjectElement);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding, N.BindingBase);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding);
    _inherit(N.WidgetsFlutterBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding);
    _inherit(O._FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier, O._FocusNode_Object_DiagnosticableTreeMixin);
    _inherit(O.FocusNode, O._FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier);
    _inherit(O.FocusScopeNode, O.FocusNode);
    _inherit(O.FocusManager, O._FocusManager_Object_DiagnosticableTreeMixin);
    _inherit(N.UniqueKey, D.LocalKey);
    _inherit(N.GlobalObjectKey, N.GlobalKey);
    _inherit(N.InheritedWidget, N.ProxyWidget);
    _inheritMany(N.ComponentElement, [N.StatelessElement, N.ProxyElement]);
    _inherit(N.InheritedElement, N.ProxyElement);
    _inheritMany(N.InheritedWidget, [L._LocalizationsScope, F.MediaQuery, L.DefaultTextStyle]);
    _inherit(L.Text, N.StatelessWidget);
    _inheritMany(T.EngineCanvas, [T._BitmapCanvas_EngineCanvas_SaveStackTracking, T._DomCanvas_EngineCanvas_SaveElementStackTracking]);
    _inherit(T.BitmapCanvas, T._BitmapCanvas_EngineCanvas_SaveStackTracking);
    _inherit(T.HashLocationStrategy, T.LocationStrategy);
    _inherit(T.BrowserPlatformLocation, T.PlatformLocation);
    _inherit(T.DomCanvas, T._DomCanvas_EngineCanvas_SaveElementStackTracking);
    _inheritMany(T.BaseAdapter, [T.PointerAdapter, T.TouchAdapter, T.MouseAdapter]);
    _inheritMany(T.PaintCommand, [T.PaintSave, T.PaintRestore, T.PaintTranslate, T.PaintClipRect, T.PaintDrawRect, T.PaintDrawParagraph]);
    _inheritMany(T.RoleManager, [T.Checkable, T.ImageRoleManager, T.Incrementable, T.LabelAndValue, T.LiveRegion, T.Scrollable, T.Tappable, T.TextField]);
    _inheritMany(T.PersistedSurface, [T.PersistedContainerSurface, T.PersistedLeafSurface]);
    _inheritMany(T.PersistedContainerSurface, [T.PersistedOffset, T.PersistedScene, T.PersistedTransform]);
    _inherit(T.PersistedPicture, T.PersistedLeafSurface);
    _inherit(T.PersistedStandardPicture, T.PersistedPicture);
    _inherit(T._PolyfillFontManager, T._FontManager);
    _inheritMany(T.TextMeasurementService, [T.DomTextMeasurementService, T.CanvasTextMeasurementService]);
    _inherit(T.PersistentTextEditingElement, T.TextEditingElement);
    _inherit(T.EngineWindow, Q.Window);
    _inheritMany(Q.OffsetBase, [Q.Offset, Q.Size]);
    _inherit(Q.Gradient, Q.Shader);
    _inherit(Q._GradientLinear, Q.Gradient);
    _mixin(H.UnmodifiableListBase, H.UnmodifiableListMixin);
    _mixin(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, P.ListMixin);
    _mixin(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, H.FixedLengthListMixin);
    _mixin(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin, P.ListMixin);
    _mixin(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, H.FixedLengthListMixin);
    _mixin(P._AsyncStreamController, P._AsyncStreamControllerDispatch);
    _mixin(P._ListBase_Object_ListMixin, P.ListMixin);
    _mixin(P._UnmodifiableMapView_MapView__UnmodifiableMapMixin, P._UnmodifiableMapMixin);
    _mixin(W._CssStyleDeclaration_Interceptor_CssStyleDeclarationBase, W.CssStyleDeclarationBase);
    _mixin(W._DomRectList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._DomRectList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._DomStringList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._DomStringList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._FileList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._FileList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._HtmlCollection_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._HtmlCollection_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._MidiInputMap_Interceptor_MapMixin, P.MapMixin);
    _mixin(W._MidiOutputMap_Interceptor_MapMixin, P.MapMixin);
    _mixin(W._MimeTypeArray_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._NodeList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._NodeList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._PluginArray_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._PluginArray_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._RtcStatsReport_Interceptor_MapMixin, P.MapMixin);
    _mixin(W._SourceBufferList_EventTarget_ListMixin, P.ListMixin);
    _mixin(W._SourceBufferList_EventTarget_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._SpeechGrammarList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._Storage_Interceptor_MapMixin, P.MapMixin);
    _mixin(W._TextTrackCueList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._TextTrackList_EventTarget_ListMixin, P.ListMixin);
    _mixin(W._TextTrackList_EventTarget_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._TouchList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._TouchList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W.__CssRuleList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W.__CssRuleList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W.__GamepadList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W.__GamepadList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W.__NamedNodeMap_Interceptor_ListMixin, P.ListMixin);
    _mixin(W.__NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W.__SpeechRecognitionResultList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W.__SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W.__StyleSheetList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W.__StyleSheetList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(P._LengthList_Interceptor_ListMixin, P.ListMixin);
    _mixin(P._LengthList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(P._NumberList_Interceptor_ListMixin, P.ListMixin);
    _mixin(P._NumberList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(P._StringList_Interceptor_ListMixin, P.ListMixin);
    _mixin(P._StringList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(P._TransformList_Interceptor_ListMixin, P.ListMixin);
    _mixin(P._TransformList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(P._AudioParamMap_Interceptor_MapMixin, P.MapMixin);
    _mixin(P._SqlResultSetRowList_Interceptor_ListMixin, P.ListMixin);
    _mixin(P._SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(U._FlutterError_Error_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(Y._Diagnosticable_Object_DiagnosticableMixin, Y.DiagnosticableMixin);
    _mixin(T._Layer_AbstractNode_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(K._RenderObject_AbstractNode_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(A._RenderView_RenderObject_RenderObjectWithChildMixin, K.RenderObjectWithChildMixin);
    _mixin(A._SemanticsNode_AbstractNode_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding, N.GestureBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding, N.ServicesBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding, N.SchedulerBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding, N.PaintingBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding, N.SemanticsBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding, N.RendererBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding, N.WidgetsBinding);
    _mixin(O._FocusManager_Object_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(O._FocusNode_Object_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(O._FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier, B.ChangeNotifier);
    _mixin(T._BitmapCanvas_EngineCanvas_SaveStackTracking, T.SaveStackTracking);
    _mixin(T._DomCanvas_EngineCanvas_SaveElementStackTracking, T.SaveElementStackTracking);
  })();
  (function constants() {
    var makeConstList = hunkHelpers.makeConstList;
    C.BodyElement_methods = W.BodyElement.prototype;
    C.CanvasRenderingContext2D_methods = W.CanvasRenderingContext2D.prototype;
    C.CssStyleDeclaration_methods = W.CssStyleDeclaration.prototype;
    C.DivElement_methods = W.DivElement.prototype;
    C.HttpRequest_methods = W.HttpRequest.prototype;
    C.InputElement_methods = W.InputElement.prototype;
    C.Interceptor_methods = J.Interceptor.prototype;
    C.JSArray_methods = J.JSArray.prototype;
    C.JSBool_methods = J.JSBool.prototype;
    C.JSDouble_methods = J.JSDouble.prototype;
    C.JSInt_methods = J.JSInt.prototype;
    C.JSNull_methods = J.JSNull.prototype;
    C.JSNumber_methods = J.JSNumber.prototype;
    C.JSString_methods = J.JSString.prototype;
    C.JavaScriptFunction_methods = J.JavaScriptFunction.prototype;
    C.LabelElement_methods = W.LabelElement.prototype;
    C.MetaElement_methods = W.MetaElement.prototype;
    C.NativeByteBuffer_methods = H.NativeByteBuffer.prototype;
    C.NativeByteData_methods = H.NativeByteData.prototype;
    C.NativeFloat64List_methods = H.NativeFloat64List.prototype;
    C.NativeInt32List_methods = H.NativeInt32List.prototype;
    C.NodeList_methods = W.NodeList.prototype;
    C.ParagraphElement_methods = W.ParagraphElement.prototype;
    C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
    C.StyleElement_methods = W.StyleElement.prototype;
    C.TableElement_methods = W.TableElement.prototype;
    C.TouchList_methods = W.TouchList.prototype;
    C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
    C.WheelEvent_methods = W.WheelEvent.prototype;
    C.Window_methods = W.Window0.prototype;
    C.AccessibilityMode_0 = new T.AccessibilityMode("AccessibilityMode.unknown");
    C.AppLifecycleState_0 = new Q.AppLifecycleState("AppLifecycleState.resumed");
    C.AppLifecycleState_1 = new Q.AppLifecycleState("AppLifecycleState.inactive");
    C.AppLifecycleState_2 = new Q.AppLifecycleState("AppLifecycleState.paused");
    C.AppLifecycleState_3 = new Q.AppLifecycleState("AppLifecycleState.suspending");
    C.C_JSONMessageCodec = new U.JSONMessageCodec();
    C.BasicMessageChannel_Cfi = new A.BasicMessageChannel("flutter/keyevent", C.C_JSONMessageCodec, [null]);
    C.C_StringCodec = new U.StringCodec();
    C.BasicMessageChannel_No7 = new A.BasicMessageChannel("flutter/lifecycle", C.C_StringCodec, [P.String]);
    C.BasicMessageChannel_Qma = new A.BasicMessageChannel("flutter/system", C.C_JSONMessageCodec, [null]);
    C.BlendMode_1 = new Q.BlendMode("BlendMode.src");
    C.BlendMode_10 = new Q.BlendMode("BlendMode.dstATop");
    C.BlendMode_11 = new Q.BlendMode("BlendMode.xor");
    C.BlendMode_12 = new Q.BlendMode("BlendMode.plus");
    C.BlendMode_13 = new Q.BlendMode("BlendMode.modulate");
    C.BlendMode_14 = new Q.BlendMode("BlendMode.screen");
    C.BlendMode_15 = new Q.BlendMode("BlendMode.overlay");
    C.BlendMode_16 = new Q.BlendMode("BlendMode.darken");
    C.BlendMode_17 = new Q.BlendMode("BlendMode.lighten");
    C.BlendMode_18 = new Q.BlendMode("BlendMode.colorDodge");
    C.BlendMode_19 = new Q.BlendMode("BlendMode.colorBurn");
    C.BlendMode_20 = new Q.BlendMode("BlendMode.hardLight");
    C.BlendMode_21 = new Q.BlendMode("BlendMode.softLight");
    C.BlendMode_22 = new Q.BlendMode("BlendMode.difference");
    C.BlendMode_23 = new Q.BlendMode("BlendMode.exclusion");
    C.BlendMode_24 = new Q.BlendMode("BlendMode.multiply");
    C.BlendMode_25 = new Q.BlendMode("BlendMode.hue");
    C.BlendMode_26 = new Q.BlendMode("BlendMode.saturation");
    C.BlendMode_27 = new Q.BlendMode("BlendMode.color");
    C.BlendMode_28 = new Q.BlendMode("BlendMode.luminosity");
    C.BlendMode_3 = new Q.BlendMode("BlendMode.srcOver");
    C.BlendMode_4 = new Q.BlendMode("BlendMode.dstOver");
    C.BlendMode_5 = new Q.BlendMode("BlendMode.srcIn");
    C.BlendMode_6 = new Q.BlendMode("BlendMode.dstIn");
    C.BlendMode_7 = new Q.BlendMode("BlendMode.srcOut");
    C.BlendMode_8 = new Q.BlendMode("BlendMode.dstOut");
    C.BlendMode_9 = new Q.BlendMode("BlendMode.srcATop");
    C.BrowserEngine_0 = new T.BrowserEngine("BrowserEngine.blink");
    C.BrowserEngine_1 = new T.BrowserEngine("BrowserEngine.webkit");
    C.BrowserEngine_2 = new T.BrowserEngine("BrowserEngine.unknown");
    C.C_AssetManager = new T.AssetManager();
    C.C_Base64Encoder = new P.Base64Encoder();
    C.C_Base64Codec = new P.Base64Codec();
    C.C_BrowserPlatformLocation = new T.BrowserPlatformLocation();
    C.C_EmptyIterator = new H.EmptyIterator([P.Null]);
    C.C_Endian0 = new P.Endian();
    C.C_Endian = new P.Endian();
    C.C_HashLocationStrategy = new T.HashLocationStrategy();
    C.C_JSONMessageCodec0 = new T.JSONMessageCodec0();
    C.C_JSONMethodCodec = new T.JSONMethodCodec0();
    C.C_JS_CONST = function getTagFallback(o) {
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
    C.C_JS_CONST0 = function() {
  var toStringFunction = Object.prototype.toString;
  function getTag(o) {
    var s = toStringFunction.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = toStringFunction.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: getTag,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
    C.C_JS_CONST6 = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
    C.C_JS_CONST1 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
    C.C_JS_CONST2 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
    C.C_JS_CONST5 = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
    C.C_JS_CONST4 = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
    C.C_JS_CONST3 = function(hooks) { return hooks; }
;
    C.C_JsonCodec = new P.JsonCodec();
    C.C_Object = new P.Object();
    C.C_OutOfMemoryError = new P.OutOfMemoryError();
    C.C_PaintRestore = new T.PaintRestore();
    C.C_PaintSave = new T.PaintSave();
    C.C_PointerSupportDetector = new T.PointerSupportDetector();
    C.C_StandardMessageCodec = new T.StandardMessageCodec();
    C.C_StandardMethodCodec = new T.StandardMethodCodec();
    C.C_StringCodec0 = new T.StringCodec0();
    C.C_Utf8Codec = new P.Utf8Codec();
    C.C_Utf8Encoder = new P.Utf8Encoder();
    C.C__DelayedDone = new P._DelayedDone();
    C.C__HashEnd = new Q._HashEnd();
    C.C__NoDefaultValue = new Y._NoDefaultValue();
    C.C__RootZone = new P._RootZone();
    C.ClipOp_1 = new Q.ClipOp("ClipOp.intersect");
    C.Color_16777215 = new Q.Color(16777215);
    C.Color_4035969024 = new Q.Color(4035969024);
    C.Color_4294967142 = new Q.Color(4294967142);
    C.Color_4294967295 = new Q.Color(4294967295);
    C.Cubic_JUR = new Z.Cubic(0.25, 0.1, 0.25, 1);
    C.DebugSemanticsDumpOrder_0 = new A.DebugSemanticsDumpOrder("DebugSemanticsDumpOrder.inverseHitTest");
    C.DebugSemanticsDumpOrder_1 = new A.DebugSemanticsDumpOrder("DebugSemanticsDumpOrder.traversalOrder");
    C.DiagnosticLevel_0 = new Y.DiagnosticLevel(0, "DiagnosticLevel.hidden");
    C.DiagnosticLevel_1 = new Y.DiagnosticLevel(1, "DiagnosticLevel.fine");
    C.DiagnosticLevel_2 = new Y.DiagnosticLevel(2, "DiagnosticLevel.debug");
    C.DiagnosticLevel_3 = new Y.DiagnosticLevel(3, "DiagnosticLevel.info");
    C.DiagnosticLevel_4 = new Y.DiagnosticLevel(4, "DiagnosticLevel.warning");
    C.DiagnosticLevel_5 = new Y.DiagnosticLevel(5, "DiagnosticLevel.hint");
    C.DiagnosticLevel_6 = new Y.DiagnosticLevel(6, "DiagnosticLevel.summary");
    C.DiagnosticLevel_7 = new Y.DiagnosticLevel(7, "DiagnosticLevel.error");
    C.DiagnosticsTreeStyle_0 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.sparse");
    C.DiagnosticsTreeStyle_1 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.offstage");
    C.DiagnosticsTreeStyle_10 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.truncateChildren");
    C.DiagnosticsTreeStyle_2 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.dense");
    C.DiagnosticsTreeStyle_3 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.transition");
    C.DiagnosticsTreeStyle_4 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.error");
    C.DiagnosticsTreeStyle_5 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.whitespace");
    C.DiagnosticsTreeStyle_6 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.flat");
    C.DiagnosticsTreeStyle_7 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.singleLine");
    C.DiagnosticsTreeStyle_8 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.errorProperty");
    C.DiagnosticsTreeStyle_9 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.shallow");
    C.Duration_0 = new P.Duration(0);
    C.Duration_100000 = new P.Duration(100000);
    C.Duration_1000000 = new P.Duration(1000000);
    C.Duration_300000 = new P.Duration(300000);
    C.Duration_50000 = new P.Duration(50000);
    C.Duration_5000000 = new P.Duration(5000000);
    C.ElementType_0 = new T.ElementType("ElementType.input");
    C.ElementType_1 = new T.ElementType("ElementType.textarea");
    C.ElementType_2 = new T.ElementType("ElementType.contentEditable");
    C.FontWeight_6 = new Q.FontWeight(6);
    C.FormatException_Qi2 = new P.FormatException("Invalid method call", null, null);
    C.FormatException_oCg = new P.FormatException("Message corrupted", null, null);
    C.GestureMode_0 = new T.GestureMode("GestureMode.pointerEvents");
    C.GestureMode_1 = new T.GestureMode("GestureMode.browserGestures");
    C.InputType_0 = new T.InputType("InputType.text");
    C.InputType_1 = new T.InputType("InputType.multiline");
    C.JsonDecoder_null = new P.JsonDecoder(null);
    C.JsonEncoder_null = new P.JsonEncoder(null);
    C.KeyboardSide_0 = new B.KeyboardSide("KeyboardSide.any");
    C.KeyboardSide_1 = new B.KeyboardSide("KeyboardSide.left");
    C.KeyboardSide_2 = new B.KeyboardSide("KeyboardSide.right");
    C.KeyboardSide_3 = new B.KeyboardSide("KeyboardSide.all");
    C.LineBreakType_0 = new T.LineBreakType("LineBreakType.opportunity");
    C.LineBreakType_1 = new T.LineBreakType("LineBreakType.mandatory");
    C.LineBreakType_2 = new T.LineBreakType("LineBreakType.endOfText");
    C.ModifierKey_0 = new B.ModifierKey("ModifierKey.controlModifier");
    C.ModifierKey_1 = new B.ModifierKey("ModifierKey.shiftModifier");
    C.ModifierKey_2 = new B.ModifierKey("ModifierKey.altModifier");
    C.ModifierKey_3 = new B.ModifierKey("ModifierKey.metaModifier");
    C.ModifierKey_4 = new B.ModifierKey("ModifierKey.capsLockModifier");
    C.ModifierKey_5 = new B.ModifierKey("ModifierKey.numLockModifier");
    C.ModifierKey_6 = new B.ModifierKey("ModifierKey.scrollLockModifier");
    C.ModifierKey_7 = new B.ModifierKey("ModifierKey.functionModifier");
    C.ModifierKey_8 = new B.ModifierKey("ModifierKey.symbolModifier");
    C.List_0 = H.setRuntimeTypeInfo(makeConstList([C.ModifierKey_0, C.ModifierKey_1, C.ModifierKey_2, C.ModifierKey_3, C.ModifierKey_4, C.ModifierKey_5, C.ModifierKey_6, C.ModifierKey_7, C.ModifierKey_8]), [B.ModifierKey]);
    C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(makeConstList([127, 2047, 65535, 1114111]), [P.int]);
    C.List_2Vk = H.setRuntimeTypeInfo(makeConstList([0, 0, 32776, 33792, 1, 10240, 0, 0]), [P.int]);
    C.List_2Zi = H.setRuntimeTypeInfo(makeConstList(["*::class", "*::dir", "*::draggable", "*::hidden", "*::id", "*::inert", "*::itemprop", "*::itemref", "*::itemscope", "*::lang", "*::spellcheck", "*::title", "*::translate", "A::accesskey", "A::coords", "A::hreflang", "A::name", "A::shape", "A::tabindex", "A::target", "A::type", "AREA::accesskey", "AREA::alt", "AREA::coords", "AREA::nohref", "AREA::shape", "AREA::tabindex", "AREA::target", "AUDIO::controls", "AUDIO::loop", "AUDIO::mediagroup", "AUDIO::muted", "AUDIO::preload", "BDO::dir", "BODY::alink", "BODY::bgcolor", "BODY::link", "BODY::text", "BODY::vlink", "BR::clear", "BUTTON::accesskey", "BUTTON::disabled", "BUTTON::name", "BUTTON::tabindex", "BUTTON::type", "BUTTON::value", "CANVAS::height", "CANVAS::width", "CAPTION::align", "COL::align", "COL::char", "COL::charoff", "COL::span", "COL::valign", "COL::width", "COLGROUP::align", "COLGROUP::char", "COLGROUP::charoff", "COLGROUP::span", "COLGROUP::valign", "COLGROUP::width", "COMMAND::checked", "COMMAND::command", "COMMAND::disabled", "COMMAND::label", "COMMAND::radiogroup", "COMMAND::type", "DATA::value", "DEL::datetime", "DETAILS::open", "DIR::compact", "DIV::align", "DL::compact", "FIELDSET::disabled", "FONT::color", "FONT::face", "FONT::size", "FORM::accept", "FORM::autocomplete", "FORM::enctype", "FORM::method", "FORM::name", "FORM::novalidate", "FORM::target", "FRAME::name", "H1::align", "H2::align", "H3::align", "H4::align", "H5::align", "H6::align", "HR::align", "HR::noshade", "HR::size", "HR::width", "HTML::version", "IFRAME::align", "IFRAME::frameborder", "IFRAME::height", "IFRAME::marginheight", "IFRAME::marginwidth", "IFRAME::width", "IMG::align", "IMG::alt", "IMG::border", "IMG::height", "IMG::hspace", "IMG::ismap", "IMG::name", "IMG::usemap", "IMG::vspace", "IMG::width", "INPUT::accept", "INPUT::accesskey", "INPUT::align", "INPUT::alt", "INPUT::autocomplete", "INPUT::autofocus", "INPUT::checked", "INPUT::disabled", "INPUT::inputmode", "INPUT::ismap", "INPUT::list", "INPUT::max", "INPUT::maxlength", "INPUT::min", "INPUT::multiple", "INPUT::name", "INPUT::placeholder", "INPUT::readonly", "INPUT::required", "INPUT::size", "INPUT::step", "INPUT::tabindex", "INPUT::type", "INPUT::usemap", "INPUT::value", "INS::datetime", "KEYGEN::disabled", "KEYGEN::keytype", "KEYGEN::name", "LABEL::accesskey", "LABEL::for", "LEGEND::accesskey", "LEGEND::align", "LI::type", "LI::value", "LINK::sizes", "MAP::name", "MENU::compact", "MENU::label", "MENU::type", "METER::high", "METER::low", "METER::max", "METER::min", "METER::value", "OBJECT::typemustmatch", "OL::compact", "OL::reversed", "OL::start", "OL::type", "OPTGROUP::disabled", "OPTGROUP::label", "OPTION::disabled", "OPTION::label", "OPTION::selected", "OPTION::value", "OUTPUT::for", "OUTPUT::name", "P::align", "PRE::width", "PROGRESS::max", "PROGRESS::min", "PROGRESS::value", "SELECT::autocomplete", "SELECT::disabled", "SELECT::multiple", "SELECT::name", "SELECT::required", "SELECT::size", "SELECT::tabindex", "SOURCE::type", "TABLE::align", "TABLE::bgcolor", "TABLE::border", "TABLE::cellpadding", "TABLE::cellspacing", "TABLE::frame", "TABLE::rules", "TABLE::summary", "TABLE::width", "TBODY::align", "TBODY::char", "TBODY::charoff", "TBODY::valign", "TD::abbr", "TD::align", "TD::axis", "TD::bgcolor", "TD::char", "TD::charoff", "TD::colspan", "TD::headers", "TD::height", "TD::nowrap", "TD::rowspan", "TD::scope", "TD::valign", "TD::width", "TEXTAREA::accesskey", "TEXTAREA::autocomplete", "TEXTAREA::cols", "TEXTAREA::disabled", "TEXTAREA::inputmode", "TEXTAREA::name", "TEXTAREA::placeholder", "TEXTAREA::readonly", "TEXTAREA::required", "TEXTAREA::rows", "TEXTAREA::tabindex", "TEXTAREA::wrap", "TFOOT::align", "TFOOT::char", "TFOOT::charoff", "TFOOT::valign", "TH::abbr", "TH::align", "TH::axis", "TH::bgcolor", "TH::char", "TH::charoff", "TH::colspan", "TH::headers", "TH::height", "TH::nowrap", "TH::rowspan", "TH::scope", "TH::valign", "TH::width", "THEAD::align", "THEAD::char", "THEAD::charoff", "THEAD::valign", "TR::align", "TR::bgcolor", "TR::char", "TR::charoff", "TR::valign", "TRACK::default", "TRACK::kind", "TRACK::label", "TRACK::srclang", "UL::compact", "UL::type", "VIDEO::controls", "VIDEO::height", "VIDEO::loop", "VIDEO::mediagroup", "VIDEO::muted", "VIDEO::preload", "VIDEO::width"]), [P.String]);
    C.List_CVk = H.setRuntimeTypeInfo(makeConstList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]), [P.int]);
    C.List_JYB = H.setRuntimeTypeInfo(makeConstList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]), [P.int]);
    C.Locale_en_US = new Q.Locale("en", "US");
    C.List_Locale_en_US = H.setRuntimeTypeInfo(makeConstList([C.Locale_en_US]), [Q.Locale]);
    C.List_cg9 = H.setRuntimeTypeInfo(makeConstList(["dart:async-patch", "dart:async", "package:stack_trace"]), [P.String]);
    C.List_click_scroll = H.setRuntimeTypeInfo(makeConstList(["click", "scroll"]), [P.String]);
    C.List_click_touchstart_touchend = H.setRuntimeTypeInfo(makeConstList(["click", "touchstart", "touchend"]), [P.String]);
    C.List_e3D = H.setRuntimeTypeInfo(makeConstList(["pointerdown", "pointermove", "pointerup", "pointercancel", "touchstart", "touchend", "touchmove", "touchcancel", "mousedown", "mousemove", "mouseup"]), [P.String]);
    C.List_ego = H.setRuntimeTypeInfo(makeConstList(["HEAD", "AREA", "BASE", "BASEFONT", "BR", "COL", "COLGROUP", "EMBED", "FRAME", "FRAMESET", "HR", "IMAGE", "IMG", "INPUT", "ISINDEX", "LINK", "META", "PARAM", "SOURCE", "STYLE", "TITLE", "WBR"]), [P.String]);
    C.List_empty = H.setRuntimeTypeInfo(makeConstList([]), [Y.DiagnosticsNode]);
    C.List_empty2 = H.setRuntimeTypeInfo(makeConstList([]), [P.Null]);
    C.List_empty1 = H.setRuntimeTypeInfo(makeConstList([]), [A.SemanticsNode]);
    C.List_empty3 = H.setRuntimeTypeInfo(makeConstList([]), [P.String]);
    C.List_empty0 = makeConstList([]);
    C.List_gRj = H.setRuntimeTypeInfo(makeConstList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]), [P.int]);
    C.List_gnE = H.setRuntimeTypeInfo(makeConstList([0, 0, 65498, 45055, 65535, 34815, 65534, 18431]), [P.int]);
    C.List_ifn = H.setRuntimeTypeInfo(makeConstList(["_AssertionError", "_FakeAsync", "_FrameCallbackEntry"]), [P.String]);
    C.List_null = H.setRuntimeTypeInfo(makeConstList(["null"]), [P.String]);
    C.List_nxB = H.setRuntimeTypeInfo(makeConstList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]), [P.int]);
    C.List_qNA = H.setRuntimeTypeInfo(makeConstList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]), [P.int]);
    C.List_qg40 = H.setRuntimeTypeInfo(makeConstList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]), [P.int]);
    C.List_qg4 = H.setRuntimeTypeInfo(makeConstList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]), [P.int]);
    C.List_wSV = H.setRuntimeTypeInfo(makeConstList(["bind", "if", "ref", "repeat", "syntax"]), [P.String]);
    C.List_yrN = H.setRuntimeTypeInfo(makeConstList(["A::href", "AREA::href", "BLOCKQUOTE::cite", "BODY::background", "COMMAND::icon", "DEL::cite", "FORM::action", "IMG::src", "INPUT::src", "INS::cite", "Q::cite", "VIDEO::poster"]), [P.String]);
    C.LogicalKeyboardKey_4294967296_None_null = new G.LogicalKeyboardKey(4294967296, "None", null);
    C.LogicalKeyboardKey_4294967314_Fn_null = new G.LogicalKeyboardKey(4294967314, "Fn", null);
    C.LogicalKeyboardKey_4295032962_Sleep_null = new G.LogicalKeyboardKey(4295032962, "Sleep", null);
    C.LogicalKeyboardKey_owA = new G.LogicalKeyboardKey(4295032963, "Wake Up", null);
    C.LogicalKeyboardKey_7G2 = new G.LogicalKeyboardKey(97, "Key A", "a");
    C.LogicalKeyboardKey_jjv = new G.LogicalKeyboardKey(98, "Key B", "b");
    C.LogicalKeyboardKey_mF8 = new G.LogicalKeyboardKey(99, "Key C", "c");
    C.LogicalKeyboardKey_ICU = new G.LogicalKeyboardKey(100, "Key D", "d");
    C.LogicalKeyboardKey_AaU = new G.LogicalKeyboardKey(101, "Key E", "e");
    C.LogicalKeyboardKey_2jN = new G.LogicalKeyboardKey(102, "Key F", "f");
    C.LogicalKeyboardKey_cKo = new G.LogicalKeyboardKey(103, "Key G", "g");
    C.LogicalKeyboardKey_QhK = new G.LogicalKeyboardKey(104, "Key H", "h");
    C.LogicalKeyboardKey_swi = new G.LogicalKeyboardKey(105, "Key I", "i");
    C.LogicalKeyboardKey_CG7 = new G.LogicalKeyboardKey(106, "Key J", "j");
    C.LogicalKeyboardKey_3jH = new G.LogicalKeyboardKey(107, "Key K", "k");
    C.LogicalKeyboardKey_4iU = new G.LogicalKeyboardKey(108, "Key L", "l");
    C.LogicalKeyboardKey_oe4 = new G.LogicalKeyboardKey(109, "Key M", "m");
    C.LogicalKeyboardKey_OLv = new G.LogicalKeyboardKey(110, "Key N", "n");
    C.LogicalKeyboardKey_sav = new G.LogicalKeyboardKey(111, "Key O", "o");
    C.LogicalKeyboardKey_M6L = new G.LogicalKeyboardKey(112, "Key P", "p");
    C.LogicalKeyboardKey_Ods = new G.LogicalKeyboardKey(113, "Key Q", "q");
    C.LogicalKeyboardKey_qsN = new G.LogicalKeyboardKey(114, "Key R", "r");
    C.LogicalKeyboardKey_fLj = new G.LogicalKeyboardKey(115, "Key S", "s");
    C.LogicalKeyboardKey_V86 = new G.LogicalKeyboardKey(116, "Key T", "t");
    C.LogicalKeyboardKey_Tng = new G.LogicalKeyboardKey(117, "Key U", "u");
    C.LogicalKeyboardKey_6Ng = new G.LogicalKeyboardKey(118, "Key V", "v");
    C.LogicalKeyboardKey_XaR = new G.LogicalKeyboardKey(119, "Key W", "w");
    C.LogicalKeyboardKey_ifx = new G.LogicalKeyboardKey(120, "Key X", "x");
    C.LogicalKeyboardKey_kQR = new G.LogicalKeyboardKey(121, "Key Y", "y");
    C.LogicalKeyboardKey_W2D = new G.LogicalKeyboardKey(122, "Key Z", "z");
    C.LogicalKeyboardKey_4AN = new G.LogicalKeyboardKey(49, "Digit 1", "1");
    C.LogicalKeyboardKey_mmo = new G.LogicalKeyboardKey(50, "Digit 2", "2");
    C.LogicalKeyboardKey_a7X = new G.LogicalKeyboardKey(51, "Digit 3", "3");
    C.LogicalKeyboardKey_e9s = new G.LogicalKeyboardKey(52, "Digit 4", "4");
    C.LogicalKeyboardKey_43h = new G.LogicalKeyboardKey(53, "Digit 5", "5");
    C.LogicalKeyboardKey_CmI = new G.LogicalKeyboardKey(54, "Digit 6", "6");
    C.LogicalKeyboardKey_Db0 = new G.LogicalKeyboardKey(55, "Digit 7", "7");
    C.LogicalKeyboardKey_GZG = new G.LogicalKeyboardKey(56, "Digit 8", "8");
    C.LogicalKeyboardKey_86y = new G.LogicalKeyboardKey(57, "Digit 9", "9");
    C.LogicalKeyboardKey_0 = new G.LogicalKeyboardKey(48, "Digit 0", "0");
    C.LogicalKeyboardKey_4295426088_Enter_null = new G.LogicalKeyboardKey(4295426088, "Enter", null);
    C.LogicalKeyboardKey_4295426089_Escape_null = new G.LogicalKeyboardKey(4295426089, "Escape", null);
    C.LogicalKeyboardKey_4295426090_Backspace_null = new G.LogicalKeyboardKey(4295426090, "Backspace", null);
    C.LogicalKeyboardKey_4295426091_Tab_null = new G.LogicalKeyboardKey(4295426091, "Tab", null);
    C.LogicalKeyboardKey_YdN = new G.LogicalKeyboardKey(32, "Space", " ");
    C.LogicalKeyboardKey_oEN = new G.LogicalKeyboardKey(45, "Minus", "-");
    C.LogicalKeyboardKey_wrE = new G.LogicalKeyboardKey(61, "Equal", "=");
    C.LogicalKeyboardKey_TLI = new G.LogicalKeyboardKey(91, "Bracket Left", "[");
    C.LogicalKeyboardKey_awJ = new G.LogicalKeyboardKey(93, "Bracket Right", "]");
    C.LogicalKeyboardKey_cdS = new G.LogicalKeyboardKey(92, "Backslash", "\\");
    C.LogicalKeyboardKey_atK = new G.LogicalKeyboardKey(59, "Semicolon", ";");
    C.LogicalKeyboardKey_Qo8 = new G.LogicalKeyboardKey(39, "Quote", "'");
    C.LogicalKeyboardKey_7FR = new G.LogicalKeyboardKey(96, "Backquote", "`");
    C.LogicalKeyboardKey_71T = new G.LogicalKeyboardKey(44, "Comma", ",");
    C.LogicalKeyboardKey_h8g = new G.LogicalKeyboardKey(46, "Period", ".");
    C.LogicalKeyboardKey_ouN = new G.LogicalKeyboardKey(47, "Slash", "/");
    C.LogicalKeyboardKey_OWF = new G.LogicalKeyboardKey(4295426105, "Caps Lock", null);
    C.LogicalKeyboardKey_4295426106_F1_null = new G.LogicalKeyboardKey(4295426106, "F1", null);
    C.LogicalKeyboardKey_4295426107_F2_null = new G.LogicalKeyboardKey(4295426107, "F2", null);
    C.LogicalKeyboardKey_4295426108_F3_null = new G.LogicalKeyboardKey(4295426108, "F3", null);
    C.LogicalKeyboardKey_4295426109_F4_null = new G.LogicalKeyboardKey(4295426109, "F4", null);
    C.LogicalKeyboardKey_4295426110_F5_null = new G.LogicalKeyboardKey(4295426110, "F5", null);
    C.LogicalKeyboardKey_4295426111_F6_null = new G.LogicalKeyboardKey(4295426111, "F6", null);
    C.LogicalKeyboardKey_4295426112_F7_null = new G.LogicalKeyboardKey(4295426112, "F7", null);
    C.LogicalKeyboardKey_4295426113_F8_null = new G.LogicalKeyboardKey(4295426113, "F8", null);
    C.LogicalKeyboardKey_4295426114_F9_null = new G.LogicalKeyboardKey(4295426114, "F9", null);
    C.LogicalKeyboardKey_4295426115_F10_null = new G.LogicalKeyboardKey(4295426115, "F10", null);
    C.LogicalKeyboardKey_4295426116_F11_null = new G.LogicalKeyboardKey(4295426116, "F11", null);
    C.LogicalKeyboardKey_4295426117_F12_null = new G.LogicalKeyboardKey(4295426117, "F12", null);
    C.LogicalKeyboardKey_wAl = new G.LogicalKeyboardKey(4295426118, "Print Screen", null);
    C.LogicalKeyboardKey_ujM = new G.LogicalKeyboardKey(4295426119, "Scroll Lock", null);
    C.LogicalKeyboardKey_4295426120_Pause_null = new G.LogicalKeyboardKey(4295426120, "Pause", null);
    C.LogicalKeyboardKey_4295426121_Insert_null = new G.LogicalKeyboardKey(4295426121, "Insert", null);
    C.LogicalKeyboardKey_4295426122_Home_null = new G.LogicalKeyboardKey(4295426122, "Home", null);
    C.LogicalKeyboardKey_mgB = new G.LogicalKeyboardKey(4295426123, "Page Up", null);
    C.LogicalKeyboardKey_4295426124_Delete_null = new G.LogicalKeyboardKey(4295426124, "Delete", null);
    C.LogicalKeyboardKey_4295426125_End_null = new G.LogicalKeyboardKey(4295426125, "End", null);
    C.LogicalKeyboardKey_wYn = new G.LogicalKeyboardKey(4295426126, "Page Down", null);
    C.LogicalKeyboardKey_CzM = new G.LogicalKeyboardKey(4295426127, "Arrow Right", null);
    C.LogicalKeyboardKey_muk = new G.LogicalKeyboardKey(4295426128, "Arrow Left", null);
    C.LogicalKeyboardKey_O7X = new G.LogicalKeyboardKey(4295426129, "Arrow Down", null);
    C.LogicalKeyboardKey_gCR = new G.LogicalKeyboardKey(4295426130, "Arrow Up", null);
    C.LogicalKeyboardKey_uHn = new G.LogicalKeyboardKey(4295426131, "Num Lock", null);
    C.LogicalKeyboardKey_Npb = new G.LogicalKeyboardKey(4295426132, "Numpad Divide", "/");
    C.LogicalKeyboardKey_iOn = new G.LogicalKeyboardKey(4295426133, "Numpad Multiply", "*");
    C.LogicalKeyboardKey_7xV = new G.LogicalKeyboardKey(4295426134, "Numpad Subtract", "-");
    C.LogicalKeyboardKey_YaH = new G.LogicalKeyboardKey(4295426135, "Numpad Add", "+");
    C.LogicalKeyboardKey_U2J = new G.LogicalKeyboardKey(4295426136, "Numpad Enter", null);
    C.LogicalKeyboardKey_qsT = new G.LogicalKeyboardKey(4295426137, "Numpad 1", "1");
    C.LogicalKeyboardKey_ka2 = new G.LogicalKeyboardKey(4295426138, "Numpad 2", "2");
    C.LogicalKeyboardKey_Ddz = new G.LogicalKeyboardKey(4295426139, "Numpad 3", "3");
    C.LogicalKeyboardKey_YGD = new G.LogicalKeyboardKey(4295426140, "Numpad 4", "4");
    C.LogicalKeyboardKey_s0r = new G.LogicalKeyboardKey(4295426141, "Numpad 5", "5");
    C.LogicalKeyboardKey_atK0 = new G.LogicalKeyboardKey(4295426142, "Numpad 6", "6");
    C.LogicalKeyboardKey_3bB = new G.LogicalKeyboardKey(4295426143, "Numpad 7", "7");
    C.LogicalKeyboardKey_sx4 = new G.LogicalKeyboardKey(4295426144, "Numpad 8", "8");
    C.LogicalKeyboardKey_4IJ = new G.LogicalKeyboardKey(4295426145, "Numpad 9", "9");
    C.LogicalKeyboardKey_KQb = new G.LogicalKeyboardKey(4295426146, "Numpad 0", "0");
    C.LogicalKeyboardKey_iXq = new G.LogicalKeyboardKey(4295426147, "Numpad Decimal", ".");
    C.LogicalKeyboardKey_nDU = new G.LogicalKeyboardKey(4295426149, "Context Menu", null);
    C.LogicalKeyboardKey_4295426150_Power_null = new G.LogicalKeyboardKey(4295426150, "Power", null);
    C.LogicalKeyboardKey_G2v = new G.LogicalKeyboardKey(4295426151, "Numpad Equal", "=");
    C.LogicalKeyboardKey_4295426165_Help_null = new G.LogicalKeyboardKey(4295426165, "Help", null);
    C.LogicalKeyboardKey_4295426171_Cut_null = new G.LogicalKeyboardKey(4295426171, "Cut", null);
    C.LogicalKeyboardKey_4295426172_Copy_null = new G.LogicalKeyboardKey(4295426172, "Copy", null);
    C.LogicalKeyboardKey_4295426173_Paste_null = new G.LogicalKeyboardKey(4295426173, "Paste", null);
    C.LogicalKeyboardKey_MjO = new G.LogicalKeyboardKey(4295426175, "Audio Volume Mute", null);
    C.LogicalKeyboardKey_gap = new G.LogicalKeyboardKey(4295426176, "Audio Volume Up", null);
    C.LogicalKeyboardKey_c9P = new G.LogicalKeyboardKey(4295426177, "Audio Volume Down", null);
    C.LogicalKeyboardKey_CLo = new G.LogicalKeyboardKey(4295426181, "Numpad Comma", ",");
    C.LogicalKeyboardKey_4295426186_Convert_null = new G.LogicalKeyboardKey(4295426186, "Convert", null);
    C.LogicalKeyboardKey_sBE = new G.LogicalKeyboardKey(4295426187, "Non Convert", null);
    C.LogicalKeyboardKey_wEo = new G.LogicalKeyboardKey(4295426230, "Numpad Paren Left", "(");
    C.LogicalKeyboardKey_8Nr = new G.LogicalKeyboardKey(4295426231, "Numpad Paren Right", ")");
    C.LogicalKeyboardKey_p6t = new G.LogicalKeyboardKey(4295426272, "Control Left", null);
    C.LogicalKeyboardKey_xok = new G.LogicalKeyboardKey(4295426273, "Shift Left", null);
    C.LogicalKeyboardKey_PD9 = new G.LogicalKeyboardKey(4295426274, "Alt Left", null);
    C.LogicalKeyboardKey_D0U = new G.LogicalKeyboardKey(4295426275, "Meta Left", null);
    C.LogicalKeyboardKey_ijl = new G.LogicalKeyboardKey(4295426276, "Control Right", null);
    C.LogicalKeyboardKey_QOu = new G.LogicalKeyboardKey(4295426277, "Shift Right", null);
    C.LogicalKeyboardKey_EtP = new G.LogicalKeyboardKey(4295426278, "Alt Right", null);
    C.LogicalKeyboardKey_O1c = new G.LogicalKeyboardKey(4295426279, "Meta Right", null);
    C.LogicalKeyboardKey_4295753824_Info_null = new G.LogicalKeyboardKey(4295753824, "Info", null);
    C.LogicalKeyboardKey_ccN = new G.LogicalKeyboardKey(4295753825, "Closed Caption Toggle", null);
    C.LogicalKeyboardKey_Djg = new G.LogicalKeyboardKey(4295753839, "Brightness Up", null);
    C.LogicalKeyboardKey_ECL = new G.LogicalKeyboardKey(4295753840, "Brightness Down", null);
    C.LogicalKeyboardKey_Pz5 = new G.LogicalKeyboardKey(4295753859, "Media Last", null);
    C.LogicalKeyboardKey_6QF = new G.LogicalKeyboardKey(4295753884, "Channel Up", null);
    C.LogicalKeyboardKey_3J4 = new G.LogicalKeyboardKey(4295753885, "Channel Down", null);
    C.LogicalKeyboardKey_Azp = new G.LogicalKeyboardKey(4295753904, "Media Play", null);
    C.LogicalKeyboardKey_8eb = new G.LogicalKeyboardKey(4295753906, "Media Record", null);
    C.LogicalKeyboardKey_eEX = new G.LogicalKeyboardKey(4295753907, "Media Fast Forward", null);
    C.LogicalKeyboardKey_kQR0 = new G.LogicalKeyboardKey(4295753908, "Media Rewind", null);
    C.LogicalKeyboardKey_n7o = new G.LogicalKeyboardKey(4295753909, "Media Track Next", null);
    C.LogicalKeyboardKey_kHV = new G.LogicalKeyboardKey(4295753910, "Media Track Previous", null);
    C.LogicalKeyboardKey_wfl = new G.LogicalKeyboardKey(4295753911, "Media Stop", null);
    C.LogicalKeyboardKey_4295753912_Eject_null = new G.LogicalKeyboardKey(4295753912, "Eject", null);
    C.LogicalKeyboardKey_Cu4 = new G.LogicalKeyboardKey(4295753933, "Media Play Pause", null);
    C.LogicalKeyboardKey_9gS = new G.LogicalKeyboardKey(4295754122, "Launch Mail", null);
    C.LogicalKeyboardKey_mqK = new G.LogicalKeyboardKey(4295754125, "Launch Contacts", null);
    C.LogicalKeyboardKey_k44 = new G.LogicalKeyboardKey(4295754126, "Launch Calendar", null);
    C.LogicalKeyboardKey_IQp = new G.LogicalKeyboardKey(4295754187, "Launch Assistant", null);
    C.LogicalKeyboardKey_4295754243_Close_null = new G.LogicalKeyboardKey(4295754243, "Close", null);
    C.LogicalKeyboardKey_EWB = new G.LogicalKeyboardKey(4295754273, "Browser Search", null);
    C.LogicalKeyboardKey_8pc = new G.LogicalKeyboardKey(4295754277, "Browser Forward", null);
    C.LogicalKeyboardKey_46S = new G.LogicalKeyboardKey(4295754282, "Browser Favorites", null);
    C.LogicalKeyboardKey_0Rr = new G.LogicalKeyboardKey(4295754285, "Zoom In", null);
    C.LogicalKeyboardKey_wIk = new G.LogicalKeyboardKey(4295754286, "Zoom Out", null);
    C.LogicalKeyboardKey_ijl0 = new G.LogicalKeyboardKey(4295754290, "Zoom Toggle", null);
    C.Map_0rYGk = new H.GeneralConstantMap([0, C.LogicalKeyboardKey_4294967296_None_null, 119, C.LogicalKeyboardKey_4294967314_Fn_null, 223, C.LogicalKeyboardKey_4295032962_Sleep_null, 224, C.LogicalKeyboardKey_owA, 29, C.LogicalKeyboardKey_7G2, 30, C.LogicalKeyboardKey_jjv, 31, C.LogicalKeyboardKey_mF8, 32, C.LogicalKeyboardKey_ICU, 33, C.LogicalKeyboardKey_AaU, 34, C.LogicalKeyboardKey_2jN, 35, C.LogicalKeyboardKey_cKo, 36, C.LogicalKeyboardKey_QhK, 37, C.LogicalKeyboardKey_swi, 38, C.LogicalKeyboardKey_CG7, 39, C.LogicalKeyboardKey_3jH, 40, C.LogicalKeyboardKey_4iU, 41, C.LogicalKeyboardKey_oe4, 42, C.LogicalKeyboardKey_OLv, 43, C.LogicalKeyboardKey_sav, 44, C.LogicalKeyboardKey_M6L, 45, C.LogicalKeyboardKey_Ods, 46, C.LogicalKeyboardKey_qsN, 47, C.LogicalKeyboardKey_fLj, 48, C.LogicalKeyboardKey_V86, 49, C.LogicalKeyboardKey_Tng, 50, C.LogicalKeyboardKey_6Ng, 51, C.LogicalKeyboardKey_XaR, 52, C.LogicalKeyboardKey_ifx, 53, C.LogicalKeyboardKey_kQR, 54, C.LogicalKeyboardKey_W2D, 8, C.LogicalKeyboardKey_4AN, 9, C.LogicalKeyboardKey_mmo, 10, C.LogicalKeyboardKey_a7X, 11, C.LogicalKeyboardKey_e9s, 12, C.LogicalKeyboardKey_43h, 13, C.LogicalKeyboardKey_CmI, 14, C.LogicalKeyboardKey_Db0, 15, C.LogicalKeyboardKey_GZG, 16, C.LogicalKeyboardKey_86y, 7, C.LogicalKeyboardKey_0, 66, C.LogicalKeyboardKey_4295426088_Enter_null, 111, C.LogicalKeyboardKey_4295426089_Escape_null, 67, C.LogicalKeyboardKey_4295426090_Backspace_null, 61, C.LogicalKeyboardKey_4295426091_Tab_null, 62, C.LogicalKeyboardKey_YdN, 69, C.LogicalKeyboardKey_oEN, 70, C.LogicalKeyboardKey_wrE, 71, C.LogicalKeyboardKey_TLI, 72, C.LogicalKeyboardKey_awJ, 73, C.LogicalKeyboardKey_cdS, 74, C.LogicalKeyboardKey_atK, 75, C.LogicalKeyboardKey_Qo8, 68, C.LogicalKeyboardKey_7FR, 55, C.LogicalKeyboardKey_71T, 56, C.LogicalKeyboardKey_h8g, 76, C.LogicalKeyboardKey_ouN, 115, C.LogicalKeyboardKey_OWF, 131, C.LogicalKeyboardKey_4295426106_F1_null, 132, C.LogicalKeyboardKey_4295426107_F2_null, 133, C.LogicalKeyboardKey_4295426108_F3_null, 134, C.LogicalKeyboardKey_4295426109_F4_null, 135, C.LogicalKeyboardKey_4295426110_F5_null, 136, C.LogicalKeyboardKey_4295426111_F6_null, 137, C.LogicalKeyboardKey_4295426112_F7_null, 138, C.LogicalKeyboardKey_4295426113_F8_null, 139, C.LogicalKeyboardKey_4295426114_F9_null, 140, C.LogicalKeyboardKey_4295426115_F10_null, 141, C.LogicalKeyboardKey_4295426116_F11_null, 142, C.LogicalKeyboardKey_4295426117_F12_null, 120, C.LogicalKeyboardKey_wAl, 116, C.LogicalKeyboardKey_ujM, 121, C.LogicalKeyboardKey_4295426120_Pause_null, 124, C.LogicalKeyboardKey_4295426121_Insert_null, 122, C.LogicalKeyboardKey_4295426122_Home_null, 92, C.LogicalKeyboardKey_mgB, 112, C.LogicalKeyboardKey_4295426124_Delete_null, 123, C.LogicalKeyboardKey_4295426125_End_null, 93, C.LogicalKeyboardKey_wYn, 22, C.LogicalKeyboardKey_CzM, 21, C.LogicalKeyboardKey_muk, 20, C.LogicalKeyboardKey_O7X, 19, C.LogicalKeyboardKey_gCR, 143, C.LogicalKeyboardKey_uHn, 154, C.LogicalKeyboardKey_Npb, 155, C.LogicalKeyboardKey_iOn, 156, C.LogicalKeyboardKey_7xV, 157, C.LogicalKeyboardKey_YaH, 160, C.LogicalKeyboardKey_U2J, 145, C.LogicalKeyboardKey_qsT, 146, C.LogicalKeyboardKey_ka2, 147, C.LogicalKeyboardKey_Ddz, 148, C.LogicalKeyboardKey_YGD, 149, C.LogicalKeyboardKey_s0r, 150, C.LogicalKeyboardKey_atK0, 151, C.LogicalKeyboardKey_3bB, 152, C.LogicalKeyboardKey_sx4, 153, C.LogicalKeyboardKey_4IJ, 144, C.LogicalKeyboardKey_KQb, 158, C.LogicalKeyboardKey_iXq, 82, C.LogicalKeyboardKey_nDU, 26, C.LogicalKeyboardKey_4295426150_Power_null, 161, C.LogicalKeyboardKey_G2v, 259, C.LogicalKeyboardKey_4295426165_Help_null, 277, C.LogicalKeyboardKey_4295426171_Cut_null, 278, C.LogicalKeyboardKey_4295426172_Copy_null, 279, C.LogicalKeyboardKey_4295426173_Paste_null, 164, C.LogicalKeyboardKey_MjO, 24, C.LogicalKeyboardKey_gap, 25, C.LogicalKeyboardKey_c9P, 159, C.LogicalKeyboardKey_CLo, 214, C.LogicalKeyboardKey_4295426186_Convert_null, 213, C.LogicalKeyboardKey_sBE, 162, C.LogicalKeyboardKey_wEo, 163, C.LogicalKeyboardKey_8Nr, 113, C.LogicalKeyboardKey_p6t, 59, C.LogicalKeyboardKey_xok, 57, C.LogicalKeyboardKey_PD9, 117, C.LogicalKeyboardKey_D0U, 114, C.LogicalKeyboardKey_ijl, 60, C.LogicalKeyboardKey_QOu, 58, C.LogicalKeyboardKey_EtP, 118, C.LogicalKeyboardKey_O1c, 165, C.LogicalKeyboardKey_4295753824_Info_null, 175, C.LogicalKeyboardKey_ccN, 221, C.LogicalKeyboardKey_Djg, 220, C.LogicalKeyboardKey_ECL, 229, C.LogicalKeyboardKey_Pz5, 166, C.LogicalKeyboardKey_6QF, 167, C.LogicalKeyboardKey_3J4, 126, C.LogicalKeyboardKey_Azp, 130, C.LogicalKeyboardKey_8eb, 90, C.LogicalKeyboardKey_eEX, 89, C.LogicalKeyboardKey_kQR0, 87, C.LogicalKeyboardKey_n7o, 88, C.LogicalKeyboardKey_kHV, 86, C.LogicalKeyboardKey_wfl, 129, C.LogicalKeyboardKey_4295753912_Eject_null, 85, C.LogicalKeyboardKey_Cu4, 65, C.LogicalKeyboardKey_9gS, 207, C.LogicalKeyboardKey_mqK, 208, C.LogicalKeyboardKey_k44, 219, C.LogicalKeyboardKey_IQp, 128, C.LogicalKeyboardKey_4295754243_Close_null, 84, C.LogicalKeyboardKey_EWB, 125, C.LogicalKeyboardKey_8pc, 174, C.LogicalKeyboardKey_46S, 168, C.LogicalKeyboardKey_0Rr, 169, C.LogicalKeyboardKey_wIk, 255, C.LogicalKeyboardKey_ijl0], [P.int, G.LogicalKeyboardKey]);
    C.List_mode = H.setRuntimeTypeInfo(makeConstList(["mode"]), [P.String]);
    C.Map_9aZ6I = new H.ConstantStringMap(1, {mode: "basic"}, C.List_mode, [P.String, P.String]);
    C.SemanticsAction_1 = new Q.SemanticsAction(1);
    C.SemanticsAction_2 = new Q.SemanticsAction(2);
    C.SemanticsAction_4 = new Q.SemanticsAction(4);
    C.SemanticsAction_8 = new Q.SemanticsAction(8);
    C.SemanticsAction_16 = new Q.SemanticsAction(16);
    C.SemanticsAction_32 = new Q.SemanticsAction(32);
    C.SemanticsAction_64 = new Q.SemanticsAction(64);
    C.SemanticsAction_128 = new Q.SemanticsAction(128);
    C.SemanticsAction_256 = new Q.SemanticsAction(256);
    C.SemanticsAction_512 = new Q.SemanticsAction(512);
    C.SemanticsAction_1024 = new Q.SemanticsAction(1024);
    C.SemanticsAction_2048 = new Q.SemanticsAction(2048);
    C.SemanticsAction_4096 = new Q.SemanticsAction(4096);
    C.SemanticsAction_8192 = new Q.SemanticsAction(8192);
    C.SemanticsAction_16384 = new Q.SemanticsAction(16384);
    C.SemanticsAction_32768 = new Q.SemanticsAction(32768);
    C.SemanticsAction_65536 = new Q.SemanticsAction(65536);
    C.SemanticsAction_131072 = new Q.SemanticsAction(131072);
    C.SemanticsAction_262144 = new Q.SemanticsAction(262144);
    C.SemanticsAction_524288 = new Q.SemanticsAction(524288);
    C.SemanticsAction_1048576 = new Q.SemanticsAction(1048576);
    C.Map_EC0yd = new H.GeneralConstantMap([1, C.SemanticsAction_1, 2, C.SemanticsAction_2, 4, C.SemanticsAction_4, 8, C.SemanticsAction_8, 16, C.SemanticsAction_16, 32, C.SemanticsAction_32, 64, C.SemanticsAction_64, 128, C.SemanticsAction_128, 256, C.SemanticsAction_256, 512, C.SemanticsAction_512, 1024, C.SemanticsAction_1024, 2048, C.SemanticsAction_2048, 4096, C.SemanticsAction_4096, 8192, C.SemanticsAction_8192, 16384, C.SemanticsAction_16384, 32768, C.SemanticsAction_32768, 65536, C.SemanticsAction_65536, 131072, C.SemanticsAction_131072, 262144, C.SemanticsAction_262144, 524288, C.SemanticsAction_524288, 1048576, C.SemanticsAction_1048576], [P.int, Q.SemanticsAction]);
    C.SemanticsFlag_1 = new Q.SemanticsFlag(1);
    C.SemanticsFlag_2 = new Q.SemanticsFlag(2);
    C.SemanticsFlag_4 = new Q.SemanticsFlag(4);
    C.SemanticsFlag_8 = new Q.SemanticsFlag(8);
    C.SemanticsFlag_16 = new Q.SemanticsFlag(16);
    C.SemanticsFlag_32 = new Q.SemanticsFlag(32);
    C.SemanticsFlag_64 = new Q.SemanticsFlag(64);
    C.SemanticsFlag_128 = new Q.SemanticsFlag(128);
    C.SemanticsFlag_256 = new Q.SemanticsFlag(256);
    C.SemanticsFlag_512 = new Q.SemanticsFlag(512);
    C.SemanticsFlag_1024 = new Q.SemanticsFlag(1024);
    C.SemanticsFlag_2048 = new Q.SemanticsFlag(2048);
    C.SemanticsFlag_4096 = new Q.SemanticsFlag(4096);
    C.SemanticsFlag_8192 = new Q.SemanticsFlag(8192);
    C.SemanticsFlag_16384 = new Q.SemanticsFlag(16384);
    C.SemanticsFlag_32768 = new Q.SemanticsFlag(32768);
    C.SemanticsFlag_65536 = new Q.SemanticsFlag(65536);
    C.SemanticsFlag_131072 = new Q.SemanticsFlag(131072);
    C.SemanticsFlag_262144 = new Q.SemanticsFlag(262144);
    C.SemanticsFlag_524288 = new Q.SemanticsFlag(524288);
    C.Map_ek6Ds = new H.GeneralConstantMap([1, C.SemanticsFlag_1, 2, C.SemanticsFlag_2, 4, C.SemanticsFlag_4, 8, C.SemanticsFlag_8, 16, C.SemanticsFlag_16, 32, C.SemanticsFlag_32, 64, C.SemanticsFlag_64, 128, C.SemanticsFlag_128, 256, C.SemanticsFlag_256, 512, C.SemanticsFlag_512, 1024, C.SemanticsFlag_1024, 2048, C.SemanticsFlag_2048, 4096, C.SemanticsFlag_4096, 8192, C.SemanticsFlag_8192, 16384, C.SemanticsFlag_16384, 32768, C.SemanticsFlag_32768, 65536, C.SemanticsFlag_65536, 131072, C.SemanticsFlag_131072, 262144, C.SemanticsFlag_262144, 524288, C.SemanticsFlag_524288], [P.int, Q.SemanticsFlag]);
    C.List_empty4 = H.setRuntimeTypeInfo(makeConstList([]), [T.PersistedSurface]);
    C.Map_empty0 = new H.ConstantStringMap(0, {}, C.List_empty4, [T.PersistedSurface, T.PersistedSurface]);
    C.List_empty5 = H.setRuntimeTypeInfo(makeConstList([]), [P.Symbol0]);
    C.Map_empty = new H.ConstantStringMap(0, {}, C.List_empty5, [P.Symbol0, null]);
    C.Map_uS2jN = new H.GeneralConstantMap([154, C.LogicalKeyboardKey_Npb, 155, C.LogicalKeyboardKey_iOn, 156, C.LogicalKeyboardKey_7xV, 157, C.LogicalKeyboardKey_YaH, 145, C.LogicalKeyboardKey_qsT, 146, C.LogicalKeyboardKey_ka2, 147, C.LogicalKeyboardKey_Ddz, 148, C.LogicalKeyboardKey_YGD, 149, C.LogicalKeyboardKey_s0r, 150, C.LogicalKeyboardKey_atK0, 151, C.LogicalKeyboardKey_3bB, 152, C.LogicalKeyboardKey_sx4, 153, C.LogicalKeyboardKey_4IJ, 144, C.LogicalKeyboardKey_KQb, 158, C.LogicalKeyboardKey_iXq, 161, C.LogicalKeyboardKey_G2v, 159, C.LogicalKeyboardKey_CLo, 162, C.LogicalKeyboardKey_wEo, 163, C.LogicalKeyboardKey_8Nr], [P.int, G.LogicalKeyboardKey]);
    C.LogicalKeyboardKey_4294967312_Hyper_null = new G.LogicalKeyboardKey(4294967312, "Hyper", null);
    C.LogicalKeyboardKey_No3 = new G.LogicalKeyboardKey(4294967313, "Super Key", null);
    C.LogicalKeyboardKey_wz6 = new G.LogicalKeyboardKey(4294967315, "Fn Lock", null);
    C.LogicalKeyboardKey_4294967316_Suspend_null = new G.LogicalKeyboardKey(4294967316, "Suspend", null);
    C.LogicalKeyboardKey_4294967317_Resume_null = new G.LogicalKeyboardKey(4294967317, "Resume", null);
    C.LogicalKeyboardKey_4294967318_Turbo_null = new G.LogicalKeyboardKey(4294967318, "Turbo", null);
    C.LogicalKeyboardKey_M6i = new G.LogicalKeyboardKey(4295033013, "Display Toggle Int Ext", null);
    C.LogicalKeyboardKey_8uL = new G.LogicalKeyboardKey(4295426048, "Usb Reserved", null);
    C.LogicalKeyboardKey_2nn = new G.LogicalKeyboardKey(4295426049, "Usb Error Roll Over", null);
    C.LogicalKeyboardKey_2bx = new G.LogicalKeyboardKey(4295426050, "Usb Post Fail", null);
    C.LogicalKeyboardKey_FYo = new G.LogicalKeyboardKey(4295426051, "Usb Error Undefined", null);
    C.LogicalKeyboardKey_6vi = new G.LogicalKeyboardKey(4295426148, "Intl Backslash", null);
    C.LogicalKeyboardKey_4295426152_F13_null = new G.LogicalKeyboardKey(4295426152, "F13", null);
    C.LogicalKeyboardKey_4295426153_F14_null = new G.LogicalKeyboardKey(4295426153, "F14", null);
    C.LogicalKeyboardKey_4295426154_F15_null = new G.LogicalKeyboardKey(4295426154, "F15", null);
    C.LogicalKeyboardKey_4295426155_F16_null = new G.LogicalKeyboardKey(4295426155, "F16", null);
    C.LogicalKeyboardKey_4295426156_F17_null = new G.LogicalKeyboardKey(4295426156, "F17", null);
    C.LogicalKeyboardKey_4295426157_F18_null = new G.LogicalKeyboardKey(4295426157, "F18", null);
    C.LogicalKeyboardKey_4295426158_F19_null = new G.LogicalKeyboardKey(4295426158, "F19", null);
    C.LogicalKeyboardKey_4295426159_F20_null = new G.LogicalKeyboardKey(4295426159, "F20", null);
    C.LogicalKeyboardKey_4295426160_F21_null = new G.LogicalKeyboardKey(4295426160, "F21", null);
    C.LogicalKeyboardKey_4295426161_F22_null = new G.LogicalKeyboardKey(4295426161, "F22", null);
    C.LogicalKeyboardKey_4295426162_F23_null = new G.LogicalKeyboardKey(4295426162, "F23", null);
    C.LogicalKeyboardKey_4295426163_F24_null = new G.LogicalKeyboardKey(4295426163, "F24", null);
    C.LogicalKeyboardKey_4295426164_Open_null = new G.LogicalKeyboardKey(4295426164, "Open", null);
    C.LogicalKeyboardKey_4295426167_Select_null = new G.LogicalKeyboardKey(4295426167, "Select", null);
    C.LogicalKeyboardKey_4295426169_Again_null = new G.LogicalKeyboardKey(4295426169, "Again", null);
    C.LogicalKeyboardKey_4295426170_Undo_null = new G.LogicalKeyboardKey(4295426170, "Undo", null);
    C.LogicalKeyboardKey_4295426174_Find_null = new G.LogicalKeyboardKey(4295426174, "Find", null);
    C.LogicalKeyboardKey_iDZ = new G.LogicalKeyboardKey(4295426183, "Intl Ro", null);
    C.LogicalKeyboardKey_aBa = new G.LogicalKeyboardKey(4295426184, "Kana Mode", null);
    C.LogicalKeyboardKey_c0h = new G.LogicalKeyboardKey(4295426185, "Intl Yen", null);
    C.LogicalKeyboardKey_nx9 = new G.LogicalKeyboardKey(4295426192, "Lang 1", null);
    C.LogicalKeyboardKey_nx90 = new G.LogicalKeyboardKey(4295426193, "Lang 2", null);
    C.LogicalKeyboardKey_nx91 = new G.LogicalKeyboardKey(4295426194, "Lang 3", null);
    C.LogicalKeyboardKey_nx92 = new G.LogicalKeyboardKey(4295426195, "Lang 4", null);
    C.LogicalKeyboardKey_nx93 = new G.LogicalKeyboardKey(4295426196, "Lang 5", null);
    C.LogicalKeyboardKey_4295426203_Abort_null = new G.LogicalKeyboardKey(4295426203, "Abort", null);
    C.LogicalKeyboardKey_4295426211_Props_null = new G.LogicalKeyboardKey(4295426211, "Props", null);
    C.LogicalKeyboardKey_MUx = new G.LogicalKeyboardKey(4295426235, "Numpad Backspace", null);
    C.LogicalKeyboardKey_2Zx = new G.LogicalKeyboardKey(4295426256, "Numpad Memory Store", null);
    C.LogicalKeyboardKey_qqh = new G.LogicalKeyboardKey(4295426257, "Numpad Memory Recall", null);
    C.LogicalKeyboardKey_CxF = new G.LogicalKeyboardKey(4295426258, "Numpad Memory Clear", null);
    C.LogicalKeyboardKey_I9f = new G.LogicalKeyboardKey(4295426259, "Numpad Memory Add", null);
    C.LogicalKeyboardKey_YQd = new G.LogicalKeyboardKey(4295426260, "Numpad Memory Subtract", null);
    C.LogicalKeyboardKey_75N = new G.LogicalKeyboardKey(4295426263, "Numpad Sign Change", null);
    C.LogicalKeyboardKey_U86 = new G.LogicalKeyboardKey(4295426264, "Numpad Clear", null);
    C.LogicalKeyboardKey_OBv = new G.LogicalKeyboardKey(4295426265, "Numpad Clear Entry", null);
    C.LogicalKeyboardKey_B8J = new G.LogicalKeyboardKey(4295753842, "Brightness Toggle", null);
    C.LogicalKeyboardKey_kc1 = new G.LogicalKeyboardKey(4295753843, "Brightness Minimum", null);
    C.LogicalKeyboardKey_kc10 = new G.LogicalKeyboardKey(4295753844, "Brightness Maximum", null);
    C.LogicalKeyboardKey_HDR = new G.LogicalKeyboardKey(4295753845, "Brightness Auto", null);
    C.LogicalKeyboardKey_Ak1 = new G.LogicalKeyboardKey(4295753868, "Launch Phone", null);
    C.LogicalKeyboardKey_wg3 = new G.LogicalKeyboardKey(4295753869, "Program Guide", null);
    C.LogicalKeyboardKey_4295753876_Exit_null = new G.LogicalKeyboardKey(4295753876, "Exit", null);
    C.LogicalKeyboardKey_Q5s = new G.LogicalKeyboardKey(4295753935, "Speech Input Toggle", null);
    C.LogicalKeyboardKey_qNA = new G.LogicalKeyboardKey(4295753957, "Bass Boost", null);
    C.LogicalKeyboardKey_oPr = new G.LogicalKeyboardKey(4295754115, "Media Select", null);
    C.LogicalKeyboardKey_2Ly = new G.LogicalKeyboardKey(4295754116, "Launch Word Processor", null);
    C.LogicalKeyboardKey_8Gl = new G.LogicalKeyboardKey(4295754118, "Launch Spreadsheet", null);
    C.LogicalKeyboardKey_00 = new G.LogicalKeyboardKey(4295754130, "Launch App2", null);
    C.LogicalKeyboardKey_01 = new G.LogicalKeyboardKey(4295754132, "Launch App1", null);
    C.LogicalKeyboardKey_zvr = new G.LogicalKeyboardKey(4295754134, "Launch Internet Browser", null);
    C.LogicalKeyboardKey_D6Y = new G.LogicalKeyboardKey(4295754140, "Log Off", null);
    C.LogicalKeyboardKey_jmM = new G.LogicalKeyboardKey(4295754142, "Lock Screen", null);
    C.LogicalKeyboardKey_9hT = new G.LogicalKeyboardKey(4295754143, "Launch Control Panel", null);
    C.LogicalKeyboardKey_Dns = new G.LogicalKeyboardKey(4295754146, "Select Task", null);
    C.LogicalKeyboardKey_MIo = new G.LogicalKeyboardKey(4295754151, "Launch Documents", null);
    C.LogicalKeyboardKey_oCX = new G.LogicalKeyboardKey(4295754155, "Spell Check", null);
    C.LogicalKeyboardKey_lCr = new G.LogicalKeyboardKey(4295754158, "Launch Keyboard Layout", null);
    C.LogicalKeyboardKey_MYz = new G.LogicalKeyboardKey(4295754161, "Launch Screen Saver", null);
    C.LogicalKeyboardKey_1oF = new G.LogicalKeyboardKey(4295754167, "Launch Audio Browser", null);
    C.LogicalKeyboardKey_YSm = new G.LogicalKeyboardKey(4295754241, "New Key", null);
    C.LogicalKeyboardKey_4295754247_Save_null = new G.LogicalKeyboardKey(4295754247, "Save", null);
    C.LogicalKeyboardKey_4295754248_Print_null = new G.LogicalKeyboardKey(4295754248, "Print", null);
    C.LogicalKeyboardKey_cEy = new G.LogicalKeyboardKey(4295754275, "Browser Home", null);
    C.LogicalKeyboardKey_kKc = new G.LogicalKeyboardKey(4295754276, "Browser Back", null);
    C.LogicalKeyboardKey_MYu = new G.LogicalKeyboardKey(4295754278, "Browser Stop", null);
    C.LogicalKeyboardKey_Un6 = new G.LogicalKeyboardKey(4295754279, "Browser Refresh", null);
    C.LogicalKeyboardKey_4295754361_Redo_null = new G.LogicalKeyboardKey(4295754361, "Redo", null);
    C.LogicalKeyboardKey_XHd = new G.LogicalKeyboardKey(4295754377, "Mail Reply", null);
    C.LogicalKeyboardKey_WpI = new G.LogicalKeyboardKey(4295754379, "Mail Forward", null);
    C.LogicalKeyboardKey_7aa = new G.LogicalKeyboardKey(4295754380, "Mail Send", null);
    C.LogicalKeyboardKey_7eO = new G.LogicalKeyboardKey(4295754399, "Show All Windows", null);
    C.Map_yHIsn = new H.GeneralConstantMap([4294967296, C.LogicalKeyboardKey_4294967296_None_null, 4294967312, C.LogicalKeyboardKey_4294967312_Hyper_null, 4294967313, C.LogicalKeyboardKey_No3, 4294967314, C.LogicalKeyboardKey_4294967314_Fn_null, 4294967315, C.LogicalKeyboardKey_wz6, 4294967316, C.LogicalKeyboardKey_4294967316_Suspend_null, 4294967317, C.LogicalKeyboardKey_4294967317_Resume_null, 4294967318, C.LogicalKeyboardKey_4294967318_Turbo_null, 4295032962, C.LogicalKeyboardKey_4295032962_Sleep_null, 4295032963, C.LogicalKeyboardKey_owA, 4295033013, C.LogicalKeyboardKey_M6i, 4295426048, C.LogicalKeyboardKey_8uL, 4295426049, C.LogicalKeyboardKey_2nn, 4295426050, C.LogicalKeyboardKey_2bx, 4295426051, C.LogicalKeyboardKey_FYo, 97, C.LogicalKeyboardKey_7G2, 98, C.LogicalKeyboardKey_jjv, 99, C.LogicalKeyboardKey_mF8, 100, C.LogicalKeyboardKey_ICU, 101, C.LogicalKeyboardKey_AaU, 102, C.LogicalKeyboardKey_2jN, 103, C.LogicalKeyboardKey_cKo, 104, C.LogicalKeyboardKey_QhK, 105, C.LogicalKeyboardKey_swi, 106, C.LogicalKeyboardKey_CG7, 107, C.LogicalKeyboardKey_3jH, 108, C.LogicalKeyboardKey_4iU, 109, C.LogicalKeyboardKey_oe4, 110, C.LogicalKeyboardKey_OLv, 111, C.LogicalKeyboardKey_sav, 112, C.LogicalKeyboardKey_M6L, 113, C.LogicalKeyboardKey_Ods, 114, C.LogicalKeyboardKey_qsN, 115, C.LogicalKeyboardKey_fLj, 116, C.LogicalKeyboardKey_V86, 117, C.LogicalKeyboardKey_Tng, 118, C.LogicalKeyboardKey_6Ng, 119, C.LogicalKeyboardKey_XaR, 120, C.LogicalKeyboardKey_ifx, 121, C.LogicalKeyboardKey_kQR, 122, C.LogicalKeyboardKey_W2D, 49, C.LogicalKeyboardKey_4AN, 50, C.LogicalKeyboardKey_mmo, 51, C.LogicalKeyboardKey_a7X, 52, C.LogicalKeyboardKey_e9s, 53, C.LogicalKeyboardKey_43h, 54, C.LogicalKeyboardKey_CmI, 55, C.LogicalKeyboardKey_Db0, 56, C.LogicalKeyboardKey_GZG, 57, C.LogicalKeyboardKey_86y, 48, C.LogicalKeyboardKey_0, 4295426088, C.LogicalKeyboardKey_4295426088_Enter_null, 4295426089, C.LogicalKeyboardKey_4295426089_Escape_null, 4295426090, C.LogicalKeyboardKey_4295426090_Backspace_null, 4295426091, C.LogicalKeyboardKey_4295426091_Tab_null, 32, C.LogicalKeyboardKey_YdN, 45, C.LogicalKeyboardKey_oEN, 61, C.LogicalKeyboardKey_wrE, 91, C.LogicalKeyboardKey_TLI, 93, C.LogicalKeyboardKey_awJ, 92, C.LogicalKeyboardKey_cdS, 59, C.LogicalKeyboardKey_atK, 39, C.LogicalKeyboardKey_Qo8, 96, C.LogicalKeyboardKey_7FR, 44, C.LogicalKeyboardKey_71T, 46, C.LogicalKeyboardKey_h8g, 47, C.LogicalKeyboardKey_ouN, 4295426105, C.LogicalKeyboardKey_OWF, 4295426106, C.LogicalKeyboardKey_4295426106_F1_null, 4295426107, C.LogicalKeyboardKey_4295426107_F2_null, 4295426108, C.LogicalKeyboardKey_4295426108_F3_null, 4295426109, C.LogicalKeyboardKey_4295426109_F4_null, 4295426110, C.LogicalKeyboardKey_4295426110_F5_null, 4295426111, C.LogicalKeyboardKey_4295426111_F6_null, 4295426112, C.LogicalKeyboardKey_4295426112_F7_null, 4295426113, C.LogicalKeyboardKey_4295426113_F8_null, 4295426114, C.LogicalKeyboardKey_4295426114_F9_null, 4295426115, C.LogicalKeyboardKey_4295426115_F10_null, 4295426116, C.LogicalKeyboardKey_4295426116_F11_null, 4295426117, C.LogicalKeyboardKey_4295426117_F12_null, 4295426118, C.LogicalKeyboardKey_wAl, 4295426119, C.LogicalKeyboardKey_ujM, 4295426120, C.LogicalKeyboardKey_4295426120_Pause_null, 4295426121, C.LogicalKeyboardKey_4295426121_Insert_null, 4295426122, C.LogicalKeyboardKey_4295426122_Home_null, 4295426123, C.LogicalKeyboardKey_mgB, 4295426124, C.LogicalKeyboardKey_4295426124_Delete_null, 4295426125, C.LogicalKeyboardKey_4295426125_End_null, 4295426126, C.LogicalKeyboardKey_wYn, 4295426127, C.LogicalKeyboardKey_CzM, 4295426128, C.LogicalKeyboardKey_muk, 4295426129, C.LogicalKeyboardKey_O7X, 4295426130, C.LogicalKeyboardKey_gCR, 4295426131, C.LogicalKeyboardKey_uHn, 4295426132, C.LogicalKeyboardKey_Npb, 4295426133, C.LogicalKeyboardKey_iOn, 4295426134, C.LogicalKeyboardKey_7xV, 4295426135, C.LogicalKeyboardKey_YaH, 4295426136, C.LogicalKeyboardKey_U2J, 4295426137, C.LogicalKeyboardKey_qsT, 4295426138, C.LogicalKeyboardKey_ka2, 4295426139, C.LogicalKeyboardKey_Ddz, 4295426140, C.LogicalKeyboardKey_YGD, 4295426141, C.LogicalKeyboardKey_s0r, 4295426142, C.LogicalKeyboardKey_atK0, 4295426143, C.LogicalKeyboardKey_3bB, 4295426144, C.LogicalKeyboardKey_sx4, 4295426145, C.LogicalKeyboardKey_4IJ, 4295426146, C.LogicalKeyboardKey_KQb, 4295426147, C.LogicalKeyboardKey_iXq, 4295426148, C.LogicalKeyboardKey_6vi, 4295426149, C.LogicalKeyboardKey_nDU, 4295426150, C.LogicalKeyboardKey_4295426150_Power_null, 4295426151, C.LogicalKeyboardKey_G2v, 4295426152, C.LogicalKeyboardKey_4295426152_F13_null, 4295426153, C.LogicalKeyboardKey_4295426153_F14_null, 4295426154, C.LogicalKeyboardKey_4295426154_F15_null, 4295426155, C.LogicalKeyboardKey_4295426155_F16_null, 4295426156, C.LogicalKeyboardKey_4295426156_F17_null, 4295426157, C.LogicalKeyboardKey_4295426157_F18_null, 4295426158, C.LogicalKeyboardKey_4295426158_F19_null, 4295426159, C.LogicalKeyboardKey_4295426159_F20_null, 4295426160, C.LogicalKeyboardKey_4295426160_F21_null, 4295426161, C.LogicalKeyboardKey_4295426161_F22_null, 4295426162, C.LogicalKeyboardKey_4295426162_F23_null, 4295426163, C.LogicalKeyboardKey_4295426163_F24_null, 4295426164, C.LogicalKeyboardKey_4295426164_Open_null, 4295426165, C.LogicalKeyboardKey_4295426165_Help_null, 4295426167, C.LogicalKeyboardKey_4295426167_Select_null, 4295426169, C.LogicalKeyboardKey_4295426169_Again_null, 4295426170, C.LogicalKeyboardKey_4295426170_Undo_null, 4295426171, C.LogicalKeyboardKey_4295426171_Cut_null, 4295426172, C.LogicalKeyboardKey_4295426172_Copy_null, 4295426173, C.LogicalKeyboardKey_4295426173_Paste_null, 4295426174, C.LogicalKeyboardKey_4295426174_Find_null, 4295426175, C.LogicalKeyboardKey_MjO, 4295426176, C.LogicalKeyboardKey_gap, 4295426177, C.LogicalKeyboardKey_c9P, 4295426181, C.LogicalKeyboardKey_CLo, 4295426183, C.LogicalKeyboardKey_iDZ, 4295426184, C.LogicalKeyboardKey_aBa, 4295426185, C.LogicalKeyboardKey_c0h, 4295426186, C.LogicalKeyboardKey_4295426186_Convert_null, 4295426187, C.LogicalKeyboardKey_sBE, 4295426192, C.LogicalKeyboardKey_nx9, 4295426193, C.LogicalKeyboardKey_nx90, 4295426194, C.LogicalKeyboardKey_nx91, 4295426195, C.LogicalKeyboardKey_nx92, 4295426196, C.LogicalKeyboardKey_nx93, 4295426203, C.LogicalKeyboardKey_4295426203_Abort_null, 4295426211, C.LogicalKeyboardKey_4295426211_Props_null, 4295426230, C.LogicalKeyboardKey_wEo, 4295426231, C.LogicalKeyboardKey_8Nr, 4295426235, C.LogicalKeyboardKey_MUx, 4295426256, C.LogicalKeyboardKey_2Zx, 4295426257, C.LogicalKeyboardKey_qqh, 4295426258, C.LogicalKeyboardKey_CxF, 4295426259, C.LogicalKeyboardKey_I9f, 4295426260, C.LogicalKeyboardKey_YQd, 4295426263, C.LogicalKeyboardKey_75N, 4295426264, C.LogicalKeyboardKey_U86, 4295426265, C.LogicalKeyboardKey_OBv, 4295426272, C.LogicalKeyboardKey_p6t, 4295426273, C.LogicalKeyboardKey_xok, 4295426274, C.LogicalKeyboardKey_PD9, 4295426275, C.LogicalKeyboardKey_D0U, 4295426276, C.LogicalKeyboardKey_ijl, 4295426277, C.LogicalKeyboardKey_QOu, 4295426278, C.LogicalKeyboardKey_EtP, 4295426279, C.LogicalKeyboardKey_O1c, 4295753824, C.LogicalKeyboardKey_4295753824_Info_null, 4295753825, C.LogicalKeyboardKey_ccN, 4295753839, C.LogicalKeyboardKey_Djg, 4295753840, C.LogicalKeyboardKey_ECL, 4295753842, C.LogicalKeyboardKey_B8J, 4295753843, C.LogicalKeyboardKey_kc1, 4295753844, C.LogicalKeyboardKey_kc10, 4295753845, C.LogicalKeyboardKey_HDR, 4295753859, C.LogicalKeyboardKey_Pz5, 4295753868, C.LogicalKeyboardKey_Ak1, 4295753869, C.LogicalKeyboardKey_wg3, 4295753876, C.LogicalKeyboardKey_4295753876_Exit_null, 4295753884, C.LogicalKeyboardKey_6QF, 4295753885, C.LogicalKeyboardKey_3J4, 4295753904, C.LogicalKeyboardKey_Azp, 4295753906, C.LogicalKeyboardKey_8eb, 4295753907, C.LogicalKeyboardKey_eEX, 4295753908, C.LogicalKeyboardKey_kQR0, 4295753909, C.LogicalKeyboardKey_n7o, 4295753910, C.LogicalKeyboardKey_kHV, 4295753911, C.LogicalKeyboardKey_wfl, 4295753912, C.LogicalKeyboardKey_4295753912_Eject_null, 4295753933, C.LogicalKeyboardKey_Cu4, 4295753935, C.LogicalKeyboardKey_Q5s, 4295753957, C.LogicalKeyboardKey_qNA, 4295754115, C.LogicalKeyboardKey_oPr, 4295754116, C.LogicalKeyboardKey_2Ly, 4295754118, C.LogicalKeyboardKey_8Gl, 4295754122, C.LogicalKeyboardKey_9gS, 4295754125, C.LogicalKeyboardKey_mqK, 4295754126, C.LogicalKeyboardKey_k44, 4295754130, C.LogicalKeyboardKey_00, 4295754132, C.LogicalKeyboardKey_01, 4295754134, C.LogicalKeyboardKey_zvr, 4295754140, C.LogicalKeyboardKey_D6Y, 4295754142, C.LogicalKeyboardKey_jmM, 4295754143, C.LogicalKeyboardKey_9hT, 4295754146, C.LogicalKeyboardKey_Dns, 4295754151, C.LogicalKeyboardKey_MIo, 4295754155, C.LogicalKeyboardKey_oCX, 4295754158, C.LogicalKeyboardKey_lCr, 4295754161, C.LogicalKeyboardKey_MYz, 4295754187, C.LogicalKeyboardKey_IQp, 4295754167, C.LogicalKeyboardKey_1oF, 4295754241, C.LogicalKeyboardKey_YSm, 4295754243, C.LogicalKeyboardKey_4295754243_Close_null, 4295754247, C.LogicalKeyboardKey_4295754247_Save_null, 4295754248, C.LogicalKeyboardKey_4295754248_Print_null, 4295754273, C.LogicalKeyboardKey_EWB, 4295754275, C.LogicalKeyboardKey_cEy, 4295754276, C.LogicalKeyboardKey_kKc, 4295754277, C.LogicalKeyboardKey_8pc, 4295754278, C.LogicalKeyboardKey_MYu, 4295754279, C.LogicalKeyboardKey_Un6, 4295754282, C.LogicalKeyboardKey_46S, 4295754285, C.LogicalKeyboardKey_0Rr, 4295754286, C.LogicalKeyboardKey_wIk, 4295754290, C.LogicalKeyboardKey_ijl0, 4295754361, C.LogicalKeyboardKey_4295754361_Redo_null, 4295754377, C.LogicalKeyboardKey_XHd, 4295754379, C.LogicalKeyboardKey_WpI, 4295754380, C.LogicalKeyboardKey_7aa, 4295754399, C.LogicalKeyboardKey_7eO], [P.int, G.LogicalKeyboardKey]);
    C.Map_yXAeS = new H.GeneralConstantMap([0, "FontWeight.w100", 1, "FontWeight.w200", 2, "FontWeight.w300", 3, "FontWeight.w400", 4, "FontWeight.w500", 5, "FontWeight.w600", 6, "FontWeight.w700", 7, "FontWeight.w800", 8, "FontWeight.w900"], [P.int, P.String]);
    C.MethodCall_popRoute_null = new T.MethodCall("popRoute", null);
    C.C_JSONMethodCodec0 = new U.JSONMethodCodec();
    C.MethodChannel_89P = new A.MethodChannel("flutter/navigation", C.C_JSONMethodCodec0);
    C.Offset_0_0 = new Q.Offset(0, 0);
    C.OptionalMethodChannel_cWd = new A.OptionalMethodChannel("flutter/platform", C.C_JSONMethodCodec0);
    C.PaintingStyle_0 = new Q.PaintingStyle("PaintingStyle.fill");
    C.PaintingStyle_1 = new Q.PaintingStyle("PaintingStyle.stroke");
    C.PersistedSurfaceState_0 = new T.PersistedSurfaceState("PersistedSurfaceState.created");
    C.PersistedSurfaceState_1 = new T.PersistedSurfaceState("PersistedSurfaceState.active");
    C.PersistedSurfaceState_2 = new T.PersistedSurfaceState("PersistedSurfaceState.pendingRetention");
    C.PersistedSurfaceState_3 = new T.PersistedSurfaceState("PersistedSurfaceState.pendingUpdate");
    C.PersistedSurfaceState_4 = new T.PersistedSurfaceState("PersistedSurfaceState.released");
    C.PointerChange_0 = new Q.PointerChange("PointerChange.cancel");
    C.PointerChange_1 = new Q.PointerChange("PointerChange.add");
    C.PointerChange_2 = new Q.PointerChange("PointerChange.remove");
    C.PointerChange_3 = new Q.PointerChange("PointerChange.hover");
    C.PointerChange_4 = new Q.PointerChange("PointerChange.down");
    C.PointerChange_5 = new Q.PointerChange("PointerChange.move");
    C.PointerChange_6 = new Q.PointerChange("PointerChange.up");
    C.PointerDeviceKind_0 = new Q.PointerDeviceKind("PointerDeviceKind.touch");
    C.PointerDeviceKind_1 = new Q.PointerDeviceKind("PointerDeviceKind.mouse");
    C.PointerDeviceKind_2 = new Q.PointerDeviceKind("PointerDeviceKind.stylus");
    C.PointerDeviceKind_3 = new Q.PointerDeviceKind("PointerDeviceKind.invertedStylus");
    C.PointerDeviceKind_4 = new Q.PointerDeviceKind("PointerDeviceKind.unknown");
    C.PointerSignalKind_0 = new Q.PointerSignalKind("PointerSignalKind.none");
    C.PointerSignalKind_1 = new Q.PointerSignalKind("PointerSignalKind.scroll");
    C.PointerSignalKind_2 = new Q.PointerSignalKind("PointerSignalKind.unknown");
    C.Rect_0_0_0_0 = new Q.Rect(0, 0, 0, 0);
    C.Rect_aha = new Q.Rect(-1000000000, -1000000000, 1000000000, 1000000000);
    C.RenderComparison_0 = new G.RenderComparison(0, "RenderComparison.identical");
    C.RenderComparison_1 = new G.RenderComparison(1, "RenderComparison.metadata");
    C.RenderComparison_2 = new G.RenderComparison(2, "RenderComparison.paint");
    C.RenderComparison_3 = new G.RenderComparison(3, "RenderComparison.layout");
    C.Role_0 = new T.Role("Role.incrementable");
    C.Role_1 = new T.Role("Role.scrollable");
    C.Role_2 = new T.Role("Role.labelAndValue");
    C.Role_3 = new T.Role("Role.tappable");
    C.Role_4 = new T.Role("Role.textField");
    C.Role_5 = new T.Role("Role.checkable");
    C.Role_6 = new T.Role("Role.image");
    C.Role_7 = new T.Role("Role.liveRegion");
    C.SchedulerPhase_0 = new N.SchedulerPhase("SchedulerPhase.idle");
    C.SchedulerPhase_1 = new N.SchedulerPhase("SchedulerPhase.transientCallbacks");
    C.SchedulerPhase_2 = new N.SchedulerPhase("SchedulerPhase.midFrameMicrotasks");
    C.SchedulerPhase_3 = new N.SchedulerPhase("SchedulerPhase.persistentCallbacks");
    C.SchedulerPhase_4 = new N.SchedulerPhase("SchedulerPhase.postFrameCallbacks");
    C.Size_0_0 = new Q.Size(0, 0);
    C.Size_100000_100000 = new Q.Size(100000, 100000);
    C.Symbol_call = new H.Symbol("call");
    C.TargetPlatform_0 = new T.TargetPlatform("TargetPlatform.android");
    C.TargetPlatform_1 = new T.TargetPlatform("TargetPlatform.fuchsia");
    C.TargetPlatform_2 = new T.TargetPlatform("TargetPlatform.iOS");
    C.TextAffinity_0 = new Q.TextAffinity("TextAffinity.upstream");
    C.TextAffinity_1 = new Q.TextAffinity("TextAffinity.downstream");
    C.TextAlign_0 = new Q.TextAlign("TextAlign.left");
    C.TextAlign_1 = new Q.TextAlign("TextAlign.right");
    C.TextAlign_2 = new Q.TextAlign("TextAlign.center");
    C.TextAlign_3 = new Q.TextAlign("TextAlign.justify");
    C.TextAlign_4 = new Q.TextAlign("TextAlign.start");
    C.TextAlign_5 = new Q.TextAlign("TextAlign.end");
    C.TextDirection_0 = new Q.TextDirection("TextDirection.rtl");
    C.TextDirection_1 = new Q.TextDirection("TextDirection.ltr");
    C.TextOverflow_0 = new Q.TextOverflow("TextOverflow.clip");
    C.TextOverflow_1 = new Q.TextOverflow("TextOverflow.fade");
    C.TextOverflow_2 = new Q.TextOverflow("TextOverflow.ellipsis");
    C.TextOverflow_3 = new Q.TextOverflow("TextOverflow.visible");
    C.TextPosition_0_TextAffinity_1 = new Q.TextPosition(0, C.TextAffinity_1);
    C.TextStyle_v9c = new A.TextStyle0(true, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    C.TextWidthBasis_0 = new U.TextWidthBasis("TextWidthBasis.parent");
    C.TileMode_0 = new Q.TileMode("TileMode.clamp");
    C.Type_ByteBuffer_RkP = H.createRuntimeType(P.ByteBuffer);
    C.Type_ByteData_zNC = H.createRuntimeType(P.ByteData);
    C.Type_DefaultTextStyle_ird = H.createRuntimeType(L.DefaultTextStyle);
    C.Type_Float32List_LB7 = H.createRuntimeType(P.Float32List);
    C.Type_Float64List_LB7 = H.createRuntimeType(P.Float64List);
    C.Type_Int16List_uXf = H.createRuntimeType(P.Int16List);
    C.Type_Int32List_O50 = H.createRuntimeType(P.Int32List);
    C.Type_Int8List_ekJ = H.createRuntimeType(P.Int8List);
    C.Type_JSObject_8k0 = H.createRuntimeType(J.JSObject);
    C.Type_MediaQuery_nDB = H.createRuntimeType(F.MediaQuery);
    C.Type_Null_Yyn = H.createRuntimeType(P.Null);
    C.Type_String_k8F = H.createRuntimeType(P.String);
    C.Type_Uint16List_2bx = H.createRuntimeType(P.Uint16List);
    C.Type_Uint32List_2bx = H.createRuntimeType(P.Uint32List);
    C.Type_Uint8ClampedList_Jik = H.createRuntimeType(P.Uint8ClampedList);
    C.Type_Uint8List_WLA = H.createRuntimeType(P.Uint8List);
    C.Type__LocalizationsScope_Lpb = H.createRuntimeType(L._LocalizationsScope);
    C.Type_bool_lhE = H.createRuntimeType(P.bool);
    C.Type_double_K1J = H.createRuntimeType(P.double);
    C.Type_int_tHn = H.createRuntimeType(P.int);
    C.Type_num_cv7 = H.createRuntimeType(P.num);
    C._CheckableKind_0 = new T._CheckableKind("_CheckableKind.checkbox");
    C._CheckableKind_1 = new T._CheckableKind("_CheckableKind.radio");
    C._CheckableKind_2 = new T._CheckableKind("_CheckableKind.toggle");
    C._ElementLifecycle_0 = new N._ElementLifecycle("_ElementLifecycle.initial");
    C._IterationMarker_null_2 = new P._IterationMarker(null, 2);
    C._WordWrapParseMode_0 = new Y._WordWrapParseMode("_WordWrapParseMode.inSpace");
    C._WordWrapParseMode_1 = new Y._WordWrapParseMode("_WordWrapParseMode.inWord");
    C._WordWrapParseMode_2 = new Y._WordWrapParseMode("_WordWrapParseMode.atBreak");
  })();
  var init = {mangledGlobalNames: {int: "int", double: "double", num: "num", String: "String", bool: "bool", Null: "Null", List: "List"}, mangledNames: {}, getTypeFromName: getGlobalFromName, metadata: [], types: [{func: 1, ret: P.Null}, {func: 1, ret: -1}, {func: 1, ret: P.Null, args: [W.Event]}, {func: 1, ret: -1, args: [,]}, {func: 1, ret: P.Null, args: [,]}, {func: 1, ret: P.Null, args: [,,]}, {func: 1, ret: [P.Future, -1]}, {func: 1, ret: P.Null, args: [N.Element]}, {func: 1, ret: P.String, args: [P.String]}, {func: 1, ret: -1, args: [P.String,,]}, {func: 1, ret: P.int, args: [K.RenderObject, K.RenderObject]}, {func: 1, ret: P.Null, args: [K.RenderObject]}, {func: 1, ret: P.Null, args: [P.ByteData]}, {func: 1, ret: -1, args: [N.Element]}, {func: 1, ret: -1, args: [{func: 1, ret: -1}]}, {func: 1, args: [,]}, {func: 1, ret: P.String, args: [P.int]}, {func: 1, ret: P.Null, args: [P.num]}, {func: 1, ret: P.bool, args: [Y.DiagnosticsNode]}, {func: 1, ret: [P.Future, [P.Map, P.String,,]], args: [[P.Map, P.String, P.String]]}, {func: 1, ret: P.bool, args: [P.int]}, {func: 1, ret: P.bool, args: [Q.TextSpan]}, {func: 1, ret: [P.Future, P.Null]}, {func: 1, ret: P.int, args: [A.SemanticsNode, A.SemanticsNode]}, {func: 1, ret: [P.Iterable, Y.DiagnosticsNode]}, {func: 1, ret: P.bool, args: [W.Element0, P.String, P.String, W._Html5NodeValidator]}, {func: 1, ret: -1, args: [P.Uint8List, P.String, P.int]}, {func: 1, ret: P.bool, args: [W.Node]}, {func: 1, ret: P.Null, args: [, P.StackTrace]}, {func: 1, ret: P.bool, args: [W.NodeValidator]}, {func: 1, ret: P.bool, args: [P.String]}, {func: 1, ret: -1, args: [P.Object], opt: [P.StackTrace]}, {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [P.String, [P.Map, P.String, P.String]]}, {func: 1, ret: P.int}, {func: 1, ret: -1, args: [Y.DiagnosticsNode]}, {func: 1, ret: [P.Iterable, [Y.DiagnosticsProperty, F.PointerEvent]]}, {func: 1, ret: P.Null, args: [P.Duration]}, {func: 1, ret: -1, args: [P.Duration]}, {func: 1, ret: -1, args: [P.Object]}, {func: 1, ret: P.bool, args: [A.SemanticsNode]}, {func: 1, ret: [P.Future, P.ByteData], args: [P.ByteData]}, {func: 1, ret: -1, args: [W.Event]}, {func: 1, ret: P.Null, args: [W.WheelEvent]}, {func: 1, ret: P.Null, args: [T.GestureMode]}, {func: 1, ret: P.Null, args: [-1]}, {func: 1, ret: P.int, args: [,,]}, {func: 1, ret: P.Null, args: [,], opt: [P.StackTrace]}, {func: 1, ret: [P.Iterable, [Y.DiagnosticsProperty, B.ChangeNotifier]]}, {func: 1, ret: -1, opt: [P.Object]}, {func: 1, ret: P.Null, args: [P.int,,]}, {func: 1, ret: -1, args: [B.AbstractNode]}, {func: 1, ret: -1, args: [Q.PointerDataPacket]}, {func: 1, args: [W.Event]}, {func: 1, ret: [P.Iterable, [Y.DiagnosticsProperty, P.Object]]}, {func: 1, ret: G._PointerState}, {func: 1, ret: -1, args: [F.PointerEvent]}, {func: 1, ret: P.Null, args: [P.String,,]}, {func: 1, ret: -1, args: [Y._TrackedAnnotation, P.int]}, {func: 1, ret: -1, args: [Y._TrackedAnnotation]}, {func: 1, ret: Y._TrackedAnnotation, args: [Y.MouseTrackerAnnotation]}, {func: 1, ret: P.String, args: [E.Vector4]}, {func: 1, ret: P.String, args: [P.double]}, {func: 1, ret: P.Null, args: [P.String]}, {func: 1, ret: Y.DiagnosticsNode, args: [Q.TextSpan]}, {func: 1, ret: -1, args: [P.int, Q.SemanticsAction, P.ByteData]}, {func: 1, ret: P.Uint8List, args: [P.int]}, {func: 1, ret: [P.Iterable, Y.MouseTrackerAnnotation], args: [Q.Offset]}, {func: 1, ret: [P._Future,,], args: [,]}, {func: 1, ret: -1, named: {curve: Z.Curve, descendant: K.RenderObject, duration: P.Duration, rect: Q.Rect}}, {func: 1, ret: -1, args: [P.String], opt: [,]}, {func: 1, ret: -1, args: [W.Node, W.Node]}, {func: 1, ret: A.SemanticsConfiguration, args: [P.int, P.int]}, {func: 1, ret: [P.Future, P.String], args: [P.String]}, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}, {func: 1, ret: P.Null, args: [P.int, N._FrameCallbackEntry]}, {func: 1, ret: A.SemanticsNode, args: [A._TraversalSortNode]}, {func: 1, ret: P.String, args: [Q.SemanticsAction]}, {func: 1, ret: P.String, args: [A.CustomSemanticsAction]}, {func: 1, ret: P.bool, args: [Q.SemanticsFlag]}, {func: 1, ret: P.String, args: [Q.SemanticsFlag]}, {func: 1, ret: Y.DiagnosticsNode, args: [A.SemanticsNode]}, {func: 1, ret: P.Null, args: [{func: 1, ret: -1}]}, {func: 1, ret: -1, args: [P.int]}, {func: 1, ret: P.int, args: [A.SemanticsNode]}, {func: 1, ret: A.SemanticsNode, args: [P.int]}, {func: 1, args: [,,]}, {func: 1, ret: [P.Stream, F.LicenseEntry]}, {func: 1, ret: W.Element0, args: [W.Node]}, {func: 1, ret: P.Null, args: [P.Symbol0,,]}, {func: 1, ret: [P.Future,,], args: [,]}, {func: 1, ret: B.KeyboardSide, args: [P.int, P.int]}, {func: 1, ret: B.KeyboardSide, args: [P.int, P.int, P.int]}, {func: 1, ret: -1, args: [P.String], named: {wrapWidth: P.int}}, {func: 1, ret: [P.Future, P.Null], args: [P.double]}, {func: 1, ret: [P.Future,,], args: [F.MethodCall0]}, {func: 1, ret: [P.Future, -1], args: [P.Object]}, {func: 1, ret: Y.DiagnosticsNode, args: [O.FocusNode]}, {func: 1, ret: -1, args: [B.RawKeyEvent]}, {func: 1, args: [, P.String]}, {func: 1, ret: -1, args: [P.String, P.int]}, {func: 1, ret: -1, args: [P.ByteData]}, {func: 1, ret: N.ErrorWidget, args: [U.FlutterErrorDetails]}, {func: 1, args: [P.String]}, {func: 1, ret: [P.Future,,]}, {func: 1, ret: P.Null, args: [P.Timer]}, {func: 1, ret: -1, args: [[P.List, Q.PointerData]]}, {func: 1, ret: U.ErrorDescription, args: [P.String]}, {func: 1, ret: -1, args: [W.WheelEvent]}, {func: 1, ret: P.String, args: [Y.DiagnosticsNode]}, {func: 1, ret: T.Incrementable, args: [T.SemanticsObject]}, {func: 1, ret: T.Scrollable, args: [T.SemanticsObject]}, {func: 1, ret: T.LabelAndValue, args: [T.SemanticsObject]}, {func: 1, ret: T.Tappable, args: [T.SemanticsObject]}, {func: 1, ret: T.TextField, args: [T.SemanticsObject]}, {func: 1, ret: T.Checkable, args: [T.SemanticsObject]}, {func: 1, ret: T.ImageRoleManager, args: [T.SemanticsObject]}, {func: 1, ret: T.LiveRegion, args: [T.SemanticsObject]}, {func: 1, ret: P.DateTime}, {func: 1, ret: P.int, args: [T._PaintRequest, T._PaintRequest]}, {func: 1, ret: -1, args: [T.PersistedSurface]}, {func: 1, ret: P.int, args: [T._PersistedSurfaceMatch, T._PersistedSurfaceMatch]}, {func: 1, ret: W.FontFaceSet, args: [W.FontFace]}, {func: 1, ret: P.int, args: [T.ParagraphRuler, T.ParagraphRuler]}, {func: 1, ret: -1, args: [T.EditingState]}, {func: 1, ret: P.Null, args: [W.ProgressEvent]}, {func: 1}, {func: 1, ret: P.int, args: [P.int, P.Object]}, {func: 1, ret: P.Uint8List, args: [,,]}, {func: 1, ret: P.int, args: [P.int, P.int]}, {func: 1, ret: -1, args: [P.String, P.String]}, {func: 1, ret: -1, args: [U.FlutterErrorDetails], named: {forceReport: P.bool}}, {func: 1, ret: [P.Iterable, P.String], args: [[P.Iterable, P.String]]}, {func: 1, ret: Y.DiagnosticsNode, args: [P.String]}, {func: 1, ret: P.int, args: [[N._TaskEntry,,], [N._TaskEntry,,]]}, {func: 1, ret: P.bool, named: {priority: P.int, scheduler: N.SchedulerBinding}}, {func: 1, ret: [P.List, F.LicenseEntry], args: [P.String]}, {func: 1, ret: [P.Future, -1], args: [P.String, P.ByteData, {func: 1, ret: -1, args: [P.ByteData]}]}, {func: 1, ret: P.int, args: [N.Element, N.Element]}, {func: 1, ret: Y.DiagnosticsNode, args: [N.InheritedElement]}, {func: 1, ret: [P.Future, P.double]}], interceptorsByTag: null, leafTags: null};
  (function staticFields() {
    $.Primitives_timerFrequency = null;
    $.Primitives_timerTicks = null;
    $.Closure_functionCounter = 0;
    $.BoundClosure_selfFieldNameCache = null;
    $.BoundClosure_receiverFieldNameCache = null;
    $._inTypeAssertion = false;
    $.getTagFunction = null;
    $.alternateTagFunction = null;
    $.prototypeForTagFunction = null;
    $.dispatchRecordsForInstanceTags = null;
    $.interceptorsForUncacheableTags = null;
    $.initNativeDispatchFlag = null;
    $._nextCallback = null;
    $._lastCallback = null;
    $._lastPriorityCallback = null;
    $._isInCallbackLoop = false;
    $.Zone__current = C.C__RootZone;
    $._toStringVisiting = [];
    $.Stopwatch__frequency = null;
    $.Element__parseDocument = null;
    $.Element__parseRange = null;
    $.Element__defaultValidator = null;
    $.Element__defaultSanitizer = null;
    $._Html5NodeValidator__attributeValidators = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.Function);
    $.Device__isOpera = null;
    $.Device__isIE = null;
    $.Device__isFirefox = null;
    $.Device__cachedCssPrefix = null;
    $.FlutterError__errorCount = 0;
    $.LicenseRegistry__collectors = null;
    $._debugPrintedCharacters = 0;
    $._debugPrintCompleter = null;
    $._debugPrintScheduled = false;
    $._PointerState__pointerCount = 0;
    $.PointerEventConverter__pointers = P.LinkedHashMap_LinkedHashMap$_empty(P.int, G._PointerState);
    $.RendererBinding__instance = null;
    $._SemanticsGeometry__transformRectTransform = null;
    $._timeDilation = 1;
    $.SchedulerBinding__instance = null;
    $.CustomSemanticsAction__nextId = 0;
    $.CustomSemanticsAction__actions = P.LinkedHashMap_LinkedHashMap$_empty(P.int, A.CustomSemanticsAction);
    $.CustomSemanticsAction__ids = P.LinkedHashMap_LinkedHashMap$_empty(A.CustomSemanticsAction, P.int);
    $.SemanticsNode__lastIdentifier = 0;
    $.BinaryMessages__handlers = P.LinkedHashMap_LinkedHashMap$_empty(P.String, {func: 1, ret: [P.Future, P.ByteData], args: [P.ByteData]});
    $.BinaryMessages__mockHandlers = P.LinkedHashMap_LinkedHashMap$_empty(P.String, {func: 1, ret: [P.Future, P.ByteData], args: [P.ByteData]});
    $.WidgetsBinding__instance = null;
    $.debugProfileBuildsEnabled = false;
    $.GlobalKey__registry = P.LinkedHashMap_LinkedHashMap$_empty([N.GlobalKey, [N.State, N.StatefulWidget]], N.Element);
    $.Element__nextHashCode = 1;
    $._engineInitialized = false;
    $._hotRestartListeners = H.setRuntimeTypeInfo([], [{func: 1, ret: -1}]);
    $._browserEngine = null;
    $._originState = P.LinkedHashMap_LinkedHashMap$_literal(["origin", true], P.String, P.bool);
    $._flutterState = P.LinkedHashMap_LinkedHashMap$_literal(["flutter", true], P.String, P.bool);
    $.Keyboard__instance = null;
    $.PointerBinding__instance = null;
    $.BaseAdapter__listeners = P.LinkedHashMap_LinkedHashMap$_empty(P.String, {func: 1, args: [W.Event]});
    $._isWheelDeviceAdded = false;
    $.AccessibilityAnnouncements__instance = null;
    $.EngineSemanticsOwner__instance = null;
    $._recycledCanvases = H.setRuntimeTypeInfo([], [T.BitmapCanvas]);
    $._paintQueue = H.setRuntimeTypeInfo([], [T._PaintRequest]);
    $._frameReferences = H.setRuntimeTypeInfo([], [[T.FrameReference,,]]);
    $._retainedSurfaces = H.setRuntimeTypeInfo([], [T.PersistedSurface]);
    $.TextMeasurementService_rulerManager = null;
    $.DomTextMeasurementService__instance = null;
    $._lastStart = -1;
    $._lastEnd = -1;
    $._lastText = "";
    $._lastWidth = -1;
    $.SceneBuilder__lastFrameScene = null;
    $._assetManager = null;
    $._fontCollection = null;
    $._webOnlyIsInitialized = false;
    $.webOnlyScheduleFrameCallback = null;
  })();
  (function lazyInitializers() {
    var _lazy = hunkHelpers.lazy;
    _lazy($, "DART_CLOSURE_PROPERTY_NAME", "$get$DART_CLOSURE_PROPERTY_NAME", function() {
      return H.getIsolateAffinityTag("_$dart_dartClosure");
    });
    _lazy($, "JS_INTEROP_INTERCEPTOR_TAG", "$get$JS_INTEROP_INTERCEPTOR_TAG", function() {
      return H.getIsolateAffinityTag("_$dart_js");
    });
    _lazy($, "TypeErrorDecoder_noSuchMethodPattern", "$get$TypeErrorDecoder_noSuchMethodPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({
        toString: function() {
          return "$receiver$";
        }
      }));
    });
    _lazy($, "TypeErrorDecoder_notClosurePattern", "$get$TypeErrorDecoder_notClosurePattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null,
        toString: function() {
          return "$receiver$";
        }
      }));
    });
    _lazy($, "TypeErrorDecoder_nullCallPattern", "$get$TypeErrorDecoder_nullCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
    });
    _lazy($, "TypeErrorDecoder_nullLiteralCallPattern", "$get$TypeErrorDecoder_nullLiteralCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        var $argumentsExpr$ = '$arguments$';
        try {
          null.$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_undefinedCallPattern", "$get$TypeErrorDecoder_undefinedCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
    });
    _lazy($, "TypeErrorDecoder_undefinedLiteralCallPattern", "$get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        var $argumentsExpr$ = '$arguments$';
        try {
          (void 0).$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_nullPropertyPattern", "$get$TypeErrorDecoder_nullPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
    });
    _lazy($, "TypeErrorDecoder_nullLiteralPropertyPattern", "$get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        try {
          null.$method$;
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_undefinedPropertyPattern", "$get$TypeErrorDecoder_undefinedPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
    });
    _lazy($, "TypeErrorDecoder_undefinedLiteralPropertyPattern", "$get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        try {
          (void 0).$method$;
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "_AsyncRun__scheduleImmediateClosure", "$get$_AsyncRun__scheduleImmediateClosure", function() {
      return P._AsyncRun__initializeScheduleImmediate();
    });
    _lazy($, "Future__nullFuture", "$get$Future__nullFuture", function() {
      return P._Future$zoneValue(null, C.C__RootZone, P.Null);
    });
    _lazy($, "Utf8Decoder__decoder", "$get$Utf8Decoder__decoder", function() {
      return P.Utf8Decoder__makeDecoder();
    });
    _lazy($, "_Base64Decoder__inverseAlphabet", "$get$_Base64Decoder__inverseAlphabet", function() {
      return H.NativeInt8List__create1(H._ensureNativeList(H.setRuntimeTypeInfo([-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -1, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2], [P.int])));
    });
    _lazy($, "_Uri__needsNoEncoding", "$get$_Uri__needsNoEncoding", function() {
      return P.RegExp_RegExp("^[\\-\\.0-9A-Z_a-z~]*$");
    });
    _lazy($, "_scannerTables", "$get$_scannerTables", function() {
      return P._createTables();
    });
    _lazy($, "_extensions", "$get$_extensions", function() {
      return H.JsLinkedHashMap_JsLinkedHashMap$es6(P.String, {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [P.String, [P.Map, P.String, P.String]]});
    });
    _lazy($, "Timeline__stack", "$get$Timeline__stack", function() {
      return H.setRuntimeTypeInfo([], [P._SyncBlock]);
    });
    _lazy($, "CssStyleDeclaration__propertyCache", "$get$CssStyleDeclaration__propertyCache", function() {
      return {};
    });
    _lazy($, "_Html5NodeValidator__allowedElements", "$get$_Html5NodeValidator__allowedElements", function() {
      return P.LinkedHashSet_LinkedHashSet$from(["A", "ABBR", "ACRONYM", "ADDRESS", "AREA", "ARTICLE", "ASIDE", "AUDIO", "B", "BDI", "BDO", "BIG", "BLOCKQUOTE", "BR", "BUTTON", "CANVAS", "CAPTION", "CENTER", "CITE", "CODE", "COL", "COLGROUP", "COMMAND", "DATA", "DATALIST", "DD", "DEL", "DETAILS", "DFN", "DIR", "DIV", "DL", "DT", "EM", "FIELDSET", "FIGCAPTION", "FIGURE", "FONT", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "HEADER", "HGROUP", "HR", "I", "IFRAME", "IMG", "INPUT", "INS", "KBD", "LABEL", "LEGEND", "LI", "MAP", "MARK", "MENU", "METER", "NAV", "NOBR", "OL", "OPTGROUP", "OPTION", "OUTPUT", "P", "PRE", "PROGRESS", "Q", "S", "SAMP", "SECTION", "SELECT", "SMALL", "SOURCE", "SPAN", "STRIKE", "STRONG", "SUB", "SUMMARY", "SUP", "TABLE", "TBODY", "TD", "TEXTAREA", "TFOOT", "TH", "THEAD", "TIME", "TR", "TRACK", "TT", "U", "UL", "VAR", "VIDEO", "WBR"], P.String);
    });
    _lazy($, "Endian_host", "$get$Endian_host", function() {
      var t1 = H.NativeUint16List__create1(H._ensureNativeList(H.setRuntimeTypeInfo([1], [P.int]))).buffer;
      t1.toString;
      return H.NativeByteData_NativeByteData$view(t1, 0, null).getInt8(0) === 1 ? C.C_Endian : C.C_Endian0;
    });
    _lazy($, "sparseTextConfiguration", "$get$sparseTextConfiguration", function() {
      return Y.TextTreeConfiguration$(true, "", ":", "", "", "", "", "", true, false, "\n", true, "\u2502", "", "\u2514\u2500", "\u251c\u2500", " ", " ", "\u2502 ", "  ", "", true, "");
    });
    _lazy($, "dashedTextConfiguration", "$get$dashedTextConfiguration", function() {
      return Y.TextTreeConfiguration$(true, "", ":", "", "", "", "", "", true, false, "\n", true, "\u254e", "", "\u2514\u254c", "\u254e\u254c", " ", " ", "\u2502 ", "  ", "", true, "");
    });
    _lazy($, "denseTextConfiguration", "$get$denseTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, "", ":", ")", "", "(", "", "", false, false, "\n", false, "\u2502", "", "\u2514", "\u251c", "", "", "\u2502", " ", ", ", true, "");
    });
    _lazy($, "transitionTextConfiguration", "$get$transitionTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, ":", " \u2550\u2550\u2550", "", "", "", "  ", " \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550", false, true, "\n", true, "\u2502", "", "\u2558\u2550\u2566\u2550\u2550 ", "\u255e\u2550\u2566\u2550\u2550 ", " \u2551 ", "", "", "", "", true, "");
    });
    _lazy($, "errorTextConfiguration", "$get$errorTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, "", ":", "", "\u2550\u2550\u2561 ", "", "", " \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550", false, false, "\n", true, "\u2502", "\u2550\u2550\u2550\u2550\u2550", "\u2558\u2550\u2566", "\u255e\u2550\u2566", " \u2551 ", "", "", "", "", true, " \u255e\u2550\u2550");
    });
    _lazy($, "whitespaceTextConfiguration", "$get$whitespaceTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, ":", ":", "", "", "", "", "", false, false, "\n", true, " ", "", "", "", " ", "  ", "", "", "", true, "");
    });
    _lazy($, "flatTextConfiguration", "$get$flatTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, ":", ":", "", "", "", "", "", false, false, "\n", true, "", "", "", "", "", "", "", "", "", true, "");
    });
    _lazy($, "singleLineTextConfiguration", "$get$singleLineTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, "", ":", ")", "", "(", "", "", true, false, "", false, "", "", "", "", "", "", "  ", "  ", ", ", false, "");
    });
    _lazy($, "errorPropertyTextConfiguration", "$get$errorPropertyTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, "", ":", ")", "", "(", "", "", true, true, "\n", false, "", "", "", "", "", "", "  ", "  ", ", ", false, "");
    });
    _lazy($, "shallowTextConfiguration", "$get$shallowTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, ":", ":", "", "", "", "", "", false, false, "\n", true, " ", "", "", "", " ", "  ", "", "", "", false, "");
    });
    _lazy($, "_debugPrintBuffer", "$get$_debugPrintBuffer", function() {
      return P.ListQueue$(P.String);
    });
    _lazy($, "_debugPrintStopwatch", "$get$_debugPrintStopwatch", function() {
      return P.Stopwatch$();
    });
    _lazy($, "RenderErrorBox_textStyle", "$get$RenderErrorBox_textStyle", function() {
      var _null = null;
      return Q.TextStyle$(_null, C.Color_4294967142, _null, _null, _null, _null, "monospace", _null, 14, _null, C.FontWeight_6, _null, _null, _null, _null, _null, _null, _null);
    });
    _lazy($, "RenderErrorBox_paragraphStyle", "$get$RenderErrorBox_paragraphStyle", function() {
      var _null = null;
      return Q.ParagraphStyle$(_null, _null, _null, _null, _null, 1, _null, _null, _null, _null, _null);
    });
    _lazy($, "SemanticsNode__kEmptyConfig", "$get$SemanticsNode__kEmptyConfig", function() {
      return A.SemanticsConfiguration$();
    });
    _lazy($, "SemanticsNode__kEmptyChildList", "$get$SemanticsNode__kEmptyChildList", function() {
      return H.NativeInt32List_NativeInt32List(0);
    });
    _lazy($, "SemanticsNode__kEmptyCustomSemanticsActionsList", "$get$SemanticsNode__kEmptyCustomSemanticsActionsList", function() {
      return H.NativeInt32List_NativeInt32List(0);
    });
    _lazy($, "SemanticsNode__kIdentityTransform", "$get$SemanticsNode__kIdentityTransform", function() {
      return E.Matrix4_Matrix4$identity()._m4storage;
    });
    _lazy($, "rootBundle", "$get$rootBundle", function() {
      var t1 = P.String;
      return new Q.PlatformAssetBundle(P.LinkedHashMap_LinkedHashMap$_empty(t1, [P.Future, P.String]), P.LinkedHashMap_LinkedHashMap$_empty(t1, [P.Future,,]));
    });
    _lazy($, "RawKeyboard_instance", "$get$RawKeyboard_instance", function() {
      var t1 = new B.RawKeyboard(H.setRuntimeTypeInfo([], [{func: 1, ret: -1, args: [B.RawKeyEvent]}]), P.LinkedHashSet_LinkedHashSet$_empty(G.LogicalKeyboardKey));
      C.BasicMessageChannel_Cfi.setMessageHandler$1(t1.get$_handleKeyEvent());
      return t1;
    });
    _lazy($, "ErrorWidget_builder", "$get$ErrorWidget_builder", function() {
      return new N.ErrorWidget_closure();
    });
    _lazy($, "domRenderer", "$get$domRenderer", function() {
      var t2, t3, t4,
        t1 = new T.DomRenderer(W.document().body);
      t1.reset$0(0);
      t2 = $.TextMeasurementService_rulerManager;
      if (t2 != null)
        t2.dispose$0();
      $.TextMeasurementService_rulerManager = null;
      t2 = W.Element_Element$tag("flt-ruler-host");
      t3 = new T.RulerManager(10, t2, P.LinkedHashMap_LinkedHashMap$_empty(T.ParagraphGeometricStyle, T.ParagraphRuler));
      t4 = t2.style;
      (t4 && C.CssStyleDeclaration_methods).set$position(t4, "fixed");
      C.CssStyleDeclaration_methods.set$visibility(t4, "hidden");
      C.CssStyleDeclaration_methods.set$overflow(t4, "hidden");
      C.CssStyleDeclaration_methods.set$top(t4, "0");
      C.CssStyleDeclaration_methods.set$left(t4, "0");
      C.CssStyleDeclaration_methods.set$width(t4, "0");
      C.CssStyleDeclaration_methods.set$height(t4, "0");
      W.document().body.appendChild(t2);
      T.registerHotRestartListener(t3.get$dispose());
      $.TextMeasurementService_rulerManager = t3;
      return t1;
    });
    _lazy($, "platformViewRegistry", "$get$platformViewRegistry", function() {
      return new T.PlatformViewRegistry(P.LinkedHashMap_LinkedHashMap$_empty(P.String, {func: 1, ret: W.Element0, args: [P.int]}), P.LinkedHashMap_LinkedHashMap$_empty(P.int, W.Element0));
    });
    _lazy($, "accessibilityAnnouncements", "$get$accessibilityAnnouncements", function() {
      var t1 = $.AccessibilityAnnouncements__instance;
      return t1 == null ? $.AccessibilityAnnouncements__instance = T.AccessibilityAnnouncements$_() : t1;
    });
    _lazy($, "_roleFactories", "$get$_roleFactories", function() {
      return P.LinkedHashMap_LinkedHashMap$_literal([C.Role_0, new T.closure(), C.Role_1, new T.closure0(), C.Role_2, new T.closure1(), C.Role_3, new T.closure2(), C.Role_4, new T.closure3(), C.Role_5, new T.closure4(), C.Role_6, new T.closure5(), C.Role_7, new T.closure6()], T.Role, {func: 1, ret: T.RoleManager, args: [T.SemanticsObject]});
    });
    _lazy($, "supportsFontLoadingApi", "$get$supportsFontLoadingApi", function() {
      return W.document().fonts != null;
    });
    _lazy($, "textEditing", "$get$textEditing", function() {
      return new T.HybridTextEditing(T.TextEditingElement$());
    });
    _lazy($, "window", "$get$window", function() {
      return new T.EngineWindow(C.Size_0_0, new T.BrowserHistory(), new Q.AccessibilityFeatures(0), null);
    });
    _lazy($, "ParagraphBuilder__paragraphBuilderPop", "$get$ParagraphBuilder__paragraphBuilderPop", function() {
      return new P.Object();
    });
  })();
  (function nativeSupport() {
    !function() {
      var intern = function(s) {
        var o = {};
        o[s] = 1;
        return Object.keys(hunkHelpers.convertToFastObject(o))[0];
      };
      init.getIsolateTag = function(name) {
        return intern("___dart_" + name + init.isolateTag);
      };
      var tableProperty = "___dart_isolate_tags_";
      var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
      var rootProperty = "_ZxYxX";
      for (var i = 0;; i++) {
        var property = intern(rootProperty + "_" + i + "_");
        if (!(property in usedProperties)) {
          usedProperties[property] = 1;
          init.isolateTag = property;
          break;
        }
      }
      init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
    }();
    hunkHelpers.setOrUpdateInterceptorsByTag({AnimationEffectReadOnly: J.Interceptor, AnimationEffectTiming: J.Interceptor, AnimationEffectTimingReadOnly: J.Interceptor, AnimationTimeline: J.Interceptor, AnimationWorkletGlobalScope: J.Interceptor, AuthenticatorAssertionResponse: J.Interceptor, AuthenticatorAttestationResponse: J.Interceptor, AuthenticatorResponse: J.Interceptor, BackgroundFetchFetch: J.Interceptor, BackgroundFetchManager: J.Interceptor, BackgroundFetchSettledFetch: J.Interceptor, BarProp: J.Interceptor, BarcodeDetector: J.Interceptor, BluetoothRemoteGATTDescriptor: J.Interceptor, Body: J.Interceptor, BudgetState: J.Interceptor, CacheStorage: J.Interceptor, CanvasGradient: J.Interceptor, CanvasPattern: J.Interceptor, Client: J.Interceptor, Clients: J.Interceptor, CookieStore: J.Interceptor, Coordinates: J.Interceptor, Credential: J.Interceptor, CredentialUserData: J.Interceptor, CredentialsContainer: J.Interceptor, Crypto: J.Interceptor, CryptoKey: J.Interceptor, CSS: J.Interceptor, CSSVariableReferenceValue: J.Interceptor, CustomElementRegistry: J.Interceptor, DataTransfer: J.Interceptor, DataTransferItem: J.Interceptor, DeprecatedStorageInfo: J.Interceptor, DeprecatedStorageQuota: J.Interceptor, DetectedBarcode: J.Interceptor, DetectedFace: J.Interceptor, DetectedText: J.Interceptor, DeviceAcceleration: J.Interceptor, DeviceRotationRate: J.Interceptor, DirectoryEntry: J.Interceptor, DirectoryReader: J.Interceptor, DocumentOrShadowRoot: J.Interceptor, DocumentTimeline: J.Interceptor, DOMImplementation: J.Interceptor, Iterator: J.Interceptor, DOMMatrix: J.Interceptor, DOMMatrixReadOnly: J.Interceptor, DOMParser: J.Interceptor, DOMPoint: J.Interceptor, DOMPointReadOnly: J.Interceptor, DOMQuad: J.Interceptor, DOMStringMap: J.Interceptor, Entry: J.Interceptor, External: J.Interceptor, FaceDetector: J.Interceptor, FederatedCredential: J.Interceptor, FileEntry: J.Interceptor, DOMFileSystem: J.Interceptor, FontFaceSource: J.Interceptor, FormData: J.Interceptor, GamepadButton: J.Interceptor, GamepadPose: J.Interceptor, Geolocation: J.Interceptor, Position: J.Interceptor, Headers: J.Interceptor, HTMLHyperlinkElementUtils: J.Interceptor, IdleDeadline: J.Interceptor, ImageBitmap: J.Interceptor, ImageBitmapRenderingContext: J.Interceptor, ImageCapture: J.Interceptor, InputDeviceCapabilities: J.Interceptor, IntersectionObserver: J.Interceptor, IntersectionObserverEntry: J.Interceptor, KeyframeEffect: J.Interceptor, KeyframeEffectReadOnly: J.Interceptor, MediaCapabilities: J.Interceptor, MediaCapabilitiesInfo: J.Interceptor, MediaDeviceInfo: J.Interceptor, MediaKeyStatusMap: J.Interceptor, MediaKeySystemAccess: J.Interceptor, MediaKeys: J.Interceptor, MediaKeysPolicy: J.Interceptor, MediaMetadata: J.Interceptor, MediaSession: J.Interceptor, MediaSettingsRange: J.Interceptor, MemoryInfo: J.Interceptor, MessageChannel: J.Interceptor, Metadata: J.Interceptor, MutationObserver: J.Interceptor, WebKitMutationObserver: J.Interceptor, MutationRecord: J.Interceptor, NavigationPreloadManager: J.Interceptor, Navigator: J.Interceptor, NavigatorAutomationInformation: J.Interceptor, NavigatorConcurrentHardware: J.Interceptor, NavigatorCookies: J.Interceptor, NodeFilter: J.Interceptor, NodeIterator: J.Interceptor, NonDocumentTypeChildNode: J.Interceptor, NonElementParentNode: J.Interceptor, NoncedElement: J.Interceptor, OffscreenCanvasRenderingContext2D: J.Interceptor, PaintRenderingContext2D: J.Interceptor, PaintSize: J.Interceptor, PaintWorkletGlobalScope: J.Interceptor, PasswordCredential: J.Interceptor, Path2D: J.Interceptor, PaymentAddress: J.Interceptor, PaymentInstruments: J.Interceptor, PaymentManager: J.Interceptor, PaymentResponse: J.Interceptor, PerformanceEntry: J.Interceptor, PerformanceLongTaskTiming: J.Interceptor, PerformanceMark: J.Interceptor, PerformanceMeasure: J.Interceptor, PerformanceNavigation: J.Interceptor, PerformanceNavigationTiming: J.Interceptor, PerformanceObserver: J.Interceptor, PerformanceObserverEntryList: J.Interceptor, PerformancePaintTiming: J.Interceptor, PerformanceResourceTiming: J.Interceptor, PerformanceServerTiming: J.Interceptor, PerformanceTiming: J.Interceptor, Permissions: J.Interceptor, PhotoCapabilities: J.Interceptor, Presentation: J.Interceptor, PresentationReceiver: J.Interceptor, PublicKeyCredential: J.Interceptor, PushManager: J.Interceptor, PushMessageData: J.Interceptor, PushSubscription: J.Interceptor, PushSubscriptionOptions: J.Interceptor, Range: J.Interceptor, RelatedApplication: J.Interceptor, ReportingObserver: J.Interceptor, ResizeObserver: J.Interceptor, ResizeObserverEntry: J.Interceptor, RTCCertificate: J.Interceptor, RTCIceCandidate: J.Interceptor, mozRTCIceCandidate: J.Interceptor, RTCLegacyStatsReport: J.Interceptor, RTCRtpContributingSource: J.Interceptor, RTCRtpReceiver: J.Interceptor, RTCRtpSender: J.Interceptor, RTCSessionDescription: J.Interceptor, mozRTCSessionDescription: J.Interceptor, RTCStatsResponse: J.Interceptor, Screen: J.Interceptor, ScrollState: J.Interceptor, ScrollTimeline: J.Interceptor, Selection: J.Interceptor, SharedArrayBuffer: J.Interceptor, SpeechRecognitionAlternative: J.Interceptor, SpeechSynthesisVoice: J.Interceptor, StaticRange: J.Interceptor, StorageManager: J.Interceptor, StyleMedia: J.Interceptor, StylePropertyMap: J.Interceptor, StylePropertyMapReadonly: J.Interceptor, SyncManager: J.Interceptor, TaskAttributionTiming: J.Interceptor, TextDetector: J.Interceptor, TextMetrics: J.Interceptor, TrackDefault: J.Interceptor, TreeWalker: J.Interceptor, TrustedHTML: J.Interceptor, TrustedScriptURL: J.Interceptor, TrustedURL: J.Interceptor, UnderlyingSourceBase: J.Interceptor, URLSearchParams: J.Interceptor, VRCoordinateSystem: J.Interceptor, VRDisplayCapabilities: J.Interceptor, VREyeParameters: J.Interceptor, VRFrameData: J.Interceptor, VRFrameOfReference: J.Interceptor, VRPose: J.Interceptor, VRStageBounds: J.Interceptor, VRStageBoundsPoint: J.Interceptor, VRStageParameters: J.Interceptor, ValidityState: J.Interceptor, VideoPlaybackQuality: J.Interceptor, VideoTrack: J.Interceptor, VTTRegion: J.Interceptor, WindowClient: J.Interceptor, WorkletAnimation: J.Interceptor, WorkletGlobalScope: J.Interceptor, XPathEvaluator: J.Interceptor, XPathExpression: J.Interceptor, XPathNSResolver: J.Interceptor, XPathResult: J.Interceptor, XMLSerializer: J.Interceptor, XSLTProcessor: J.Interceptor, Bluetooth: J.Interceptor, BluetoothCharacteristicProperties: J.Interceptor, BluetoothRemoteGATTServer: J.Interceptor, BluetoothRemoteGATTService: J.Interceptor, BluetoothUUID: J.Interceptor, BudgetService: J.Interceptor, Cache: J.Interceptor, DOMFileSystemSync: J.Interceptor, DirectoryEntrySync: J.Interceptor, DirectoryReaderSync: J.Interceptor, EntrySync: J.Interceptor, FileEntrySync: J.Interceptor, FileReaderSync: J.Interceptor, FileWriterSync: J.Interceptor, HTMLAllCollection: J.Interceptor, Mojo: J.Interceptor, MojoHandle: J.Interceptor, MojoWatcher: J.Interceptor, NFC: J.Interceptor, PagePopupController: J.Interceptor, Report: J.Interceptor, Request: J.Interceptor, Response: J.Interceptor, SubtleCrypto: J.Interceptor, USBAlternateInterface: J.Interceptor, USBConfiguration: J.Interceptor, USBDevice: J.Interceptor, USBEndpoint: J.Interceptor, USBInTransferResult: J.Interceptor, USBInterface: J.Interceptor, USBIsochronousInTransferPacket: J.Interceptor, USBIsochronousInTransferResult: J.Interceptor, USBIsochronousOutTransferPacket: J.Interceptor, USBIsochronousOutTransferResult: J.Interceptor, USBOutTransferResult: J.Interceptor, WorkerLocation: J.Interceptor, WorkerNavigator: J.Interceptor, Worklet: J.Interceptor, IDBCursor: J.Interceptor, IDBCursorWithValue: J.Interceptor, IDBFactory: J.Interceptor, IDBIndex: J.Interceptor, IDBKeyRange: J.Interceptor, IDBObjectStore: J.Interceptor, IDBObservation: J.Interceptor, IDBObserver: J.Interceptor, IDBObserverChanges: J.Interceptor, SVGAngle: J.Interceptor, SVGAnimatedAngle: J.Interceptor, SVGAnimatedBoolean: J.Interceptor, SVGAnimatedEnumeration: J.Interceptor, SVGAnimatedInteger: J.Interceptor, SVGAnimatedLength: J.Interceptor, SVGAnimatedLengthList: J.Interceptor, SVGAnimatedNumber: J.Interceptor, SVGAnimatedNumberList: J.Interceptor, SVGAnimatedPreserveAspectRatio: J.Interceptor, SVGAnimatedRect: J.Interceptor, SVGAnimatedString: J.Interceptor, SVGAnimatedTransformList: J.Interceptor, SVGMatrix: J.Interceptor, SVGPoint: J.Interceptor, SVGPreserveAspectRatio: J.Interceptor, SVGRect: J.Interceptor, SVGUnitTypes: J.Interceptor, AudioListener: J.Interceptor, AudioParam: J.Interceptor, AudioTrack: J.Interceptor, AudioWorkletGlobalScope: J.Interceptor, AudioWorkletProcessor: J.Interceptor, PeriodicWave: J.Interceptor, WebGLActiveInfo: J.Interceptor, ANGLEInstancedArrays: J.Interceptor, ANGLE_instanced_arrays: J.Interceptor, WebGLBuffer: J.Interceptor, WebGLCanvas: J.Interceptor, WebGLColorBufferFloat: J.Interceptor, WebGLCompressedTextureASTC: J.Interceptor, WebGLCompressedTextureATC: J.Interceptor, WEBGL_compressed_texture_atc: J.Interceptor, WebGLCompressedTextureETC1: J.Interceptor, WEBGL_compressed_texture_etc1: J.Interceptor, WebGLCompressedTextureETC: J.Interceptor, WebGLCompressedTexturePVRTC: J.Interceptor, WEBGL_compressed_texture_pvrtc: J.Interceptor, WebGLCompressedTextureS3TC: J.Interceptor, WEBGL_compressed_texture_s3tc: J.Interceptor, WebGLCompressedTextureS3TCsRGB: J.Interceptor, WebGLDebugRendererInfo: J.Interceptor, WEBGL_debug_renderer_info: J.Interceptor, WebGLDebugShaders: J.Interceptor, WEBGL_debug_shaders: J.Interceptor, WebGLDepthTexture: J.Interceptor, WEBGL_depth_texture: J.Interceptor, WebGLDrawBuffers: J.Interceptor, WEBGL_draw_buffers: J.Interceptor, EXTsRGB: J.Interceptor, EXT_sRGB: J.Interceptor, EXTBlendMinMax: J.Interceptor, EXT_blend_minmax: J.Interceptor, EXTColorBufferFloat: J.Interceptor, EXTColorBufferHalfFloat: J.Interceptor, EXTDisjointTimerQuery: J.Interceptor, EXTDisjointTimerQueryWebGL2: J.Interceptor, EXTFragDepth: J.Interceptor, EXT_frag_depth: J.Interceptor, EXTShaderTextureLOD: J.Interceptor, EXT_shader_texture_lod: J.Interceptor, EXTTextureFilterAnisotropic: J.Interceptor, EXT_texture_filter_anisotropic: J.Interceptor, WebGLFramebuffer: J.Interceptor, WebGLGetBufferSubDataAsync: J.Interceptor, WebGLLoseContext: J.Interceptor, WebGLExtensionLoseContext: J.Interceptor, WEBGL_lose_context: J.Interceptor, OESElementIndexUint: J.Interceptor, OES_element_index_uint: J.Interceptor, OESStandardDerivatives: J.Interceptor, OES_standard_derivatives: J.Interceptor, OESTextureFloat: J.Interceptor, OES_texture_float: J.Interceptor, OESTextureFloatLinear: J.Interceptor, OES_texture_float_linear: J.Interceptor, OESTextureHalfFloat: J.Interceptor, OES_texture_half_float: J.Interceptor, OESTextureHalfFloatLinear: J.Interceptor, OES_texture_half_float_linear: J.Interceptor, OESVertexArrayObject: J.Interceptor, OES_vertex_array_object: J.Interceptor, WebGLProgram: J.Interceptor, WebGLQuery: J.Interceptor, WebGLRenderbuffer: J.Interceptor, WebGLRenderingContext: J.Interceptor, WebGL2RenderingContext: J.Interceptor, WebGLSampler: J.Interceptor, WebGLShader: J.Interceptor, WebGLShaderPrecisionFormat: J.Interceptor, WebGLSync: J.Interceptor, WebGLTexture: J.Interceptor, WebGLTimerQueryEXT: J.Interceptor, WebGLTransformFeedback: J.Interceptor, WebGLUniformLocation: J.Interceptor, WebGLVertexArrayObject: J.Interceptor, WebGLVertexArrayObjectOES: J.Interceptor, WebGL: J.Interceptor, WebGL2RenderingContextBase: J.Interceptor, Database: J.Interceptor, SQLResultSet: J.Interceptor, SQLTransaction: J.Interceptor, ArrayBuffer: H.NativeByteBuffer, ArrayBufferView: H.NativeTypedData, DataView: H.NativeByteData, Float32Array: H.NativeFloat32List, Float64Array: H.NativeFloat64List, Int16Array: H.NativeInt16List, Int32Array: H.NativeInt32List, Int8Array: H.NativeInt8List, Uint16Array: H.NativeUint16List, Uint32Array: H.NativeUint32List, Uint8ClampedArray: H.NativeUint8ClampedList, CanvasPixelArray: H.NativeUint8ClampedList, Uint8Array: H.NativeUint8List, HTMLAudioElement: W.HtmlElement, HTMLBRElement: W.HtmlElement, HTMLButtonElement: W.HtmlElement, HTMLContentElement: W.HtmlElement, HTMLDListElement: W.HtmlElement, HTMLDataElement: W.HtmlElement, HTMLDataListElement: W.HtmlElement, HTMLDetailsElement: W.HtmlElement, HTMLDialogElement: W.HtmlElement, HTMLEmbedElement: W.HtmlElement, HTMLFieldSetElement: W.HtmlElement, HTMLHRElement: W.HtmlElement, HTMLHeadElement: W.HtmlElement, HTMLHeadingElement: W.HtmlElement, HTMLHtmlElement: W.HtmlElement, HTMLIFrameElement: W.HtmlElement, HTMLImageElement: W.HtmlElement, HTMLLIElement: W.HtmlElement, HTMLLegendElement: W.HtmlElement, HTMLLinkElement: W.HtmlElement, HTMLMapElement: W.HtmlElement, HTMLMediaElement: W.HtmlElement, HTMLMenuElement: W.HtmlElement, HTMLMeterElement: W.HtmlElement, HTMLModElement: W.HtmlElement, HTMLOListElement: W.HtmlElement, HTMLObjectElement: W.HtmlElement, HTMLOptGroupElement: W.HtmlElement, HTMLOptionElement: W.HtmlElement, HTMLOutputElement: W.HtmlElement, HTMLParamElement: W.HtmlElement, HTMLPictureElement: W.HtmlElement, HTMLPreElement: W.HtmlElement, HTMLProgressElement: W.HtmlElement, HTMLQuoteElement: W.HtmlElement, HTMLShadowElement: W.HtmlElement, HTMLSlotElement: W.HtmlElement, HTMLSourceElement: W.HtmlElement, HTMLTableCaptionElement: W.HtmlElement, HTMLTableCellElement: W.HtmlElement, HTMLTableDataCellElement: W.HtmlElement, HTMLTableHeaderCellElement: W.HtmlElement, HTMLTableColElement: W.HtmlElement, HTMLTimeElement: W.HtmlElement, HTMLTitleElement: W.HtmlElement, HTMLTrackElement: W.HtmlElement, HTMLUListElement: W.HtmlElement, HTMLUnknownElement: W.HtmlElement, HTMLVideoElement: W.HtmlElement, HTMLDirectoryElement: W.HtmlElement, HTMLFontElement: W.HtmlElement, HTMLFrameElement: W.HtmlElement, HTMLFrameSetElement: W.HtmlElement, HTMLMarqueeElement: W.HtmlElement, HTMLElement: W.HtmlElement, AccessibleNodeList: W.AccessibleNodeList, HTMLAnchorElement: W.AnchorElement, ApplicationCacheErrorEvent: W.ApplicationCacheErrorEvent, HTMLAreaElement: W.AreaElement, HTMLBaseElement: W.BaseElement, Blob: W.Blob, HTMLBodyElement: W.BodyElement, HTMLCanvasElement: W.CanvasElement, CanvasRenderingContext2D: W.CanvasRenderingContext2D, CDATASection: W.CharacterData, CharacterData: W.CharacterData, Comment: W.CharacterData, ProcessingInstruction: W.CharacterData, Text: W.CharacterData, CSSNumericValue: W.CssNumericValue, CSSUnitValue: W.CssNumericValue, CSSPerspective: W.CssPerspective, CSSCharsetRule: W.CssRule, CSSConditionRule: W.CssRule, CSSFontFaceRule: W.CssRule, CSSGroupingRule: W.CssRule, CSSImportRule: W.CssRule, CSSKeyframeRule: W.CssRule, MozCSSKeyframeRule: W.CssRule, WebKitCSSKeyframeRule: W.CssRule, CSSKeyframesRule: W.CssRule, MozCSSKeyframesRule: W.CssRule, WebKitCSSKeyframesRule: W.CssRule, CSSMediaRule: W.CssRule, CSSNamespaceRule: W.CssRule, CSSPageRule: W.CssRule, CSSRule: W.CssRule, CSSStyleRule: W.CssRule, CSSSupportsRule: W.CssRule, CSSViewportRule: W.CssRule, CSSStyleDeclaration: W.CssStyleDeclaration, MSStyleCSSProperties: W.CssStyleDeclaration, CSS2Properties: W.CssStyleDeclaration, CSSStyleSheet: W.CssStyleSheet, CSSImageValue: W.CssStyleValue, CSSKeywordValue: W.CssStyleValue, CSSPositionValue: W.CssStyleValue, CSSResourceValue: W.CssStyleValue, CSSURLImageValue: W.CssStyleValue, CSSStyleValue: W.CssStyleValue, CSSMatrixComponent: W.CssTransformComponent, CSSRotation: W.CssTransformComponent, CSSScale: W.CssTransformComponent, CSSSkew: W.CssTransformComponent, CSSTranslation: W.CssTransformComponent, CSSTransformComponent: W.CssTransformComponent, CSSTransformValue: W.CssTransformValue, CSSUnparsedValue: W.CssUnparsedValue, DataTransferItemList: W.DataTransferItemList, DeprecationReport: W.DeprecationReport, HTMLDivElement: W.DivElement, Document: W.Document, HTMLDocument: W.Document, XMLDocument: W.Document, DOMError: W.DomError, DOMException: W.DomException, ClientRectList: W.DomRectList, DOMRectList: W.DomRectList, DOMRectReadOnly: W.DomRectReadOnly, DOMStringList: W.DomStringList, DOMTokenList: W.DomTokenList, Element: W.Element0, ErrorEvent: W.ErrorEvent, AbortPaymentEvent: W.Event, AnimationEvent: W.Event, AnimationPlaybackEvent: W.Event, BackgroundFetchClickEvent: W.Event, BackgroundFetchEvent: W.Event, BackgroundFetchFailEvent: W.Event, BackgroundFetchedEvent: W.Event, BeforeInstallPromptEvent: W.Event, BeforeUnloadEvent: W.Event, BlobEvent: W.Event, CanMakePaymentEvent: W.Event, ClipboardEvent: W.Event, CloseEvent: W.Event, CustomEvent: W.Event, DeviceMotionEvent: W.Event, DeviceOrientationEvent: W.Event, ExtendableEvent: W.Event, ExtendableMessageEvent: W.Event, FetchEvent: W.Event, FontFaceSetLoadEvent: W.Event, ForeignFetchEvent: W.Event, GamepadEvent: W.Event, HashChangeEvent: W.Event, InstallEvent: W.Event, MediaEncryptedEvent: W.Event, MediaQueryListEvent: W.Event, MediaStreamEvent: W.Event, MediaStreamTrackEvent: W.Event, MessageEvent: W.Event, MIDIConnectionEvent: W.Event, MIDIMessageEvent: W.Event, MutationEvent: W.Event, NotificationEvent: W.Event, PageTransitionEvent: W.Event, PaymentRequestEvent: W.Event, PaymentRequestUpdateEvent: W.Event, PresentationConnectionAvailableEvent: W.Event, PromiseRejectionEvent: W.Event, PushEvent: W.Event, RTCDataChannelEvent: W.Event, RTCDTMFToneChangeEvent: W.Event, RTCPeerConnectionIceEvent: W.Event, RTCTrackEvent: W.Event, SecurityPolicyViolationEvent: W.Event, SensorErrorEvent: W.Event, SpeechRecognitionEvent: W.Event, SpeechSynthesisEvent: W.Event, StorageEvent: W.Event, SyncEvent: W.Event, TrackEvent: W.Event, TransitionEvent: W.Event, WebKitTransitionEvent: W.Event, VRDeviceEvent: W.Event, VRDisplayEvent: W.Event, VRSessionEvent: W.Event, MojoInterfaceRequestEvent: W.Event, USBConnectionEvent: W.Event, IDBVersionChangeEvent: W.Event, AudioProcessingEvent: W.Event, OfflineAudioCompletionEvent: W.Event, WebGLContextEvent: W.Event, Event: W.Event, InputEvent: W.Event, AbsoluteOrientationSensor: W.EventTarget, Accelerometer: W.EventTarget, AccessibleNode: W.EventTarget, AmbientLightSensor: W.EventTarget, Animation: W.EventTarget, ApplicationCache: W.EventTarget, DOMApplicationCache: W.EventTarget, OfflineResourceList: W.EventTarget, BackgroundFetchRegistration: W.EventTarget, BatteryManager: W.EventTarget, BroadcastChannel: W.EventTarget, CanvasCaptureMediaStreamTrack: W.EventTarget, DedicatedWorkerGlobalScope: W.EventTarget, EventSource: W.EventTarget, FileReader: W.EventTarget, Gyroscope: W.EventTarget, LinearAccelerationSensor: W.EventTarget, Magnetometer: W.EventTarget, MediaDevices: W.EventTarget, MediaKeySession: W.EventTarget, MediaQueryList: W.EventTarget, MediaRecorder: W.EventTarget, MediaSource: W.EventTarget, MediaStream: W.EventTarget, MediaStreamTrack: W.EventTarget, MIDIAccess: W.EventTarget, MIDIInput: W.EventTarget, MIDIOutput: W.EventTarget, MIDIPort: W.EventTarget, NetworkInformation: W.EventTarget, Notification: W.EventTarget, OffscreenCanvas: W.EventTarget, OrientationSensor: W.EventTarget, PaymentRequest: W.EventTarget, Performance: W.EventTarget, PermissionStatus: W.EventTarget, PresentationAvailability: W.EventTarget, PresentationConnection: W.EventTarget, PresentationConnectionList: W.EventTarget, PresentationRequest: W.EventTarget, RelativeOrientationSensor: W.EventTarget, RemotePlayback: W.EventTarget, RTCDataChannel: W.EventTarget, DataChannel: W.EventTarget, RTCDTMFSender: W.EventTarget, RTCPeerConnection: W.EventTarget, webkitRTCPeerConnection: W.EventTarget, mozRTCPeerConnection: W.EventTarget, ScreenOrientation: W.EventTarget, Sensor: W.EventTarget, ServiceWorker: W.EventTarget, ServiceWorkerContainer: W.EventTarget, ServiceWorkerGlobalScope: W.EventTarget, ServiceWorkerRegistration: W.EventTarget, SharedWorker: W.EventTarget, SharedWorkerGlobalScope: W.EventTarget, SpeechRecognition: W.EventTarget, SpeechSynthesis: W.EventTarget, SpeechSynthesisUtterance: W.EventTarget, VR: W.EventTarget, VRDevice: W.EventTarget, VRDisplay: W.EventTarget, VRSession: W.EventTarget, VisualViewport: W.EventTarget, WebSocket: W.EventTarget, Worker: W.EventTarget, WorkerGlobalScope: W.EventTarget, WorkerPerformance: W.EventTarget, BluetoothDevice: W.EventTarget, BluetoothRemoteGATTCharacteristic: W.EventTarget, Clipboard: W.EventTarget, MojoInterfaceInterceptor: W.EventTarget, USB: W.EventTarget, IDBDatabase: W.EventTarget, IDBOpenDBRequest: W.EventTarget, IDBVersionChangeRequest: W.EventTarget, IDBRequest: W.EventTarget, IDBTransaction: W.EventTarget, AnalyserNode: W.EventTarget, RealtimeAnalyserNode: W.EventTarget, AudioBufferSourceNode: W.EventTarget, AudioDestinationNode: W.EventTarget, AudioNode: W.EventTarget, AudioScheduledSourceNode: W.EventTarget, AudioWorkletNode: W.EventTarget, BiquadFilterNode: W.EventTarget, ChannelMergerNode: W.EventTarget, AudioChannelMerger: W.EventTarget, ChannelSplitterNode: W.EventTarget, AudioChannelSplitter: W.EventTarget, ConstantSourceNode: W.EventTarget, ConvolverNode: W.EventTarget, DelayNode: W.EventTarget, DynamicsCompressorNode: W.EventTarget, GainNode: W.EventTarget, AudioGainNode: W.EventTarget, IIRFilterNode: W.EventTarget, MediaElementAudioSourceNode: W.EventTarget, MediaStreamAudioDestinationNode: W.EventTarget, MediaStreamAudioSourceNode: W.EventTarget, OscillatorNode: W.EventTarget, Oscillator: W.EventTarget, PannerNode: W.EventTarget, AudioPannerNode: W.EventTarget, webkitAudioPannerNode: W.EventTarget, ScriptProcessorNode: W.EventTarget, JavaScriptAudioNode: W.EventTarget, StereoPannerNode: W.EventTarget, WaveShaperNode: W.EventTarget, EventTarget: W.EventTarget, File: W.File, FileList: W.FileList, FileWriter: W.FileWriter, FontFace: W.FontFace, FontFaceSet: W.FontFaceSet, HTMLFormElement: W.FormElement, Gamepad: W.Gamepad, History: W.History, HTMLCollection: W.HtmlCollection, HTMLFormControlsCollection: W.HtmlCollection, HTMLOptionsCollection: W.HtmlCollection, XMLHttpRequest: W.HttpRequest, XMLHttpRequestUpload: W.HttpRequestEventTarget, XMLHttpRequestEventTarget: W.HttpRequestEventTarget, ImageData: W.ImageData, HTMLInputElement: W.InputElement, InterventionReport: W.InterventionReport, KeyboardEvent: W.KeyboardEvent, HTMLLabelElement: W.LabelElement, Location: W.Location, MediaError: W.MediaError, MediaKeyMessageEvent: W.MediaKeyMessageEvent, MediaList: W.MediaList, MessagePort: W.MessagePort, HTMLMetaElement: W.MetaElement, MIDIInputMap: W.MidiInputMap, MIDIOutputMap: W.MidiOutputMap, MimeType: W.MimeType, MimeTypeArray: W.MimeTypeArray, MouseEvent: W.MouseEvent, DragEvent: W.MouseEvent, NavigatorUserMediaError: W.NavigatorUserMediaError, DocumentFragment: W.Node, ShadowRoot: W.Node, DocumentType: W.Node, Node: W.Node, NodeList: W.NodeList, RadioNodeList: W.NodeList, OverconstrainedError: W.OverconstrainedError, HTMLParagraphElement: W.ParagraphElement, Plugin: W.Plugin, PluginArray: W.PluginArray, PointerEvent: W.PointerEvent0, PopStateEvent: W.PopStateEvent, PositionError: W.PositionError, PresentationConnectionCloseEvent: W.PresentationConnectionCloseEvent, ProgressEvent: W.ProgressEvent, ResourceProgressEvent: W.ProgressEvent, ReportBody: W.ReportBody, RTCStatsReport: W.RtcStatsReport, HTMLScriptElement: W.ScriptElement, HTMLSelectElement: W.SelectElement, SourceBuffer: W.SourceBuffer, SourceBufferList: W.SourceBufferList, HTMLSpanElement: W.SpanElement, SpeechGrammar: W.SpeechGrammar, SpeechGrammarList: W.SpeechGrammarList, SpeechRecognitionError: W.SpeechRecognitionError, SpeechRecognitionResult: W.SpeechRecognitionResult, Storage: W.Storage, HTMLStyleElement: W.StyleElement, StyleSheet: W.StyleSheet, HTMLTableElement: W.TableElement, HTMLTableRowElement: W.TableRowElement, HTMLTableSectionElement: W.TableSectionElement, HTMLTemplateElement: W.TemplateElement, HTMLTextAreaElement: W.TextAreaElement, TextTrack: W.TextTrack, TextTrackCue: W.TextTrackCue, VTTCue: W.TextTrackCue, TextTrackCueList: W.TextTrackCueList, TextTrackList: W.TextTrackList, TimeRanges: W.TimeRanges, Touch: W.Touch, TouchEvent: W.TouchEvent, TouchList: W.TouchList, TrackDefaultList: W.TrackDefaultList, CompositionEvent: W.UIEvent, FocusEvent: W.UIEvent, TextEvent: W.UIEvent, UIEvent: W.UIEvent, URL: W.Url, VideoTrackList: W.VideoTrackList, WheelEvent: W.WheelEvent, Window: W.Window0, DOMWindow: W.Window0, Attr: W._Attr, CSSRuleList: W._CssRuleList, ClientRect: W._DomRect, DOMRect: W._DomRect, GamepadList: W._GamepadList, NamedNodeMap: W._NamedNodeMap, MozNamedAttrMap: W._NamedNodeMap, SpeechRecognitionResultList: W._SpeechRecognitionResultList, StyleSheetList: W._StyleSheetList, SVGLength: P.Length, SVGLengthList: P.LengthList, SVGNumber: P.Number, SVGNumberList: P.NumberList, SVGPointList: P.PointList, SVGScriptElement: P.ScriptElement0, SVGStringList: P.StringList, SVGAElement: P.SvgElement, SVGAnimateElement: P.SvgElement, SVGAnimateMotionElement: P.SvgElement, SVGAnimateTransformElement: P.SvgElement, SVGAnimationElement: P.SvgElement, SVGCircleElement: P.SvgElement, SVGClipPathElement: P.SvgElement, SVGDefsElement: P.SvgElement, SVGDescElement: P.SvgElement, SVGDiscardElement: P.SvgElement, SVGEllipseElement: P.SvgElement, SVGFEBlendElement: P.SvgElement, SVGFEColorMatrixElement: P.SvgElement, SVGFEComponentTransferElement: P.SvgElement, SVGFECompositeElement: P.SvgElement, SVGFEConvolveMatrixElement: P.SvgElement, SVGFEDiffuseLightingElement: P.SvgElement, SVGFEDisplacementMapElement: P.SvgElement, SVGFEDistantLightElement: P.SvgElement, SVGFEFloodElement: P.SvgElement, SVGFEFuncAElement: P.SvgElement, SVGFEFuncBElement: P.SvgElement, SVGFEFuncGElement: P.SvgElement, SVGFEFuncRElement: P.SvgElement, SVGFEGaussianBlurElement: P.SvgElement, SVGFEImageElement: P.SvgElement, SVGFEMergeElement: P.SvgElement, SVGFEMergeNodeElement: P.SvgElement, SVGFEMorphologyElement: P.SvgElement, SVGFEOffsetElement: P.SvgElement, SVGFEPointLightElement: P.SvgElement, SVGFESpecularLightingElement: P.SvgElement, SVGFESpotLightElement: P.SvgElement, SVGFETileElement: P.SvgElement, SVGFETurbulenceElement: P.SvgElement, SVGFilterElement: P.SvgElement, SVGForeignObjectElement: P.SvgElement, SVGGElement: P.SvgElement, SVGGeometryElement: P.SvgElement, SVGGraphicsElement: P.SvgElement, SVGImageElement: P.SvgElement, SVGLineElement: P.SvgElement, SVGLinearGradientElement: P.SvgElement, SVGMarkerElement: P.SvgElement, SVGMaskElement: P.SvgElement, SVGMetadataElement: P.SvgElement, SVGPathElement: P.SvgElement, SVGPatternElement: P.SvgElement, SVGPolygonElement: P.SvgElement, SVGPolylineElement: P.SvgElement, SVGRadialGradientElement: P.SvgElement, SVGRectElement: P.SvgElement, SVGSetElement: P.SvgElement, SVGStopElement: P.SvgElement, SVGStyleElement: P.SvgElement, SVGSVGElement: P.SvgElement, SVGSwitchElement: P.SvgElement, SVGSymbolElement: P.SvgElement, SVGTSpanElement: P.SvgElement, SVGTextContentElement: P.SvgElement, SVGTextElement: P.SvgElement, SVGTextPathElement: P.SvgElement, SVGTextPositioningElement: P.SvgElement, SVGTitleElement: P.SvgElement, SVGUseElement: P.SvgElement, SVGViewElement: P.SvgElement, SVGGradientElement: P.SvgElement, SVGComponentTransferFunctionElement: P.SvgElement, SVGFEDropShadowElement: P.SvgElement, SVGMPathElement: P.SvgElement, SVGElement: P.SvgElement, SVGTransform: P.Transform, SVGTransformList: P.TransformList, AudioBuffer: P.AudioBuffer, AudioParamMap: P.AudioParamMap, AudioTrackList: P.AudioTrackList, AudioContext: P.BaseAudioContext, webkitAudioContext: P.BaseAudioContext, BaseAudioContext: P.BaseAudioContext, OfflineAudioContext: P.OfflineAudioContext, SQLError: P.SqlError, SQLResultSetRowList: P.SqlResultSetRowList});
    hunkHelpers.setOrUpdateLeafTags({AnimationEffectReadOnly: true, AnimationEffectTiming: true, AnimationEffectTimingReadOnly: true, AnimationTimeline: true, AnimationWorkletGlobalScope: true, AuthenticatorAssertionResponse: true, AuthenticatorAttestationResponse: true, AuthenticatorResponse: true, BackgroundFetchFetch: true, BackgroundFetchManager: true, BackgroundFetchSettledFetch: true, BarProp: true, BarcodeDetector: true, BluetoothRemoteGATTDescriptor: true, Body: true, BudgetState: true, CacheStorage: true, CanvasGradient: true, CanvasPattern: true, Client: true, Clients: true, CookieStore: true, Coordinates: true, Credential: true, CredentialUserData: true, CredentialsContainer: true, Crypto: true, CryptoKey: true, CSS: true, CSSVariableReferenceValue: true, CustomElementRegistry: true, DataTransfer: true, DataTransferItem: true, DeprecatedStorageInfo: true, DeprecatedStorageQuota: true, DetectedBarcode: true, DetectedFace: true, DetectedText: true, DeviceAcceleration: true, DeviceRotationRate: true, DirectoryEntry: true, DirectoryReader: true, DocumentOrShadowRoot: true, DocumentTimeline: true, DOMImplementation: true, Iterator: true, DOMMatrix: true, DOMMatrixReadOnly: true, DOMParser: true, DOMPoint: true, DOMPointReadOnly: true, DOMQuad: true, DOMStringMap: true, Entry: true, External: true, FaceDetector: true, FederatedCredential: true, FileEntry: true, DOMFileSystem: true, FontFaceSource: true, FormData: true, GamepadButton: true, GamepadPose: true, Geolocation: true, Position: true, Headers: true, HTMLHyperlinkElementUtils: true, IdleDeadline: true, ImageBitmap: true, ImageBitmapRenderingContext: true, ImageCapture: true, InputDeviceCapabilities: true, IntersectionObserver: true, IntersectionObserverEntry: true, KeyframeEffect: true, KeyframeEffectReadOnly: true, MediaCapabilities: true, MediaCapabilitiesInfo: true, MediaDeviceInfo: true, MediaKeyStatusMap: true, MediaKeySystemAccess: true, MediaKeys: true, MediaKeysPolicy: true, MediaMetadata: true, MediaSession: true, MediaSettingsRange: true, MemoryInfo: true, MessageChannel: true, Metadata: true, MutationObserver: true, WebKitMutationObserver: true, MutationRecord: true, NavigationPreloadManager: true, Navigator: true, NavigatorAutomationInformation: true, NavigatorConcurrentHardware: true, NavigatorCookies: true, NodeFilter: true, NodeIterator: true, NonDocumentTypeChildNode: true, NonElementParentNode: true, NoncedElement: true, OffscreenCanvasRenderingContext2D: true, PaintRenderingContext2D: true, PaintSize: true, PaintWorkletGlobalScope: true, PasswordCredential: true, Path2D: true, PaymentAddress: true, PaymentInstruments: true, PaymentManager: true, PaymentResponse: true, PerformanceEntry: true, PerformanceLongTaskTiming: true, PerformanceMark: true, PerformanceMeasure: true, PerformanceNavigation: true, PerformanceNavigationTiming: true, PerformanceObserver: true, PerformanceObserverEntryList: true, PerformancePaintTiming: true, PerformanceResourceTiming: true, PerformanceServerTiming: true, PerformanceTiming: true, Permissions: true, PhotoCapabilities: true, Presentation: true, PresentationReceiver: true, PublicKeyCredential: true, PushManager: true, PushMessageData: true, PushSubscription: true, PushSubscriptionOptions: true, Range: true, RelatedApplication: true, ReportingObserver: true, ResizeObserver: true, ResizeObserverEntry: true, RTCCertificate: true, RTCIceCandidate: true, mozRTCIceCandidate: true, RTCLegacyStatsReport: true, RTCRtpContributingSource: true, RTCRtpReceiver: true, RTCRtpSender: true, RTCSessionDescription: true, mozRTCSessionDescription: true, RTCStatsResponse: true, Screen: true, ScrollState: true, ScrollTimeline: true, Selection: true, SharedArrayBuffer: true, SpeechRecognitionAlternative: true, SpeechSynthesisVoice: true, StaticRange: true, StorageManager: true, StyleMedia: true, StylePropertyMap: true, StylePropertyMapReadonly: true, SyncManager: true, TaskAttributionTiming: true, TextDetector: true, TextMetrics: true, TrackDefault: true, TreeWalker: true, TrustedHTML: true, TrustedScriptURL: true, TrustedURL: true, UnderlyingSourceBase: true, URLSearchParams: true, VRCoordinateSystem: true, VRDisplayCapabilities: true, VREyeParameters: true, VRFrameData: true, VRFrameOfReference: true, VRPose: true, VRStageBounds: true, VRStageBoundsPoint: true, VRStageParameters: true, ValidityState: true, VideoPlaybackQuality: true, VideoTrack: true, VTTRegion: true, WindowClient: true, WorkletAnimation: true, WorkletGlobalScope: true, XPathEvaluator: true, XPathExpression: true, XPathNSResolver: true, XPathResult: true, XMLSerializer: true, XSLTProcessor: true, Bluetooth: true, BluetoothCharacteristicProperties: true, BluetoothRemoteGATTServer: true, BluetoothRemoteGATTService: true, BluetoothUUID: true, BudgetService: true, Cache: true, DOMFileSystemSync: true, DirectoryEntrySync: true, DirectoryReaderSync: true, EntrySync: true, FileEntrySync: true, FileReaderSync: true, FileWriterSync: true, HTMLAllCollection: true, Mojo: true, MojoHandle: true, MojoWatcher: true, NFC: true, PagePopupController: true, Report: true, Request: true, Response: true, SubtleCrypto: true, USBAlternateInterface: true, USBConfiguration: true, USBDevice: true, USBEndpoint: true, USBInTransferResult: true, USBInterface: true, USBIsochronousInTransferPacket: true, USBIsochronousInTransferResult: true, USBIsochronousOutTransferPacket: true, USBIsochronousOutTransferResult: true, USBOutTransferResult: true, WorkerLocation: true, WorkerNavigator: true, Worklet: true, IDBCursor: true, IDBCursorWithValue: true, IDBFactory: true, IDBIndex: true, IDBKeyRange: true, IDBObjectStore: true, IDBObservation: true, IDBObserver: true, IDBObserverChanges: true, SVGAngle: true, SVGAnimatedAngle: true, SVGAnimatedBoolean: true, SVGAnimatedEnumeration: true, SVGAnimatedInteger: true, SVGAnimatedLength: true, SVGAnimatedLengthList: true, SVGAnimatedNumber: true, SVGAnimatedNumberList: true, SVGAnimatedPreserveAspectRatio: true, SVGAnimatedRect: true, SVGAnimatedString: true, SVGAnimatedTransformList: true, SVGMatrix: true, SVGPoint: true, SVGPreserveAspectRatio: true, SVGRect: true, SVGUnitTypes: true, AudioListener: true, AudioParam: true, AudioTrack: true, AudioWorkletGlobalScope: true, AudioWorkletProcessor: true, PeriodicWave: true, WebGLActiveInfo: true, ANGLEInstancedArrays: true, ANGLE_instanced_arrays: true, WebGLBuffer: true, WebGLCanvas: true, WebGLColorBufferFloat: true, WebGLCompressedTextureASTC: true, WebGLCompressedTextureATC: true, WEBGL_compressed_texture_atc: true, WebGLCompressedTextureETC1: true, WEBGL_compressed_texture_etc1: true, WebGLCompressedTextureETC: true, WebGLCompressedTexturePVRTC: true, WEBGL_compressed_texture_pvrtc: true, WebGLCompressedTextureS3TC: true, WEBGL_compressed_texture_s3tc: true, WebGLCompressedTextureS3TCsRGB: true, WebGLDebugRendererInfo: true, WEBGL_debug_renderer_info: true, WebGLDebugShaders: true, WEBGL_debug_shaders: true, WebGLDepthTexture: true, WEBGL_depth_texture: true, WebGLDrawBuffers: true, WEBGL_draw_buffers: true, EXTsRGB: true, EXT_sRGB: true, EXTBlendMinMax: true, EXT_blend_minmax: true, EXTColorBufferFloat: true, EXTColorBufferHalfFloat: true, EXTDisjointTimerQuery: true, EXTDisjointTimerQueryWebGL2: true, EXTFragDepth: true, EXT_frag_depth: true, EXTShaderTextureLOD: true, EXT_shader_texture_lod: true, EXTTextureFilterAnisotropic: true, EXT_texture_filter_anisotropic: true, WebGLFramebuffer: true, WebGLGetBufferSubDataAsync: true, WebGLLoseContext: true, WebGLExtensionLoseContext: true, WEBGL_lose_context: true, OESElementIndexUint: true, OES_element_index_uint: true, OESStandardDerivatives: true, OES_standard_derivatives: true, OESTextureFloat: true, OES_texture_float: true, OESTextureFloatLinear: true, OES_texture_float_linear: true, OESTextureHalfFloat: true, OES_texture_half_float: true, OESTextureHalfFloatLinear: true, OES_texture_half_float_linear: true, OESVertexArrayObject: true, OES_vertex_array_object: true, WebGLProgram: true, WebGLQuery: true, WebGLRenderbuffer: true, WebGLRenderingContext: true, WebGL2RenderingContext: true, WebGLSampler: true, WebGLShader: true, WebGLShaderPrecisionFormat: true, WebGLSync: true, WebGLTexture: true, WebGLTimerQueryEXT: true, WebGLTransformFeedback: true, WebGLUniformLocation: true, WebGLVertexArrayObject: true, WebGLVertexArrayObjectOES: true, WebGL: true, WebGL2RenderingContextBase: true, Database: true, SQLResultSet: true, SQLTransaction: true, ArrayBuffer: true, ArrayBufferView: false, DataView: true, Float32Array: true, Float64Array: true, Int16Array: true, Int32Array: true, Int8Array: true, Uint16Array: true, Uint32Array: true, Uint8ClampedArray: true, CanvasPixelArray: true, Uint8Array: false, HTMLAudioElement: true, HTMLBRElement: true, HTMLButtonElement: true, HTMLContentElement: true, HTMLDListElement: true, HTMLDataElement: true, HTMLDataListElement: true, HTMLDetailsElement: true, HTMLDialogElement: true, HTMLEmbedElement: true, HTMLFieldSetElement: true, HTMLHRElement: true, HTMLHeadElement: true, HTMLHeadingElement: true, HTMLHtmlElement: true, HTMLIFrameElement: true, HTMLImageElement: true, HTMLLIElement: true, HTMLLegendElement: true, HTMLLinkElement: true, HTMLMapElement: true, HTMLMediaElement: true, HTMLMenuElement: true, HTMLMeterElement: true, HTMLModElement: true, HTMLOListElement: true, HTMLObjectElement: true, HTMLOptGroupElement: true, HTMLOptionElement: true, HTMLOutputElement: true, HTMLParamElement: true, HTMLPictureElement: true, HTMLPreElement: true, HTMLProgressElement: true, HTMLQuoteElement: true, HTMLShadowElement: true, HTMLSlotElement: true, HTMLSourceElement: true, HTMLTableCaptionElement: true, HTMLTableCellElement: true, HTMLTableDataCellElement: true, HTMLTableHeaderCellElement: true, HTMLTableColElement: true, HTMLTimeElement: true, HTMLTitleElement: true, HTMLTrackElement: true, HTMLUListElement: true, HTMLUnknownElement: true, HTMLVideoElement: true, HTMLDirectoryElement: true, HTMLFontElement: true, HTMLFrameElement: true, HTMLFrameSetElement: true, HTMLMarqueeElement: true, HTMLElement: false, AccessibleNodeList: true, HTMLAnchorElement: true, ApplicationCacheErrorEvent: true, HTMLAreaElement: true, HTMLBaseElement: true, Blob: false, HTMLBodyElement: true, HTMLCanvasElement: true, CanvasRenderingContext2D: true, CDATASection: true, CharacterData: true, Comment: true, ProcessingInstruction: true, Text: true, CSSNumericValue: true, CSSUnitValue: true, CSSPerspective: true, CSSCharsetRule: true, CSSConditionRule: true, CSSFontFaceRule: true, CSSGroupingRule: true, CSSImportRule: true, CSSKeyframeRule: true, MozCSSKeyframeRule: true, WebKitCSSKeyframeRule: true, CSSKeyframesRule: true, MozCSSKeyframesRule: true, WebKitCSSKeyframesRule: true, CSSMediaRule: true, CSSNamespaceRule: true, CSSPageRule: true, CSSRule: true, CSSStyleRule: true, CSSSupportsRule: true, CSSViewportRule: true, CSSStyleDeclaration: true, MSStyleCSSProperties: true, CSS2Properties: true, CSSStyleSheet: true, CSSImageValue: true, CSSKeywordValue: true, CSSPositionValue: true, CSSResourceValue: true, CSSURLImageValue: true, CSSStyleValue: false, CSSMatrixComponent: true, CSSRotation: true, CSSScale: true, CSSSkew: true, CSSTranslation: true, CSSTransformComponent: false, CSSTransformValue: true, CSSUnparsedValue: true, DataTransferItemList: true, DeprecationReport: true, HTMLDivElement: true, Document: true, HTMLDocument: true, XMLDocument: true, DOMError: true, DOMException: true, ClientRectList: true, DOMRectList: true, DOMRectReadOnly: false, DOMStringList: true, DOMTokenList: true, Element: false, ErrorEvent: true, AbortPaymentEvent: true, AnimationEvent: true, AnimationPlaybackEvent: true, BackgroundFetchClickEvent: true, BackgroundFetchEvent: true, BackgroundFetchFailEvent: true, BackgroundFetchedEvent: true, BeforeInstallPromptEvent: true, BeforeUnloadEvent: true, BlobEvent: true, CanMakePaymentEvent: true, ClipboardEvent: true, CloseEvent: true, CustomEvent: true, DeviceMotionEvent: true, DeviceOrientationEvent: true, ExtendableEvent: true, ExtendableMessageEvent: true, FetchEvent: true, FontFaceSetLoadEvent: true, ForeignFetchEvent: true, GamepadEvent: true, HashChangeEvent: true, InstallEvent: true, MediaEncryptedEvent: true, MediaQueryListEvent: true, MediaStreamEvent: true, MediaStreamTrackEvent: true, MessageEvent: true, MIDIConnectionEvent: true, MIDIMessageEvent: true, MutationEvent: true, NotificationEvent: true, PageTransitionEvent: true, PaymentRequestEvent: true, PaymentRequestUpdateEvent: true, PresentationConnectionAvailableEvent: true, PromiseRejectionEvent: true, PushEvent: true, RTCDataChannelEvent: true, RTCDTMFToneChangeEvent: true, RTCPeerConnectionIceEvent: true, RTCTrackEvent: true, SecurityPolicyViolationEvent: true, SensorErrorEvent: true, SpeechRecognitionEvent: true, SpeechSynthesisEvent: true, StorageEvent: true, SyncEvent: true, TrackEvent: true, TransitionEvent: true, WebKitTransitionEvent: true, VRDeviceEvent: true, VRDisplayEvent: true, VRSessionEvent: true, MojoInterfaceRequestEvent: true, USBConnectionEvent: true, IDBVersionChangeEvent: true, AudioProcessingEvent: true, OfflineAudioCompletionEvent: true, WebGLContextEvent: true, Event: false, InputEvent: false, AbsoluteOrientationSensor: true, Accelerometer: true, AccessibleNode: true, AmbientLightSensor: true, Animation: true, ApplicationCache: true, DOMApplicationCache: true, OfflineResourceList: true, BackgroundFetchRegistration: true, BatteryManager: true, BroadcastChannel: true, CanvasCaptureMediaStreamTrack: true, DedicatedWorkerGlobalScope: true, EventSource: true, FileReader: true, Gyroscope: true, LinearAccelerationSensor: true, Magnetometer: true, MediaDevices: true, MediaKeySession: true, MediaQueryList: true, MediaRecorder: true, MediaSource: true, MediaStream: true, MediaStreamTrack: true, MIDIAccess: true, MIDIInput: true, MIDIOutput: true, MIDIPort: true, NetworkInformation: true, Notification: true, OffscreenCanvas: true, OrientationSensor: true, PaymentRequest: true, Performance: true, PermissionStatus: true, PresentationAvailability: true, PresentationConnection: true, PresentationConnectionList: true, PresentationRequest: true, RelativeOrientationSensor: true, RemotePlayback: true, RTCDataChannel: true, DataChannel: true, RTCDTMFSender: true, RTCPeerConnection: true, webkitRTCPeerConnection: true, mozRTCPeerConnection: true, ScreenOrientation: true, Sensor: true, ServiceWorker: true, ServiceWorkerContainer: true, ServiceWorkerGlobalScope: true, ServiceWorkerRegistration: true, SharedWorker: true, SharedWorkerGlobalScope: true, SpeechRecognition: true, SpeechSynthesis: true, SpeechSynthesisUtterance: true, VR: true, VRDevice: true, VRDisplay: true, VRSession: true, VisualViewport: true, WebSocket: true, Worker: true, WorkerGlobalScope: true, WorkerPerformance: true, BluetoothDevice: true, BluetoothRemoteGATTCharacteristic: true, Clipboard: true, MojoInterfaceInterceptor: true, USB: true, IDBDatabase: true, IDBOpenDBRequest: true, IDBVersionChangeRequest: true, IDBRequest: true, IDBTransaction: true, AnalyserNode: true, RealtimeAnalyserNode: true, AudioBufferSourceNode: true, AudioDestinationNode: true, AudioNode: true, AudioScheduledSourceNode: true, AudioWorkletNode: true, BiquadFilterNode: true, ChannelMergerNode: true, AudioChannelMerger: true, ChannelSplitterNode: true, AudioChannelSplitter: true, ConstantSourceNode: true, ConvolverNode: true, DelayNode: true, DynamicsCompressorNode: true, GainNode: true, AudioGainNode: true, IIRFilterNode: true, MediaElementAudioSourceNode: true, MediaStreamAudioDestinationNode: true, MediaStreamAudioSourceNode: true, OscillatorNode: true, Oscillator: true, PannerNode: true, AudioPannerNode: true, webkitAudioPannerNode: true, ScriptProcessorNode: true, JavaScriptAudioNode: true, StereoPannerNode: true, WaveShaperNode: true, EventTarget: false, File: true, FileList: true, FileWriter: true, FontFace: true, FontFaceSet: true, HTMLFormElement: true, Gamepad: true, History: true, HTMLCollection: true, HTMLFormControlsCollection: true, HTMLOptionsCollection: true, XMLHttpRequest: true, XMLHttpRequestUpload: true, XMLHttpRequestEventTarget: false, ImageData: true, HTMLInputElement: true, InterventionReport: true, KeyboardEvent: true, HTMLLabelElement: true, Location: true, MediaError: true, MediaKeyMessageEvent: true, MediaList: true, MessagePort: true, HTMLMetaElement: true, MIDIInputMap: true, MIDIOutputMap: true, MimeType: true, MimeTypeArray: true, MouseEvent: false, DragEvent: false, NavigatorUserMediaError: true, DocumentFragment: true, ShadowRoot: true, DocumentType: true, Node: false, NodeList: true, RadioNodeList: true, OverconstrainedError: true, HTMLParagraphElement: true, Plugin: true, PluginArray: true, PointerEvent: true, PopStateEvent: true, PositionError: true, PresentationConnectionCloseEvent: true, ProgressEvent: true, ResourceProgressEvent: true, ReportBody: false, RTCStatsReport: true, HTMLScriptElement: true, HTMLSelectElement: true, SourceBuffer: true, SourceBufferList: true, HTMLSpanElement: true, SpeechGrammar: true, SpeechGrammarList: true, SpeechRecognitionError: true, SpeechRecognitionResult: true, Storage: true, HTMLStyleElement: true, StyleSheet: false, HTMLTableElement: true, HTMLTableRowElement: true, HTMLTableSectionElement: true, HTMLTemplateElement: true, HTMLTextAreaElement: true, TextTrack: true, TextTrackCue: true, VTTCue: true, TextTrackCueList: true, TextTrackList: true, TimeRanges: true, Touch: true, TouchEvent: true, TouchList: true, TrackDefaultList: true, CompositionEvent: true, FocusEvent: true, TextEvent: true, UIEvent: false, URL: true, VideoTrackList: true, WheelEvent: true, Window: true, DOMWindow: true, Attr: true, CSSRuleList: true, ClientRect: true, DOMRect: true, GamepadList: true, NamedNodeMap: true, MozNamedAttrMap: true, SpeechRecognitionResultList: true, StyleSheetList: true, SVGLength: true, SVGLengthList: true, SVGNumber: true, SVGNumberList: true, SVGPointList: true, SVGScriptElement: true, SVGStringList: true, SVGAElement: true, SVGAnimateElement: true, SVGAnimateMotionElement: true, SVGAnimateTransformElement: true, SVGAnimationElement: true, SVGCircleElement: true, SVGClipPathElement: true, SVGDefsElement: true, SVGDescElement: true, SVGDiscardElement: true, SVGEllipseElement: true, SVGFEBlendElement: true, SVGFEColorMatrixElement: true, SVGFEComponentTransferElement: true, SVGFECompositeElement: true, SVGFEConvolveMatrixElement: true, SVGFEDiffuseLightingElement: true, SVGFEDisplacementMapElement: true, SVGFEDistantLightElement: true, SVGFEFloodElement: true, SVGFEFuncAElement: true, SVGFEFuncBElement: true, SVGFEFuncGElement: true, SVGFEFuncRElement: true, SVGFEGaussianBlurElement: true, SVGFEImageElement: true, SVGFEMergeElement: true, SVGFEMergeNodeElement: true, SVGFEMorphologyElement: true, SVGFEOffsetElement: true, SVGFEPointLightElement: true, SVGFESpecularLightingElement: true, SVGFESpotLightElement: true, SVGFETileElement: true, SVGFETurbulenceElement: true, SVGFilterElement: true, SVGForeignObjectElement: true, SVGGElement: true, SVGGeometryElement: true, SVGGraphicsElement: true, SVGImageElement: true, SVGLineElement: true, SVGLinearGradientElement: true, SVGMarkerElement: true, SVGMaskElement: true, SVGMetadataElement: true, SVGPathElement: true, SVGPatternElement: true, SVGPolygonElement: true, SVGPolylineElement: true, SVGRadialGradientElement: true, SVGRectElement: true, SVGSetElement: true, SVGStopElement: true, SVGStyleElement: true, SVGSVGElement: true, SVGSwitchElement: true, SVGSymbolElement: true, SVGTSpanElement: true, SVGTextContentElement: true, SVGTextElement: true, SVGTextPathElement: true, SVGTextPositioningElement: true, SVGTitleElement: true, SVGUseElement: true, SVGViewElement: true, SVGGradientElement: true, SVGComponentTransferFunctionElement: true, SVGFEDropShadowElement: true, SVGMPathElement: true, SVGElement: false, SVGTransform: true, SVGTransformList: true, AudioBuffer: true, AudioParamMap: true, AudioTrackList: true, AudioContext: true, webkitAudioContext: true, BaseAudioContext: false, OfflineAudioContext: true, SQLError: true, SQLResultSetRowList: true});
    H.NativeTypedArray.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H.NativeTypedArrayOfDouble.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H.NativeTypedArrayOfInt.$nativeSuperclassTag = "ArrayBufferView";
    W._SourceBufferList_EventTarget_ListMixin.$nativeSuperclassTag = "EventTarget";
    W._SourceBufferList_EventTarget_ListMixin_ImmutableListMixin.$nativeSuperclassTag = "EventTarget";
    W._TextTrackList_EventTarget_ListMixin.$nativeSuperclassTag = "EventTarget";
    W._TextTrackList_EventTarget_ListMixin_ImmutableListMixin.$nativeSuperclassTag = "EventTarget";
  })();
  convertAllToFastObject(holders);
  convertToFastObject($);
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != 'undefined') {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i)
        scripts[i].removeEventListener("load", onLoad, false);
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].addEventListener("load", onLoad, false);
  })(function(currentScript) {
    init.currentScript = currentScript;
    if (typeof dartMainRunner === "function")
      dartMainRunner(F.main, []);
    else
      F.main([]);
  });
})();

//# sourceMappingURL=main.dart.js.map
